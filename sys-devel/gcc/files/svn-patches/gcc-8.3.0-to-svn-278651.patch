Index: libitm/ChangeLog
===================================================================
diff --git a/libitm/ChangeLog b/libitm/ChangeLog
--- a/libitm/ChangeLog	(revision 278653)
+++ b/libitm/ChangeLog	(revision 278653)
@@ -1,3 +1,12 @@
+2019-09-28  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2018-08-03  Sergei Trofimovich  <slyfox@gentoo.org>
+
+	PR target/86712
+	* config/sh/sjlj.S: Adjust to use PIC vs normal code to avoid
+	absolute relocation in a shared library.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: libitm/config/sh/sjlj.S
===================================================================
diff --git a/libitm/config/sh/sjlj.S b/libitm/config/sh/sjlj.S
--- a/libitm/config/sh/sjlj.S	(revision 278653)
+++ b/libitm/config/sh/sjlj.S	(revision 278653)
@@ -53,7 +53,7 @@
 #else
 	cfi_def_cfa_offset (4*10)
 #endif
-#if defined HAVE_ATTRIBUTE_VISIBILITY || !defined __PIC__
+#if !defined __PIC__
 	mov.l	.Lbegin, r1
 	jsr	@r1
 	 mov	r15, r5
@@ -78,7 +78,7 @@
 
 	.align  2
 .Lbegin:
-#if defined HAVE_ATTRIBUTE_VISIBILITY || !defined __PIC__
+#if !defined __PIC__
 	.long	GTM_begin_transaction
 #else
 	.long	GTM_begin_transaction@PCREL-(.Lbegin0-.)
Index: libgomp/ChangeLog
===================================================================
diff --git a/libgomp/ChangeLog b/libgomp/ChangeLog
--- a/libgomp/ChangeLog	(revision 278653)
+++ b/libgomp/ChangeLog	(revision 278653)
@@ -1,3 +1,19 @@
+2019-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-05-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR libgomp/90585
+	* plugin/plugin-hsa.c (print_kernel_dispatch, run_kernel): Use PRIu64
+	macro instead of "lu".
+	(release_kernel_dispatch): Likewise.  Cast shadow->debug to uintptr_t
+	before casting to void *.
+
+2019-06-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/90811
+	* testsuite/libgomp.c/pr90811.c: New test.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: libgomp/testsuite/libgomp.c/pr90811.c
===================================================================
diff --git a/libgomp/testsuite/libgomp.c/pr90811.c b/libgomp/testsuite/libgomp.c/pr90811.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libgomp/testsuite/libgomp.c/pr90811.c	(revision 278653)
@@ -0,0 +1,29 @@
+/* PR target/90811 */
+
+int
+main ()
+{
+  long long a[100], b[100];
+  int i;
+  for (i = 0; i < 100; i++)
+    {
+      a[i] = i;
+      b[i] = i % 10;
+    }
+  #pragma omp target teams distribute parallel for simd map(tofrom: a[:100], b[:100])
+  for (i = 0; i < 100; i++)
+    {
+      long long c = 0;
+      const long long d[] = { 1, 3, 5, 7, 9 };
+      for (int j = 4; j >= 0; j--)
+         c = d[j] + b[i] * c;
+      a[i] += c;
+    }
+  for (i = 0; i < 100; i++)
+    {
+      const long long r[] = { 1, 26, 229, 976, 2849, 6646, 13381, 24284, 40801, 64594 };
+      if (a[i] != r[i % 10] + (i / 10 * 10))
+	__builtin_abort ();
+    }
+  return 0;
+}
Index: libgomp/plugin/plugin-hsa.c
===================================================================
diff --git a/libgomp/plugin/plugin-hsa.c b/libgomp/plugin/plugin-hsa.c
--- a/libgomp/plugin/plugin-hsa.c	(revision 278653)
+++ b/libgomp/plugin/plugin-hsa.c	(revision 278653)
@@ -1154,8 +1154,9 @@
 static void
 release_kernel_dispatch (struct GOMP_hsa_kernel_dispatch *shadow)
 {
-  HSA_DEBUG ("Released kernel dispatch: %p has value: %lu (%p)\n", shadow,
-	     shadow->debug, (void *) shadow->debug);
+  HSA_DEBUG ("Released kernel dispatch: %p has value: %" PRIu64 " (%p)\n",
+	     shadow, shadow->debug,
+	     (void *) (uintptr_t) shadow->debug);
 
   hsa_fns.hsa_memory_free_fn (shadow->kernarg_address);
 
@@ -1276,9 +1277,9 @@
   indent_stream (stderr, indent);
   fprintf (stderr, "kernarg_address: %p\n", dispatch->kernarg_address);
   indent_stream (stderr, indent);
-  fprintf (stderr, "object: %lu\n", dispatch->object);
+  fprintf (stderr, "object: %" PRIu64 "\n", dispatch->object);
   indent_stream (stderr, indent);
-  fprintf (stderr, "signal: %lu\n", dispatch->signal);
+  fprintf (stderr, "signal: %" PRIu64 "\n", dispatch->signal);
   indent_stream (stderr, indent);
   fprintf (stderr, "private_segment_size: %u\n",
 	   dispatch->private_segment_size);
@@ -1286,7 +1287,7 @@
   fprintf (stderr, "group_segment_size: %u\n",
 	   dispatch->group_segment_size);
   indent_stream (stderr, indent);
-  fprintf (stderr, "children dispatches: %lu\n",
+  fprintf (stderr, "children dispatches: %" PRIu64 "\n",
 	   dispatch->kernel_dispatch_count);
   indent_stream (stderr, indent);
   fprintf (stderr, "omp_num_threads: %u\n",
@@ -1594,7 +1595,7 @@
 	hsa_signal_t child_s;
 	child_s.handle = shadow->children_dispatches[i]->signal;
 
-	HSA_DEBUG ("Waiting for children completion signal: %lu\n",
+	HSA_DEBUG ("Waiting for children completion signal: %" PRIu64 "\n",
 		   shadow->children_dispatches[i]->signal);
 	hsa_fns.hsa_signal_load_acquire_fn (child_s);
       }
Index: libquadmath/ChangeLog
===================================================================
diff --git a/libquadmath/ChangeLog b/libquadmath/ChangeLog
--- a/libquadmath/ChangeLog	(revision 278653)
+++ b/libquadmath/ChangeLog	(revision 278653)
@@ -1,3 +1,12 @@
+2019-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-08-02  Jakub Jelinek  <jakub@redhat.com>
+
+	* quadmath.h (M_Eq, M_LOG2Eq, M_LOG10Eq, M_LN2q, M_LN10q, M_PIq,
+	M_PI_2q, M_PI_4q, M_1_PIq, M_2_PIq, M_2_SQRTPIq, M_SQRT2q,
+	M_SQRT1_2q): Use two more decimal places.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: libquadmath/quadmath.h
===================================================================
diff --git a/libquadmath/quadmath.h b/libquadmath/quadmath.h
--- a/libquadmath/quadmath.h	(revision 278653)
+++ b/libquadmath/quadmath.h	(revision 278653)
@@ -1,5 +1,5 @@
 /* GCC Quad-Precision Math Library
-   Copyright (C) 2010, 2011 Free Software Foundation, Inc.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
    Written by Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>
 
 This file is part of the libquadmath library.
@@ -163,19 +163,19 @@
    (floating constant exceeds range of ‘__float128’)  */
 /* #define HUGE_VALQ (__extension__ 0x1.0p32767Q) */
 
-#define M_Eq		2.7182818284590452353602874713526625Q  /* e */
-#define M_LOG2Eq	1.4426950408889634073599246810018921Q  /* log_2 e */
-#define M_LOG10Eq	0.4342944819032518276511289189166051Q  /* log_10 e */
-#define M_LN2q		0.6931471805599453094172321214581766Q  /* log_e 2 */
-#define M_LN10q		2.3025850929940456840179914546843642Q  /* log_e 10 */
-#define M_PIq		3.1415926535897932384626433832795029Q  /* pi */
-#define M_PI_2q		1.5707963267948966192313216916397514Q  /* pi/2 */
-#define M_PI_4q		0.7853981633974483096156608458198757Q  /* pi/4 */
-#define M_1_PIq		0.3183098861837906715377675267450287Q  /* 1/pi */
-#define M_2_PIq		0.6366197723675813430755350534900574Q  /* 2/pi */
-#define M_2_SQRTPIq	1.1283791670955125738961589031215452Q  /* 2/sqrt(pi) */
-#define M_SQRT2q	1.4142135623730950488016887242096981Q  /* sqrt(2) */
-#define M_SQRT1_2q	0.7071067811865475244008443621048490Q  /* 1/sqrt(2) */
+#define M_Eq		2.718281828459045235360287471352662498Q  /* e */
+#define M_LOG2Eq	1.442695040888963407359924681001892137Q  /* log_2 e */
+#define M_LOG10Eq	0.434294481903251827651128918916605082Q  /* log_10 e */
+#define M_LN2q		0.693147180559945309417232121458176568Q  /* log_e 2 */
+#define M_LN10q		2.302585092994045684017991454684364208Q  /* log_e 10 */
+#define M_PIq		3.141592653589793238462643383279502884Q  /* pi */
+#define M_PI_2q		1.570796326794896619231321691639751442Q  /* pi/2 */
+#define M_PI_4q		0.785398163397448309615660845819875721Q  /* pi/4 */
+#define M_1_PIq		0.318309886183790671537767526745028724Q  /* 1/pi */
+#define M_2_PIq		0.636619772367581343075535053490057448Q  /* 2/pi */
+#define M_2_SQRTPIq	1.128379167095512573896158903121545172Q  /* 2/sqrt(pi) */
+#define M_SQRT2q	1.414213562373095048801688724209698079Q  /* sqrt(2) */
+#define M_SQRT1_2q	0.707106781186547524400844362104849039Q  /* 1/sqrt(2) */
 
 #define __quadmath_extern_inline \
   extern inline __attribute__ ((__gnu_inline__))
Index: libstdc++-v3/configure
===================================================================
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
--- a/libstdc++-v3/configure	(revision 278653)
+++ b/libstdc++-v3/configure	(revision 278653)
@@ -638,6 +638,7 @@
 XSL_STYLE_DIR
 XMLLINT
 XSLTPROC
+XMLCATALOG
 DOT
 DOXYGEN
 BUILD_INFO_FALSE
@@ -11608,7 +11609,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11611 "configure"
+#line 11612 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11714,7 +11715,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11717 "configure"
+#line 11718 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -15400,7 +15401,7 @@
   # Fake what AC_TRY_COMPILE does.
 
     cat > conftest.$ac_ext << EOF
-#line 15403 "configure"
+#line 15404 "configure"
 int main()
 {
   typedef bool atomic_type;
@@ -15435,7 +15436,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15438 "configure"
+#line 15439 "configure"
 int main()
 {
   typedef short atomic_type;
@@ -15470,7 +15471,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15473 "configure"
+#line 15474 "configure"
 int main()
 {
   // NB: _Atomic_word not necessarily int.
@@ -15506,7 +15507,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15509 "configure"
+#line 15510 "configure"
 int main()
 {
   typedef long long atomic_type;
@@ -15587,7 +15588,7 @@
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15590 "configure"
+#line 15591 "configure"
 int main()
 {
   _Decimal32 d1;
@@ -15629,7 +15630,7 @@
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15632 "configure"
+#line 15633 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -15663,7 +15664,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15666 "configure"
+#line 15667 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -80857,6 +80858,44 @@
 
 
 # Check for docbook
+# Extract the first word of "xmlcatalog", so it can be a program name with args.
+set dummy xmlcatalog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if test "${ac_cv_prog_XMLCATALOG+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$XMLCATALOG"; then
+  ac_cv_prog_XMLCATALOG="$XMLCATALOG" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_XMLCATALOG="yes"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+  test -z "$ac_cv_prog_XMLCATALOG" && ac_cv_prog_XMLCATALOG="no"
+fi
+fi
+XMLCATALOG=$ac_cv_prog_XMLCATALOG
+if test -n "$XMLCATALOG"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $XMLCATALOG" >&5
+$as_echo "$XMLCATALOG" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
 # Extract the first word of "xsltproc", so it can be a program name with args.
 set dummy xsltproc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
@@ -80935,31 +80974,28 @@
 
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for docbook stylesheets for documentation creation" >&5
-$as_echo_n "checking for docbook stylesheets for documentation creation... " >&6; }
-glibcxx_stylesheets=no
-if test x${XSLTPROC} = xyes && echo '<title/>' | xsltproc --noout --nonet --xinclude http://docbook.sourceforge.net/release/xsl-ns/current/xhtml-1_1/docbook.xsl - 2>/dev/null; then
-  glibcxx_stylesheets=yes
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_stylesheets" >&5
-$as_echo "$glibcxx_stylesheets" >&6; }
+glibcxx_docbook_url=http://docbook.sourceforge.net/release/xsl-ns/current/
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for local stylesheet directory" >&5
 $as_echo_n "checking for local stylesheet directory... " >&6; }
 glibcxx_local_stylesheets=no
-if test x"$glibcxx_stylesheets" = x"yes"; then
-  if test -d /usr/share/sgml/docbook/xsl-ns-stylesheets; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/sgml/docbook/xsl-ns-stylesheets
-  fi
-  if test -d /usr/share/xml/docbook/stylesheet/docbook-xsl-ns; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/xml/docbook/stylesheet/docbook-xsl-ns
-  fi
-  if test -d /usr/share/xml/docbook/stylesheet/nwalsh5/current; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/xml/docbook/stylesheet/nwalsh5/current
-  fi
+if test x${XMLCATALOG} = xyes && xsl_style_dir=`xmlcatalog "" $glibcxx_docbook_url 2>/dev/null`
+then
+  XSL_STYLE_DIR=`echo $xsl_style_dir | sed -n 's;^file://;;p'`
+  glibcxx_local_stylesheets=yes
+else
+  for dir in \
+    /usr/share/sgml/docbook/xsl-ns-stylesheets \
+    /usr/share/xml/docbook/stylesheet/docbook-xsl-ns \
+    /usr/share/xml/docbook/stylesheet/nwalsh5/current \
+    /usr/share/xml/docbook/stylesheet/nwalsh/current
+  do
+    if test -d $dir; then
+      glibcxx_local_stylesheets=yes
+      XSL_STYLE_DIR=$dir
+      break
+    fi
+  done
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_local_stylesheets" >&5
 $as_echo "$glibcxx_local_stylesheets" >&6; }
@@ -80968,6 +81004,18 @@
 
   { $as_echo "$as_me:${as_lineno-$LINENO}: $XSL_STYLE_DIR" >&5
 $as_echo "$as_me: $XSL_STYLE_DIR" >&6;}
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for docbook stylesheets for documentation creation" >&5
+$as_echo_n "checking for docbook stylesheets for documentation creation... " >&6; }
+  glibcxx_stylesheets=no
+  if test x${XMLCATALOG} = xno || xmlcatalog "" $glibcxx_docbook_url/xhtml/docbook.xsl >/dev/null 2>&1; then
+    if test x${XSLTPROC} = xyes && echo '<title/>' | xsltproc --noout --nonet --xinclude $glibcxx_docbook_url/xhtml/docbook.xsl - 2>/dev/null; then
+      glibcxx_stylesheets=yes
+    fi
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $glibcxx_stylesheets" >&5
+$as_echo "$glibcxx_stylesheets" >&6; }
+
 else
   glibcxx_stylesheets=no
 fi
Index: libstdc++-v3/python/Makefile.in
===================================================================
diff --git a/libstdc++-v3/python/Makefile.in b/libstdc++-v3/python/Makefile.in
--- a/libstdc++-v3/python/Makefile.in	(revision 278653)
+++ b/libstdc++-v3/python/Makefile.in	(revision 278653)
@@ -235,6 +235,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/python/libstdcxx/v6/xmethods.py
===================================================================
diff --git a/libstdc++-v3/python/libstdcxx/v6/xmethods.py b/libstdc++-v3/python/libstdcxx/v6/xmethods.py
--- a/libstdc++-v3/python/libstdcxx/v6/xmethods.py	(revision 278653)
+++ b/libstdc++-v3/python/libstdcxx/v6/xmethods.py	(revision 278653)
@@ -728,7 +728,7 @@
         return gdb.lookup_type('long')
 
     def __call__(self, obj):
-        refcounts = ['_M_refcount']['_M_pi']
+        refcounts = obj['_M_refcount']['_M_pi']
         return refcounts['_M_use_count'] if refcounts else 0
 
 class SharedPtrUniqueWorker(SharedPtrUseCountWorker):
Index: libstdc++-v3/Makefile.in
===================================================================
diff --git a/libstdc++-v3/Makefile.in b/libstdc++-v3/Makefile.in
--- a/libstdc++-v3/Makefile.in	(revision 278653)
+++ b/libstdc++-v3/Makefile.in	(revision 278653)
@@ -233,6 +233,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/src/c++17/Makefile.in
===================================================================
diff --git a/libstdc++-v3/src/c++17/Makefile.in b/libstdc++-v3/src/c++17/Makefile.in
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/src/c++17/Makefile.in	(revision 278653)
@@ -0,0 +1,754 @@
+# Makefile.in generated by automake 1.15.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994-2017 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+subdir = src/c++17
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \
+	$(top_srcdir)/../config/enable.m4 \
+	$(top_srcdir)/../config/futex.m4 \
+	$(top_srcdir)/../config/hwcaps.m4 \
+	$(top_srcdir)/../config/iconv.m4 \
+	$(top_srcdir)/../config/lead-dot.m4 \
+	$(top_srcdir)/../config/lib-ld.m4 \
+	$(top_srcdir)/../config/lib-link.m4 \
+	$(top_srcdir)/../config/lib-prefix.m4 \
+	$(top_srcdir)/../config/lthostflags.m4 \
+	$(top_srcdir)/../config/multi.m4 \
+	$(top_srcdir)/../config/no-executables.m4 \
+	$(top_srcdir)/../config/override.m4 \
+	$(top_srcdir)/../config/stdint.m4 \
+	$(top_srcdir)/../config/unwind_ipinfo.m4 \
+	$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \
+	$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \
+	$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/crossconfig.m4 \
+	$(top_srcdir)/linkage.m4 $(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/../config/gc++filt.m4 \
+	$(top_srcdir)/../config/tls.m4 $(top_srcdir)/../config/gthr.m4 \
+	$(top_srcdir)/../config/cet.m4 $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+LTLIBRARIES = $(noinst_LTLIBRARIES)
+libc__17convenience_la_LIBADD =
+@ENABLE_DUAL_ABI_TRUE@am__objects_1 = cow-fs_dir.lo cow-fs_ops.lo \
+@ENABLE_DUAL_ABI_TRUE@	cow-fs_path.lo
+am__objects_2 = fs_dir.lo fs_ops.lo fs_path.lo memory_resource.lo \
+	$(am__objects_1)
+@ENABLE_DUAL_ABI_TRUE@am__objects_3 = cow-string-inst.lo
+@ENABLE_EXTERN_TEMPLATE_TRUE@am__objects_4 = ostream-inst.lo \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	string-inst.lo $(am__objects_3)
+am_libc__17convenience_la_OBJECTS = $(am__objects_2) $(am__objects_4)
+libc__17convenience_la_OBJECTS = $(am_libc__17convenience_la_OBJECTS)
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp =
+am__depfiles_maybe =
+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+AM_V_CXX = $(am__v_CXX_@AM_V@)
+am__v_CXX_ = $(am__v_CXX_@AM_DEFAULT_V@)
+am__v_CXX_0 = @echo "  CXX     " $@;
+am__v_CXX_1 = 
+CXXLD = $(CXX)
+AM_V_CXXLD = $(am__v_CXXLD_@AM_V@)
+am__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)
+am__v_CXXLD_0 = @echo "  CXXLD   " $@;
+am__v_CXXLD_1 = 
+SOURCES = $(libc__17convenience_la_SOURCES)
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
+ETAGS = etags
+CTAGS = ctags
+ABI_TWEAKS_SRCDIR = @ABI_TWEAKS_SRCDIR@
+ACLOCAL = @ACLOCAL@
+ALLOCATOR_H = @ALLOCATOR_H@
+ALLOCATOR_NAME = @ALLOCATOR_NAME@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AR = @AR@
+AS = @AS@
+ATOMICITY_SRCDIR = @ATOMICITY_SRCDIR@
+ATOMIC_FLAGS = @ATOMIC_FLAGS@
+ATOMIC_WORD_SRCDIR = @ATOMIC_WORD_SRCDIR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+BASIC_FILE_CC = @BASIC_FILE_CC@
+BASIC_FILE_H = @BASIC_FILE_H@
+CC = @CC@
+CCODECVT_CC = @CCODECVT_CC@
+CCOLLATE_CC = @CCOLLATE_CC@
+CCTYPE_CC = @CCTYPE_CC@
+CFLAGS = @CFLAGS@
+CLOCALE_CC = @CLOCALE_CC@
+CLOCALE_H = @CLOCALE_H@
+CLOCALE_INTERNAL_H = @CLOCALE_INTERNAL_H@
+CMESSAGES_CC = @CMESSAGES_CC@
+CMESSAGES_H = @CMESSAGES_H@
+CMONEY_CC = @CMONEY_CC@
+CNUMERIC_CC = @CNUMERIC_CC@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPU_DEFINES_SRCDIR = @CPU_DEFINES_SRCDIR@
+CPU_OPT_BITS_RANDOM = @CPU_OPT_BITS_RANDOM@
+CPU_OPT_EXT_RANDOM = @CPU_OPT_EXT_RANDOM@
+CSTDIO_H = @CSTDIO_H@
+CTIME_CC = @CTIME_CC@
+CTIME_H = @CTIME_H@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXFILT = @CXXFILT@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+C_INCLUDE_DIR = @C_INCLUDE_DIR@
+DBLATEX = @DBLATEX@
+DEBUG_FLAGS = @DEBUG_FLAGS@
+DEFS = @DEFS@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+ERROR_CONSTANTS_SRCDIR = @ERROR_CONSTANTS_SRCDIR@
+EXEEXT = @EXEEXT@
+EXTRA_CFLAGS = @EXTRA_CFLAGS@
+EXTRA_CXX_FLAGS = @EXTRA_CXX_FLAGS@
+FGREP = @FGREP@
+GLIBCXX_INCLUDES = @GLIBCXX_INCLUDES@
+GLIBCXX_LIBS = @GLIBCXX_LIBS@
+GREP = @GREP@
+HWCAP_CFLAGS = @HWCAP_CFLAGS@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LONG_DOUBLE_COMPAT_FLAGS = @LONG_DOUBLE_COMPAT_FLAGS@
+LTLIBICONV = @LTLIBICONV@
+LTLIBOBJS = @LTLIBOBJS@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OPTIMIZE_CXXFLAGS = @OPTIMIZE_CXXFLAGS@
+OPT_LDFLAGS = @OPT_LDFLAGS@
+OS_INC_SRCDIR = @OS_INC_SRCDIR@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PDFLATEX = @PDFLATEX@
+RANLIB = @RANLIB@
+SECTION_FLAGS = @SECTION_FLAGS@
+SECTION_LDFLAGS = @SECTION_LDFLAGS@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+SYMVER_FILE = @SYMVER_FILE@
+TOPLEVEL_INCLUDES = @TOPLEVEL_INCLUDES@
+USE_NLS = @USE_NLS@
+VERSION = @VERSION@
+VTV_CXXFLAGS = @VTV_CXXFLAGS@
+VTV_CXXLINKFLAGS = @VTV_CXXLINKFLAGS@
+VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
+WARN_FLAGS = @WARN_FLAGS@
+XMLCATALOG = @XMLCATALOG@
+XMLLINT = @XMLLINT@
+XSLTPROC = @XSLTPROC@
+XSL_STYLE_DIR = @XSL_STYLE_DIR@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__leading_dot = @am__leading_dot@
+am__tar = @am__tar@
+am__untar = @am__untar@
+baseline_dir = @baseline_dir@
+baseline_subdir_switch = @baseline_subdir_switch@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+check_msgfmt = @check_msgfmt@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_shared = @enable_shared@
+enable_static = @enable_static@
+exec_prefix = @exec_prefix@
+get_gcc_base_ver = @get_gcc_base_ver@
+glibcxx_MOFILES = @glibcxx_MOFILES@
+glibcxx_PCHFLAGS = @glibcxx_PCHFLAGS@
+glibcxx_POFILES = @glibcxx_POFILES@
+glibcxx_builddir = @glibcxx_builddir@
+glibcxx_compiler_pic_flag = @glibcxx_compiler_pic_flag@
+glibcxx_compiler_shared_flag = @glibcxx_compiler_shared_flag@
+glibcxx_cxx98_abi = @glibcxx_cxx98_abi@
+glibcxx_localedir = @glibcxx_localedir@
+glibcxx_lt_pic_flag = @glibcxx_lt_pic_flag@
+glibcxx_prefixdir = @glibcxx_prefixdir@
+glibcxx_srcdir = @glibcxx_srcdir@
+glibcxx_toolexecdir = @glibcxx_toolexecdir@
+glibcxx_toolexeclibdir = @glibcxx_toolexeclibdir@
+gxx_include_dir = @gxx_include_dir@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+libtool_VERSION = @libtool_VERSION@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_host_flags = @lt_host_flags@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+multi_basedir = @multi_basedir@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+port_specific_symbol_files = @port_specific_symbol_files@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+python_mod_dir = @python_mod_dir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+thread_header = @thread_header@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+toplevel_builddir = @toplevel_builddir@
+toplevel_srcdir = @toplevel_srcdir@
+
+# May be used by various substitution variables.
+gcc_version := $(shell @get_gcc_base_ver@ $(top_srcdir)/../gcc/BASE-VER)
+MAINT_CHARSET = latin1
+mkinstalldirs = $(SHELL) $(toplevel_srcdir)/mkinstalldirs
+PWD_COMMAND = $${PWDCMD-pwd}
+STAMP = echo timestamp >
+toolexecdir = $(glibcxx_toolexecdir)
+toolexeclibdir = $(glibcxx_toolexeclibdir)
+@ENABLE_WERROR_FALSE@WERROR_FLAG = 
+@ENABLE_WERROR_TRUE@WERROR_FLAG = -Werror
+@ENABLE_EXTERN_TEMPLATE_FALSE@XTEMPLATE_FLAGS = 
+@ENABLE_EXTERN_TEMPLATE_TRUE@XTEMPLATE_FLAGS = -fno-implicit-templates
+
+# These bits are all figured out from configure.  Look in acinclude.m4
+# or configure.ac to see how they are set.  See GLIBCXX_EXPORT_FLAGS.
+CONFIG_CXXFLAGS = \
+	$(SECTION_FLAGS) $(HWCAP_CFLAGS) -frandom-seed=$@
+
+WARN_CXXFLAGS = \
+	$(WARN_FLAGS) $(WERROR_FLAG) -fdiagnostics-show-location=once 
+
+
+# -I/-D flags to pass when compiling.
+AM_CPPFLAGS = $(GLIBCXX_INCLUDES) $(CPPFLAGS)
+
+# Convenience library for C++17 runtime.
+noinst_LTLIBRARIES = libc++17convenience.la
+headers = 
+@ENABLE_DUAL_ABI_FALSE@extra_string_inst_sources = 
+@ENABLE_DUAL_ABI_TRUE@extra_string_inst_sources = cow-string-inst.cc
+@ENABLE_DUAL_ABI_FALSE@extra_fs_sources = 
+@ENABLE_DUAL_ABI_TRUE@extra_fs_sources = \
+@ENABLE_DUAL_ABI_TRUE@	cow-fs_dir.cc \
+@ENABLE_DUAL_ABI_TRUE@	cow-fs_ops.cc \
+@ENABLE_DUAL_ABI_TRUE@	cow-fs_path.cc
+
+# XTEMPLATE_FLAGS =
+@ENABLE_EXTERN_TEMPLATE_FALSE@inst_sources = 
+
+# XTEMPLATE_FLAGS = -fno-implicit-templates
+@ENABLE_EXTERN_TEMPLATE_TRUE@inst_sources = \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	ostream-inst.cc \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	string-inst.cc \
+@ENABLE_EXTERN_TEMPLATE_TRUE@	$(extra_string_inst_sources)
+
+sources = \
+	fs_dir.cc \
+	fs_ops.cc \
+	fs_path.cc \
+	memory_resource.cc \
+	$(extra_fs_sources)
+
+libc__17convenience_la_SOURCES = $(sources)  $(inst_sources)
+
+# AM_CXXFLAGS needs to be in each subdirectory so that it can be
+# modified in a per-library or per-sub-library way.  Need to manually
+# set this option because CONFIG_CXXFLAGS has to be after
+# OPTIMIZE_CXXFLAGS on the compile line so that -O2 can be overridden
+# as the occasion calls for it.
+AM_CXXFLAGS = \
+	-std=gnu++17 \
+	$(glibcxx_lt_pic_flag) $(glibcxx_compiler_shared_flag) \
+	$(XTEMPLATE_FLAGS) $(VTV_CXXFLAGS) \
+	$(WARN_CXXFLAGS) $(OPTIMIZE_CXXFLAGS) $(CONFIG_CXXFLAGS) \
+	-fimplicit-templates
+
+AM_MAKEFLAGS = \
+	"gxx_include_dir=$(gxx_include_dir)"
+
+
+# Libtool notes
+
+# 1) In general, libtool expects an argument such as `--tag=CXX' when
+# using the C++ compiler, because that will enable the settings
+# detected when C++ support was being configured.  However, when no
+# such flag is given in the command line, libtool attempts to figure
+# it out by matching the compiler name in each configuration section
+# against a prefix of the command line.  The problem is that, if the
+# compiler name and its initial flags stored in the libtool
+# configuration file don't match those in the command line, libtool
+# can't decide which configuration to use, and it gives up.  The
+# correct solution is to add `--tag CXX' to LTCXXCOMPILE and maybe
+# CXXLINK, just after $(LIBTOOL), so that libtool doesn't have to
+# attempt to infer which configuration to use.
+#
+# The second tag argument, `--tag disable-shared` means that libtool
+# only compiles each source once, for static objects. In actuality,
+# glibcxx_lt_pic_flag and glibcxx_compiler_shared_flag are added to
+# the libtool command that is used create the object, which is
+# suitable for shared libraries.  The `--tag disable-shared` must be
+# placed after --tag CXX lest things CXX undo the affect of
+# disable-shared.
+
+# 2) Need to explicitly set LTCXXCOMPILE so that EXTRA_CXX_FLAGS is
+# last. (That way, things like -O2 passed down from the toplevel can
+# be overridden by --enable-debug.)
+LTCXXCOMPILE = \
+	$(LIBTOOL) --tag CXX --tag disable-shared \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CXX) $(TOPLEVEL_INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) $(EXTRA_CXX_FLAGS)
+
+LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))
+
+# 3) We'd have a problem when building the shared libstdc++ object if
+# the rules automake generates would be used.  We cannot allow g++ to
+# be used since this would add -lstdc++ to the link line which of
+# course is problematic at this point.  So, we get the top-level
+# directory to configure libstdc++-v3 to use gcc as the C++
+# compilation driver.
+CXXLINK = \
+	$(LIBTOOL) --tag CXX --tag disable-shared \
+	$(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CXX) \
+	$(VTV_CXXLINKFLAGS) \
+	$(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .cc .lo .o .obj
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am $(top_srcdir)/fragment.am $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign --ignore-deps src/c++17/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign --ignore-deps src/c++17/Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+$(top_srcdir)/fragment.am $(am__empty):
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
+
+libc++17convenience.la: $(libc__17convenience_la_OBJECTS) $(libc__17convenience_la_DEPENDENCIES) $(EXTRA_libc__17convenience_la_DEPENDENCIES) 
+	$(AM_V_CXXLD)$(CXXLINK)  $(libc__17convenience_la_OBJECTS) $(libc__17convenience_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+.cc.o:
+	$(AM_V_CXX)$(CXXCOMPILE) -c -o $@ $<
+
+.cc.obj:
+	$(AM_V_CXX)$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+.cc.lo:
+	$(AM_V_CXX)$(LTCXXCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-am
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	set x; \
+	here=`pwd`; \
+	$(am__define_uniq_tagged_files); \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: ctags-am
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscopelist: cscopelist-am
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS TAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES cscopelist-am ctags \
+	ctags-am distclean distclean-compile distclean-generic \
+	distclean-libtool distclean-tags dvi dvi-am html html-am info \
+	info-am install install-am install-data install-data-am \
+	install-dvi install-dvi-am install-exec install-exec-am \
+	install-html install-html-am install-info install-info-am \
+	install-man install-pdf install-pdf-am install-ps \
+	install-ps-am install-strip installcheck installcheck-am \
+	installdirs maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-am uninstall \
+	uninstall-am
+
+.PRECIOUS: Makefile
+
+
+vpath % $(top_srcdir)/src/c++17
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
Index: libstdc++-v3/src/Makefile.in
===================================================================
diff --git a/libstdc++-v3/src/Makefile.in b/libstdc++-v3/src/Makefile.in
--- a/libstdc++-v3/src/Makefile.in	(revision 278653)
+++ b/libstdc++-v3/src/Makefile.in	(revision 278653)
@@ -268,6 +268,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
@@ -993,7 +994,7 @@
 	fi; \
 	echo `date` > stamp-libstdc++convenience;
 stamp-debug:
-	if test ! -d ${debugdir}; then \
+	if test ! -d ${debugdir} || test ! -f ${debugdir}/Makefile ; then \
 	  mkdir -p ${debugdir}; \
 	  for d in $(SUBDIRS); do mkdir -p  ${debugdir}/$$d; done; \
 	  (cd ${debugdir}; \
Index: libstdc++-v3/src/filesystem/path.cc
===================================================================
diff --git a/libstdc++-v3/src/filesystem/path.cc b/libstdc++-v3/src/filesystem/path.cc
--- a/libstdc++-v3/src/filesystem/path.cc	(revision 278653)
+++ b/libstdc++-v3/src/filesystem/path.cc	(revision 278653)
@@ -334,6 +334,28 @@
   if (_M_pathname.empty())
     return;
 
+  {
+    // Approximate count of components, to reserve space in _M_cmpts vector:
+    int count = 1;
+    bool saw_sep_last = _S_is_dir_sep(_M_pathname[0]);
+    bool saw_non_sep = !saw_sep_last;
+    for (value_type c : _M_pathname)
+      {
+	if (_S_is_dir_sep(c))
+	  saw_sep_last = true;
+	else if (saw_sep_last)
+	  {
+	    ++count;
+	    saw_sep_last = false;
+	    saw_non_sep = true;
+	  }
+      }
+    if (saw_non_sep && saw_sep_last)
+      ++count; // empty filename after trailing slash
+    if (count > 1)
+      _M_cmpts.reserve(count);
+  }
+
   size_t pos = 0;
   const size_t len = _M_pathname.size();
 
@@ -356,9 +378,13 @@
 	      pos = 3;
 	      while (pos < len && !_S_is_dir_sep(_M_pathname[pos]))
 		++pos;
+	      if (pos == len)
+		{
+		  _M_type = _Type::_Root_name;
+		  return;
+		}
 	      _M_add_root_name(pos);
-	      if (pos < len) // also got root directory
-		_M_add_root_dir(pos);
+	      _M_add_root_dir(pos);
 	    }
 	  else
 	    {
@@ -367,6 +393,11 @@
 	      _M_add_root_dir(0);
 	    }
 	}
+      else if (len == 1) // got root directory only
+	{
+	  _M_type = _Type::_Root_dir;
+	  return;
+	}
       else // got root directory
 	_M_add_root_dir(0);
       ++pos;
@@ -375,6 +406,11 @@
   else if (len > 1 && _M_pathname[1] == L':')
     {
       // got disk designator
+      if (len == 2)
+	{
+	  _M_type = _Type::_Root_name;
+	  return;
+	}
       _M_add_root_name(2);
       if (len > 2 && _S_is_dir_sep(_M_pathname[2]))
 	_M_add_root_dir(2);
@@ -381,6 +417,17 @@
       pos = 2;
     }
 #endif
+  else
+    {
+      size_t n = 1;
+      for (; n < _M_pathname.size() && !_S_is_dir_sep(_M_pathname[n]); ++n)
+	{ }
+      if (n == _M_pathname.size())
+	{
+	  _M_type = _Type::_Filename;
+	  return;
+	}
+    }
 
   size_t back = pos;
   while (pos < len)
Index: libstdc++-v3/src/filesystem/Makefile.in
===================================================================
diff --git a/libstdc++-v3/src/filesystem/Makefile.in b/libstdc++-v3/src/filesystem/Makefile.in
--- a/libstdc++-v3/src/filesystem/Makefile.in	(revision 278653)
+++ b/libstdc++-v3/src/filesystem/Makefile.in	(revision 278653)
@@ -249,6 +249,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/src/filesystem/std-dir.cc
===================================================================
diff --git a/libstdc++-v3/src/filesystem/std-dir.cc b/libstdc++-v3/src/filesystem/std-dir.cc
--- a/libstdc++-v3/src/filesystem/std-dir.cc	(revision 278653)
+++ b/libstdc++-v3/src/filesystem/std-dir.cc	(revision 278653)
@@ -57,7 +57,13 @@
   {
     if (const auto entp = _Dir_base::advance(skip_permission_denied, ec))
       {
-	entry = fs::directory_entry{path / entp->d_name, get_file_type(*entp)};
+	file_type type = file_type::none;
+#ifdef _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE
+	// Even if the OS supports dirent::d_type the filesystem might not:
+	if (entp->d_type != DT_UNKNOWN)
+	  type = get_file_type(*entp);
+#endif
+	entry = fs::directory_entry{path / entp->d_name, type};
 	return true;
       }
     else if (!ec)
Index: libstdc++-v3/src/filesystem/std-path.cc
===================================================================
diff --git a/libstdc++-v3/src/filesystem/std-path.cc b/libstdc++-v3/src/filesystem/std-path.cc
--- a/libstdc++-v3/src/filesystem/std-path.cc	(revision 278653)
+++ b/libstdc++-v3/src/filesystem/std-path.cc	(revision 278653)
@@ -539,6 +539,28 @@
     }
   _M_type = _Type::_Multi;
 
+  {
+    // Approximate count of components, to reserve space in _M_cmpts vector:
+    int count = 1;
+    bool saw_sep_last = _S_is_dir_sep(_M_pathname[0]);
+    bool saw_non_sep = !saw_sep_last;
+    for (value_type c : _M_pathname)
+      {
+	if (_S_is_dir_sep(c))
+	  saw_sep_last = true;
+	else if (saw_sep_last)
+	  {
+	    ++count;
+	    saw_sep_last = false;
+	    saw_non_sep = true;
+	  }
+      }
+    if (saw_non_sep && saw_sep_last)
+      ++count; // empty filename after trailing slash
+    if (count > 1)
+      _M_cmpts.reserve(count);
+  }
+
   size_t pos = 0;
   const size_t len = _M_pathname.size();
 
@@ -555,9 +577,13 @@
 	      pos = 3;
 	      while (pos < len && !_S_is_dir_sep(_M_pathname[pos]))
 		++pos;
+	      if (pos == len)
+		{
+		  _M_type = _Type::_Root_name;
+		  return;
+		}
 	      _M_add_root_name(pos);
-	      if (pos < len) // also got root directory
-		_M_add_root_dir(pos);
+	      _M_add_root_dir(pos);
 	    }
 	  else
 	    {
@@ -584,6 +610,11 @@
   else if (len > 1 && _M_pathname[1] == L':')
     {
       // got disk designator
+      if (len == 2)
+	{
+	  _M_type = _Type::_Root_name;
+	  return;
+	}
       _M_add_root_name(2);
       if (len > 2 && _S_is_dir_sep(_M_pathname[2]))
 	_M_add_root_dir(2);
@@ -590,6 +621,17 @@
       pos = 2;
     }
 #endif
+  else
+    {
+      size_t n = 1;
+      for (; n < _M_pathname.size() && !_S_is_dir_sep(_M_pathname[n]); ++n)
+	{ }
+      if (n == _M_pathname.size())
+	{
+	  _M_type = _Type::_Filename;
+	  return;
+	}
+    }
 
   size_t back = pos;
   while (pos < len)
Index: libstdc++-v3/src/filesystem/std-ops.cc
===================================================================
diff --git a/libstdc++-v3/src/filesystem/std-ops.cc b/libstdc++-v3/src/filesystem/std-ops.cc
--- a/libstdc++-v3/src/filesystem/std-ops.cc	(revision 278653)
+++ b/libstdc++-v3/src/filesystem/std-ops.cc	(revision 278653)
@@ -77,6 +77,9 @@
 	std::make_error_code(errc::not_supported)));
   return ret;
 #else
+  if (p.empty())
+    _GLIBCXX_THROW_OR_ABORT(filesystem_error("cannot make absolute path", p,
+	  make_error_code(std::errc::invalid_argument)));
   return current_path() / p;
 #endif
 }
@@ -87,7 +90,7 @@
   path ret;
   if (p.empty())
     {
-      ec = make_error_code(std::errc::no_such_file_or_directory);
+      ec = make_error_code(std::errc::invalid_argument);
       return ret;
     }
   if (p.is_absolute())
Index: libstdc++-v3/src/Makefile.am
===================================================================
diff --git a/libstdc++-v3/src/Makefile.am b/libstdc++-v3/src/Makefile.am
--- a/libstdc++-v3/src/Makefile.am	(revision 278653)
+++ b/libstdc++-v3/src/Makefile.am	(revision 278653)
@@ -321,7 +321,7 @@
 # Take care to fix all possibly-relative paths.
 debugdir = ${glibcxx_builddir}/src/debug
 stamp-debug:
-	if test ! -d ${debugdir}; then \
+	if test ! -d ${debugdir} || test ! -f ${debugdir}/Makefile ; then \
 	  mkdir -p ${debugdir}; \
 	  for d in $(SUBDIRS); do mkdir -p  ${debugdir}/$$d; done; \
 	  (cd ${debugdir}; \
Index: libstdc++-v3/src/c++98/Makefile.in
===================================================================
diff --git a/libstdc++-v3/src/c++98/Makefile.in b/libstdc++-v3/src/c++98/Makefile.in
--- a/libstdc++-v3/src/c++98/Makefile.in	(revision 278653)
+++ b/libstdc++-v3/src/c++98/Makefile.in	(revision 278653)
@@ -239,6 +239,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/src/c++11/Makefile.in
===================================================================
diff --git a/libstdc++-v3/src/c++11/Makefile.in b/libstdc++-v3/src/c++11/Makefile.in
--- a/libstdc++-v3/src/c++11/Makefile.in	(revision 278653)
+++ b/libstdc++-v3/src/c++11/Makefile.in	(revision 278653)
@@ -243,6 +243,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/configure.ac
===================================================================
diff --git a/libstdc++-v3/configure.ac b/libstdc++-v3/configure.ac
--- a/libstdc++-v3/configure.ac	(revision 278653)
+++ b/libstdc++-v3/configure.ac	(revision 278653)
@@ -442,6 +442,7 @@
 AC_CHECK_PROG([DOT], dot, yes, no)
 
 # Check for docbook
+AC_CHECK_PROG([XMLCATALOG], xmlcatalog, yes, no)
 AC_CHECK_PROG([XSLTPROC], xsltproc, yes, no)
 AC_CHECK_PROG([XMLLINT], xmllint, yes, no)
 GLIBCXX_CONFIGURE_DOCBOOK
Index: libstdc++-v3/doc/xml/faq.xml
===================================================================
diff --git a/libstdc++-v3/doc/xml/faq.xml b/libstdc++-v3/doc/xml/faq.xml
--- a/libstdc++-v3/doc/xml/faq.xml	(revision 278653)
+++ b/libstdc++-v3/doc/xml/faq.xml	(revision 278653)
@@ -1001,21 +1001,31 @@
 <qandaentry xml:id="faq.memory_leaks">
   <question xml:id="q-memory_leaks">
     <para>
-      <quote>Memory leaks</quote> in containers
+      <quote>Memory leaks</quote> in libstdc++
     </para>
   </question>
   <answer xml:id="a-memory_leaks">
-    <note>
-      <para>This answer is old and probably no longer be relevant.</para>
-    </note>
     <para>
-    A few people have reported that the standard containers appear
+    Since GCC 5.1.0, libstdc++ automatically allocates a pool
+    of a few dozen kilobytes on startup. This pool is used to ensure it's
+    possible to throw exceptions (such as <classname>bad_alloc</classname>)
+    even when <code>malloc</code> is unable to allocate any more memory.
+    With some versions of <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://valgrind.org/"><command>valgrind</command></link>
+    this pool will be shown as "still reachable" when the process exits, e.g.
+    <code>still reachable: 72,704 bytes in 1 blocks</code>.
+    This memory is not a leak, because it's still in use by libstdc++,
+    and the memory will be returned to the OS when the process exits.
+    Later versions of <command>valgrind</command> know how to free this
+    pool as the process exits, and so won't show any "still reachable" memory.
+    </para>
+    <para>
+    In the past, a few people reported that the standard containers appear
     to leak memory when tested with memory checkers such as
     <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://valgrind.org/"><command>valgrind</command></link>.
     Under some (non-default) configurations the library's allocators keep
     free memory in a
-    pool for later reuse, rather than returning it to the OS.  Although
-    this memory is always reachable by the library and is never
+    pool for later reuse, rather than deallocating it with <code>delete</code>
+    Although this memory is always reachable by the library and is never
     lost, memory debugging tools can report it as a leak.  If you
     want to test the library for memory leaks please read
     <link linkend="debug.memory">Tips for memory leak hunting</link>
Index: libstdc++-v3/doc/xml/manual/allocator.xml
===================================================================
diff --git a/libstdc++-v3/doc/xml/manual/allocator.xml b/libstdc++-v3/doc/xml/manual/allocator.xml
--- a/libstdc++-v3/doc/xml/manual/allocator.xml	(revision 278653)
+++ b/libstdc++-v3/doc/xml/manual/allocator.xml	(revision 278653)
@@ -502,12 +502,12 @@
   </biblioentry>
 
   <biblioentry>
-      <title>
-	<link xmlns:xlink="http://www.w3.org/1999/xlink"
-	      xlink:href="http://www.drdobbs.com/the-standard-librarian-what-are-allocato/184403759">
+    <title>
+      <link xmlns:xlink="http://www.w3.org/1999/xlink"
+	    xlink:href="https://web.archive.org/web/20190622154249/http://www.drdobbs.com/the-standard-librarian-what-are-allocato/184403759">
       The Standard Librarian: What Are Allocators Good For?
-	</link>
-      </title>
+      </link>
+    </title>
 
     <author><personname><firstname>Matt</firstname><surname>Austern</surname></personname></author>
     <publisher>
@@ -515,12 +515,13 @@
 	C/C++ Users Journal
       </publishername>
     </publisher>
+    <pubdate>2000-12</pubdate>
   </biblioentry>
 
   <biblioentry>
       <title>
 	<link xmlns:xlink="http://www.w3.org/1999/xlink"
-	      xlink:href="https://www.hoard.org">
+	      xlink:href="http://hoard.org">
       The Hoard Memory Allocator
 	</link>
       </title>
Index: libstdc++-v3/doc/xml/manual/intro.xml
===================================================================
diff --git a/libstdc++-v3/doc/xml/manual/intro.xml b/libstdc++-v3/doc/xml/manual/intro.xml
--- a/libstdc++-v3/doc/xml/manual/intro.xml	(revision 278653)
+++ b/libstdc++-v3/doc/xml/manual/intro.xml	(revision 278653)
@@ -1105,6 +1105,14 @@
     ill-formed.
     </para></listitem></varlistentry>
 
+    <varlistentry xml:id="manual.bugs.dr2537"><term><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="&DR;#2537">2537</link>:
+       <emphasis>Constructors for <code>priority_queue</code> taking allocators
+	 should call <code>make_heap</code>
+       </emphasis>
+    </term>
+    <listitem><para>Call <code>make_heap</code>.
+    </para></listitem></varlistentry>
+
     <varlistentry xml:id="manual.bugs.dr2583"><term><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="&DR;#2583">2583</link>:
        <emphasis>There is no way to supply an allocator for <code>basic_string(str, pos)</code>
        </emphasis>
@@ -1112,6 +1120,14 @@
     <listitem><para>Add new constructor
     </para></listitem></varlistentry>
 
+    <varlistentry xml:id="manual.bugs.dr2586"><term><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="&DR;#2586">2586</link>:
+       <emphasis>Wrong value category used in <code>scoped_allocator_adaptor::construct()</code>
+       </emphasis>
+    </term>
+    <listitem><para>Change internal helper for uses-allocator construction
+      to always check using const lvalue allocators.
+    </para></listitem></varlistentry>
+
     <varlistentry xml:id="manual.bugs.dr2684"><term><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="&DR;#2684">2684</link>:
        <emphasis><code>priority_queue</code> lacking comparator typedef
        </emphasis>
Index: libstdc++-v3/doc/xml/manual/shared_ptr.xml
===================================================================
diff --git a/libstdc++-v3/doc/xml/manual/shared_ptr.xml b/libstdc++-v3/doc/xml/manual/shared_ptr.xml
--- a/libstdc++-v3/doc/xml/manual/shared_ptr.xml	(revision 278653)
+++ b/libstdc++-v3/doc/xml/manual/shared_ptr.xml	(revision 278653)
@@ -239,7 +239,7 @@
    <orderedlist>
      <listitem>
        <para>
-       <constant>_S_Atomic</constant>
+       <constant>_S_atomic</constant>
        </para>
        <para>
 Selected when GCC supports a builtin atomic compare-and-swap operation
@@ -252,7 +252,7 @@
 
      <listitem>
        <para>
-       <constant>_S_Mutex</constant>
+       <constant>_S_mutex</constant>
        </para>
        <para>
 The _Sp_counted_base specialization for this policy contains a mutex,
@@ -263,7 +263,7 @@
 
      <listitem>
        <para>
-       <constant>_S_Single</constant>
+       <constant>_S_single</constant>
        </para>
        <para>
 This policy uses a non-reentrant add_ref_lock() with no locking. It is
Index: libstdc++-v3/doc/xml/manual/status_cxx2017.xml
===================================================================
diff --git a/libstdc++-v3/doc/xml/manual/status_cxx2017.xml b/libstdc++-v3/doc/xml/manual/status_cxx2017.xml
--- a/libstdc++-v3/doc/xml/manual/status_cxx2017.xml	(revision 278653)
+++ b/libstdc++-v3/doc/xml/manual/status_cxx2017.xml	(revision 278653)
@@ -25,8 +25,8 @@
 </para>
 
 <para>
-The following table lists new library features that have been accepted into
-the C++17 working draft. The "Proposal" column provides a link to the
+The following table lists new library features that are included in
+the C++17 standard. The "Proposal" column provides a link to the
 ISO C++ committee proposal that describes the feature, while the "Status"
 column indicates the first version of GCC that contains an implementation of
 this feature (if it has been implemented).
@@ -382,7 +382,7 @@
 	</link>
       </entry>
       <entry align="center"> 7.1 </entry>
-      <entry><code> </code></entry>
+      <entry><code>__cpp_lib_raw_memory_algorithms &gt;= 201606L</code></entry>
     </row>
 
     <row>
@@ -788,7 +788,32 @@
              <code> __cpp_lib_to_chars >= 201611 </code></entry>
     </row>
 
+    <row>
+      <entry> Homogeneous interface for variant, any and optional </entry>
+      <entry>
+	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0032r3.pdf">
+	P0032R3
+	</link>
+      </entry>
+      <entry align="center"> 7.1  </entry>
+      <entry>
+             <code> __cpp_lib_any >= 201606 </code>,
+             <code> __cpp_lib_optional >= 201606 </code>,
+             <code> __cpp_lib_variant >= 201606 </code>
+      </entry>
+    </row>
 
+    <row>
+      <entry> Making Optional Greater Equal Again </entry>
+      <entry>
+	<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0307r2.pdf">
+	P0307R2
+	</link>
+      </entry>
+      <entry align="center"> 7.1  </entry>
+      <entry> <code> __cpp_lib_optional >= 201606 </code> </entry>
+    </row>
+
   </tbody>
 </tgroup>
 </table>
@@ -1049,7 +1074,7 @@
    <para>
       <emphasis>30.10.2.1 [fs.conform.9945]</emphasis>
       The behavior of the filesystem library implementation will depend on
-      the target operating system. Some features will not be not supported
+      the target operating system. Some features will not be supported
       on some targets.
    </para>
 
Index: libstdc++-v3/doc/xml/manual/evolution.xml
===================================================================
diff --git a/libstdc++-v3/doc/xml/manual/evolution.xml b/libstdc++-v3/doc/xml/manual/evolution.xml
--- a/libstdc++-v3/doc/xml/manual/evolution.xml	(revision 278653)
+++ b/libstdc++-v3/doc/xml/manual/evolution.xml	(revision 278653)
@@ -80,11 +80,12 @@
 
    <para> For GCC releases from 2.95 through the 3.1 series, defining
    <literal>__USE_MALLOC</literal> on the gcc command line would change the
-   default allocation strategy to instead use <code> malloc</code> and
-   <function>free</function>. For the 3.2 and 3.3 release series the same
+   default allocation strategy to instead use <code>malloc</code> and
+   <code>free</code>. For the 3.2 and 3.3 release series the same
    functionality was spelled <literal>_GLIBCXX_FORCE_NEW</literal>. From
-   GCC 3.4 onwards the functionality is enabled by setting
-   <literal>GLIBCXX_FORCE_NEW</literal> in the environment, see
+   GCC 3.4 onwards the default allocator uses <code>new</code> anyway,
+   but for the optional pooling allocators the functionality is enabled by
+   setting <literal>GLIBCXX_FORCE_NEW</literal> in the environment, see
    <link linkend="manual.ext.allocator.mt">the mt allocator chapter</link>
    for details.
    </para>
Index: libstdc++-v3/doc/xml/manual/using.xml
===================================================================
diff --git a/libstdc++-v3/doc/xml/manual/using.xml b/libstdc++-v3/doc/xml/manual/using.xml
--- a/libstdc++-v3/doc/xml/manual/using.xml	(revision 278653)
+++ b/libstdc++-v3/doc/xml/manual/using.xml	(revision 278653)
@@ -1130,8 +1130,8 @@
         enabled for
         <classname>std::vector&lt;T, std::allocator&lt;T&gt;&gt;</classname>
         and only when <classname>std::allocator</classname> is derived from
-        <xref linkend="allocator.impl"><classname>new_allocator</classname>
-        or <classname>malloc_allocator</classname></xref>. The annotations
+        <link linkend="allocator.impl"><classname>new_allocator</classname>
+        or <classname>malloc_allocator</classname></link>. The annotations
         must be present on all vector operations or none, so this macro must
         be defined to the same value for all translation units that create,
         destroy or modify vectors.
Index: libstdc++-v3/doc/xml/manual/debug.xml
===================================================================
diff --git a/libstdc++-v3/doc/xml/manual/debug.xml b/libstdc++-v3/doc/xml/manual/debug.xml
--- a/libstdc++-v3/doc/xml/manual/debug.xml	(revision 278653)
+++ b/libstdc++-v3/doc/xml/manual/debug.xml	(revision 278653)
@@ -94,50 +94,35 @@
 
 <section xml:id="debug.memory"><info><title>Memory Leak Hunting</title></info>
 
+<para>
+  On many targets GCC supports AddressSanitizer, a fast memory error detector,
+  which is enabled by the <option>-fsanitize=address</option> option.
+</para>
 
 <para>
-  There are various third party memory tracing and debug utilities
+  There are also various third party memory tracing and debug utilities
   that can be used to provide detailed memory allocation information
   about C++ code. An exhaustive list of tools is not going to be
   attempted, but includes <code>mtrace</code>, <code>valgrind</code>,
-  <code>mudflap</code>, and the non-free commercial product
-  <code>purify</code>. In addition, <code>libcwd</code> has a
-  replacement for the global new and delete operators that can track
-  memory allocation and deallocation and provide useful memory
-  statistics.
+  <code>mudflap</code> (no longer supported since GCC 4.9.0), ElectricFence,
+  and the non-free commercial product <code>purify</code>.
+  In addition, <code>libcwd</code>, jemalloc and TCMalloc have replacements
+  for the global <code>new</code> and <code>delete</code> operators
+  that can track memory allocation and deallocation and provide useful
+  memory statistics.
 </para>
 
 <para>
-  Regardless of the memory debugging tool being used, there is one
-  thing of great importance to keep in mind when debugging C++ code
-  that uses <code>new</code> and <code>delete</code>: there are
-  different kinds of allocation schemes that can be used by <code>
-  std::allocator</code>. For implementation details, see the <link linkend="manual.ext.allocator.mt">mt allocator</link> documentation and
-  look specifically for <code>GLIBCXX_FORCE_NEW</code>.
-</para>
-
-<para>
-  In a nutshell, the optional <classname>mt_allocator</classname>
-  is a high-performance pool allocator, and can
-  give the mistaken impression that in a suspect executable, memory is
-  being leaked, when in reality the memory "leak" is a pool being used
-  by the library's allocator and is reclaimed after program
-  termination.
-</para>
-
-<para>
   For valgrind, there are some specific items to keep in mind. First
   of all, use a version of valgrind that will work with current GNU
   C++ tools: the first that can do this is valgrind 1.0.4, but later
-  versions should work at least as well. Second of all, use a
-  completely unoptimized build to avoid confusing valgrind. Third, use
-  GLIBCXX_FORCE_NEW to keep extraneous pool allocation noise from
-  cluttering debug information.
+  versions should work better. Second, using an unoptimized build
+  might avoid confusing valgrind.
 </para>
 
 <para>
-  Fourth, it may be necessary to force deallocation in other libraries
-  as well, namely the "C" library. On linux, this can be accomplished
+  Third, it may be necessary to force deallocation in other libraries
+  as well, namely the "C" library. On GNU/Linux, this can be accomplished
   with the appropriate use of the <code>__cxa_atexit</code> or
   <code>atexit</code> functions.
 </para>
@@ -157,7 +142,6 @@
    }
 </programlisting>
 
-
 <para>or, using <code>__cxa_atexit</code>:</para>
 
 <programlisting>
@@ -184,8 +168,41 @@
    valgrind -v --num-callers=20 --leak-check=yes --leak-resolution=high --show-reachable=yes a.out
 </programlisting>
 
+<section xml:id="debug.memory.mtalloc">
+<info><title>Non-memory leaks in Pool and MT allocators</title></info>
+
+<para>
+  There are different kinds of allocation schemes that can be used by
+  <code>std::allocator</code>. Prior to GCC 3.4.0 the default was to use
+  a pooling allocator, <classname>pool_allocator</classname>,
+  which is still available as the optional
+  <classname>__pool_alloc</classname> extension.
+  Another optional extension, <classname>__mt_alloc</classname>,
+  is a high-performance pool allocator.
+</para>
+
+<para>
+  In a suspect executable these pooling allocators can give
+  the mistaken impression that memory is being leaked,
+  when in reality the memory "leak" is a pool being used
+  by the library's allocator and is reclaimed after program
+  termination.
+</para>
+
+<para>
+  If you're using memory debugging tools on a program that uses
+  one of these pooling allocators, you can set the environment variable
+  <literal>GLIBCXX_FORCE_NEW</literal> to keep extraneous pool allocation
+  noise from cluttering debug information.
+  For more details, see the
+  <link linkend="manual.ext.allocator.mt">mt allocator</link>
+  documentation and look specifically for <code>GLIBCXX_FORCE_NEW</code>.
+</para>
+
 </section>
 
+</section>
+
 <section xml:id="debug.races"><info><title>Data Race Hunting</title></info>
 <para>
   All synchronization primitives used in the library internals need to be
Index: libstdc++-v3/doc/xml/manual/documentation_hacking.xml
===================================================================
diff --git a/libstdc++-v3/doc/xml/manual/documentation_hacking.xml b/libstdc++-v3/doc/xml/manual/documentation_hacking.xml
--- a/libstdc++-v3/doc/xml/manual/documentation_hacking.xml	(revision 278653)
+++ b/libstdc++-v3/doc/xml/manual/documentation_hacking.xml	(revision 278653)
@@ -805,7 +805,7 @@
       </para>
 
       <para>
-	Generated files are output into separate sub directores of
+	Generated files are output into separate sub-directores of
 	<filename class="directory">doc/docbook/</filename> in the
 	build directory, based on the output format. For instance, the
 	HTML docs will be in <filename
@@ -813,6 +813,13 @@
       </para>
 
       <para>
+	The <screen>doc-html-docbook-regenerate</screen> target will generate
+	the HTML files and copy them back to the libstdc++ source tree.
+	This can be used to update the HTML files that are checked in to
+	version control.
+      </para>
+
+      <para>
 	If the Docbook stylesheets are installed in a custom location,
 	one can use the variable <literal>XSL_STYLE_DIR</literal> to
 	override the Makefile defaults. For example:
Index: libstdc++-v3/doc/Makefile.in
===================================================================
diff --git a/libstdc++-v3/doc/Makefile.in b/libstdc++-v3/doc/Makefile.in
--- a/libstdc++-v3/doc/Makefile.in	(revision 278653)
+++ b/libstdc++-v3/doc/Makefile.in	(revision 278653)
@@ -205,6 +205,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 
 # Validate existing XML structure.
 XMLLINT = xmllint
@@ -926,7 +927,6 @@
 
 ${docbook_outdir}/html:
 	mkdir -p ${docbook_outdir}/html
-	mkdir -p ${docbook_outdir}/html/ext
 	mkdir -p ${docbook_outdir}/html/images
 	mkdir -p ${docbook_outdir}/html/manual
 
@@ -978,6 +978,12 @@
 	$(STAMP) stamp-html-docbook
 
 doc-html-docbook: stamp-html-docbook-data
+
+# Generate the HTML pages and copy them back to the source tree.
+doc-html-docbook-regenerate: doc-html-docbook
+	$(INSTALL_DATA) ${docbook_outdir}/html/*.html ${top_srcdir}/doc/html
+	$(INSTALL_DATA) ${docbook_outdir}/html/images/* ${top_srcdir}/doc/html/images
+	$(INSTALL_DATA) ${docbook_outdir}/html/manual/*.html ${top_srcdir}/doc/html/manual
 stamp-html-single-docbook: $(xml_sources) ${docbook_outdir}/html
 	@echo "Generating html single file..."
 	$(XSLTPROC) $(XSLT_PARAM) $(XSLT_FLAGS) -o ${manual_html} \
Index: libstdc++-v3/doc/html/faq.html
===================================================================
diff --git a/libstdc++-v3/doc/html/faq.html b/libstdc++-v3/doc/html/faq.html
--- a/libstdc++-v3/doc/html/faq.html	(revision 278653)
+++ b/libstdc++-v3/doc/html/faq.html	(revision 278653)
@@ -70,7 +70,7 @@
       Program crashes when using library code in a
       dynamically-loaded library
     </a></dt><dt>6.7. <a href="faq.html#faq.memory_leaks">
-      “Memory leaks” in containers
+      “Memory leaks” in libstdc++
     </a></dt><dt>6.8. <a href="faq.html#faq.list_size_on">
       list::size() is O(n)!
     </a></dt><dt>6.9. <a href="faq.html#faq.easy_to_fix">
@@ -593,7 +593,7 @@
       Program crashes when using library code in a
       dynamically-loaded library
     </a></dt><dt>6.7. <a href="faq.html#faq.memory_leaks">
-      “Memory leaks” in containers
+      “Memory leaks” in libstdc++
     </a></dt><dt>6.8. <a href="faq.html#faq.list_size_on">
       list::size() is O(n)!
     </a></dt><dt>6.9. <a href="faq.html#faq.easy_to_fix">
@@ -708,15 +708,27 @@
     Link the executable:<br />
     <span class="command"><strong>g++ -fPIC -rdynamic -o foo ... -L. -lfoo -ldl</strong></span><br />
     </p></div></td></tr><tr class="question"><td align="left" valign="top"><a id="faq.memory_leaks"></a><a id="q-memory_leaks"></a><p><strong>6.7.</strong></p></td><td align="left" valign="top"><p>
-      <span class="quote">“<span class="quote">Memory leaks</span>”</span> in containers
-    </p></td></tr><tr class="answer"><td align="left" valign="top"><a id="a-memory_leaks"></a></td><td align="left" valign="top"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This answer is old and probably no longer be relevant.</p></div><p>
-    A few people have reported that the standard containers appear
+      <span class="quote">“<span class="quote">Memory leaks</span>”</span> in libstdc++
+    </p></td></tr><tr class="answer"><td align="left" valign="top"><a id="a-memory_leaks"></a></td><td align="left" valign="top"><p>
+    Since GCC 5.1.0, libstdc++ automatically allocates a pool
+    of a few dozen kilobytes on startup. This pool is used to ensure it's
+    possible to throw exceptions (such as <code class="classname">bad_alloc</code>)
+    even when <code class="code">malloc</code> is unable to allocate any more memory.
+    With some versions of <a class="link" href="http://valgrind.org/" target="_top"><span class="command"><strong>valgrind</strong></span></a>
+    this pool will be shown as "still reachable" when the process exits, e.g.
+    <code class="code">still reachable: 72,704 bytes in 1 blocks</code>.
+    This memory is not a leak, because it's still in use by libstdc++,
+    and the memory will be returned to the OS when the process exits.
+    Later versions of <span class="command"><strong>valgrind</strong></span> know how to free this
+    pool as the process exits, and so won't show any "still reachable" memory.
+    </p><p>
+    In the past, a few people reported that the standard containers appear
     to leak memory when tested with memory checkers such as
     <a class="link" href="http://valgrind.org/" target="_top"><span class="command"><strong>valgrind</strong></span></a>.
     Under some (non-default) configurations the library's allocators keep
     free memory in a
-    pool for later reuse, rather than returning it to the OS.  Although
-    this memory is always reachable by the library and is never
+    pool for later reuse, rather than deallocating it with <code class="code">delete</code>
+    Although this memory is always reachable by the library and is never
     lost, memory debugging tools can report it as a leak.  If you
     want to test the library for memory leaks please read
     <a class="link" href="manual/debug.html#debug.memory" title="Memory Leak Hunting">Tips for memory leak hunting</a>
Index: libstdc++-v3/doc/html/index.html
===================================================================
diff --git a/libstdc++-v3/doc/html/index.html b/libstdc++-v3/doc/html/index.html
--- a/libstdc++-v3/doc/html/index.html	(revision 278653)
+++ b/libstdc++-v3/doc/html/index.html	(revision 278653)
@@ -23,7 +23,7 @@
     </p></div></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="book"><a href="manual/index.html">The GNU C++ Library Manual</a></span></dt><dd><dl><dt><span class="part"><a href="manual/intro.html">I. 
   Introduction
   
-</a></span></dt><dd><dl><dt><span class="chapter"><a href="manual/status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="manual/status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="manual/bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="manual/setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="manual/setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/configure.html">Configure</a></span></dt><dt><span class="section"><a href="manual/make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="manual/using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="manual/using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="manual/using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="manual/std_contents.html">II. 
+</a></span></dt><dd><dl><dt><span class="chapter"><a href="manual/status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="manual/status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="manual/status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="manual/status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="manual/status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="manual/license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="manual/bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="manual/bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="manual/setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="manual/setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/configure.html">Configure</a></span></dt><dt><span class="section"><a href="manual/make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="manual/using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="manual/using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="manual/using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="manual/using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="manual/using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="manual/using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="manual/using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="manual/using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="manual/using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="manual/debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="manual/debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="manual/debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="manual/debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="manual/std_contents.html">II. 
     Standard Contents
   </a></span></dt><dd><dl><dt><span class="chapter"><a href="manual/support.html">4. 
   Support
Index: libstdc++-v3/doc/html/manual/status.html
===================================================================
diff --git a/libstdc++-v3/doc/html/manual/status.html b/libstdc++-v3/doc/html/manual/status.html
--- a/libstdc++-v3/doc/html/manual/status.html	(revision 278653)
+++ b/libstdc++-v3/doc/html/manual/status.html	(revision 278653)
@@ -526,8 +526,8 @@
 This section describes the C++17 and library TS support in mainline GCC SVN,
 not in any particular release.
 </p><p>
-The following table lists new library features that have been accepted into
-the C++17 working draft. The "Proposal" column provides a link to the
+The following table lists new library features that are included in
+the C++17 standard. The "Proposal" column provides a link to the
 ISO C++ committee proposal that describes the feature, while the "Status"
 column indicates the first version of GCC that contains an implementation of
 this feature (if it has been implemented).
@@ -665,7 +665,7 @@
 	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0040r3.html" target="_top">
 	P0040R3
 	</a>
-      </td><td align="center"> 7.1 </td><td align="left"><code class="code"> </code></td></tr><tr><td align="left"> <code class="code">shared_ptr::weak_type</code></td><td align="left">
+      </td><td align="center"> 7.1 </td><td align="left"><code class="code">__cpp_lib_raw_memory_algorithms &gt;= 201606L</code></td></tr><tr><td align="left"> <code class="code">shared_ptr::weak_type</code></td><td align="left">
 	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0163r0.html" target="_top">
 	P0163R0
 	</a>
@@ -821,7 +821,19 @@
 	P0067R5
 	</a>
       </td><td align="center"> 8 (only integral types supported) </td><td align="left"><code class="code"> __has_include(&lt;charconv&gt;) </code>
-             <code class="code"> __cpp_lib_to_chars &gt;= 201611 </code></td></tr></tbody></table></div></div><br class="table-break" /><p>
+             <code class="code"> __cpp_lib_to_chars &gt;= 201611 </code></td></tr><tr><td align="left"> Homogeneous interface for variant, any and optional </td><td align="left">
+	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0032r3.pdf" target="_top">
+	P0032R3
+	</a>
+      </td><td align="center"> 7.1  </td><td align="left">
+             <code class="code"> __cpp_lib_any &gt;= 201606 </code>,
+             <code class="code"> __cpp_lib_optional &gt;= 201606 </code>,
+             <code class="code"> __cpp_lib_variant &gt;= 201606 </code>
+      </td></tr><tr><td align="left"> Making Optional Greater Equal Again </td><td align="left">
+	<a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0307r2.pdf" target="_top">
+	P0307R2
+	</a>
+      </td><td align="center"> 7.1  </td><td align="left"> <code class="code"> __cpp_lib_optional &gt;= 201606 </code> </td></tr></tbody></table></div></div><br class="table-break" /><p>
 Note 1: This feature is supported in GCC 7.1 and 7.2 but before GCC 7.3 the
 <code class="code">__cpp_lib</code> macro is not defined, and compilation will fail if the
 header is included without using <code class="option">-std</code> to enable C++17 support.
@@ -939,7 +951,7 @@
    </p><p>
       <span class="emphasis"><em>30.10.2.1 [fs.conform.9945]</em></span>
       The behavior of the filesystem library implementation will depend on
-      the target operating system. Some features will not be not supported
+      the target operating system. Some features will not be supported
       on some targets.
    </p><p>
       <span class="emphasis"><em>30.10.5 [fs.filesystem.syn]</em></span>
Index: libstdc++-v3/doc/html/manual/using.html
===================================================================
diff --git a/libstdc++-v3/doc/html/manual/using.html b/libstdc++-v3/doc/html/manual/using.html
--- a/libstdc++-v3/doc/html/manual/using.html	(revision 278653)
+++ b/libstdc++-v3/doc/html/manual/using.html	(revision 278653)
@@ -2,7 +2,7 @@
 <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 3. Using</title><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><meta name="keywords" content="ISO C++, library" /><meta name="keywords" content="ISO C++, runtime, library" /><link rel="home" href="../index.html" title="The GNU C++ Library" /><link rel="up" href="intro.html" title="Part I.  Introduction" /><link rel="prev" href="make.html" title="Make" /><link rel="next" href="using_headers.html" title="Headers" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 3. Using</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="make.html">Prev</a> </td><th width="60%" align="center">Part I. 
   Introduction
   
-</th><td width="20%" align="right"> <a accesskey="n" href="using_headers.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="manual.intro.using"></a>Chapter 3. Using</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="manual.intro.using.flags"></a>Command Options</h2></div></div></div><p>
+</th><td width="20%" align="right"> <a accesskey="n" href="using_headers.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="manual.intro.using"></a>Chapter 3. Using</h2></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="manual.intro.using.flags"></a>Command Options</h2></div></div></div><p>
       The set of features available in the GNU C++ library is shaped by
       several <a class="link" href="http://gcc.gnu.org/onlinedocs/gcc-4.3.2/gcc/Invoking-GCC.html" target="_top">GCC
       Command Options</a>. Options that impact libstdc++ are
Index: libstdc++-v3/doc/html/manual/using_macros.html
===================================================================
diff --git a/libstdc++-v3/doc/html/manual/using_macros.html b/libstdc++-v3/doc/html/manual/using_macros.html
--- a/libstdc++-v3/doc/html/manual/using_macros.html	(revision 278653)
+++ b/libstdc++-v3/doc/html/manual/using_macros.html	(revision 278653)
@@ -116,7 +116,8 @@
         enabled for
         <code class="classname">std::vector&lt;T, std::allocator&lt;T&gt;&gt;</code>
         and only when <code class="classname">std::allocator</code> is derived from
-        <a class="xref" href="memory.html#allocator.impl" title="Implementation">the section called “Implementation”</a>. The annotations
+        <a class="link" href="memory.html#allocator.impl" title="Implementation"><code class="classname">new_allocator</code>
+        or <code class="classname">malloc_allocator</code></a>. The annotations
         must be present on all vector operations or none, so this macro must
         be defined to the same value for all translation units that create,
         destroy or modify vectors.
Index: libstdc++-v3/doc/html/manual/intro.html
===================================================================
diff --git a/libstdc++-v3/doc/html/manual/intro.html b/libstdc++-v3/doc/html/manual/intro.html
--- a/libstdc++-v3/doc/html/manual/intro.html	(revision 278653)
+++ b/libstdc++-v3/doc/html/manual/intro.html	(revision 278653)
@@ -5,4 +5,4 @@
 </th></tr><tr><td width="20%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><th width="60%" align="center">The GNU C++ Library Manual</th><td width="20%" align="right"> <a accesskey="n" href="status.html">Next</a></td></tr></table><hr /></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="manual.intro"></a>Part I. 
   Introduction
   <a id="id-1.3.3.1.1.1" class="indexterm"></a>
-</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="status.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">The GNU C++ Library Manual </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 1. Status</td></tr></table></div></body></html>
\ No newline at end of file
+</h1></div></div></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="status.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">The GNU C++ Library Manual </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 1. Status</td></tr></table></div></body></html>
\ No newline at end of file
Index: libstdc++-v3/doc/html/manual/bugs.html
===================================================================
diff --git a/libstdc++-v3/doc/html/manual/bugs.html b/libstdc++-v3/doc/html/manual/bugs.html
--- a/libstdc++-v3/doc/html/manual/bugs.html	(revision 278653)
+++ b/libstdc++-v3/doc/html/manual/bugs.html	(revision 278653)
@@ -492,10 +492,20 @@
        </em></span>
     </span></dt><dd><p>Avoid using <code class="code">dynamic_cast</code> when it would be
     ill-formed.
+    </p></dd><dt><a id="manual.bugs.dr2537"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2537" target="_top">2537</a>:
+       <span class="emphasis"><em>Constructors for <code class="code">priority_queue</code> taking allocators
+	 should call <code class="code">make_heap</code>
+       </em></span>
+    </span></dt><dd><p>Call <code class="code">make_heap</code>.
     </p></dd><dt><a id="manual.bugs.dr2583"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2583" target="_top">2583</a>:
        <span class="emphasis"><em>There is no way to supply an allocator for <code class="code">basic_string(str, pos)</code>
        </em></span>
     </span></dt><dd><p>Add new constructor
+    </p></dd><dt><a id="manual.bugs.dr2586"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2586" target="_top">2586</a>:
+       <span class="emphasis"><em>Wrong value category used in <code class="code">scoped_allocator_adaptor::construct()</code>
+       </em></span>
+    </span></dt><dd><p>Change internal helper for uses-allocator construction
+      to always check using const lvalue allocators.
     </p></dd><dt><a id="manual.bugs.dr2684"></a><span class="term"><a class="link" href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2684" target="_top">2684</a>:
        <span class="emphasis"><em><code class="code">priority_queue</code> lacking comparator typedef
        </em></span>
Index: libstdc++-v3/doc/html/manual/memory.html
===================================================================
diff --git a/libstdc++-v3/doc/html/manual/memory.html b/libstdc++-v3/doc/html/manual/memory.html
--- a/libstdc++-v3/doc/html/manual/memory.html	(revision 278653)
+++ b/libstdc++-v3/doc/html/manual/memory.html	(revision 278653)
@@ -314,13 +314,13 @@
     </em>. </span>
       isoc++_1998
     <span class="pagenums">20.4 Memory. </span></p></div><div class="biblioentry"><a id="id-1.3.4.4.4.3.9.3"></a><p><span class="title"><em>
-	<a class="link" href="http://www.drdobbs.com/the-standard-librarian-what-are-allocato/184403759" target="_top">
+      <a class="link" href="https://web.archive.org/web/20190622154249/http://www.drdobbs.com/the-standard-librarian-what-are-allocato/184403759" target="_top">
       The Standard Librarian: What Are Allocators Good For?
-	</a>
-      </em>. </span><span class="author"><span class="firstname">Matt</span> <span class="surname">Austern</span>. </span><span class="publisher"><span class="publishername">
+      </a>
+    </em>. </span><span class="author"><span class="firstname">Matt</span> <span class="surname">Austern</span>. </span><span class="publisher"><span class="publishername">
 	C/C++ Users Journal
-      . </span></span></p></div><div class="biblioentry"><a id="id-1.3.4.4.4.3.9.4"></a><p><span class="title"><em>
-	<a class="link" href="https://www.hoard.org" target="_top">
+      . </span></span><span class="pubdate">2000-12. </span></p></div><div class="biblioentry"><a id="id-1.3.4.4.4.3.9.4"></a><p><span class="title"><em>
+	<a class="link" href="http://hoard.org" target="_top">
       The Hoard Memory Allocator
 	</a>
       </em>. </span><span class="author"><span class="firstname">Emery</span> <span class="surname">Berger</span>. </span></p></div><div class="biblioentry"><a id="id-1.3.4.4.4.3.9.5"></a><p><span class="title"><em>
@@ -554,7 +554,7 @@
 extra template parameter, even if it had a default value.  The
 available policies are:
     </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
-       <code class="constant">_S_Atomic</code>
+       <code class="constant">_S_atomic</code>
        </p><p>
 Selected when GCC supports a builtin atomic compare-and-swap operation
 on the target processor (see <a class="link" href="http://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html" target="_top">Atomic
@@ -562,13 +562,13 @@
 algorithm and GCC's atomic builtins, which provide the required memory
 synchronisation.
        </p></li><li class="listitem"><p>
-       <code class="constant">_S_Mutex</code>
+       <code class="constant">_S_mutex</code>
        </p><p>
 The _Sp_counted_base specialization for this policy contains a mutex,
 which is locked in add_ref_lock(). This policy is used when GCC's atomic
 builtins aren't available so explicit memory barriers are needed in places.
        </p></li><li class="listitem"><p>
-       <code class="constant">_S_Single</code>
+       <code class="constant">_S_single</code>
        </p><p>
 This policy uses a non-reentrant add_ref_lock() with no locking. It is
 used when libstdc++ is built without <code class="literal">--enable-threads</code>.
Index: libstdc++-v3/doc/html/manual/api.html
===================================================================
diff --git a/libstdc++-v3/doc/html/manual/api.html b/libstdc++-v3/doc/html/manual/api.html
--- a/libstdc++-v3/doc/html/manual/api.html	(revision 278653)
+++ b/libstdc++-v3/doc/html/manual/api.html	(revision 278653)
@@ -28,11 +28,12 @@
 </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="api.rel_320"></a><code class="constant">3.2</code></h3></div></div></div><p>
   </p><p>Symbol versioning introduced for shared library.</p><p>Removal of include <code class="filename">backward/strstream.h</code>.</p><p>Allocator changes. Change <code class="code">__malloc_alloc</code> to <code class="code">malloc_allocator</code> and <code class="code">__new_alloc</code> to <code class="code">new_allocator</code>. </p><p> For GCC releases from 2.95 through the 3.1 series, defining
    <code class="literal">__USE_MALLOC</code> on the gcc command line would change the
-   default allocation strategy to instead use <code class="code"> malloc</code> and
-   <code class="function">free</code>. For the 3.2 and 3.3 release series the same
+   default allocation strategy to instead use <code class="code">malloc</code> and
+   <code class="code">free</code>. For the 3.2 and 3.3 release series the same
    functionality was spelled <code class="literal">_GLIBCXX_FORCE_NEW</code>. From
-   GCC 3.4 onwards the functionality is enabled by setting
-   <code class="literal">GLIBCXX_FORCE_NEW</code> in the environment, see
+   GCC 3.4 onwards the default allocator uses <code class="code">new</code> anyway,
+   but for the optional pooling allocators the functionality is enabled by
+   setting <code class="literal">GLIBCXX_FORCE_NEW</code> in the environment, see
    <a class="link" href="mt_allocator.html" title="Chapter 20. The mt_allocator">the mt allocator chapter</a>
    for details.
    </p><p>Error handling in iostreams cleaned up, made consistent. </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="api.rel_330"></a><code class="constant">3.3</code></h3></div></div></div><p>
Index: libstdc++-v3/doc/html/manual/documentation_hacking.html
===================================================================
diff --git a/libstdc++-v3/doc/html/manual/documentation_hacking.html b/libstdc++-v3/doc/html/manual/documentation_hacking.html
--- a/libstdc++-v3/doc/html/manual/documentation_hacking.html	(revision 278653)
+++ b/libstdc++-v3/doc/html/manual/documentation_hacking.html	(revision 278653)
@@ -381,11 +381,16 @@
       </p><p>
       </p><pre class="screen"><strong class="userinput"><code>make doc-xml-single-docbook</code></strong></pre><p>
       </p><p>
-	Generated files are output into separate sub directores of
+	Generated files are output into separate sub-directores of
 	<code class="filename">doc/docbook/</code> in the
 	build directory, based on the output format. For instance, the
 	HTML docs will be in <code class="filename">doc/docbook/html</code>.
       </p><p>
+	The </p><pre class="screen">doc-html-docbook-regenerate</pre><p> target will generate
+	the HTML files and copy them back to the libstdc++ source tree.
+	This can be used to update the HTML files that are checked in to
+	version control.
+      </p><p>
 	If the Docbook stylesheets are installed in a custom location,
 	one can use the variable <code class="literal">XSL_STYLE_DIR</code> to
 	override the Makefile defaults. For example:
Index: libstdc++-v3/doc/html/manual/debug.html
===================================================================
diff --git a/libstdc++-v3/doc/html/manual/debug.html b/libstdc++-v3/doc/html/manual/debug.html
--- a/libstdc++-v3/doc/html/manual/debug.html	(revision 278653)
+++ b/libstdc++-v3/doc/html/manual/debug.html	(revision 278653)
@@ -53,40 +53,28 @@
   This quick and dirty approach is often sufficient for quick
   debugging tasks, when you cannot or don't want to recompile your
   application to use the <a class="link" href="debug_mode.html" title="Chapter 17. Debug Mode">debug mode</a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="debug.memory"></a>Memory Leak Hunting</h3></div></div></div><p>
-  There are various third party memory tracing and debug utilities
+  On many targets GCC supports AddressSanitizer, a fast memory error detector,
+  which is enabled by the <code class="option">-fsanitize=address</code> option.
+</p><p>
+  There are also various third party memory tracing and debug utilities
   that can be used to provide detailed memory allocation information
   about C++ code. An exhaustive list of tools is not going to be
   attempted, but includes <code class="code">mtrace</code>, <code class="code">valgrind</code>,
-  <code class="code">mudflap</code>, and the non-free commercial product
-  <code class="code">purify</code>. In addition, <code class="code">libcwd</code> has a
-  replacement for the global new and delete operators that can track
-  memory allocation and deallocation and provide useful memory
-  statistics.
+  <code class="code">mudflap</code> (no longer supported since GCC 4.9.0), ElectricFence,
+  and the non-free commercial product <code class="code">purify</code>.
+  In addition, <code class="code">libcwd</code>, jemalloc and TCMalloc have replacements
+  for the global <code class="code">new</code> and <code class="code">delete</code> operators
+  that can track memory allocation and deallocation and provide useful
+  memory statistics.
 </p><p>
-  Regardless of the memory debugging tool being used, there is one
-  thing of great importance to keep in mind when debugging C++ code
-  that uses <code class="code">new</code> and <code class="code">delete</code>: there are
-  different kinds of allocation schemes that can be used by <code class="code">
-  std::allocator</code>. For implementation details, see the <a class="link" href="mt_allocator.html" title="Chapter 20. The mt_allocator">mt allocator</a> documentation and
-  look specifically for <code class="code">GLIBCXX_FORCE_NEW</code>.
-</p><p>
-  In a nutshell, the optional <code class="classname">mt_allocator</code>
-  is a high-performance pool allocator, and can
-  give the mistaken impression that in a suspect executable, memory is
-  being leaked, when in reality the memory "leak" is a pool being used
-  by the library's allocator and is reclaimed after program
-  termination.
-</p><p>
   For valgrind, there are some specific items to keep in mind. First
   of all, use a version of valgrind that will work with current GNU
   C++ tools: the first that can do this is valgrind 1.0.4, but later
-  versions should work at least as well. Second of all, use a
-  completely unoptimized build to avoid confusing valgrind. Third, use
-  GLIBCXX_FORCE_NEW to keep extraneous pool allocation noise from
-  cluttering debug information.
+  versions should work better. Second, using an unoptimized build
+  might avoid confusing valgrind.
 </p><p>
-  Fourth, it may be necessary to force deallocation in other libraries
-  as well, namely the "C" library. On linux, this can be accomplished
+  Third, it may be necessary to force deallocation in other libraries
+  as well, namely the "C" library. On GNU/Linux, this can be accomplished
   with the appropriate use of the <code class="code">__cxa_atexit</code> or
   <code class="code">atexit</code> functions.
 </p><pre class="programlisting">
@@ -121,7 +109,29 @@
   up the runtime environment, library, and test file, might be:
 </p><pre class="programlisting">
    valgrind -v --num-callers=20 --leak-check=yes --leak-resolution=high --show-reachable=yes a.out
-</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="debug.races"></a>Data Race Hunting</h3></div></div></div><p>
+</pre><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="debug.memory.mtalloc"></a>Non-memory leaks in Pool and MT allocators</h4></div></div></div><p>
+  There are different kinds of allocation schemes that can be used by
+  <code class="code">std::allocator</code>. Prior to GCC 3.4.0 the default was to use
+  a pooling allocator, <code class="classname">pool_allocator</code>,
+  which is still available as the optional
+  <code class="classname">__pool_alloc</code> extension.
+  Another optional extension, <code class="classname">__mt_alloc</code>,
+  is a high-performance pool allocator.
+</p><p>
+  In a suspect executable these pooling allocators can give
+  the mistaken impression that memory is being leaked,
+  when in reality the memory "leak" is a pool being used
+  by the library's allocator and is reclaimed after program
+  termination.
+</p><p>
+  If you're using memory debugging tools on a program that uses
+  one of these pooling allocators, you can set the environment variable
+  <code class="literal">GLIBCXX_FORCE_NEW</code> to keep extraneous pool allocation
+  noise from cluttering debug information.
+  For more details, see the
+  <a class="link" href="mt_allocator.html" title="Chapter 20. The mt_allocator">mt allocator</a>
+  documentation and look specifically for <code class="code">GLIBCXX_FORCE_NEW</code>.
+</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="debug.races"></a>Data Race Hunting</h3></div></div></div><p>
   All synchronization primitives used in the library internals need to be
   understood by race detectors so that they do not produce false reports.
 </p><p>
Index: libstdc++-v3/doc/html/manual/index.html
===================================================================
diff --git a/libstdc++-v3/doc/html/manual/index.html b/libstdc++-v3/doc/html/manual/index.html
--- a/libstdc++-v3/doc/html/manual/index.html	(revision 278653)
+++ b/libstdc++-v3/doc/html/manual/index.html	(revision 278653)
@@ -4,7 +4,7 @@
     </p></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="part"><a href="intro.html">I. 
   Introduction
   
-</a></span></dt><dd><dl><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="std_contents.html">II. 
+</a></span></dt><dd><dl><dt><span class="chapter"><a href="status.html">1. Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#manual.intro.status.iso">Implementation Status</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#status.iso.1998">C++ 1998/2003</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.1998.status">Implementation Status</a></span></dt><dt><span class="section"><a href="status.html#iso.1998.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2011">C++ 2011</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2011.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.2014">C++ 2014</a></span></dt><dt><span class="section"><a href="status.html#status.iso.2017">C++ 2017</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.2017.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr1">C++ TR1</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.tr1.specific">Implementation Specific Behavior</a></span></dt></dl></dd><dt><span class="section"><a href="status.html#status.iso.tr24733">C++ TR 24733</a></span></dt><dt><span class="section"><a href="status.html#status.iso.specfun">C++ IS 29124</a></span></dt><dd><dl><dt><span class="section"><a href="status.html#iso.specfun.specific">Implementation Specific Behavior</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="license.html">License</a></span></dt><dd><dl><dt><span class="section"><a href="license.html#manual.intro.status.license.gpl">The Code: GPL</a></span></dt><dt><span class="section"><a href="license.html#manual.intro.status.license.fdl">The Documentation: GPL, FDL</a></span></dt></dl></dd><dt><span class="section"><a href="bugs.html">Bugs</a></span></dt><dd><dl><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.impl">Implementation Bugs</a></span></dt><dt><span class="section"><a href="bugs.html#manual.intro.status.bugs.iso">Standard Bugs</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="setup.html">2. Setup</a></span></dt><dd><dl><dt><span class="section"><a href="setup.html#manual.intro.setup.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="configure.html">Configure</a></span></dt><dt><span class="section"><a href="make.html">Make</a></span></dt></dl></dd><dt><span class="chapter"><a href="using.html">3. Using</a></span></dt><dd><dl><dt><span class="section"><a href="using.html#manual.intro.using.flags">Command Options</a></span></dt><dt><span class="section"><a href="using_headers.html">Headers</a></span></dt><dd><dl><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.all">Header Files</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.mixing">Mixing Headers</a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.cheaders">The C Headers and <code class="code">namespace std</code></a></span></dt><dt><span class="section"><a href="using_headers.html#manual.intro.using.headers.pre">Precompiled Headers</a></span></dt></dl></dd><dt><span class="section"><a href="using_macros.html">Macros</a></span></dt><dt><span class="section"><a href="using_dual_abi.html">Dual ABI</a></span></dt><dd><dl><dt><span class="section"><a href="using_dual_abi.html#manual.intro.using.abi.trouble">Troubleshooting</a></span></dt></dl></dd><dt><span class="section"><a href="using_namespaces.html">Namespaces</a></span></dt><dd><dl><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.all">Available Namespaces</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.std">namespace std</a></span></dt><dt><span class="section"><a href="using_namespaces.html#manual.intro.using.namespaces.comp">Using Namespace Composition</a></span></dt></dl></dd><dt><span class="section"><a href="using_dynamic_or_shared.html">Linking</a></span></dt><dd><dl><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.freestanding">Almost Nothing</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.dynamic">Finding Dynamic or Shared Libraries</a></span></dt><dt><span class="section"><a href="using_dynamic_or_shared.html#manual.intro.using.linkage.experimental">Experimental Library Extensions</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html">Concurrency</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.prereq">Prerequisites</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.thread_safety">Thread Safety</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.atomics">Atomics</a></span></dt><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.io">IO</a></span></dt><dd><dl><dt><span class="section"><a href="using_concurrency.html#concurrency.io.structure">Structure</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.defaults">Defaults</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.future">Future</a></span></dt><dt><span class="section"><a href="using_concurrency.html#concurrency.io.alt">Alternatives</a></span></dt></dl></dd><dt><span class="section"><a href="using_concurrency.html#manual.intro.using.concurrency.containers">Containers</a></span></dt></dl></dd><dt><span class="section"><a href="using_exceptions.html">Exceptions</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.safety">Exception Safety</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.propagating">Exception Neutrality</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.no">Doing without</a></span></dt><dt><span class="section"><a href="using_exceptions.html#intro.using.exception.compat">Compatibility</a></span></dt><dd><dl><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.c">With <code class="literal">C</code></a></span></dt><dt><span class="section"><a href="using_exceptions.html#using.exception.compat.posix">With <code class="literal">POSIX</code> thread cancellation</a></span></dt></dl></dd></dl></dd><dt><span class="section"><a href="debug.html">Debugging Support</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.compiler">Using <span class="command"><strong>g++</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.req">Debug Versions of Library Binary Files</a></span></dt><dt><span class="section"><a href="debug.html#debug.memory">Memory Leak Hunting</a></span></dt><dd><dl><dt><span class="section"><a href="debug.html#debug.memory.mtalloc">Non-memory leaks in Pool and MT allocators</a></span></dt></dl></dd><dt><span class="section"><a href="debug.html#debug.races">Data Race Hunting</a></span></dt><dt><span class="section"><a href="debug.html#debug.gdb">Using <span class="command"><strong>gdb</strong></span></a></span></dt><dt><span class="section"><a href="debug.html#debug.exceptions">Tracking uncaught exceptions</a></span></dt><dt><span class="section"><a href="debug.html#debug.debug_mode">Debug Mode</a></span></dt><dt><span class="section"><a href="debug.html#debug.compile_time_checks">Compile Time Checking</a></span></dt><dt><span class="section"><a href="debug.html#debug.profile_mode">Profile-based Performance Analysis</a></span></dt></dl></dd></dl></dd></dl></dd><dt><span class="part"><a href="std_contents.html">II. 
     Standard Contents
   </a></span></dt><dd><dl><dt><span class="chapter"><a href="support.html">4. 
   Support
Index: libstdc++-v3/doc/Makefile.am
===================================================================
diff --git a/libstdc++-v3/doc/Makefile.am b/libstdc++-v3/doc/Makefile.am
--- a/libstdc++-v3/doc/Makefile.am	(revision 278653)
+++ b/libstdc++-v3/doc/Makefile.am	(revision 278653)
@@ -477,7 +477,6 @@
 
 ${docbook_outdir}/html:
 	mkdir -p ${docbook_outdir}/html
-	mkdir -p ${docbook_outdir}/html/ext
 	mkdir -p ${docbook_outdir}/html/images
 	mkdir -p ${docbook_outdir}/html/manual
 
@@ -546,6 +545,12 @@
 
 doc-html-docbook: stamp-html-docbook-data
 
+# Generate the HTML pages and copy them back to the source tree.
+doc-html-docbook-regenerate: doc-html-docbook
+	$(INSTALL_DATA) ${docbook_outdir}/html/*.html ${top_srcdir}/doc/html
+	$(INSTALL_DATA) ${docbook_outdir}/html/images/* ${top_srcdir}/doc/html/images
+	$(INSTALL_DATA) ${docbook_outdir}/html/manual/*.html ${top_srcdir}/doc/html/manual
+
 # HTML, all one page
 # NB: Have to generate customization XSL for UTF-8 output.
 manual_html = ${docbook_outdir}/html/libstdc++-manual-single.html
Index: libstdc++-v3/po/Makefile.in
===================================================================
diff --git a/libstdc++-v3/po/Makefile.in b/libstdc++-v3/po/Makefile.in
--- a/libstdc++-v3/po/Makefile.in	(revision 278653)
+++ b/libstdc++-v3/po/Makefile.in	(revision 278653)
@@ -205,6 +205,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/include/Makefile.in
===================================================================
diff --git a/libstdc++-v3/include/Makefile.in b/libstdc++-v3/include/Makefile.in
--- a/libstdc++-v3/include/Makefile.in	(revision 278653)
+++ b/libstdc++-v3/include/Makefile.in	(revision 278653)
@@ -205,6 +205,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/include/std/optional
===================================================================
diff --git a/libstdc++-v3/include/std/optional b/libstdc++-v3/include/std/optional
--- a/libstdc++-v3/include/std/optional	(revision 278653)
+++ b/libstdc++-v3/include/std/optional	(revision 278653)
@@ -51,7 +51,7 @@
    *  @{
    */
 
-#define __cpp_lib_optional 201603
+#define __cpp_lib_optional 201606L
 
   template<typename _Tp>
     class optional;
@@ -1256,7 +1256,7 @@
 	}
 
       template<typename _Up>
-	_Tp
+	constexpr _Tp
 	value_or(_Up&& __u) &&
 	{
 	  static_assert(is_move_constructible_v<_Tp>);
Index: libstdc++-v3/include/std/any
===================================================================
diff --git a/libstdc++-v3/include/std/any b/libstdc++-v3/include/std/any
--- a/libstdc++-v3/include/std/any	(revision 278653)
+++ b/libstdc++-v3/include/std/any	(revision 278653)
@@ -66,7 +66,7 @@
 #endif
   }
 
-#define __cpp_lib_any 201603
+#define __cpp_lib_any 201606L
 
   /**
    *  @brief A type-safe container of any type.
@@ -503,20 +503,34 @@
     }
   // @}
 
+  /// @cond undocumented
   template<typename _Tp>
     void* __any_caster(const any* __any)
     {
-      if constexpr (is_copy_constructible_v<decay_t<_Tp>>)
+      // any_cast<T> returns non-null if __any->type() == typeid(T) and
+      // typeid(T) ignores cv-qualifiers so remove them:
+      using _Up = remove_cv_t<_Tp>;
+      // The contained value has a decayed type, so if decay_t<U> is not U,
+      // then it's not possible to have a contained value of type U:
+      if constexpr (!is_same_v<decay_t<_Up>, _Up>)
+	return nullptr;
+      // Only copy constructible types can be used for contained values:
+      else if constexpr (!is_copy_constructible_v<_Up>)
+	return nullptr;
+      // First try comparing function addresses, which works without RTTI
+      else if (__any->_M_manager == &any::_Manager<_Up>::_S_manage
+#if __cpp_rtti
+	  || __any->type() == typeid(_Tp)
+#endif
+	  )
 	{
-	  if (__any->_M_manager == &any::_Manager<decay_t<_Tp>>::_S_manage)
-	    {
-	      any::_Arg __arg;
-	      __any->_M_manager(any::_Op_access, __any, &__arg);
-	      return __arg._M_obj;
-	    }
+	  any::_Arg __arg;
+	  __any->_M_manager(any::_Op_access, __any, &__arg);
+	  return __arg._M_obj;
 	}
       return nullptr;
     }
+  /// @endcond
 
   /**
    * @brief Access the contained object.
@@ -532,8 +546,9 @@
   template<typename _ValueType>
     inline const _ValueType* any_cast(const any* __any) noexcept
     {
-      if (__any)
-	return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
+      if constexpr (is_object_v<_ValueType>)
+	if (__any)
+	  return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
       return nullptr;
     }
 
@@ -540,8 +555,9 @@
   template<typename _ValueType>
     inline _ValueType* any_cast(any* __any) noexcept
     {
-      if (__any)
-	return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
+      if constexpr (is_object_v<_ValueType>)
+	if (__any)
+	  return static_cast<_ValueType*>(__any_caster<_ValueType>(__any));
       return nullptr;
     }
   // @}
Index: libstdc++-v3/include/std/type_traits
===================================================================
diff --git a/libstdc++-v3/include/std/type_traits b/libstdc++-v3/include/std/type_traits
--- a/libstdc++-v3/include/std/type_traits	(revision 278653)
+++ b/libstdc++-v3/include/std/type_traits	(revision 278653)
@@ -867,60 +867,18 @@
     : public __is_nt_destructible_safe<_Tp>::type
     { };
 
-  struct __do_is_default_constructible_impl
-  {
-    template<typename _Tp, typename = decltype(_Tp())>
-      static true_type __test(int);
-
-    template<typename>
-      static false_type __test(...);
-  };
-
-  template<typename _Tp>
-    struct __is_default_constructible_impl
-    : public __do_is_default_constructible_impl
-    {
-      typedef decltype(__test<_Tp>(0)) type;
-    };
-
-  template<typename _Tp>
-    struct __is_default_constructible_atom
-    : public __and_<__not_<is_void<_Tp>>,
-                    __is_default_constructible_impl<_Tp>>
+  /// is_constructible
+  template<typename _Tp, typename... _Args>
+    struct is_constructible
+      : public __bool_constant<__is_constructible(_Tp, _Args...)>
     { };
 
-  template<typename _Tp, bool = is_array<_Tp>::value>
-    struct __is_default_constructible_safe;
-
-  // The following technique is a workaround for a current core language
-  // restriction, which does not allow for array types to occur in
-  // functional casts of the form T().  Complete arrays can be default-
-  // constructed, if the element type is default-constructible, but
-  // arrays with unknown bounds are not.
-  template<typename _Tp>
-    struct __is_default_constructible_safe<_Tp, true>
-    : public __and_<__is_array_known_bounds<_Tp>,
-		    __is_default_constructible_atom<typename
-                      remove_all_extents<_Tp>::type>>
-    { };
-
-  template<typename _Tp>
-    struct __is_default_constructible_safe<_Tp, false>
-    : public __is_default_constructible_atom<_Tp>::type
-    { };
-
   /// is_default_constructible
   template<typename _Tp>
     struct is_default_constructible
-    : public __is_default_constructible_safe<_Tp>::type
+    : public is_constructible<_Tp>::type
     { };
 
-  /// is_constructible
-  template<typename _Tp, typename... _Args>
-    struct is_constructible
-      : public __bool_constant<__is_constructible(_Tp, _Args...)>
-    { };
-
   template<typename _Tp, bool = __is_referenceable<_Tp>::value>
     struct __is_copy_constructible_impl;
 
@@ -2024,9 +1982,14 @@
     struct __expanded_common_type_wrapper<__failure_type, _Args...>
     { typedef __failure_type type; };
 
+  template<>
+    struct common_type<>
+    { };
+
   template<typename _Tp>
     struct common_type<_Tp>
-    { typedef typename decay<_Tp>::type type; };
+    : common_type<_Tp, _Tp>
+    { };
 
   template<typename _Tp, typename _Up>
     struct common_type<_Tp, _Up>
Index: libstdc++-v3/include/std/variant
===================================================================
diff --git a/libstdc++-v3/include/std/variant b/libstdc++-v3/include/std/variant
--- a/libstdc++-v3/include/std/variant	(revision 278653)
+++ b/libstdc++-v3/include/std/variant	(revision 278653)
@@ -68,7 +68,7 @@
 } // namespace __variant
 } // namespace __detail
 
-#define __cpp_lib_variant 201603
+#define __cpp_lib_variant 201606L
 
   template<typename... _Types> class tuple;
   template<typename... _Types> class variant;
@@ -809,9 +809,8 @@
 	{
 	  using _Alternative = variant_alternative_t<__index, _Next>;
 	  __element = __gen_vtable_impl<
-	    remove_reference_t<
-	      decltype(__element)>, tuple<_Variants...>,
-	      std::index_sequence<__indices..., __index>>::_S_apply();
+	    remove_reference_t<decltype(__element)>, tuple<_Variants...>,
+	    std::index_sequence<__indices..., __index>>::_S_apply();
 	}
     };
 
@@ -824,11 +823,11 @@
       using _Array_type =
 	  _Multi_array<_Result_type (*)(_Visitor&&, _Variants...)>;
 
-      decltype(auto)
-      static constexpr __visit_invoke(_Visitor&& __visitor, _Variants... __vars)
+      static constexpr decltype(auto)
+      __visit_invoke(_Visitor&& __visitor, _Variants... __vars)
       {
 	return std::__invoke(std::forward<_Visitor>(__visitor),
-	    std::get<__indices>(std::forward<_Variants>(__vars))...);
+	    __variant::__get<__indices>(std::forward<_Variants>(__vars))...);
       }
 
       static constexpr auto
@@ -869,8 +868,8 @@
 } // namespace __detail
 
   template<typename _Tp, typename... _Types>
-    inline constexpr bool holds_alternative(const variant<_Types...>& __v)
-    noexcept
+    constexpr bool
+    holds_alternative(const variant<_Types...>& __v) noexcept
     {
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
@@ -878,7 +877,7 @@
     }
 
   template<typename _Tp, typename... _Types>
-    constexpr inline _Tp& get(variant<_Types...>& __v)
+    constexpr _Tp& get(variant<_Types...>& __v)
     {
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
@@ -887,7 +886,7 @@
     }
 
   template<typename _Tp, typename... _Types>
-    constexpr inline _Tp&& get(variant<_Types...>&& __v)
+    constexpr _Tp&& get(variant<_Types...>&& __v)
     {
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
@@ -897,7 +896,7 @@
     }
 
   template<typename _Tp, typename... _Types>
-    constexpr inline const _Tp& get(const variant<_Types...>& __v)
+    constexpr const _Tp& get(const variant<_Types...>& __v)
     {
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
@@ -906,7 +905,7 @@
     }
 
   template<typename _Tp, typename... _Types>
-    constexpr inline const _Tp&& get(const variant<_Types...>&& __v)
+    constexpr const _Tp&& get(const variant<_Types...>&& __v)
     {
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
@@ -916,8 +915,7 @@
     }
 
   template<size_t _Np, typename... _Types>
-    constexpr inline
-    add_pointer_t<variant_alternative_t<_Np, variant<_Types...>>>
+    constexpr add_pointer_t<variant_alternative_t<_Np, variant<_Types...>>>
     get_if(variant<_Types...>* __ptr) noexcept
     {
       using _Alternative_type = variant_alternative_t<_Np, variant<_Types...>>;
@@ -930,7 +928,7 @@
     }
 
   template<size_t _Np, typename... _Types>
-    constexpr inline
+    constexpr
     add_pointer_t<const variant_alternative_t<_Np, variant<_Types...>>>
     get_if(const variant<_Types...>* __ptr) noexcept
     {
@@ -944,7 +942,7 @@
     }
 
   template<typename _Tp, typename... _Types>
-    constexpr inline add_pointer_t<_Tp>
+    constexpr add_pointer_t<_Tp>
     get_if(variant<_Types...>* __ptr) noexcept
     {
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
@@ -955,7 +953,7 @@
     }
 
   template<typename _Tp, typename... _Types>
-    constexpr inline add_pointer_t<const _Tp>
+    constexpr add_pointer_t<const _Tp>
     get_if(const variant<_Types...>* __ptr)
     noexcept
     {
@@ -1076,6 +1074,17 @@
 
       using _Traits = __detail::__variant::_Traits<_Types...>;
 
+      template<typename _Tp>
+	struct __is_in_place_tag : false_type { };
+      template<typename _Tp>
+	struct __is_in_place_tag<in_place_type_t<_Tp>> : true_type { };
+      template<size_t _Np>
+	struct __is_in_place_tag<in_place_index_t<_Np>> : true_type { };
+
+      template<typename _Tp>
+	static constexpr bool __not_in_place_tag
+	  = !__is_in_place_tag<decay_t<_Tp>>::value;
+
     public:
       variant() = default;
       variant(const variant& __rhs) = default;
@@ -1087,6 +1096,7 @@
       template<typename _Tp,
 	       typename = enable_if_t<!is_same_v<decay_t<_Tp>, variant>>,
 	       typename = enable_if_t<(sizeof...(_Types)>0)>,
+	       typename = enable_if_t<__not_in_place_tag<_Tp>>,
 	       typename = enable_if_t<__exactly_once<__accepted_type<_Tp&&>>
 			  && is_constructible_v<__accepted_type<_Tp&&>, _Tp&&>>>
 	constexpr
@@ -1275,7 +1285,7 @@
 	  { &__detail::__variant::__erased_##__NAME< \
 		const variant&, __indices>... }; \
       template<size_t... __indices> \
-	constexpr inline bool \
+	constexpr bool \
 	_M_##__NAME(const variant& __rhs, \
 		    std::index_sequence<__indices...>) const \
 	{ \
Index: libstdc++-v3/include/std/ostream
===================================================================
diff --git a/libstdc++-v3/include/std/ostream b/libstdc++-v3/include/std/ostream
--- a/libstdc++-v3/include/std/ostream	(revision 278653)
+++ b/libstdc++-v3/include/std/ostream	(revision 278653)
@@ -444,6 +444,8 @@
       explicit
       sentry(basic_ostream<_CharT, _Traits>& __os);
 
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
       /**
        *  @brief  Possibly flushes the stream.
        *
@@ -461,6 +463,7 @@
 	      _M_os.setstate(ios_base::badbit);
 	  }
       }
+#pragma GCC diagnostic pop
 
       /**
        *  @brief  Quick status checking.
Index: libstdc++-v3/include/experimental/any
===================================================================
diff --git a/libstdc++-v3/include/experimental/any b/libstdc++-v3/include/experimental/any
--- a/libstdc++-v3/include/experimental/any	(revision 278653)
+++ b/libstdc++-v3/include/experimental/any	(revision 278653)
@@ -300,7 +300,8 @@
     _Storage _M_storage;
 
     template<typename _Tp>
-      friend void* __any_caster(const any* __any);
+      friend enable_if_t<is_object<_Tp>::value, void*>
+      __any_caster(const any* __any);
 
     // Manage in-place contained object.
     template<typename _Tp>
@@ -410,19 +411,45 @@
     }
   // @}
 
+  /// @cond undocumented
   template<typename _Tp>
-    void* __any_caster(const any* __any)
+    enable_if_t<is_object<_Tp>::value, void*>
+    __any_caster(const any* __any)
     {
-      struct _None { };
-      using _Up = decay_t<_Tp>;
-      using _Vp = conditional_t<is_copy_constructible<_Up>::value, _Up, _None>;
-      if (__any->_M_manager != &any::_Manager<_Vp>::_S_manage)
-	return nullptr;
-      any::_Arg __arg;
-      __any->_M_manager(any::_Op_access, __any, &__arg);
-      return __arg._M_obj;
+      // any_cast<T> returns non-null if __any->type() == typeid(T) and
+      // typeid(T) ignores cv-qualifiers so remove them:
+      using _Up = remove_cv_t<_Tp>;
+      // The contained value has a decayed type, so if decay_t<U> is not U,
+      // then it's not possible to have a contained value of type U.
+      using __does_not_decay = is_same<decay_t<_Up>, _Up>;
+      // Only copy constructible types can be used for contained values.
+      using __is_copyable = is_copy_constructible<_Up>;
+      // If the type _Tp could never be stored in an any we don't want to
+      // instantiate _Manager<_Tp>, so use _Manager<any::_Op> instead, which
+      // is explicitly specialized and has a no-op _S_manage function.
+      using _Vp = conditional_t<__and_<__does_not_decay, __is_copyable>::value,
+				_Up, any::_Op>;
+      // First try comparing function addresses, which works without RTTI
+      if (__any->_M_manager == &any::_Manager<_Vp>::_S_manage
+#if __cpp_rtti
+	  || __any->type() == typeid(_Tp)
+#endif
+	  )
+	{
+	  any::_Arg __arg;
+	  __any->_M_manager(any::_Op_access, __any, &__arg);
+	  return __arg._M_obj;
+	}
+      return nullptr;
     }
 
+  // This overload exists so that std::any_cast<void(*)()>(a) is well-formed.
+  template<typename _Tp>
+    enable_if_t<!is_object<_Tp>::value, _Tp*>
+    __any_caster(const any*) noexcept
+    { return nullptr; }
+  /// @endcond
+
   /**
    * @brief Access the contained object.
    *
@@ -517,6 +544,14 @@
       }
     }
 
+  // Dummy specialization used by __any_caster.
+  template<>
+    struct any::_Manager_internal<any::_Op>
+    {
+      static void
+      _S_manage(_Op, const any*, _Arg*) { }
+    };
+
   // @} group any
 } // namespace fundamentals_v1
 } // namespace experimental
Index: libstdc++-v3/include/experimental/bits/fs_path.h
===================================================================
diff --git a/libstdc++-v3/include/experimental/bits/fs_path.h b/libstdc++-v3/include/experimental/bits/fs_path.h
--- a/libstdc++-v3/include/experimental/bits/fs_path.h	(revision 278653)
+++ b/libstdc++-v3/include/experimental/bits/fs_path.h	(revision 278653)
@@ -120,11 +120,12 @@
       : decltype(__is_path_src(std::declval<_Source>(), 0))
       { };
 
-    template<typename _Tp1, typename _Tp2 = void>
+    template<typename _Tp1, typename _Tp2 = void,
+	     typename _Tp1_nocv = typename remove_cv<_Tp1>::type,
+	     typename _Tp1_noptr = typename remove_pointer<_Tp1>::type>
       using _Path = typename
-	std::enable_if<__and_<__not_<is_same<typename remove_cv<_Tp1>::type,
-					     path>>,
-			      __not_<is_void<_Tp1>>,
+	std::enable_if<__and_<__not_<is_same<_Tp1_nocv, path>>,
+			      __not_<is_void<_Tp1_noptr>>,
 			      __constructible_from<_Tp1, _Tp2>>::value,
 		       path>::type;
 
@@ -185,7 +186,8 @@
     path(path&& __p) noexcept
     : _M_pathname(std::move(__p._M_pathname)), _M_type(__p._M_type)
     {
-      _M_split_cmpts();
+      if (_M_type == _Type::_Multi)
+	_M_split_cmpts();
       __p.clear();
     }
 
@@ -459,7 +461,7 @@
 	return _S_convert_loc(__tmp.data(), __tmp.data()+__tmp.size(), __loc);
       }
 
-    bool _S_is_dir_sep(value_type __ch)
+    static bool _S_is_dir_sep(value_type __ch)
     {
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
       return __ch == L'/' || __ch == preferred_separator;
Index: libstdc++-v3/include/experimental/type_traits
===================================================================
diff --git a/libstdc++-v3/include/experimental/type_traits b/libstdc++-v3/include/experimental/type_traits
--- a/libstdc++-v3/include/experimental/type_traits	(revision 278653)
+++ b/libstdc++-v3/include/experimental/type_traits	(revision 278653)
@@ -251,12 +251,12 @@
 template<typename _Default, template<typename...> class _Op, typename... _Args>
   using detected_or_t = typename detected_or<_Default, _Op, _Args...>::type;
 
-template<typename Expected, template<typename...> class _Op, typename... _Args>
-  using is_detected_exact = is_same<Expected, detected_t<_Op, _Args...>>;
+template<typename _Expected, template<typename...> class _Op, typename... _Args>
+  using is_detected_exact = is_same<_Expected, detected_t<_Op, _Args...>>;
 
-template<typename Expected, template<typename...> class _Op, typename... _Args>
+template<typename _Expected, template<typename...> class _Op, typename... _Args>
   constexpr bool is_detected_exact_v
-    = is_detected_exact<Expected, _Op, _Args...>::value;
+    = is_detected_exact<_Expected, _Op, _Args...>::value;
 
 template<typename _To, template<typename...> class _Op, typename... _Args>
   using is_detected_convertible
Index: libstdc++-v3/include/bits/hashtable.h
===================================================================
diff --git a/libstdc++-v3/include/bits/hashtable.h b/libstdc++-v3/include/bits/hashtable.h
--- a/libstdc++-v3/include/bits/hashtable.h	(revision 278653)
+++ b/libstdc++-v3/include/bits/hashtable.h	(revision 278653)
@@ -192,11 +192,6 @@
       static_assert(is_same<typename _Alloc::value_type, _Value>{},
 	  "unordered container must have the same value_type as its allocator");
 #endif
-      static_assert(__is_invocable<const _H1&, const _Key&>{},
-	  "hash function must be invocable with an argument of key type");
-      static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
-	  "key equality predicate must be invocable with two arguments of "
-	  "key type");
 
       using __traits_type = _Traits;
       using __hash_cached = typename __traits_type::__hash_cached;
Index: libstdc++-v3/include/bits/stl_algobase.h
===================================================================
diff --git a/libstdc++-v3/include/bits/stl_algobase.h b/libstdc++-v3/include/bits/stl_algobase.h
--- a/libstdc++-v3/include/bits/stl_algobase.h	(revision 278653)
+++ b/libstdc++-v3/include/bits/stl_algobase.h	(revision 278653)
@@ -998,27 +998,27 @@
   //  Precondition: __n > 0.
   inline _GLIBCXX_CONSTEXPR int
   __lg(int __n)
-  { return sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
+  { return (int)sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
 
   inline _GLIBCXX_CONSTEXPR unsigned
   __lg(unsigned __n)
-  { return sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
+  { return (int)sizeof(int) * __CHAR_BIT__  - 1 - __builtin_clz(__n); }
 
   inline _GLIBCXX_CONSTEXPR long
   __lg(long __n)
-  { return sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
+  { return (int)sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
 
   inline _GLIBCXX_CONSTEXPR unsigned long
   __lg(unsigned long __n)
-  { return sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
+  { return (int)sizeof(long) * __CHAR_BIT__ - 1 - __builtin_clzl(__n); }
 
   inline _GLIBCXX_CONSTEXPR long long
   __lg(long long __n)
-  { return sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
+  { return (int)sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
 
   inline _GLIBCXX_CONSTEXPR unsigned long long
   __lg(unsigned long long __n)
-  { return sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
+  { return (int)sizeof(long long) * __CHAR_BIT__ - 1 - __builtin_clzll(__n); }
 
 _GLIBCXX_BEGIN_NAMESPACE_ALGO
 
Index: libstdc++-v3/include/bits/stl_queue.h
===================================================================
diff --git a/libstdc++-v3/include/bits/stl_queue.h b/libstdc++-v3/include/bits/stl_queue.h
--- a/libstdc++-v3/include/bits/stl_queue.h	(revision 278653)
+++ b/libstdc++-v3/include/bits/stl_queue.h	(revision 278653)
@@ -504,14 +504,18 @@
 	priority_queue(const _Compare& __x, const _Alloc& __a)
 	: c(__a), comp(__x) { }
 
+      // _GLIBCXX_RESOLVE_LIB_DEFECTS
+      // 2537. Constructors [...] taking allocators should call make_heap
       template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 	priority_queue(const _Compare& __x, const _Sequence& __c,
 		       const _Alloc& __a)
-	: c(__c, __a), comp(__x) { }
+	: c(__c, __a), comp(__x)
+	{ std::make_heap(c.begin(), c.end(), comp); }
 
       template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 	priority_queue(const _Compare& __x, _Sequence&& __c, const _Alloc& __a)
-	: c(std::move(__c), __a), comp(__x) { }
+	: c(std::move(__c), __a), comp(__x)
+	{ std::make_heap(c.begin(), c.end(), comp); }
 
       template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 	priority_queue(const priority_queue& __q, const _Alloc& __a)
Index: libstdc++-v3/include/bits/hashtable_policy.h
===================================================================
diff --git a/libstdc++-v3/include/bits/hashtable_policy.h b/libstdc++-v3/include/bits/hashtable_policy.h
--- a/libstdc++-v3/include/bits/hashtable_policy.h	(revision 278653)
+++ b/libstdc++-v3/include/bits/hashtable_policy.h	(revision 278653)
@@ -1296,7 +1296,11 @@
 
       __hash_code
       _M_hash_code(const _Key& __k) const
-      { return _M_h1()(__k); }
+      {
+	static_assert(__is_invocable<const _H1&, const _Key&>{},
+	    "hash function must be invocable with an argument of key type");
+	return _M_h1()(__k);
+      }
 
       std::size_t
       _M_bucket_index(const _Key&, __hash_code __c, std::size_t __n) const
@@ -1384,7 +1388,11 @@
 
       __hash_code
       _M_hash_code(const _Key& __k) const
-      { return _M_h1()(__k); }
+      {
+	static_assert(__is_invocable<const _H1&, const _Key&>{},
+	    "hash function must be invocable with an argument of key type");
+	return _M_h1()(__k);
+      }
 
       std::size_t
       _M_bucket_index(const _Key&, __hash_code __c,
@@ -1830,6 +1838,9 @@
     bool
     _M_equals(const _Key& __k, __hash_code __c, __node_type* __n) const
     {
+      static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
+	  "key equality predicate must be invocable with two arguments of "
+	  "key type");
       return _EqualHelper::_S_equals(_M_eq(), this->_M_extract(),
 				     __k, __c, __n);
     }
Index: libstdc++-v3/include/bits/fs_path.h
===================================================================
diff --git a/libstdc++-v3/include/bits/fs_path.h b/libstdc++-v3/include/bits/fs_path.h
--- a/libstdc++-v3/include/bits/fs_path.h	(revision 278653)
+++ b/libstdc++-v3/include/bits/fs_path.h	(revision 278653)
@@ -107,7 +107,7 @@
     template<typename _Tp1, typename _Tp2 = void>
       using _Path = typename
 	std::enable_if<__and_<__not_<is_same<remove_cv_t<_Tp1>, path>>,
-			      __not_<is_void<_Tp1>>,
+			      __not_<is_void<remove_pointer_t<_Tp1>>>,
 			      __constructible_from<_Tp1, _Tp2>>::value,
 		       path>::type;
 
@@ -168,7 +168,8 @@
     path(path&& __p) noexcept
     : _M_pathname(std::move(__p._M_pathname)), _M_type(__p._M_type)
     {
-      _M_split_cmpts();
+      if (_M_type == _Type::_Multi)
+	_M_split_cmpts();
       __p.clear();
     }
 
@@ -478,7 +479,7 @@
       static basic_string<_CharT, _Traits, _Allocator>
       _S_str_convert(const string_type&, const _Allocator& __a);
 
-    bool _S_is_dir_sep(value_type __ch)
+    static bool _S_is_dir_sep(value_type __ch)
     {
 #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS
       return __ch == L'/' || __ch == preferred_separator;
@@ -789,6 +790,9 @@
   inline path&
   path::operator=(path&& __p) noexcept
   {
+    if (&__p == this)
+      return *this;
+
     _M_pathname = std::move(__p._M_pathname);
     _M_cmpts = std::move(__p._M_cmpts);
     _M_type = __p._M_type;
Index: libstdc++-v3/include/bits/unique_ptr.h
===================================================================
diff --git a/libstdc++-v3/include/bits/unique_ptr.h b/libstdc++-v3/include/bits/unique_ptr.h
--- a/libstdc++-v3/include/bits/unique_ptr.h	(revision 278653)
+++ b/libstdc++-v3/include/bits/unique_ptr.h	(revision 278653)
@@ -174,14 +174,9 @@
       // unique_ptr
       template<typename _Up, typename _Ep>
 	using __safe_conversion_up = __and_<
-	        is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
-                __not_<is_array<_Up>>,
-                __or_<__and_<is_reference<deleter_type>,
-                             is_same<deleter_type, _Ep>>,
-                      __and_<__not_<is_reference<deleter_type>>,
-                             is_convertible<_Ep, deleter_type>>
-                >
-              >;
+	  is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
+	  __not_<is_array<_Up>>
+        >;
 
       // Constructors.
 
@@ -425,16 +420,14 @@
       // helper template for detecting a safe conversion from another
       // unique_ptr
       template<typename _Up, typename _Ep,
-               typename _Up_up = unique_ptr<_Up, _Ep>,
-	       typename _Up_element_type = typename _Up_up::element_type>
+               typename _UPtr = unique_ptr<_Up, _Ep>,
+	       typename _UP_pointer = typename _UPtr::pointer,
+	       typename _UP_element_type = typename _UPtr::element_type>
 	using __safe_conversion_up = __and_<
           is_array<_Up>,
           is_same<pointer, element_type*>,
-          is_same<typename _Up_up::pointer, _Up_element_type*>,
-          is_convertible<_Up_element_type(*)[], element_type(*)[]>,
-          __or_<__and_<is_reference<deleter_type>, is_same<deleter_type, _Ep>>,
-                __and_<__not_<is_reference<deleter_type>>,
-                       is_convertible<_Ep, deleter_type>>>
+          is_same<_UP_pointer, _UP_element_type*>,
+          is_convertible<_UP_element_type(*)[], element_type(*)[]>
         >;
 
       // helper template for detecting a safe conversion from a raw pointer
@@ -519,8 +512,11 @@
 		typename = _DeleterConstraint<_Up>>
 	constexpr unique_ptr(nullptr_t) noexcept : _M_t() { }
 
-      template<typename _Up, typename _Ep,
-	       typename = _Require<__safe_conversion_up<_Up, _Ep>>>
+      template<typename _Up, typename _Ep, typename = _Require<
+	       __safe_conversion_up<_Up, _Ep>,
+	       typename conditional<is_reference<_Dp>::value,
+				    is_same<_Ep, _Dp>,
+				    is_convertible<_Ep, _Dp>>::type>>
 	unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 	: _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 	{ }
Index: libstdc++-v3/include/bits/stl_vector.h
===================================================================
diff --git a/libstdc++-v3/include/bits/stl_vector.h b/libstdc++-v3/include/bits/stl_vector.h
--- a/libstdc++-v3/include/bits/stl_vector.h	(revision 278653)
+++ b/libstdc++-v3/include/bits/stl_vector.h	(revision 278653)
@@ -1600,11 +1600,11 @@
 	{ _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }
 
 	value_type&
-	_M_val() { return *reinterpret_cast<_Tp*>(&__buf); }
+	_M_val() { return *_M_ptr(); }
 
       private:
-	pointer
-	_M_ptr() { return pointer_traits<pointer>::pointer_to(_M_val()); }
+	_Tp*
+	_M_ptr() { return reinterpret_cast<_Tp*>(&__buf); }
 
 	vector* _M_this;
 	typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;
Index: libstdc++-v3/include/bits/stl_uninitialized.h
===================================================================
diff --git a/libstdc++-v3/include/bits/stl_uninitialized.h b/libstdc++-v3/include/bits/stl_uninitialized.h
--- a/libstdc++-v3/include/bits/stl_uninitialized.h	(revision 278653)
+++ b/libstdc++-v3/include/bits/stl_uninitialized.h	(revision 278653)
@@ -826,7 +826,9 @@
 
 #endif
 
-#if __cplusplus > 201402L
+#if __cplusplus >= 201703L
+# define __cpp_lib_raw_memory_algorithms 201606L
+
   template <typename _ForwardIterator>
     inline void
     uninitialized_default_construct(_ForwardIterator __first,
@@ -877,7 +879,7 @@
 	 __count, __result);
       return {__res.first.base(), __res.second};
     }
-#endif
+#endif // C++17
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
Index: libstdc++-v3/include/bits/char_traits.h
===================================================================
diff --git a/libstdc++-v3/include/bits/char_traits.h b/libstdc++-v3/include/bits/char_traits.h
--- a/libstdc++-v3/include/bits/char_traits.h	(revision 278653)
+++ b/libstdc++-v3/include/bits/char_traits.h	(revision 278653)
@@ -248,7 +248,7 @@
     __constant_char_array_p(const _CharT* __a, size_t __n)
     {
       size_t __i = 0;
-      while (__builtin_constant_p(__a[__i]) && __i < __n)
+      while (__i < __n && __builtin_constant_p(__a[__i]))
 	__i++;
       return __i == __n;
     }
Index: libstdc++-v3/include/bits/forward_list.tcc
===================================================================
diff --git a/libstdc++-v3/include/bits/forward_list.tcc b/libstdc++-v3/include/bits/forward_list.tcc
--- a/libstdc++-v3/include/bits/forward_list.tcc	(revision 278653)
+++ b/libstdc++-v3/include/bits/forward_list.tcc	(revision 278653)
@@ -375,7 +375,7 @@
       auto __iy = __ly.cbegin();
       while (__ix != __lx.cend() && __iy != __ly.cend())
 	{
-	  if (*__ix != *__iy)
+	  if (!(*__ix == *__iy))
 	    return false;
 	  ++__ix;
 	  ++__iy;
@@ -445,9 +445,9 @@
 			__p = static_cast<_Node*>(__p->_M_next);
 			--__psize;
 		      }
-		    else if (__comp(*__p->_M_valptr(), *__q->_M_valptr()))
+		    else if (!__comp(*__q->_M_valptr(), *__p->_M_valptr()))
 		      {
-			// First node of p is lower; e must come from p.
+			// First node of q is not lower; e must come from p.
 			__e = __p;
 			__p = static_cast<_Node*>(__p->_M_next);
 			--__psize;
Index: libstdc++-v3/include/bits/memoryfwd.h
===================================================================
diff --git a/libstdc++-v3/include/bits/memoryfwd.h b/libstdc++-v3/include/bits/memoryfwd.h
--- a/libstdc++-v3/include/bits/memoryfwd.h	(revision 278653)
+++ b/libstdc++-v3/include/bits/memoryfwd.h	(revision 278653)
@@ -66,9 +66,11 @@
   template<>
     class allocator<void>;
 
+#if __cplusplus >= 201103L
   /// Declare uses_allocator so it can be specialized in \<queue\> etc.
   template<typename, typename>
     struct uses_allocator;
+#endif
 
   /// @} group memory
 
Index: libstdc++-v3/include/bits/uses_allocator.h
===================================================================
diff --git a/libstdc++-v3/include/bits/uses_allocator.h b/libstdc++-v3/include/bits/uses_allocator.h
--- a/libstdc++-v3/include/bits/uses_allocator.h	(revision 278653)
+++ b/libstdc++-v3/include/bits/uses_allocator.h	(revision 278653)
@@ -83,14 +83,17 @@
   template<typename _Tp, typename _Alloc, typename... _Args>
     struct __uses_alloc<true, _Tp, _Alloc, _Args...>
     : conditional<
-        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value,
+        is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>::value,
         __uses_alloc1<_Alloc>,
        	__uses_alloc2<_Alloc>>::type
     {
+      // _GLIBCXX_RESOLVE_LIB_DEFECTS
+      // 2586. Wrong value category used in scoped_allocator_adaptor::construct
       static_assert(__or_<
-	  is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>,
-	  is_constructible<_Tp, _Args..., _Alloc>>::value, "construction with"
-	  " an allocator must be possible if uses_allocator is true");
+	  is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>,
+	  is_constructible<_Tp, _Args..., const _Alloc&>>::value,
+	  "construction with an allocator must be possible"
+	  " if uses_allocator is true");
     };
 
   template<typename _Tp, typename _Alloc, typename... _Args>
Index: libstdc++-v3/include/bits/random.h
===================================================================
diff --git a/libstdc++-v3/include/bits/random.h b/libstdc++-v3/include/bits/random.h
--- a/libstdc++-v3/include/bits/random.h	(revision 278653)
+++ b/libstdc++-v3/include/bits/random.h	(revision 278653)
@@ -5982,9 +5982,9 @@
     size_t size() const noexcept
     { return _M_v.size(); }
 
-    template<typename OutputIterator>
+    template<typename _OutputIterator>
       void
-      param(OutputIterator __dest) const
+      param(_OutputIterator __dest) const
       { std::copy(_M_v.begin(), _M_v.end(), __dest); }
 
     // no copy functions
Index: libstdc++-v3/include/bits/stl_tree.h
===================================================================
diff --git a/libstdc++-v3/include/bits/stl_tree.h b/libstdc++-v3/include/bits/stl_tree.h
--- a/libstdc++-v3/include/bits/stl_tree.h	(revision 278653)
+++ b/libstdc++-v3/include/bits/stl_tree.h	(revision 278653)
@@ -448,17 +448,6 @@
 
       typedef __gnu_cxx::__alloc_traits<_Node_allocator> _Alloc_traits;
 
-#if __cplusplus >= 201103L
-      static_assert(__is_invocable<_Compare&, const _Key&, const _Key&>{},
-	  "comparison object must be invocable with two arguments of key type");
-# if __cplusplus >= 201703L
-      // _GLIBCXX_RESOLVE_LIB_DEFECTS
-      // 2542. Missing const requirements for associative containers
-      static_assert(is_invocable_v<const _Compare&, const _Key&, const _Key&>,
-	  "comparison object must be invocable as const");
-# endif // C++17
-#endif // C++11
-
     protected:
       typedef _Rb_tree_node_base* 		_Base_ptr;
       typedef const _Rb_tree_node_base* 	_Const_Base_ptr;
@@ -773,8 +762,26 @@
 
       static const _Key&
       _S_key(_Const_Link_type __x)
-      { return _KeyOfValue()(_S_value(__x)); }
+      {
+#if __cplusplus >= 201103L
+	// If we're asking for the key we're presumably using the comparison
+	// object, and so this is a good place to sanity check it.
+	static_assert(__is_invocable<_Compare&, const _Key&, const _Key&>{},
+		      "comparison object must be invocable "
+		      "with two arguments of key type");
+# if __cplusplus >= 201703L
+	// _GLIBCXX_RESOLVE_LIB_DEFECTS
+	// 2542. Missing const requirements for associative containers
+	if constexpr (__is_invocable<_Compare&, const _Key&, const _Key&>{})
+	  static_assert(
+	      is_invocable_v<const _Compare&, const _Key&, const _Key&>,
+	      "comparison object must be invocable as const");
+# endif // C++17
+#endif // C++11
 
+	return _KeyOfValue()(*__x->_M_valptr());
+      }
+
       static _Link_type
       _S_left(_Base_ptr __x) _GLIBCXX_NOEXCEPT
       { return static_cast<_Link_type>(__x->_M_left); }
@@ -797,7 +804,7 @@
 
       static const _Key&
       _S_key(_Const_Base_ptr __x)
-      { return _KeyOfValue()(_S_value(__x)); }
+      { return _S_key(static_cast<_Const_Link_type>(__x)); }
 
       static _Base_ptr
       _S_minimum(_Base_ptr __x) _GLIBCXX_NOEXCEPT
Index: libstdc++-v3/include/tr2/dynamic_bitset.tcc
===================================================================
diff --git a/libstdc++-v3/include/tr2/dynamic_bitset.tcc b/libstdc++-v3/include/tr2/dynamic_bitset.tcc
--- a/libstdc++-v3/include/tr2/dynamic_bitset.tcc	(revision 278653)
+++ b/libstdc++-v3/include/tr2/dynamic_bitset.tcc	(revision 278653)
@@ -174,7 +174,7 @@
 
   // Definitions of non-inline member functions.
   template<typename _WordT, typename _Alloc>
-    template<typename _CharT, typename _Traits>
+    template<typename _Traits, typename _CharT>
       void
       dynamic_bitset<_WordT, _Alloc>::
       _M_copy_from_ptr(const _CharT* __str, size_t __len,
Index: libstdc++-v3/include/tr2/dynamic_bitset
===================================================================
diff --git a/libstdc++-v3/include/tr2/dynamic_bitset b/libstdc++-v3/include/tr2/dynamic_bitset
--- a/libstdc++-v3/include/tr2/dynamic_bitset	(revision 278653)
+++ b/libstdc++-v3/include/tr2/dynamic_bitset	(revision 278653)
@@ -34,10 +34,9 @@
 #include <limits>
 #include <vector>
 #include <string>
-#include <memory> // For std::allocator
-#include <bits/functexcept.h>   // For invalid_argument, out_of_range,
-				// overflow_error
-#include <iosfwd>
+#include <istream>
+#include <bits/functexcept.h>
+#include <bits/stl_algo.h>	// For fill
 #include <bits/cxxabi_forced.h>
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -76,41 +75,48 @@
       std::vector<block_type, allocator_type> _M_w;
 
       explicit
-      __dynamic_bitset_base(const allocator_type& __alloc = allocator_type())
+      __dynamic_bitset_base(const allocator_type& __alloc)
       : _M_w(__alloc)
       { }
 
-      explicit
-      __dynamic_bitset_base(__dynamic_bitset_base&& __b)
-      { this->_M_w.swap(__b._M_w); }
+      __dynamic_bitset_base() = default;
+      __dynamic_bitset_base(const __dynamic_bitset_base&) = default;
+      __dynamic_bitset_base(__dynamic_bitset_base&& __b) = default;
+      __dynamic_bitset_base& operator=(const __dynamic_bitset_base&) = default;
+      __dynamic_bitset_base& operator=(__dynamic_bitset_base&&) = default;
+      ~__dynamic_bitset_base() = default;
 
       explicit
       __dynamic_bitset_base(size_type __nbits, unsigned long long __val = 0ULL,
 			   const allocator_type& __alloc = allocator_type())
-      : _M_w(__nbits / _S_bits_per_block
-	     + (__nbits % _S_bits_per_block > 0),
-	     __val, __alloc)
+      : _M_w(__nbits / _S_bits_per_block + (__nbits % _S_bits_per_block > 0),
+	     block_type(0), __alloc)
       {
-	unsigned long long __mask = ~static_cast<block_type>(0);
-	size_t __n = std::min(this->_M_w.size(),
-			      sizeof(unsigned long long) / sizeof(block_type));
-	for (size_t __i = 0; __i < __n; ++__i)
+	if (__nbits < std::numeric_limits<decltype(__val)>::digits)
+	  __val &= ~(-1ULL << __nbits);
+	if (__val == 0)
+	  return;
+
+	if _GLIBCXX17_CONSTEXPR (sizeof(__val) == sizeof(block_type))
+	  _M_w[0] = __val;
+	else
 	  {
-	    this->_M_w[__i] = (__val & __mask) >> (__i * _S_bits_per_block);
-	    __mask <<= _S_bits_per_block;
+	    const size_t __n
+	      = std::min(_M_w.size(), sizeof(__val) / sizeof(block_type));
+	    for (size_t __i = 0; __val && __i < __n; ++__i)
+	      {
+		_M_w[__i] = static_cast<block_type>(__val);
+		__val >>= _S_bits_per_block;
+	      }
 	  }
       }
 
       void
-      _M_assign(const __dynamic_bitset_base& __b)
-      { this->_M_w = __b._M_w; }
-
-      void
-      _M_swap(__dynamic_bitset_base& __b)
+      _M_swap(__dynamic_bitset_base& __b) noexcept
       { this->_M_w.swap(__b._M_w); }
 
       void
-      _M_clear()
+      _M_clear() noexcept
       { this->_M_w.clear(); }
 
       void
@@ -129,7 +135,7 @@
       }
 
       allocator_type
-      _M_get_allocator() const
+      _M_get_allocator() const noexcept
       { return this->_M_w.get_allocator(); }
 
       static size_type
@@ -149,23 +155,23 @@
       { return (static_cast<block_type>(1)) << _S_whichbit(__pos); }
 
       block_type&
-      _M_getword(size_type __pos)
+      _M_getword(size_type __pos) noexcept
       { return this->_M_w[_S_whichword(__pos)]; }
 
       block_type
-      _M_getword(size_type __pos) const
+      _M_getword(size_type __pos) const noexcept
       { return this->_M_w[_S_whichword(__pos)]; }
 
       block_type&
-      _M_hiword()
+      _M_hiword() noexcept
       { return this->_M_w[_M_w.size() - 1]; }
 
       block_type
-      _M_hiword() const
+      _M_hiword() const noexcept
       { return this->_M_w[_M_w.size() - 1]; }
 
       void
-      _M_do_and(const __dynamic_bitset_base& __x)
+      _M_do_and(const __dynamic_bitset_base& __x) noexcept
       {
 	if (__x._M_w.size() == this->_M_w.size())
 	  for (size_t __i = 0; __i < this->_M_w.size(); ++__i)
@@ -175,7 +181,7 @@
       }
 
       void
-      _M_do_or(const __dynamic_bitset_base& __x)
+      _M_do_or(const __dynamic_bitset_base& __x) noexcept
       {
 	if (__x._M_w.size() == this->_M_w.size())
 	  for (size_t __i = 0; __i < this->_M_w.size(); ++__i)
@@ -185,7 +191,7 @@
       }
 
       void
-      _M_do_xor(const __dynamic_bitset_base& __x)
+      _M_do_xor(const __dynamic_bitset_base& __x) noexcept
       {
 	if (__x._M_w.size() == this->_M_w.size())
 	  for (size_t __i = 0; __i < this->_M_w.size(); ++__i)
@@ -195,7 +201,7 @@
       }
 
       void
-      _M_do_dif(const __dynamic_bitset_base& __x)
+      _M_do_dif(const __dynamic_bitset_base& __x) noexcept
       {
 	if (__x._M_w.size() == this->_M_w.size())
 	  for (size_t __i = 0; __i < this->_M_w.size(); ++__i)
@@ -211,7 +217,7 @@
       _M_do_right_shift(size_t __shift);
 
       void
-      _M_do_flip()
+      _M_do_flip() noexcept
       {
 	for (size_t __i = 0; __i < this->_M_w.size(); ++__i)
 	  this->_M_w[__i] = ~this->_M_w[__i];
@@ -218,21 +224,20 @@
       }
 
       void
-      _M_do_set()
+      _M_do_set() noexcept
       {
 	for (size_t __i = 0; __i < this->_M_w.size(); ++__i)
-	  this->_M_w[__i] = ~static_cast<block_type>(0);
+	  this->_M_w[__i] = static_cast<block_type>(-1);
       }
 
       void
-      _M_do_reset()
+      _M_do_reset() noexcept
       {
-	for (size_t __i = 0; __i < this->_M_w.size(); ++__i)
-	  this->_M_w[__i] = static_cast<block_type>(0);
+	std::fill(_M_w.begin(), _M_w.end(), static_cast<block_type>(0));
       }
 
       bool
-      _M_is_equal(const __dynamic_bitset_base& __x) const
+      _M_is_equal(const __dynamic_bitset_base& __x) const noexcept
       {
 	if (__x._M_w.size() == this->_M_w.size())
 	  {
@@ -246,7 +251,7 @@
       }
 
       bool
-      _M_is_less(const __dynamic_bitset_base& __x) const
+      _M_is_less(const __dynamic_bitset_base& __x) const noexcept
       {
 	if (__x._M_w.size() == this->_M_w.size())
 	  {
@@ -264,10 +269,10 @@
       }
 
       size_t
-      _M_are_all_aux() const
+      _M_are_all_aux() const noexcept
       {
 	for (size_t __i = 0; __i < this->_M_w.size() - 1; ++__i)
-	  if (_M_w[__i] != ~static_cast<block_type>(0))
+	  if (_M_w[__i] != static_cast<block_type>(-1))
 	    return 0;
 	return ((this->_M_w.size() - 1) * _S_bits_per_block
 		+ __builtin_popcountll(this->_M_hiword()));
@@ -274,7 +279,7 @@
       }
 
       bool
-      _M_is_any() const
+      _M_is_any() const noexcept
       {
 	for (size_t __i = 0; __i < this->_M_w.size(); ++__i)
 	  if (this->_M_w[__i] != static_cast<block_type>(0))
@@ -283,7 +288,7 @@
       }
 
       bool
-      _M_is_subset_of(const __dynamic_bitset_base& __b)
+      _M_is_subset_of(const __dynamic_bitset_base& __b) noexcept
       {
 	if (__b._M_w.size() == this->_M_w.size())
 	  {
@@ -297,7 +302,7 @@
       }
 
       bool
-      _M_is_proper_subset_of(const __dynamic_bitset_base& __b) const
+      _M_is_proper_subset_of(const __dynamic_bitset_base& __b) const noexcept
       {
 	if (this->is_subset_of(__b))
 	  {
@@ -311,7 +316,7 @@
       }
 
       size_t
-      _M_do_count() const
+      _M_do_count() const noexcept
       {
 	size_t __result = 0;
 	for (size_t __i = 0; __i < this->_M_w.size(); ++__i)
@@ -357,6 +362,7 @@
    *
    *  See N2050,
    *  Proposal to Add a Dynamically Sizeable Bitset to the Standard Library.
+   *  http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2050.pdf
    *
    *  In the general unoptimized case, storage is allocated in
    *  word-sized blocks.  Let B be the number of bits in a word, then
@@ -435,7 +441,7 @@
       {
 	size_type __shift = this->_M_Nb % bits_per_block;
 	if (__shift > 0)
-	  this->_M_hiword() &= ~((~static_cast<block_type>(0)) << __shift);
+	  this->_M_hiword() &= block_type(~(block_type(-1) << __shift));
       }
 
       //  Set the unused bits in the uppermost word.
@@ -444,7 +450,7 @@
       {
 	size_type __shift = this->_M_Nb % bits_per_block;
 	if (__shift > 0)
-	  this->_M_hiword() |= ((~static_cast<block_type>(0)) << __shift);
+	  this->_M_hiword() |= block_type(block_type(-1) << __shift);
       }
 
       /**
@@ -451,15 +457,15 @@
        *  These versions of single-bit set, reset, flip, and test
        *  do no range checking.
        */
-      dynamic_bitset<_WordT, _Alloc>&
-      _M_unchecked_set(size_type __pos)
+      dynamic_bitset&
+      _M_unchecked_set(size_type __pos) noexcept
       {
 	this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
 	return *this;
       }
 
-      dynamic_bitset<_WordT, _Alloc>&
-      _M_unchecked_set(size_type __pos, int __val)
+      dynamic_bitset&
+      _M_unchecked_set(size_type __pos, int __val) noexcept
       {
 	if (__val)
 	  this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);
@@ -468,15 +474,15 @@
 	return *this;
       }
 
-      dynamic_bitset<_WordT, _Alloc>&
-      _M_unchecked_reset(size_type __pos)
+      dynamic_bitset&
+      _M_unchecked_reset(size_type __pos) noexcept
       {
 	this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);
 	return *this;
       }
 
-      dynamic_bitset<_WordT, _Alloc>&
-      _M_unchecked_flip(size_type __pos)
+      dynamic_bitset&
+      _M_unchecked_flip(size_type __pos) noexcept
       {
 	this->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);
 	return *this;
@@ -483,11 +489,11 @@
       }
 
       bool
-      _M_unchecked_test(size_type __pos) const
+      _M_unchecked_test(size_type __pos) const noexcept
       { return ((this->_M_getword(__pos) & _Base::_S_maskbit(__pos))
 		!= static_cast<_WordT>(0)); }
 
-      size_type _M_Nb;
+      size_type _M_Nb = 0;
 
     public:
       /**
@@ -511,22 +517,16 @@
 	block_type *_M_wp;
 	size_type _M_bpos;
 
-	// left undefined
-	reference();
-
       public:
-	reference(dynamic_bitset& __b, size_type __pos)
+	reference(dynamic_bitset& __b, size_type __pos) noexcept
 	{
 	  this->_M_wp = &__b._M_getword(__pos);
 	  this->_M_bpos = _Base::_S_whichbit(__pos);
 	}
 
-	~reference()
-	{ }
-
 	// For b[i] = __x;
 	reference&
-	operator=(bool __x)
+	operator=(bool __x) noexcept
 	{
 	  if (__x)
 	    *this->_M_wp |= _Base::_S_maskbit(this->_M_bpos);
@@ -537,7 +537,7 @@
 
 	// For b[i] = b[__j];
 	reference&
-	operator=(const reference& __j)
+	operator=(const reference& __j) noexcept
 	{
 	  if ((*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)))
 	    *this->_M_wp |= _Base::_S_maskbit(this->_M_bpos);
@@ -548,16 +548,16 @@
 
 	// Flips the bit
 	bool
-	operator~() const
+	operator~() const noexcept
 	{ return (*(_M_wp) & _Base::_S_maskbit(this->_M_bpos)) == 0; }
 
 	// For __x = b[i];
-	operator bool() const
+	operator bool() const noexcept
 	{ return (*(this->_M_wp) & _Base::_S_maskbit(this->_M_bpos)) != 0; }
 
 	// For b[i].flip();
 	reference&
-	flip()
+	flip() noexcept
 	{
 	  *this->_M_wp ^= _Base::_S_maskbit(this->_M_bpos);
 	  return *this;
@@ -569,10 +569,14 @@
       typedef bool const_reference;
 
       // 23.3.5.1 constructors:
+
       /// All bits set to zero.
+      dynamic_bitset() = default;
+
+      /// All bits set to zero.
       explicit
-      dynamic_bitset(const allocator_type& __alloc = allocator_type())
-      : _Base(__alloc), _M_Nb(0)
+      dynamic_bitset(const allocator_type& __alloc)
+      : _Base(__alloc)
       { }
 
       /// Initial bits bitwise-copied from a single word (others set to zero).
@@ -585,7 +589,7 @@
 
       dynamic_bitset(initializer_list<block_type> __il,
 		     const allocator_type& __alloc = allocator_type())
-      : _Base(__alloc), _M_Nb(0)
+      : _Base(__alloc)
       { this->append(__il); }
 
       /**
@@ -609,8 +613,7 @@
 		       __n = std::basic_string<_CharT, _Traits, _Alloc1>::npos,
 		       _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'),
 		       const allocator_type& __alloc = allocator_type())
-	: _Base(__alloc),
-	  _M_Nb(0) // Watch for npos.
+	: _Base(__alloc)
 	{
 	  if (__pos > __str.size())
 	    __throw_out_of_range(__N("dynamic_bitset::bitset initial position "
@@ -619,8 +622,7 @@
 	  // Watch for npos.
 	  this->_M_Nb = (__n > __str.size() ? __str.size() - __pos : __n);
 	  this->resize(this->_M_Nb);
-	  this->_M_copy_from_string(__str, __pos, __n,
-				    _CharT('0'), _CharT('1'));
+	  this->_M_copy_from_string(__str, __pos, __n);
 	}
 
       /**
@@ -633,61 +635,42 @@
       explicit
       dynamic_bitset(const char* __str,
 		     const allocator_type& __alloc = allocator_type())
-      : _Base(__alloc)
+      : _Base(__builtin_strlen(__str), 0ULL, __alloc),
+	_M_Nb(__builtin_strlen(__str))
       {
-	size_t __len = 0;
-	if (__str)
-	  while (__str[__len] != '\0')
-	    ++__len;
-	this->resize(__len);
-	this->_M_copy_from_ptr<char,std::char_traits<char>>
-		   (__str, __len, 0, __len, '0', '1');
+	this->_M_copy_from_ptr(__str, _M_Nb, 0, _M_Nb);
       }
 
-      /**
-       *  @brief  Copy constructor.
-       */
-      dynamic_bitset(const dynamic_bitset& __b)
-      : _Base(__b), _M_Nb(__b.size())
-      { }
+      /// Copy constructor.
+      dynamic_bitset(const dynamic_bitset&) = default;
 
-      /**
-       *  @brief  Move constructor.
-       */
-      dynamic_bitset(dynamic_bitset&& __b)
-      : _Base(std::forward<_Base>(__b)), _M_Nb(__b.size())
-      { }
+      /// Move constructor.
+      dynamic_bitset(dynamic_bitset&& __b) noexcept
+      : _Base(std::move(__b)), _M_Nb(__b._M_Nb)
+      { __b.clear(); }
 
-      /**
-       *  @brief  Swap with another bitset.
-       */
+      /// Swap with another bitset.
       void
-      swap(dynamic_bitset& __b)
+      swap(dynamic_bitset& __b) noexcept
       {
 	this->_M_swap(__b);
 	std::swap(this->_M_Nb, __b._M_Nb);
       }
 
-      /**
-       *  @brief  Assignment.
-       */
-      dynamic_bitset&
-      operator=(const dynamic_bitset& __b)
-      {
-	if (&__b != this)
-	  {
-	    this->_M_assign(__b);
-	    this->_M_Nb = __b._M_Nb;
-	  }
-      }
+      /// Copy assignment operator.
+      dynamic_bitset& operator=(const dynamic_bitset&) = default;
 
-      /**
-       *  @brief  Move assignment.
-       */
+      /// Move assignment operator.
       dynamic_bitset&
       operator=(dynamic_bitset&& __b)
+      noexcept(std::is_nothrow_move_assignable<_Base>::value)
       {
-	this->swap(__b);
+	static_cast<_Base&>(*this) = static_cast<_Base&&>(__b);
+	_M_Nb = __b._M_Nb;
+	if _GLIBCXX17_CONSTEXPR (std::is_nothrow_move_assignable<_Base>::value)
+	  __b._M_Nb = 0;
+	else if (get_allocator() == __b.get_allocator())
+	  __b._M_Nb = 0;
 	return *this;
       }
 
@@ -695,7 +678,7 @@
        *  @brief  Return the allocator for the bitset.
        */
       allocator_type
-      get_allocator() const
+      get_allocator() const noexcept
       { return this->_M_get_allocator(); }
 
       /**
@@ -733,6 +716,8 @@
 	this->_M_unchecked_set(this->_M_Nb, __bit);
       }
 
+      // XXX why is there no pop_back() member in the proposal?
+
       /**
        *  @brief  Append a block.
        */
@@ -769,36 +754,36 @@
        *
        *  These should be self-explanatory.
        */
-      dynamic_bitset<_WordT, _Alloc>&
-      operator&=(const dynamic_bitset<_WordT, _Alloc>& __rhs)
+      dynamic_bitset&
+      operator&=(const dynamic_bitset& __rhs)
       {
 	this->_M_do_and(__rhs);
 	return *this;
       }
 
-      dynamic_bitset<_WordT, _Alloc>&
-      operator&=(dynamic_bitset<_WordT, _Alloc>&& __rhs)
+      dynamic_bitset&
+      operator&=(dynamic_bitset&& __rhs)
       {
 	this->_M_do_and(std::move(__rhs));
 	return *this;
       }
 
-      dynamic_bitset<_WordT, _Alloc>&
-      operator|=(const dynamic_bitset<_WordT, _Alloc>& __rhs)
+      dynamic_bitset&
+      operator|=(const dynamic_bitset& __rhs)
       {
 	this->_M_do_or(__rhs);
 	return *this;
       }
 
-      dynamic_bitset<_WordT, _Alloc>&
-      operator^=(const dynamic_bitset<_WordT, _Alloc>& __rhs)
+      dynamic_bitset&
+      operator^=(const dynamic_bitset& __rhs)
       {
 	this->_M_do_xor(__rhs);
 	return *this;
       }
 
-      dynamic_bitset<_WordT, _Alloc>&
-      operator-=(const dynamic_bitset<_WordT, _Alloc>& __rhs)
+      dynamic_bitset&
+      operator-=(const dynamic_bitset& __rhs)
       {
 	this->_M_do_dif(__rhs);
 	return *this;
@@ -812,7 +797,7 @@
        *
        *  These should be self-explanatory.
        */
-      dynamic_bitset<_WordT, _Alloc>&
+      dynamic_bitset&
       operator<<=(size_type __pos)
       {
 	if (__builtin_expect(__pos < this->_M_Nb, 1))
@@ -825,7 +810,7 @@
 	return *this;
       }
 
-      dynamic_bitset<_WordT, _Alloc>&
+      dynamic_bitset&
       operator>>=(size_type __pos)
       {
 	if (__builtin_expect(__pos < this->_M_Nb, 1))
@@ -843,7 +828,7 @@
       /**
        *  @brief Sets every bit to true.
        */
-      dynamic_bitset<_WordT, _Alloc>&
+      dynamic_bitset&
       set()
       {
 	this->_M_do_set();
@@ -857,7 +842,7 @@
        *  @param  __val  Either true or false, defaults to true.
        *  @throw  std::out_of_range  If @a __pos is bigger the size of the %set.
        */
-      dynamic_bitset<_WordT, _Alloc>&
+      dynamic_bitset&
       set(size_type __pos, bool __val = true)
       {
 	if (__pos >= _M_Nb)
@@ -868,7 +853,7 @@
       /**
        *  @brief Sets every bit to false.
        */
-      dynamic_bitset<_WordT, _Alloc>&
+      dynamic_bitset&
       reset()
       {
 	this->_M_do_reset();
@@ -882,7 +867,7 @@
        *
        *  Same as writing @c set(__pos, false).
        */
-      dynamic_bitset<_WordT, _Alloc>&
+      dynamic_bitset&
       reset(size_type __pos)
       {
 	if (__pos >= _M_Nb)
@@ -893,7 +878,7 @@
       /**
        *  @brief Toggles every bit to its opposite value.
        */
-      dynamic_bitset<_WordT, _Alloc>&
+      dynamic_bitset&
       flip()
       {
 	this->_M_do_flip();
@@ -906,7 +891,7 @@
        *  @param  __pos  The index of the bit.
        *  @throw  std::out_of_range  If @a __pos is bigger the size of the %set.
        */
-      dynamic_bitset<_WordT, _Alloc>&
+      dynamic_bitset&
       flip(size_type __pos)
       {
 	if (__pos >= _M_Nb)
@@ -915,7 +900,7 @@
       }
 
       /// See the no-argument flip().
-      dynamic_bitset<_WordT, _Alloc>
+      dynamic_bitset
       operator~() const
       { return dynamic_bitset<_WordT, _Alloc>(*this).flip(); }
 
@@ -977,19 +962,23 @@
 	}
 
       // Helper functions for string operations.
-      template<typename _CharT, typename _Traits>
+      template<typename _Traits = std::char_traits<char>,
+	       typename _CharT = typename _Traits::char_type>
 	void
 	_M_copy_from_ptr(const _CharT*, size_t, size_t, size_t,
-			 _CharT, _CharT);
+			 _CharT __zero = _CharT('0'),
+			 _CharT __one = _CharT('1'));
 
       template<typename _CharT, typename _Traits, typename _Alloc1>
 	void
-	_M_copy_from_string(const std::basic_string<_CharT,
-			    _Traits, _Alloc1>& __str, size_t __pos, size_t __n,
+	_M_copy_from_string(const basic_string<_CharT, _Traits, _Alloc1>& __str,
+			    size_t __pos, size_t __n,
 			    _CharT __zero = _CharT('0'),
 			    _CharT __one = _CharT('1'))
-	{ _M_copy_from_ptr<_CharT, _Traits>(__str.data(), __str.size(),
-					    __pos, __n, __zero, __one); }
+	{
+	  _M_copy_from_ptr<_Traits>(__str.data(), __str.size(), __pos, __n,
+				    __zero, __one);
+	}
 
       template<typename _CharT, typename _Traits, typename _Alloc1>
 	void
@@ -1064,13 +1053,13 @@
 
       //@{
       /// Self-explanatory.
-      dynamic_bitset<_WordT, _Alloc>
+      dynamic_bitset
       operator<<(size_type __pos) const
-      { return dynamic_bitset<_WordT, _Alloc>(*this) <<= __pos; }
+      { return dynamic_bitset(*this) <<= __pos; }
 
-      dynamic_bitset<_WordT, _Alloc>
+      dynamic_bitset
       operator>>(size_type __pos) const
-      { return dynamic_bitset<_WordT, _Alloc>(*this) >>= __pos; }
+      { return dynamic_bitset(*this) >>= __pos; }
       //@}
 
       /**
@@ -1101,14 +1090,14 @@
       { return this->_M_is_proper_subset_of(__b); }
 
       friend bool
-      operator==(const dynamic_bitset<_WordT, _Alloc>& __lhs,
-		 const dynamic_bitset<_WordT, _Alloc>& __rhs)
-      { return __lhs._M_is_equal(__rhs); }
+      operator==(const dynamic_bitset& __lhs,
+		 const dynamic_bitset& __rhs) noexcept
+      { return __lhs._M_Nb == __rhs._M_Nb && __lhs._M_is_equal(__rhs); }
 
       friend bool
-      operator<(const dynamic_bitset<_WordT, _Alloc>& __lhs,
-		const dynamic_bitset<_WordT, _Alloc>& __rhs)
-      { return __lhs._M_is_less(__rhs); }
+      operator<(const dynamic_bitset& __lhs,
+		const dynamic_bitset& __rhs) noexcept
+      { return __lhs._M_is_less(__rhs) || __lhs._M_Nb < __rhs._M_Nb; }
     };
 
   template<typename _WordT, typename _Alloc>
Index: libstdc++-v3/libsupc++/Makefile.in
===================================================================
diff --git a/libstdc++-v3/libsupc++/Makefile.in b/libstdc++-v3/libsupc++/Makefile.in
--- a/libstdc++-v3/libsupc++/Makefile.in	(revision 278653)
+++ b/libstdc++-v3/libsupc++/Makefile.in	(revision 278653)
@@ -278,6 +278,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/libsupc++/guard_error.cc
===================================================================
diff --git a/libstdc++-v3/libsupc++/guard_error.cc b/libstdc++-v3/libsupc++/guard_error.cc
--- a/libstdc++-v3/libsupc++/guard_error.cc	(revision 278653)
+++ b/libstdc++-v3/libsupc++/guard_error.cc	(revision 278653)
@@ -26,6 +26,6 @@
 
 namespace __gnu_cxx
 {
-  recursive_init_error::~recursive_init_error() throw() { }
+  recursive_init_error::recursive_init_error() noexcept { }
+  recursive_init_error::~recursive_init_error() noexcept { }
 }
-
Index: libstdc++-v3/libsupc++/new_opa.cc
===================================================================
diff --git a/libstdc++-v3/libsupc++/new_opa.cc b/libstdc++-v3/libsupc++/new_opa.cc
--- a/libstdc++-v3/libsupc++/new_opa.cc	(revision 278653)
+++ b/libstdc++-v3/libsupc++/new_opa.cc	(revision 278653)
@@ -114,9 +114,10 @@
     sz = 1;
 
 #if _GLIBCXX_HAVE_ALIGNED_ALLOC
-# ifdef _AIX
+# if defined _AIX || defined __APPLE__
   /* AIX 7.2.0.0 aligned_alloc incorrectly has posix_memalign's requirement
-   * that alignment is a multiple of sizeof(void*).  */
+   * that alignment is a multiple of sizeof(void*).
+   * OS X 10.15 has the same requirement.  */
   if (align < sizeof(void*))
     align = sizeof(void*);
 # endif
Index: libstdc++-v3/libsupc++/hash_bytes.cc
===================================================================
diff --git a/libstdc++-v3/libsupc++/hash_bytes.cc b/libstdc++-v3/libsupc++/hash_bytes.cc
--- a/libstdc++-v3/libsupc++/hash_bytes.cc	(revision 278653)
+++ b/libstdc++-v3/libsupc++/hash_bytes.cc	(revision 278653)
@@ -139,7 +139,7 @@
 
     // Remove the bytes not divisible by the sizeof(size_t).  This
     // allows the main loop to process the data as 64-bit integers.
-    const int len_aligned = len & ~0x7;
+    const size_t len_aligned = len & ~(size_t)0x7;
     const char* const end = buf + len_aligned;
     size_t hash = seed ^ (len * mul);
     for (const char* p = buf; p != end; p += 8)
Index: libstdc++-v3/libsupc++/exception
===================================================================
diff --git a/libstdc++-v3/libsupc++/exception b/libstdc++-v3/libsupc++/exception
--- a/libstdc++-v3/libsupc++/exception	(revision 278653)
+++ b/libstdc++-v3/libsupc++/exception	(revision 278653)
@@ -101,8 +101,8 @@
   _GLIBCXX17_DEPRECATED
   bool uncaught_exception() _GLIBCXX_USE_NOEXCEPT __attribute__ ((__pure__));
 
-#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++17 or gnu++98
-#define __cpp_lib_uncaught_exceptions 201411
+#if __cplusplus >= 201703L || !defined(__STRICT_ANSI__) // c++17 or gnu++98
+#define __cpp_lib_uncaught_exceptions 201411L
   /// The number of uncaught exceptions.
   int uncaught_exceptions() _GLIBCXX_USE_NOEXCEPT __attribute__ ((__pure__));
 #endif
Index: libstdc++-v3/libsupc++/cxxabi.h
===================================================================
diff --git a/libstdc++-v3/libsupc++/cxxabi.h b/libstdc++-v3/libsupc++/cxxabi.h
--- a/libstdc++-v3/libsupc++/cxxabi.h	(revision 278653)
+++ b/libstdc++-v3/libsupc++/cxxabi.h	(revision 278653)
@@ -683,8 +683,9 @@
    *  @brief Exception thrown by __cxa_guard_acquire.
    *  @ingroup exceptions
    *
-   *  6.7[stmt.dcl]/4: If control re-enters the declaration (recursively)
-   *  while the object is being initialized, the behavior is undefined.
+   *  C++ 2011 6.7 [stmt.dcl]/4: If control re-enters the declaration
+   *  recursively while the variable is being initialized, the behavior
+   *  is undefined.
    *
    *  Since we already have a library function to handle locking, we might
    *  as well check for this situation and throw an exception.
@@ -694,8 +695,8 @@
   class recursive_init_error: public std::exception
   {
   public:
-    recursive_init_error() throw() { }
-    virtual ~recursive_init_error() throw ();
+    recursive_init_error() _GLIBCXX_NOTHROW;
+    virtual ~recursive_init_error() _GLIBCXX_NOTHROW;
   };
 }
 #endif // __cplusplus
Index: libstdc++-v3/ChangeLog
===================================================================
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
--- a/libstdc++-v3/ChangeLog	(revision 278653)
+++ b/libstdc++-v3/ChangeLog	(revision 278653)
@@ -1,3 +1,555 @@
+2019-10-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-06-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/20_util/is_nothrow_invocable/value.cc: Test converting to
+	void.
+	* testsuite/experimental/names.cc: Do not run for C++98 mode. Do not
+	include Library Fundamentals or Networking headers in C++11 mode.
+
+	Backport from mainline
+	2019-10-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/memoryfwd.h (uses_allocator): Do not declare for C++98.
+	* testsuite/17_intro/names.cc: Check uses_allocator in C++98.
+
+	Backport from mainline
+	2019-10-18  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/92143
+	* libsupc++/new_opa.cc (operator new) [__APPLE__]: Increase alignment
+	to at least sizeof(void*).
+
+	Backport from mainline
+	2019-10-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/Makefile.am (doc-html-docbook-regenerate): New target.
+	(${docbook_outdir}/html): Do not create unused 'html/ext' directory.
+	* doc/Makefile.in: Regenerate.
+	* doc/xml/manual/documentation_hacking.xml: Document new target.
+	* doc/html/*: Regenerate.
+
+	* doc/xml/manual/allocator.xml: Use archived copy of CUJ article.
+
+	Backport from mainline
+	2019-05-31  Gerald Pfeifer  <gerald@pfeifer.com>
+
+	* doc/xml/manual/allocator.xml: Move hoard.org back to http.
+
+	Backport from mainline
+	2019-10-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/92059
+	* include/tr2/dynamic_bitset (__dynamic_bitset_base): Define all
+	special member functions as defaulted. Add noexcept to most members.
+	(__dynamic_bitset_base(size_t, unsigned long long, const _Alloc&)):
+	Mask off unwanted bits in the __val parameter. Avoid undefined left
+	shifts.
+	(__dynamic_bitset_base::_M_assign): Remove.
+	(__dynamic_bitset_base::_M_do_reset): Use std::fill.
+	(__dynamic_bitset_base::_M_are_all_aux): Avoid integer promotion when
+	block_type has lower rank than int.
+	(dynamic_bitset): Add noexcept to most members. Use injected-class-name
+	in return types and parameter types.
+	(dynamic_bitset::_M_Nb): Add default member initializer.
+	(dynamic_bitset(), dynamic_bitset(const dynamic_bitset&)): Define as
+	defaulted.
+	(dynamic_bitset(dynamic_bitset&&)): Clear source object after move.
+	(dynamic_bitset::operator=(const dynamic_bitset&)): Define as
+	defaulted.
+	(dynamic_bitset::operator=(dynamic_bitset&&)): Add noexcept-specifier.
+	Define without using swap, to propagate allocator correctly.
+	(dynamic_bitset(const char*, const _Alloc&)): Use strlen.
+	(dynamic_bitset::_M_do_sanitize, dynamic_bitset::_M_do_fill): Use
+	casts to avoid unwanted integer promotions.
+	(dynamic_bitset::_M_copy_from_ptr): Rearrange template parameters and
+	add default template arguments and default argument to simplify usage.
+	(dynamic_bitset::_M_copy_from_string): Adjust call to _M_copy_from_ptr.
+	(operator==(const dynamic_bitset&, const dynamic_bitset&))
+	(operator<(const dynamic_bitset&, const dynamic_bitset&)): Use _M_Nb.
+	* include/tr2/dynamic_bitset.tcc (dynamic_bitset::_M_copy_from_ptr):
+	Adjust template parameters to match declaration.
+	* testsuite/tr2/dynamic_bitset/cmp.cc: New test.
+	* testsuite/tr2/dynamic_bitset/cons.cc: New test.
+	* testsuite/tr2/dynamic_bitset/copy.cc: New test.
+	* testsuite/tr2/dynamic_bitset/move.cc: New test.
+	* testsuite/tr2/dynamic_bitset/pr92059.cc: New test.
+
+2019-09-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	* python/libstdcxx/v6/xmethods.py (SharedPtrUseCountWorker.__call__):
+	Fix syntax error.
+
+2019-09-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/html/*: Regenerate.
+
+	* testsuite/20_util/unique_ptr/assign/48635_neg.cc: Replace dg-error
+	with dg-prune-output for enable_if failure.
+	* testsuite/20_util/unique_ptr/cons/cv_qual_neg.cc: Add
+	dg-prune-output for enable_if failure.
+
+2019-08-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-10-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/variant (__gen_vtable_impl::__visit_invoke): Call __get
+	directly instead of get, as caller ensures correct index is used.
+	(holds_alternative, get, get_if): Remove redundant inline specifiers.
+	(_VARIANT_RELATION_FUNCTION_TEMPLATE): Likewise.
+
+2019-08-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-08-16  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/ostream (basic_ostream::sentry::~sentry): Suppress
+	deprecation warnings for using uncaught_exception().
+
+2019-08-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-07-31  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/91308
+	* include/bits/unique_ptr.h (unique_ptr::__safe_conversion_up): Remove
+	constraints on deleter that should only apply to the constructor.
+	(unique_ptr<T[], D>::__safe_conversion_up): Likewise.
+	(unique_ptr<T[], D>::unique_ptr(unique_ptr<U, D>&&)): Restore
+	constraints on deleter here.
+	* testsuite/20_util/unique_ptr/assign/91308.cc: New test.
+
+2019-08-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-07-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/51333
+	* libsupc++/cxxabi.h (__gnu_cxx::recursive_init_error): Do not define
+	constructor inline.
+	* libsupc++/guard_error.cc (__gnu_cxx::recursive_init_error): Define
+	constructor.
+	* testsuite/18_support/51333.cc: New test.
+
+2019-08-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/status_cxx2017.xml: Add feature test macro for
+	P0040R3.
+	* doc/html/*: Regenerate.
+
+	Backport from mainline
+	2019-06-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/status_cxx2017.xml: Fix outdated reference to
+	C++17 working draft.
+
+	Backport from mainline
+	2019-05-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/shared_ptr.xml: Fix names of lock policy constants.
+
+2019-08-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-09-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/78179
+	* testsuite/26_numerics/headers/cmath/hypot.cc: Use lower tolerance
+	when sizeof(long double) == sizeof(double).
+
+2019-08-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-03-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/stl_algobase.h (__lg): Do arithmetic on type int to
+	avoid -Wconversion warnings.
+
+2019-08-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-06-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90770
+	* src/Makefile.am (stamp-debug): Also test for missing makefile.
+	* src/Makefile.in: Regenerate.
+
+2019-08-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/random.h (seed_seq::param): Fix non-reserved name.
+	* include/experimental/type_traits (is_detected_exact)
+	(is_detected_exact_v): Likewise.
+	* testsuite/17_intro/names.cc: Check for more non-reserved names.
+	* testsuite/experimental/names.cc: New test.
+
+2019-08-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/85965
+	* include/bits/hashtable.h (_Hashtable::~_Hashtable()): Remove static
+	assertions from the destructor.
+	* include/bits/hashtable_policy.h (_Hash_code_base::_M_hash_code):
+	Move static_assert for hash function to here.
+	(_Hash_table_base::_M_equals): Move static_assert for equality
+	predicate to here.
+	* include/bits/stl_tree.h (_Rb_tree::_S_key(_Const_Link_type)): Move
+	assertions here. Access the value directly instead of calling _S_value.
+	(_Rb_tree::_S_key(_Const_Base_ptr)): Do downcast and forward to
+	_S_key(_Const_Link_type).
+	* testsuite/23_containers/set/85965.cc: Check construction,
+	destruction, assignment and size() do not trigger the assertions.
+	* testsuite/23_containers/unordered_set/85965.cc: Likewise.
+	* testsuite/23_containers/map/48101_neg.cc: Call find and adjust
+	expected errors.
+	* testsuite/23_containers/multimap/48101_neg.cc: Likewise.
+	* testsuite/23_containers/multiset/48101_neg.cc: Likewise.
+	* testsuite/23_containers/set/48101_neg.cc: Likewise.
+	* testsuite/23_containers/unordered_map/48101_neg.cc: Likewise.
+	* testsuite/23_containers/unordered_multimap/48101_neg.cc: Likewise.
+	* testsuite/23_containers/unordered_multiset/48101_neg.cc: Likewise.
+	* testsuite/23_containers/unordered_set/48101_neg.cc: Likewise.
+
+2019-08-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-09-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/stl_vector.h (vector::_Temporary_value::_M_ptr):
+	Return raw pointer not allocator's pointer type.
+	(vector::_Temporary_value::_M_val): Use _M_ptr.
+
+2019-06-01   Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-12-22 Iain Sandoe <iain@sandoe.co.uk>
+
+	* /config/os/bsd/darwin/ppc-extra.ver: Append long double symbols.
+
+2019-05-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/status_cxx2017.xml: Fix typo in documentation of
+	implementation-defined support for [fs.conform.9945].
+	* doc/html/*: Regenerate.
+
+2019-05-28  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90634
+	* src/filesystem/path.cc (path::_M_split_cmpts()): Fix check for "/".
+	* testsuite/27_io/filesystem/path/construct/90634.cc: New test.
+	* testsuite/experimental/filesystem/path/construct/90634.cc: New test.
+
+	PR libstdc++/90634
+	* include/bits/fs_path.h (path::path(path&&)): Only call
+	_M_split_cmpts() for a path with multiple components.
+	(path::_S_is_dir_sep()): Add missing 'static' keyword to function.
+	* include/experimental/bits/fs_path.h: Likewise.
+	* src/filesystem/path.cc (path::_M_split_cmpts()): Count number of
+	components and reserve space in vector. Return early when there is
+	only one component.
+	* src/filesystem/std-path.cc (path::_M_split_cmpts()): Likewise.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-02-27  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89466
+	* acinclude.m4 (GLIBCXX_CONFIGURE_DOCBOOK): Reorder check for local
+	stylesheet directories before check for xsltproc. Try to use
+	xmlcatalog to find local stylesheet directory before trying hardcoded
+	paths. Add path used by suse to hardcoded paths. Adjust xsltproc
+	check to look for the same stylesheet as doc/Makefile.am uses. Don't
+	use xsltproc if xmlcatalog fails to find a local stylesheet.
+	* configure.ac: Check for xmlcatalog.
+	* Makefile.in: Regenerate.
+	* configure: Likewise.
+	* doc/Makefile.in: Likewise.
+	* include/Makefile.in: Likewise.
+	* libsupc++/Makefile.in: Likewise.
+	* po/Makefile.in: Likewise.
+	* python/Makefile.in: Likewise.
+	* src/Makefile.in: Likewise.
+	* src/c++11/Makefile.in: Likewise.
+	* src/c++17/Makefile.in: Likewise.
+	* src/c++98/Makefile.in: Likewise.
+	* src/filesystem/Makefile.in: Likewise.
+	* testsuite/Makefile.in: Likewise.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/html/*: Regenerate.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/experimental/any (__any_caster): Use RTTI if comparing
+	addresses fails, to support non-unique addresses in shared libraries.
+	* include/std/any (__any_caster): Likewise.
+	* testsuite/experimental/any/misc/any_cast_neg.cc: Use 0 for dg-error
+	line number.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90220
+	* include/experimental/any (__any_caster): Constrain to only be
+	callable for object types. Use remove_cv_t instead of decay_t.
+	If the type decays or isn't copy constructible, compare the manager
+	function to a dummy specialization.
+	(__any_caster): Add overload constrained for non-object types.
+	(any::_Manager_internal<_Op>): Add dummy specialization.
+	* testsuite/experimental/any/misc/any_cast.cc: Test function types
+	and array types.
+
+	Backport from mainline
+	2019-04-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90220
+	* include/std/any (__any_caster): Use remove_cv_t instead of decay_t.
+	Avoid a runtime check for types that can never be stored in std::any.
+	* testsuite/20_util/any/misc/any_cast.cc: Test std::any_cast with
+	array types.
+
+	Backport from mainline
+	2019-04-24  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90220 (partial)
+	* include/std/any (any_cast<T>(any*), any_cast<T>(const any*)): Do
+	not attempt ill-formed static_cast to pointers to non-object types.
+	* testsuite/20_util/any/misc/any_cast.cc: Test std::any_cast with
+	function types.
+
+2019-05-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from mainline
+	2019-01-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/status_cxx2017.xml: Document P0032R3 and P0307R2
+	status.
+	* include/bits/stl_uninitialized.h (__cpp_lib_raw_memory_algorithms):
+	Define.
+	* include/std/any (__cpp_lib_any): Define as 201606L, because P0032R3
+	changes are supported.
+	* include/std/optional (__cpp_lib_optional): Likewise.
+	* include/std/variant (__cpp_lib_variant): Likewise.
+	* libsupc++/exception (__cpp_lib_uncaught_exceptions): Define as long
+	integer.
+
+2019-05-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from mainline
+	2019-05-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/90532 Ensure __is_constructible(T[]) is false
+	* include/std/type_traits (__do_is_default_constructible_impl)
+	(__is_default_constructible_atom, __is_default_constructible_safe):
+	Remove.
+	(is_default_constructible): Use is_constructible.
+	* testsuite/20_util/is_constructible/value.cc: Check int[] case.
+	* testsuite/20_util/is_default_constructible/value.cc: Likewise.
+	* testsuite/20_util/is_trivially_constructible/value.cc: Likewise.
+	* testsuite/20_util/is_trivially_default_constructible/value.cc:
+	Likewise.
+
+2019-05-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90299
+	* src/filesystem/std-ops.cc (absolute(const path&)): Report an error
+	if the argument is an empty path.
+	(absolute(const path&, error_code&)): Use invalid_argument as error
+	code instead of no_such_file_or_directory.
+	* testsuite/27_io/filesystem/operations/absolute.cc: Check handling
+	of non-existent paths and empty paths with both overloads of absolute.
+
+2019-05-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-04-30  Jonathan Wakely  <jwakely@redhat.com>
+
+	* testsuite/27_io/filesystem/path/decompose/root_path.cc: Remove
+	macros accidentally left in.
+
+	Backport from mainline
+	2019-05-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90454.cc path construction from void*
+	* include/bits/fs_path.h (path::_Path): Use remove_pointer so that
+	pointers to void are rejected as well as void.
+	* include/experimental/bits/fs_path.h (path::_Path): Likewise.
+	* testsuite/27_io/filesystem/path/construct/80762.cc: Also check
+	pointers to void.
+	* testsuite/experimental/filesystem/path/construct/80762.cc: Likewise.
+
+2019-05-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-05-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/81266
+	* testsuite/util/thread/all.h: Do not use remove_pointer for
+	std::thread::native_handle_type.
+
+2019-05-07  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2019-02-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89102 (partial)
+	* include/std/type_traits (common_type<>): Define.
+	(common_type<T>): Derive from common_type<T, T>.
+	* testsuite/20_util/common_type/requirements/explicit_instantiation.cc:
+	Test zero-length template argument list.
+	* testsuite/20_util/common_type/requirements/sfinae_friendly_1.cc:
+	Test additional single argument cases.
+	* testsuite/20_util/common_type/requirements/sfinae_friendly_2.cc:
+	Adjust expected error.
+
+	Backport from mainline
+	2019-01-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/88740
+	* testsuite/util/testsuite_hooks.h [stderr] (VERIFY): Use fprintf to
+	write to stderr instead of using printf.
+
+	Backport from mainline
+	2019-04-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90165
+	* include/std/variant (variant::__is_in_place_tag)
+	(variant::__not_in_place_tag): New helpers for variant(T&&)
+	constructor constraint.
+	(variant::variant(T&&)): Use __not_in_place_tag in constraints.
+	* testsuite/20_util/variant/compile.cc: Check variant(T&&) constructor
+	isn't used for in_place_type or in_place_index arguments.
+
+	Backport from mainline
+	2019-04-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/90105
+	* include/bits/forward_list.tcc (operator==): Do not use operator!= to
+	compare elements.
+	(forward_list<T, A>::sort(Comp)): When elements are equal take the one
+	earlier in the list, so that sort is stable.
+	* testsuite/23_containers/forward_list/operations/90105.cc: New test.
+	* testsuite/23_containers/forward_list/comparable.cc: Test with
+	types that meet the minimum EqualityComparable and LessThanComparable
+	requirements. Remove irrelevant comment.
+
+	Backport from mainline
+	2019-04-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/optional (optional::value_or(U&&) &&): Add missing
+	constexpr specifier.
+	* testsuite/20_util/optional/constexpr/observers/4.cc: Check value_or
+	for disengaged optionals and rvalue optionals.
+	* testsuite/20_util/optional/observers/4.cc: Likewise.
+
+	Backport from mainline
+	2019-04-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/faq.xml: Add information about emergency EH pool.
+	* doc/xml/manual/debug.xml: Update list of memory debugging tools.
+	Move outdated information on mt_allocator to a separate section.
+	* doc/xml/manual/evolution.xml: Clarify that GLIBCXX_FORCE_NEW
+	doesn't affect the default allocator.
+
+	Backport from mainline
+	2019-04-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/filesystem/std-dir.cc (_Dir::advance(bool, error_code&)): Handle
+	d_type == DT_UNKNOWN immediately.
+	(_Dir::should_recurse(bool, error_code&)): Remove file_type::unknown
+	handling here.
+	* testsuite/27_io/filesystem/iterators/caching.cc: New test.
+
+	Backport from mainline
+	2019-04-05  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/fs_path.h (path::operator=(path&&)): Check for self
+	assignment.
+	* testsuite/27_io/filesystem/path/assign/copy.cc: Test self
+	assignment.
+
+	Backport from mainline
+	2019-03-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/85965
+	* include/bits/hashtable.h (_Hashtable): Move static assertions to
+	destructor so they are not evaluated until the _Key type is complete.
+	* include/bits/stl_tree.h (_Rb_tree): Likewise.
+	* testsuite/23_containers/set/85965.cc: New test.
+	* testsuite/23_containers/unordered_set/85965.cc: New test.
+	* testsuite/23_containers/map/48101_neg.cc: Replace "here" errors
+	with regexp matching the corresponding _Rb_tree specialization.
+	* testsuite/23_containers/multimap/48101_neg.cc: Likewise.
+	* testsuite/23_containers/multiset/48101_neg.cc: Remove "here" error.
+	* testsuite/23_containers/set/48101_neg.cc: Likewise.
+	* testsuite/23_containers/unordered_map/48101_neg.cc: Likewise.
+	* testsuite/23_containers/unordered_multimap/48101_neg.cc: Likewise.
+	* testsuite/23_containers/unordered_multiset/48101_neg.cc: Likewise.
+	* testsuite/23_containers/unordered_set/48101_neg.cc: Likewise.
+
+	Backport from mainline
+	2019-03-11  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89629
+	* libsupc++/hash_bytes.cc [__SIZEOF_SIZE_T__ == 8] (_Hash_bytes):
+	Use correct type for len_aligned.
+	* testsuite/20_util/hash/89629.cc: New test.
+
+	Backport from mainline
+	2019-03-08  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/using.xml: Use link element instead of xref.
+
+	Backport from mainline
+	2019-02-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/intro.xml: Document LWG 2586 status.
+	* include/bits/uses_allocator.h (__uses_alloc): Use const lvalue
+	allocator type in is_constructible checks.
+	* testsuite/20_util/scoped_allocator/69293_neg.cc: Adjust dg-error.
+	* testsuite/20_util/scoped_allocator/dr2586.cc: New test.
+	* testsuite/20_util/tuple/cons/allocators.cc: Add test using
+	problematic type from LWG 2586 discussion.
+	* testsuite/20_util/uses_allocator/69293_neg.cc: Adjust dg-error.
+	* testsuite/20_util/uses_allocator/cons_neg.cc: Likewise.
+
+	Backport from mainline
+	2019-02-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/manual/intro.xml: Document LWG 2537 status.
+	* include/bits/stl_queue.h
+	(priority_queue(const Compare&, const Container&, const Alloc&))
+	(priority_queue(const Compare&, Container&&, const Alloc&)): Call
+	make_heap.
+	* testsuite/23_containers/priority_queue/dr2537.cc: New test.
+
+2019-02-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/89446
+	* include/bits/char_traits.h (__constant_char_array): Check index is
+	in range before dereferencing.
+	* testsuite/21_strings/basic_string_view/operators/char/89446.cc:
+	New test.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: libstdc++-v3/testsuite/Makefile.in
===================================================================
diff --git a/libstdc++-v3/testsuite/Makefile.in b/libstdc++-v3/testsuite/Makefile.in
--- a/libstdc++-v3/testsuite/Makefile.in	(revision 278653)
+++ b/libstdc++-v3/testsuite/Makefile.in	(revision 278653)
@@ -205,6 +205,7 @@
 VTV_PCH_CXXFLAGS = @VTV_PCH_CXXFLAGS@
 WARN_FLAGS = @WARN_FLAGS@
 WERROR = @WERROR@
+XMLCATALOG = @XMLCATALOG@
 XMLLINT = @XMLLINT@
 XSLTPROC = @XSLTPROC@
 XSL_STYLE_DIR = @XSL_STYLE_DIR@
Index: libstdc++-v3/testsuite/18_support/51333.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/18_support/51333.cc b/libstdc++-v3/testsuite/18_support/51333.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/18_support/51333.cc	(revision 278653)
@@ -0,0 +1,22 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-fkeep-inline-functions" }
+// { dg-do link }
+
+#include <cxxabi.h>
+int main() { } // PR libstdc++/51333
Index: libstdc++-v3/testsuite/tr2/dynamic_bitset/cmp.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/tr2/dynamic_bitset/cmp.cc b/libstdc++-v3/testsuite/tr2/dynamic_bitset/cmp.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/tr2/dynamic_bitset/cmp.cc	(revision 278653)
@@ -0,0 +1,50 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <tr2/dynamic_bitset>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::tr2::dynamic_bitset<> a(100);
+  std::tr2::dynamic_bitset<> b = a;
+  VERIFY( a == b );
+  b.resize(99);
+  VERIFY( a != b );
+}
+
+void
+test02()
+{
+  std::tr2::dynamic_bitset<> a(100);
+  std::tr2::dynamic_bitset<> b = a;
+  VERIFY( !(a < b) );
+  VERIFY( !(b < a) );
+  b.resize(99);
+  VERIFY( !(a < b) );
+  VERIFY( b < a );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
Index: libstdc++-v3/testsuite/tr2/dynamic_bitset/cons.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/tr2/dynamic_bitset/cons.cc b/libstdc++-v3/testsuite/tr2/dynamic_bitset/cons.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/tr2/dynamic_bitset/cons.cc	(revision 278653)
@@ -0,0 +1,105 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <tr2/dynamic_bitset>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::tr2::dynamic_bitset<> a;
+  VERIFY( a.size() == 0 );
+  VERIFY( a.empty() );
+  std::tr2::dynamic_bitset<> b(1);
+  VERIFY( b.size() == 1 );
+  VERIFY( !b.empty() );
+  VERIFY( a != b );
+}
+
+void
+test02()
+{
+  std::tr2::dynamic_bitset<> a(1, 0); // { 0 }
+  std::tr2::dynamic_bitset<> b(2, 2); // { 0, 1 }
+  VERIFY( a != b );
+}
+
+void
+test03()
+{
+  std::tr2::dynamic_bitset<> a;
+  a.resize(1);                        // { 0 }
+  std::tr2::dynamic_bitset<> b(2, 2); // { 0, 1 }
+  VERIFY( a != b );
+}
+
+void
+test04()
+{
+  std::tr2::dynamic_bitset<> a(3, 2); // { 0, 1, 0 }
+  std::tr2::dynamic_bitset<> b(2, 2); // { 0, 1 }
+  VERIFY( a != b );
+}
+
+void
+test05()
+{
+  std::tr2::dynamic_bitset<unsigned short> a(1, 0); // { 0 }
+  std::tr2::dynamic_bitset<unsigned short> b(2, 2); // { 0, 1 }
+  VERIFY( a != b );
+}
+
+void
+test06()
+{
+  std::tr2::dynamic_bitset<unsigned short> a;
+  a.resize(1);                                      // { 0 }
+  std::tr2::dynamic_bitset<unsigned short> b(2, 2); // { 0, 1 }
+  VERIFY( a != b );
+}
+
+void
+test07()
+{
+  std::tr2::dynamic_bitset<unsigned short> a(3, 2); // { 0, 1, 0 }
+  std::tr2::dynamic_bitset<unsigned short> b(2, 2); // { 0, 1 }
+  VERIFY( a != b );
+}
+
+void
+test08()
+{
+  std::tr2::dynamic_bitset<> a(65, -1ULL);
+  std::tr2::dynamic_bitset<> b(64, -1ULL);
+  b.push_back(0);
+  VERIFY( a == b );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+  test03();
+  test04();
+  test05();
+  test06();
+  test07();
+  test08();
+}
Index: libstdc++-v3/testsuite/tr2/dynamic_bitset/move.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/tr2/dynamic_bitset/move.cc b/libstdc++-v3/testsuite/tr2/dynamic_bitset/move.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/tr2/dynamic_bitset/move.cc	(revision 278653)
@@ -0,0 +1,53 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <tr2/dynamic_bitset>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::tr2::dynamic_bitset<> a(100);
+  const auto n = a.num_blocks();
+  std::tr2::dynamic_bitset<> b = std::move(a);
+  VERIFY(b.num_blocks() == n);
+  VERIFY(b.size() == 100);
+  VERIFY(a.num_blocks() == 0);
+  VERIFY(a.size() == 0);
+}
+
+void
+test02()
+{
+  std::tr2::dynamic_bitset<> a(100);
+  const auto n = a.num_blocks();
+  std::tr2::dynamic_bitset<> b;
+  b = std::move(a);
+  VERIFY(b.num_blocks() == n);
+  VERIFY(b.size() == 100);
+  VERIFY(a.num_blocks() == 0);
+  VERIFY(a.size() == 0);
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
Index: libstdc++-v3/testsuite/tr2/dynamic_bitset/copy.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/tr2/dynamic_bitset/copy.cc b/libstdc++-v3/testsuite/tr2/dynamic_bitset/copy.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/tr2/dynamic_bitset/copy.cc	(revision 278653)
@@ -0,0 +1,55 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <tr2/dynamic_bitset>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::tr2::dynamic_bitset<> a(100);
+  const auto n = a.num_blocks();
+  std::tr2::dynamic_bitset<> b = a;
+  VERIFY(b.num_blocks() == n);
+  VERIFY(b.size() == 100);
+  VERIFY(a.num_blocks() == n);
+  VERIFY(a.size() == 100);
+  VERIFY(b == a);
+}
+
+void
+test02()
+{
+  std::tr2::dynamic_bitset<> a(100);
+  const auto n = a.num_blocks();
+  std::tr2::dynamic_bitset<> b;
+  b = a;
+  VERIFY(b.num_blocks() == n);
+  VERIFY(b.size() == 100);
+  VERIFY(a.num_blocks() == n);
+  VERIFY(a.size() == 100);
+  VERIFY(b == a);
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
Index: libstdc++-v3/testsuite/tr2/dynamic_bitset/pr92059.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/tr2/dynamic_bitset/pr92059.cc b/libstdc++-v3/testsuite/tr2/dynamic_bitset/pr92059.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/tr2/dynamic_bitset/pr92059.cc	(revision 278653)
@@ -0,0 +1,36 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <tr2/dynamic_bitset>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  // PR libstdc++/92059
+  std::tr2::dynamic_bitset<> b1(10000), b2(10000);
+  b2 = b1; // crashed on missing return
+  VERIFY( b2 == b1);
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/23_containers/unordered_map/48101_neg.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_map/48101_neg.cc b/libstdc++-v3/testsuite/23_containers/unordered_map/48101_neg.cc
--- a/libstdc++-v3/testsuite/23_containers/unordered_map/48101_neg.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/23_containers/unordered_map/48101_neg.cc	(revision 278653)
@@ -23,9 +23,11 @@
 test01()
 {
   using namespace std;
-  unordered_map<int, int, equal_to<int>, hash<int>> c2;  // { dg-error "here" }
+  unordered_map<int, int, equal_to<int>, hash<int>> c2;
+  c2.find(2); // { dg-error "here" }
 }
 
 // { dg-error "hash function must be invocable" "" { target *-*-* } 0 }
 // { dg-error "key equality predicate must be invocable" "" { target *-*-* } 0 }
 // { dg-prune-output "use of deleted function" }
+// { dg-prune-output "no match for call" }
Index: libstdc++-v3/testsuite/23_containers/priority_queue/dr2537.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/23_containers/priority_queue/dr2537.cc b/libstdc++-v3/testsuite/23_containers/priority_queue/dr2537.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/23_containers/priority_queue/dr2537.cc	(revision 278653)
@@ -0,0 +1,50 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <queue>
+#include <testsuite_hooks.h>
+
+struct Q : std::priority_queue<int>
+{
+  using priority_queue::priority_queue;
+
+  bool is_heap() const
+  { return std::is_heap(c.begin(), c.end()); }
+};
+
+void
+test01()
+{
+  const Q::value_compare cmp;
+  const Q::container_type c{ 2, 3, 5, 7, 11, 13, 17, 19, 23 };
+  const Q::container_type::allocator_type a;
+
+  Q q1(cmp, c, a);
+  VERIFY( q1.is_heap() );
+
+  auto c2 = c;
+  Q q2(cmp, std::move(c2), a);
+  VERIFY( q2.is_heap() );
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/23_containers/multimap/48101_neg.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/23_containers/multimap/48101_neg.cc b/libstdc++-v3/testsuite/23_containers/multimap/48101_neg.cc
--- a/libstdc++-v3/testsuite/23_containers/multimap/48101_neg.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/23_containers/multimap/48101_neg.cc	(revision 278653)
@@ -23,8 +23,14 @@
 void
 test01()
 {
-  std::multimap<int, int, std::less<int*>> c;      // { dg-error "here" }
-  std::multimap<int, int, std::allocator<int>> c2; // { dg-error "here" }
+  std::multimap<int, int, std::less<int*>> c;
+  c.find(1);  // { dg-error "here" }
+  std::multimap<int, int, std::allocator<int>> c2;
+  c2.find(2); // { dg-error "here" }
 }
 
+// { dg-error "_Compare = std::less<int.>" "" { target *-*-* } 0 }
+// { dg-error "_Compare = std::allocator<int>" "" { target *-*-* } 0 }
 // { dg-error "comparison object must be invocable" "" { target *-*-* } 0 }
+// { dg-prune-output "no match for call" }
+// { dg-prune-output "invalid conversion" }
Index: libstdc++-v3/testsuite/23_containers/set/85965.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/23_containers/set/85965.cc b/libstdc++-v3/testsuite/23_containers/set/85965.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/23_containers/set/85965.cc	(revision 278653)
@@ -0,0 +1,38 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <set>
+
+struct Base { };
+struct Derived; // derives from Base, but incomplete at this point
+
+struct Foo
+{
+  // PR libstdc++/85965
+  std::set<Derived*, std::less<Base*>> s;
+};
+
+std::size_t
+test01(std::set<Derived*, std::less<Base*>> s)
+{
+  // these operations should not require the comparison object
+  auto copy = s;
+  copy = s;
+  return s.size();
+}
Index: libstdc++-v3/testsuite/23_containers/set/48101_neg.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/23_containers/set/48101_neg.cc b/libstdc++-v3/testsuite/23_containers/set/48101_neg.cc
--- a/libstdc++-v3/testsuite/23_containers/set/48101_neg.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/23_containers/set/48101_neg.cc	(revision 278653)
@@ -23,9 +23,12 @@
 test01()
 {
   std::set<const int> c;	      // { dg-error "here" }
-  std::set<int, std::less<long*>> c2; // { dg-error "here" }
+  std::set<int, std::less<long*>> c2;
+  c2.find(2);				   // { dg-error "here" }
 }
 
 // { dg-error "non-const, non-volatile value_type" "" { target *-*-* } 0 }
 // { dg-error "comparison object must be invocable" "" { target *-*-* } 0 }
 // { dg-prune-output "std::allocator<.* has no member named " }
+// { dg-prune-output "no match for call" }
+// { dg-prune-output "invalid conversion" }
Index: libstdc++-v3/testsuite/23_containers/forward_list/operations/90105.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/23_containers/forward_list/operations/90105.cc b/libstdc++-v3/testsuite/23_containers/forward_list/operations/90105.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/23_containers/forward_list/operations/90105.cc	(revision 278653)
@@ -0,0 +1,60 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+
+#include <forward_list>
+#include <testsuite_hooks.h>
+
+// PR libstdc++/90105 - std::forward_list::sort() is not "stable"
+
+struct X
+{
+  int key;
+  int val;
+};
+
+bool operator<(const X& l, const X& r)
+{ return l.key < r.key; }
+
+bool operator==(const X& l, const X& r)
+{ return l.key == r.key && l.val == r.val; }
+
+void
+test01()
+{
+  std::forward_list<X> l{ {1, 1}, {2, 2}, {1, 3}, {0, 4}, {2, 5}, {0, 6} };
+  l.sort();
+  std::forward_list<X> exp{ {0, 4}, {0, 6}, {1, 1}, {1, 3}, {2, 2}, {2, 5} };
+  VERIFY( l == exp );
+}
+
+void
+test02()
+{
+  std::forward_list<X> l{ {1, 1}, {1, 2}, {1, 3}, {1, 4}, {1, 5}, {1, 6} };
+  const std::forward_list<X> exp = l;
+  l.sort();
+  VERIFY( l == exp );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
Index: libstdc++-v3/testsuite/23_containers/forward_list/comparable.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/23_containers/forward_list/comparable.cc b/libstdc++-v3/testsuite/23_containers/forward_list/comparable.cc
--- a/libstdc++-v3/testsuite/23_containers/forward_list/comparable.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/23_containers/forward_list/comparable.cc	(revision 278653)
@@ -17,15 +17,11 @@
 // with this library; see the file COPYING3.  If not see
 // <http://www.gnu.org/licenses/>.
 
-
-// NOTE: This makes use of the fact that we know how moveable
-// is implemented on list (via swap). If the implementation changed
-// this test may begin to fail.
-
 #include <forward_list>
 #include <testsuite_hooks.h>
 
-int main()
+void
+test01()
 {
   std::forward_list<double> a = {0.0, 1.0, 2.0, 3.0, 4.0};
   std::forward_list<double> b = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0};
@@ -43,6 +39,40 @@
   VERIFY((b >  a) == true);
   VERIFY((b >= a) == true);
   VERIFY((b <= a) == false);
+}
 
-  return 0;
+void
+test02()
+{
+  // The EqualityComparable requirements only require ==
+  struct X {
+    bool operator==(const X&) const { return true; }
+  };
+
+  std::forward_list<X> a(2);
+  const auto b = a;
+  VERIFY( a == b );
 }
+
+void
+test03()
+{
+  // The LessThanComparable requirements only require <
+  struct X {
+    bool operator<(const X&) const { return false; }
+  };
+
+  std::forward_list<X> a(2);
+  const auto b = a;
+  VERIFY( !(a < b) );
+  VERIFY( !(a > b) );
+  VERIFY( a <= b );
+  VERIFY( a >= b );
+}
+
+int main()
+{
+  test01();
+  test02();
+  test03();
+}
Index: libstdc++-v3/testsuite/23_containers/unordered_multimap/48101_neg.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_multimap/48101_neg.cc b/libstdc++-v3/testsuite/23_containers/unordered_multimap/48101_neg.cc
--- a/libstdc++-v3/testsuite/23_containers/unordered_multimap/48101_neg.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/23_containers/unordered_multimap/48101_neg.cc	(revision 278653)
@@ -23,9 +23,11 @@
 test01()
 {
   using namespace std;
-  unordered_multimap<int, int, equal_to<int>, hash<int>> c2; // { dg-error "here" }
+  unordered_multimap<int, int, equal_to<int>, hash<int>> c2;
+  c2.find(2); // { dg-error "here" }
 }
 
 // { dg-error "hash function must be invocable" "" { target *-*-* } 0 }
 // { dg-error "key equality predicate must be invocable" "" { target *-*-* } 0 }
 // { dg-prune-output "use of deleted function" }
+// { dg-prune-output "no match for call" }
Index: libstdc++-v3/testsuite/23_containers/unordered_set/85965.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_set/85965.cc b/libstdc++-v3/testsuite/23_containers/unordered_set/85965.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/23_containers/unordered_set/85965.cc	(revision 278653)
@@ -0,0 +1,38 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <unordered_set>
+
+struct Base { };
+struct Derived; // derives from Base, but incomplete at this point
+
+struct Foo
+{
+  // PR libstdc++/85965
+  std::unordered_set<Derived*, std::equal_to<Base*>, std::hash<Base*>> u;
+};
+
+std::size_t
+test01(std::unordered_set<Derived*, std::equal_to<Base*>, std::hash<Base*>> s)
+{
+  // these operations should not require the comparison object
+  auto copy = s;
+  copy = s;
+  return s.size();
+}
Index: libstdc++-v3/testsuite/23_containers/unordered_set/48101_neg.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_set/48101_neg.cc b/libstdc++-v3/testsuite/23_containers/unordered_set/48101_neg.cc
--- a/libstdc++-v3/testsuite/23_containers/unordered_set/48101_neg.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/23_containers/unordered_set/48101_neg.cc	(revision 278653)
@@ -24,7 +24,8 @@
 {
   using namespace std;
   unordered_set<const int, hash<int>> c;	    // { dg-error "here" }
-  unordered_set<int, equal_to<int>, hash<int>> c2;  // { dg-error "here" }
+  unordered_set<int, equal_to<int>, hash<int>> c2;
+  c2.find(2);					    // { dg-error "here" }
 }
 
 // { dg-error "non-const, non-volatile value_type" "" { target *-*-* } 0 }
@@ -31,3 +32,4 @@
 // { dg-error "hash function must be invocable" "" { target *-*-* } 0 }
 // { dg-error "key equality predicate must be invocable" "" { target *-*-* } 0 }
 // { dg-prune-output "use of deleted function" }
+// { dg-prune-output "no match for call" }
Index: libstdc++-v3/testsuite/23_containers/multiset/48101_neg.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/23_containers/multiset/48101_neg.cc b/libstdc++-v3/testsuite/23_containers/multiset/48101_neg.cc
--- a/libstdc++-v3/testsuite/23_containers/multiset/48101_neg.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/23_containers/multiset/48101_neg.cc	(revision 278653)
@@ -23,9 +23,12 @@
 test01()
 {
   std::multiset<const int> c;		   // { dg-error "here" }
-  std::multiset<int, std::less<long*>> c2; // { dg-error "here" }
+  std::multiset<int, std::less<long*>> c2;
+  c2.find(2);				   // { dg-error "here" }
 }
 
 // { dg-error "non-const, non-volatile value_type" "" { target *-*-* } 0 }
 // { dg-error "comparison object must be invocable" "" { target *-*-* } 0 }
 // { dg-prune-output "std::allocator<.* has no member named " }
+// { dg-prune-output "no match for call" }
+// { dg-prune-output "invalid conversion" }
Index: libstdc++-v3/testsuite/23_containers/unordered_multiset/48101_neg.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/23_containers/unordered_multiset/48101_neg.cc b/libstdc++-v3/testsuite/23_containers/unordered_multiset/48101_neg.cc
--- a/libstdc++-v3/testsuite/23_containers/unordered_multiset/48101_neg.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/23_containers/unordered_multiset/48101_neg.cc	(revision 278653)
@@ -24,7 +24,8 @@
 {
   using namespace std;
   unordered_multiset<const int, hash<int>> c;		// { dg-error "here" }
-  unordered_multiset<int, equal_to<int>, hash<int>> c2; // { dg-error "here" }
+  unordered_multiset<int, equal_to<int>, hash<int>> c2;
+  c2.find(2);					    // { dg-error "here" }
 }
 
 // { dg-error "non-const, non-volatile value_type" "" { target *-*-* } 0 }
@@ -31,3 +32,4 @@
 // { dg-error "hash function must be invocable" "" { target *-*-* } 0 }
 // { dg-error "key equality predicate must be invocable" "" { target *-*-* } 0 }
 // { dg-prune-output "use of deleted function" }
+// { dg-prune-output "no match for call" }
Index: libstdc++-v3/testsuite/23_containers/map/48101_neg.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/23_containers/map/48101_neg.cc b/libstdc++-v3/testsuite/23_containers/map/48101_neg.cc
--- a/libstdc++-v3/testsuite/23_containers/map/48101_neg.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/23_containers/map/48101_neg.cc	(revision 278653)
@@ -23,8 +23,14 @@
 void
 test01()
 {
-  std::map<int, int, std::less<int*>> c;      // { dg-error "here" }
-  std::map<int, int, std::allocator<int>> c2; // { dg-error "here" }
+  std::map<int, int, std::less<int*>> c;
+  c.find(1);  // { dg-error "here" }
+  std::map<int, int, std::allocator<int>> c2;
+  c2.find(2); // { dg-error "here" }
 }
 
+// { dg-error "_Compare = std::less<int.>" "" { target *-*-* } 0 }
+// { dg-error "_Compare = std::allocator<int>" "" { target *-*-* } 0 }
 // { dg-error "comparison object must be invocable" "" { target *-*-* } 0 }
+// { dg-prune-output "no match for call" }
+// { dg-prune-output "invalid conversion" }
Index: libstdc++-v3/testsuite/27_io/filesystem/operations/absolute.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/operations/absolute.cc b/libstdc++-v3/testsuite/27_io/filesystem/operations/absolute.cc
--- a/libstdc++-v3/testsuite/27_io/filesystem/operations/absolute.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/27_io/filesystem/operations/absolute.cc	(revision 278653)
@@ -50,9 +50,37 @@
   VERIFY( absolute(p3) == (std::filesystem::current_path()/p3) );
 }
 
+void
+test03()
+{
+  // PR libstdc++/90299
+  const path p = __gnu_test::nonexistent_path();
+  std::error_code ec;
+  const path pabs = absolute(p, ec);
+  VERIFY( !ec );
+  VERIFY( pabs.is_absolute() );
+
+  const path pabs2 = absolute(p);
+  VERIFY( pabs2 == pabs );
+
+  const path eabs = absolute(path{}, ec);
+  VERIFY( ec == std::errc::invalid_argument );
+  VERIFY( eabs.empty() );
+
+  try {
+    absolute(path{});
+    VERIFY( false );
+  } catch (const std::filesystem::filesystem_error& e) {
+    VERIFY( e.code() == std::errc::invalid_argument );
+    VERIFY( e.path1().empty() );
+    VERIFY( e.path2().empty() );
+  }
+}
+
 int
 main()
 {
   test01();
   test02();
+  test03();
 }
Index: libstdc++-v3/testsuite/27_io/filesystem/iterators/caching.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/iterators/caching.cc b/libstdc++-v3/testsuite/27_io/filesystem/iterators/caching.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/27_io/filesystem/iterators/caching.cc	(revision 278653)
@@ -0,0 +1,76 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17 -lstdc++fs" }
+// { dg-do run { target c++17 } }
+// { dg-require-filesystem-ts "" }
+
+#include <filesystem>
+#include <testsuite_fs.h>
+#include <testsuite_hooks.h>
+
+namespace fs = std::filesystem;
+
+__gnu_test::scoped_file
+create_dir(fs::path dir = __gnu_test::nonexistent_path())
+{
+  fs::create_directory(dir);
+  return { dir, __gnu_test::scoped_file::adopt_file };
+}
+
+void
+test01()
+{
+  auto testdir = create_dir();
+  __gnu_test::scoped_file file1(testdir.path/"file1");
+  __gnu_test::scoped_file file2(testdir.path/"file2");
+
+  fs::directory_iterator it(testdir.path);
+  VERIFY( it->is_regular_file() );
+  ++it;
+  VERIFY( it->is_regular_file() );
+  ++it;
+  VERIFY( it == fs::directory_iterator{} );
+}
+
+void
+test02()
+{
+  auto testdir = create_dir();
+  const auto sub1 = create_dir(testdir.path/"sub1");
+  __gnu_test::scoped_file file1(sub1.path / "file");
+  const auto sub2 = create_dir(testdir.path/"sub2");
+  __gnu_test::scoped_file file2(sub2.path / "file");
+
+  fs::recursive_directory_iterator it(testdir.path);
+  VERIFY( it->is_directory() );
+  ++it;
+  VERIFY( it->is_regular_file() );
+  ++it;
+  VERIFY( it->is_directory() );
+  ++it;
+  VERIFY( it->is_regular_file() );
+  ++it;
+  VERIFY( it == fs::recursive_directory_iterator{} );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
Index: libstdc++-v3/testsuite/27_io/filesystem/path/assign/copy.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/assign/copy.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/assign/copy.cc
--- a/libstdc++-v3/testsuite/27_io/filesystem/path/assign/copy.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/assign/copy.cc	(revision 278653)
@@ -21,6 +21,7 @@
 
 #include <filesystem>
 #include <testsuite_fs.h>
+#include <testsuite_hooks.h>
 
 using std::filesystem::path;
 using __gnu_test::compare_paths;
@@ -48,9 +49,26 @@
   }
 }
 
+void
+test03()
+{
+  // self assignment should have no effect
+  const path orig = "foo/bar/baz";
+  path p = orig;
+  const auto ptr1 = p.c_str();
+  const auto ptr2 = p.begin()->c_str();
+  p = std::move(p);
+  __gnu_test::compare_paths(p, orig);
+  p = p;
+  __gnu_test::compare_paths(p, orig);
+  VERIFY( ptr1 == p.c_str() );
+  VERIFY( ptr2 == p.begin()->c_str() );
+}
+
 int
 main()
 {
   test01();
   test02();
+  test03();
 }
Index: libstdc++-v3/testsuite/27_io/filesystem/path/construct/90634.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/construct/90634.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/construct/90634.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/construct/90634.cc	(revision 278653)
@@ -0,0 +1,70 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17 -lstdc++fs" }
+// { dg-do run { target c++17 } }
+// { dg-require-filesystem-ts "" }
+
+#include <filesystem>
+#include <cstdlib>
+#include <testsuite_hooks.h>
+
+std::size_t bytes_allocated = 0;
+
+void* operator new(std::size_t n)
+{
+  bytes_allocated += n;
+  return std::malloc(n);
+}
+
+void operator delete(void* p) noexcept { std::free(p); }
+#if __cpp_sized_deallocation
+void operator delete(void* p, std::size_t) noexcept { std::free(p); }
+#endif
+
+void
+test01()
+{
+  std::string s0;
+  std::string s1 = "/";
+  std::string s2 = "///";
+  std::string s3 = "filename";
+  std::string s4 = "C:";
+  std::string s5 = "\\";
+
+  using std::filesystem::path;
+
+  bytes_allocated = 0;
+  path p0 = std::move(s0);
+  VERIFY( bytes_allocated == 0 );
+  path p1 = std::move(s1);
+  VERIFY( bytes_allocated == 0 );
+  path p2 = std::move(s2);
+  VERIFY( bytes_allocated == 0 );
+  path p3 = std::move(s3);
+  VERIFY( bytes_allocated == 0 );
+  path p4 = std::move(s4);
+  VERIFY( bytes_allocated == 0 );
+  path p5 = std::move(s5);
+  VERIFY( bytes_allocated == 0 );
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/27_io/filesystem/path/construct/80762.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/construct/80762.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/construct/80762.cc
--- a/libstdc++-v3/testsuite/27_io/filesystem/path/construct/80762.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/construct/80762.cc	(revision 278653)
@@ -22,8 +22,18 @@
 
 using std::filesystem::path;
 
+// PR libstdc++/80762.cc
 static_assert( !std::is_constructible_v<path, void> );
 static_assert( !std::is_constructible_v<path, volatile path> );
 static_assert( !std::is_constructible_v<path, volatile path&> );
 static_assert( !std::is_constructible_v<path, const volatile path> );
 static_assert( !std::is_constructible_v<path, const volatile path&> );
+
+// PR libstdc++/90454.cc
+static_assert( !std::is_constructible_v<path, void*> );
+static_assert( !std::is_constructible_v<path, const void*> );
+static_assert( !std::is_constructible_v<path, volatile void*> );
+static_assert( !std::is_constructible_v<path, const volatile void*> );
+static_assert( !std::is_constructible_v<path, void*&> );
+static_assert( !std::is_constructible_v<path, void* const&> );
+static_assert( !std::is_constructible_v<path, const void* const&> );
Index: libstdc++-v3/testsuite/27_io/filesystem/path/decompose/root_path.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/27_io/filesystem/path/decompose/root_path.cc b/libstdc++-v3/testsuite/27_io/filesystem/path/decompose/root_path.cc
--- a/libstdc++-v3/testsuite/27_io/filesystem/path/decompose/root_path.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/27_io/filesystem/path/decompose/root_path.cc	(revision 278653)
@@ -36,10 +36,6 @@
   VERIFY( p2.root_path() == path("/") );
 }
 
-#undef VERIFY
-#define VERIFY(X) do { if (!(X)) { __builtin_puts("FAIL: " #X); } } while(false)
-#define DUMP(X, Y, Z) do { if (!(Y == Z)) { __builtin_printf("%s %s %s\n", X.c_str(), Y.c_str(), Z.c_str()); } } while(false)
-
 void
 test02()
 {
@@ -49,7 +45,6 @@
     path rootn = p.root_name();
     path rootd = p.root_directory();
     VERIFY( rootp == (rootn / rootd) );
-    DUMP(p,  rootp , (rootn / rootd) );
   }
 }
 
Index: libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/89446.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/89446.cc b/libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/89446.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/21_strings/basic_string_view/operators/char/89446.cc	(revision 278653)
@@ -0,0 +1,28 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17 -fexceptions -fnon-call-exceptions -O1" }
+// { dg-do run { target { powerpc*-*-linux* i?86-*-linux* x86_64-*-linux* } } }
+// { dg-require-effective-target c++17 }
+
+#include <string_view>
+
+int main()
+{
+  std::string_view s1, s2;
+  return s1 != s2;
+}
Index: libstdc++-v3/testsuite/26_numerics/headers/cmath/hypot.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/26_numerics/headers/cmath/hypot.cc b/libstdc++-v3/testsuite/26_numerics/headers/cmath/hypot.cc
--- a/libstdc++-v3/testsuite/26_numerics/headers/cmath/hypot.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/26_numerics/headers/cmath/hypot.cc	(revision 278653)
@@ -1,4 +1,4 @@
-// Copyright (C) 2016-2018 Free Software Foundation, Inc.
+// Copyright (C) 2016-2019 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -17,7 +17,6 @@
 
 // { dg-options "-std=gnu++17" }
 // { dg-do run { target c++17 } }
-// { dg-xfail-run-if "AIX long double" { powerpc-ibm-aix* } }
 
 #include <cmath>
 #include <type_traits>
@@ -128,7 +127,10 @@
 {
   test(data1, toler1);
   test(data2, toler2);
-  test(data3, toler3);
+  if (sizeof(long double) > sizeof(double))
+    test(data3, toler3);
+  else
+    test(data3, (long double)toler1);
 }
 
 int
Index: libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc b/libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc
--- a/libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/experimental/any/misc/any_cast.cc	(revision 278653)
@@ -24,6 +24,7 @@
 
 using std::experimental::any;
 using std::experimental::any_cast;
+using std::experimental::bad_any_cast;
 
 void test01()
 {
@@ -56,7 +57,6 @@
 
 void test02()
 {
-  using std::experimental::bad_any_cast;
   any x(1);
   auto p = any_cast<double>(&x);
   VERIFY(p == nullptr);
@@ -105,7 +105,7 @@
   MoveDeleted&& md3 = any_cast<MoveDeleted&&>(any(std::move(md)));
 }
 
-void test04()
+void test05()
 {
   // PR libstdc++/69321
   struct noncopyable {
@@ -117,10 +117,60 @@
   VERIFY( p == nullptr );
 }
 
+void test06()
+{
+  // The contained value of a std::any is always an object type,
+  // but any_cast does not forbid checking for function types.
+
+  any a(1);
+  void (*p1)() = any_cast<void()>(&a);
+  VERIFY( p1 == nullptr );
+  int (*p2)(int) = any_cast<int(int)>(&a);
+  VERIFY( p2 == nullptr );
+  int (*p3)() = any_cast<int()>(&const_cast<const any&>(a));
+  VERIFY( p3 == nullptr );
+
+  try {
+    any_cast<int(&)()>(a);
+    VERIFY( false );
+  } catch (const bad_any_cast&) {
+  }
+
+  try {
+    any_cast<int(&)()>(std::move(a));
+    VERIFY( false );
+  } catch (const bad_any_cast&) {
+  }
+
+  try {
+    any_cast<int(&)()>(const_cast<const any&>(a));
+    VERIFY( false );
+  } catch (const bad_any_cast&) {
+  }
+}
+
+void test07()
+{
+  int arr[3];
+  any a(arr);
+  VERIFY( a.type() == typeid(int*) );	// contained value is decayed
+
+  int (*p1)[3] = any_cast<int[3]>(&a);
+  VERIFY( a.type() != typeid(int[3]) ); // so any_cast should return nullptr
+  VERIFY( p1 == nullptr );
+  int (*p2)[] = any_cast<int[]>(&a);
+  VERIFY( a.type() != typeid(int[]) );	// so any_cast should return nullptr
+  VERIFY( p2 == nullptr );
+  const int (*p3)[] = any_cast<int[]>(&const_cast<const any&>(a));
+  VERIFY( p3 == nullptr );
+}
+
 int main()
 {
   test01();
   test02();
   test03();
-  test04();
+  test05();
+  test06();
+  test07();
 }
Index: libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc b/libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc
--- a/libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/experimental/any/misc/any_cast_neg.cc	(revision 278653)
@@ -25,5 +25,5 @@
   using std::experimental::any_cast;
 
   const any y(1);
-  any_cast<int&>(y); // { dg-error "qualifiers" "" { target { *-*-* } } 357 }
+  any_cast<int&>(y); // { dg-error "qualifiers" "" { target { *-*-* } } 0 }
 }
Index: libstdc++-v3/testsuite/experimental/filesystem/path/construct/90634.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/path/construct/90634.cc b/libstdc++-v3/testsuite/experimental/filesystem/path/construct/90634.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/experimental/filesystem/path/construct/90634.cc	(revision 278653)
@@ -0,0 +1,67 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-DUSE_FILESYSTEM_TS -lstdc++fs" }
+// { dg-do run { target c++11 } }
+// { dg-require-filesystem-ts "" }
+
+#include <experimental/filesystem>
+#include <cstdlib>
+#include <testsuite_hooks.h>
+
+std::size_t bytes_allocated = 0;
+
+void* operator new(std::size_t n)
+{
+  bytes_allocated += n;
+  return std::malloc(n);
+}
+
+void operator delete(void* p) noexcept { std::free(p); }
+#if __cpp_sized_deallocation
+void operator delete(void* p, std::size_t) noexcept { std::free(p); }
+#endif
+
+void
+test01()
+{
+  std::string s0;
+  std::string s1 = "/";
+  std::string s2 = "filename";
+  std::string s3 = "C:";
+  std::string s4 = "\\";
+
+  using std::experimental::filesystem::path;
+
+  bytes_allocated = 0;
+  path p0 = std::move(s0);
+  VERIFY( bytes_allocated == 0 );
+  path p1 = std::move(s1);
+  VERIFY( bytes_allocated == 0 );
+  path p2 = std::move(s2);
+  VERIFY( bytes_allocated == 0 );
+  path p3 = std::move(s3);
+  VERIFY( bytes_allocated == 0 );
+  path p4 = std::move(s4);
+  VERIFY( bytes_allocated == 0 );
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/experimental/filesystem/path/construct/80762.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/path/construct/80762.cc b/libstdc++-v3/testsuite/experimental/filesystem/path/construct/80762.cc
--- a/libstdc++-v3/testsuite/experimental/filesystem/path/construct/80762.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/experimental/filesystem/path/construct/80762.cc	(revision 278653)
@@ -22,8 +22,18 @@
 
 using std::experimental::filesystem::path;
 
+// PR libstdc++/80762.cc
 static_assert( !std::is_constructible<path, void>::value, "" );
 static_assert( !std::is_constructible<path, volatile path>::value, "" );
 static_assert( !std::is_constructible<path, volatile path&>::value, "" );
 static_assert( !std::is_constructible<path, const volatile path>::value, "" );
 static_assert( !std::is_constructible<path, const volatile path&>::value, "" );
+
+// PR libstdc++/90454.cc
+static_assert( !std::is_constructible<path, void*>::value, "" );
+static_assert( !std::is_constructible<path, const void*>::value, "" );
+static_assert( !std::is_constructible<path, volatile void*>::value, "" );
+static_assert( !std::is_constructible<path, const volatile void*>::value, "" );
+static_assert( !std::is_constructible<path, void*&>::value, "" );
+static_assert( !std::is_constructible<path, void* const&>::value, "" );
+static_assert( !std::is_constructible<path, const void* const&>::value, "" );
Index: libstdc++-v3/testsuite/experimental/names.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/experimental/names.cc b/libstdc++-v3/testsuite/experimental/names.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/experimental/names.cc	(revision 278653)
@@ -0,0 +1,62 @@
+// Copyright (C) 2017-2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+// Define macros for some common variables names that we must not use for
+// naming variables, parameters etc. in the library.
+
+#include "../17_intro/names.cc"
+// Filesystem
+#if __has_include(<experimental/filesystem>)
+# include <experimental/filesystem>
+#endif
+
+#if __cplusplus >= 201402L
+
+// Library Fundamentals
+#include <experimental/algorithm>
+#include <experimental/any>
+#include <experimental/array>
+#include <experimental/chrono>
+#include <experimental/deque>
+#include <experimental/forward_list>
+#include <experimental/functional>
+#include <experimental/iterator>
+#include <experimental/list>
+#include <experimental/map>
+#include <experimental/memory>
+#include <experimental/memory_resource>
+#include <experimental/numeric>
+#include <experimental/optional>
+#include <experimental/propagate_const>
+#include <experimental/random>
+#include <experimental/ratio>
+#include <experimental/regex>
+#include <experimental/set>
+#include <experimental/source_location>
+#include <experimental/string>
+#include <experimental/string_view>
+#include <experimental/system_error>
+#include <experimental/tuple>
+#include <experimental/type_traits>
+#include <experimental/unordered_map>
+#include <experimental/unordered_set>
+#include <experimental/utility>
+#include <experimental/vector>
+
+#endif // C++14
Index: libstdc++-v3/testsuite/17_intro/names.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/17_intro/names.cc b/libstdc++-v3/testsuite/17_intro/names.cc
--- a/libstdc++-v3/testsuite/17_intro/names.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/17_intro/names.cc	(revision 278653)
@@ -19,7 +19,6 @@
 
 // Define macros for some common variables names that we must not use for
 // naming variables, parameters etc. in the library.
-#define tmp (
 #define A (
 #define B (
 #define C (
@@ -99,6 +98,82 @@
 #define y (
 #define z (
 
+#define tmp (
+
+#if __cplusplus < 201103L
+#define uses_allocator  (
+#endif
+
+#if __cplusplus < 201703L
+// <charconv> defines to_chars_result::ptr and to_chars_result::ec
+#define ec (
+#define ptr (
+#endif
+
+// Common template parameter names
+#define OutputIterator		OutputIterator is not a reserved name
+#define InputIterator		InputIterator is not a reserved name
+#define ForwardIterator		ForwardIterator is not a reserved name
+#define BidirectionalIterator	BidirectionalIterator is not a reserved name
+#define RandomAccessIterator	RandomAccessIterator is not a reserved name
+#define RandomAccessOutputIterator	RandomAccessOutputIterator is not a reserved name
+#define RAIter			RAIter is not a reserved name
+#define FwdIter			FwdIter is not a reserved name
+#define OutIter			OutIter is not a reserved name
+#define InIter			InIter is not a reserved name
+
+#define Alloc			Alloc is not a reserved name
+#define BinaryFunction1		BinaryFunction1 is not a reserved name
+#define BinaryFunction2		BinaryFunction2 is not a reserved name
+#define Char			Char is not a reserved name
+#define CharT			CharT is not a reserved name
+#define Cmp			Cmp is not a reserved name
+#define Compare			Compare is not a reserved name
+#define Const_Iterator		Const_Iterator is not a reserved name
+#define Const_Key_Reference	Const_Key_Reference is not a reserved name
+#define Const_Node_Iter		Const_Node_Iter is not a reserved name
+#define Const_Pointer		Const_Pointer is not a reserved name
+#define Const_Reference		Const_Reference is not a reserved name
+#define Data			Data is not a reserved name
+#define DiffType		DiffType is not a reserved name
+#define Eq			Eq is not a reserved name
+#define ExecPolicy		ExecPolicy is not a reserved name
+#define Expected		Expected is not a reserved name
+#define External_Load_Access	External_Load_Access is not a reserved name
+#define External_Size_Access	External_Size_Access is not a reserved name
+#define Fn			Fn is not a reserved name
+#define Function		Function is not a reserved name
+#define Functor			Functor is not a reserved name
+#define Hash			Hash is not a reserved name
+#define H1			H1 is not a reserved name
+#define H2			H2 is not a reserved name
+#define Head			Head is not a reserved name
+#define It			It is not a reserved name
+#define Iter			Iter is not a reserved name
+#define Iterator		Iterator is not a reserved name
+#define Key			Key is not a reserved name
+#define Mapped			Mapped is not a reserved name
+#define Node			Node is not a reserved name
+#define Node_iter		Node_iter is not a reserved name
+#define Node_ptr		Node_ptr is not a reserved name
+#define Overflow		Overflow is not a reserved name
+#define Pointer			Pointer is not a reserved name
+#define Policy			Policy is not a reserved name
+#define Pred			Pred is not a reserved name
+#define Ptr			Ptr is not a reserved name
+#define Reference		Reference is not a reserved name
+#define Seq			Seq is not a reserved name
+#define Seq_RAIter		Seq_RAIter is not a reserved name
+#define Series			Series is not a reserved name
+#define Set			Set is not a reserved name
+#define String			String is not a reserved name
+#define Tp			Tp is not a reserved name
+#define Traits			Traits is not a reserved name
+#define Type			Type is not a reserved name
+#define Value			Value is not a reserved name
+#define ValueT			ValueT is not a reserved name
+#define ValueType		ValueType is not a reserved name
+
 #ifdef _AIX
 // See https://gcc.gnu.org/ml/libstdc++/2017-03/msg00015.html
 #undef f
@@ -116,4 +191,9 @@
 #undef y
 #endif
 
+#ifdef __sun__
+// See https://gcc.gnu.org/ml/libstdc++/2019-05/msg00175.html
+#undef ptr
+#endif
+
 #include <bits/stdc++.h>
Index: libstdc++-v3/testsuite/util/thread/all.h
===================================================================
diff --git a/libstdc++-v3/testsuite/util/thread/all.h b/libstdc++-v3/testsuite/util/thread/all.h
--- a/libstdc++-v3/testsuite/util/thread/all.h	(revision 278653)
+++ b/libstdc++-v3/testsuite/util/thread/all.h	(revision 278653)
@@ -25,6 +25,7 @@
 #include <sstream>
 #include <stdexcept>
 #include <type_traits>
+#include <thread>
 
 // C++11 only.
 namespace __gnu_test
@@ -39,7 +40,12 @@
 
       // Remove possible pointer type.
       typedef typename test_type::native_handle_type native_handle;
-      typedef typename std::remove_pointer<native_handle>::type native_type;
+      // For std::thread native_handle_type is the type of its data member,
+      // for other types it's a pointer to the type of the data member.
+      typedef typename std::conditional<
+	std::is_same<test_type, std::thread>::value,
+	native_handle,
+	typename std::remove_pointer<native_handle>::type>::type native_type;
 
       int st = sizeof(test_type);
       int snt = sizeof(native_type);
Index: libstdc++-v3/testsuite/util/testsuite_hooks.h
===================================================================
diff --git a/libstdc++-v3/testsuite/util/testsuite_hooks.h b/libstdc++-v3/testsuite/util/testsuite_hooks.h
--- a/libstdc++-v3/testsuite/util/testsuite_hooks.h	(revision 278653)
+++ b/libstdc++-v3/testsuite/util/testsuite_hooks.h	(revision 278653)
@@ -46,18 +46,25 @@
 #include <bits/c++config.h>
 #include <bits/functexcept.h>
 #include <ctime>
+#include <stdio.h>
 
 #ifdef _GLIBCXX_HAVE_SYS_STAT_H
 #include <sys/stat.h>
 #endif
 
+#ifdef stderr
+# define _VERIFY_PRINT(S, F, L, P, C) __builtin_fprintf(stderr, S, F, L, P, C)
+#else
+# define _VERIFY_PRINT(S, F, L, P, C) __builtin_printf(S, F, L, P, C)
+#endif
+
 #define VERIFY(fn)                                                      \
   do                                                                    \
   {                                                                     \
     if (! (fn))								\
       {									\
-	__builtin_printf("%s:%d: %s: Assertion '%s' failed.\n",		\
-			 __FILE__, __LINE__, __PRETTY_FUNCTION__, #fn); \
+	_VERIFY_PRINT("%s:%d: %s: Assertion '%s' failed.\n",		\
+		      __FILE__, __LINE__, __PRETTY_FUNCTION__, #fn);	\
 	__builtin_abort();						\
       }									\
   } while (false)
Index: libstdc++-v3/testsuite/20_util/scoped_allocator/69293_neg.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/scoped_allocator/69293_neg.cc b/libstdc++-v3/testsuite/20_util/scoped_allocator/69293_neg.cc
--- a/libstdc++-v3/testsuite/20_util/scoped_allocator/69293_neg.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/20_util/scoped_allocator/69293_neg.cc	(revision 278653)
@@ -46,5 +46,5 @@
   scoped_alloc sa;
   auto p = sa.allocate(1);
   sa.construct(p);  // this is required to be ill-formed
-  // { dg-error "static assertion failed" "" { target *-*-* } 90 }
+  // { dg-error "failed: .* uses_allocator is true" "" { target *-*-* } 0 }
 }
Index: libstdc++-v3/testsuite/20_util/scoped_allocator/dr2586.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/scoped_allocator/dr2586.cc b/libstdc++-v3/testsuite/20_util/scoped_allocator/dr2586.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/20_util/scoped_allocator/dr2586.cc	(revision 278653)
@@ -0,0 +1,34 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <memory>
+#include <scoped_allocator>
+
+// DR 2586. Wrong value category used in scoped_allocator_adaptor::construct()
+
+struct X {
+  using allocator_type = std::allocator<X>;
+  X(std::allocator_arg_t, allocator_type&&) { }
+  X(const allocator_type&) { }
+};
+
+int main() {
+  std::scoped_allocator_adaptor<std::allocator<X>> sa;
+  sa.construct(sa.allocate(1));
+}
Index: libstdc++-v3/testsuite/20_util/hash/89629.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/hash/89629.cc b/libstdc++-v3/testsuite/20_util/hash/89629.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/20_util/hash/89629.cc	(revision 278653)
@@ -0,0 +1,43 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target { lp64 || llp64 } } }
+// { dg-require-effective-target c++11 }
+// { dg-require-effective-target run_expensive_tests }
+
+#include <functional>
+#include <string>
+
+void
+test01()
+{
+  const std::size_t big = std::size_t(1) << 31;
+  std::string s;
+  try {
+    s.resize(big, 'a');
+  } catch (const std::bad_alloc&) {
+    return; // try to avoid a FAIL if memory allocation fails
+  }
+  // PR libstdc++/89629
+  (void) std::hash<std::string>{}(s);
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/20_util/any/misc/any_cast.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/any/misc/any_cast.cc b/libstdc++-v3/testsuite/20_util/any/misc/any_cast.cc
--- a/libstdc++-v3/testsuite/20_util/any/misc/any_cast.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/20_util/any/misc/any_cast.cc	(revision 278653)
@@ -20,6 +20,7 @@
 
 #include <any>
 #include <string>
+#include <utility>
 #include <cstring>
 #include <testsuite_hooks.h>
 
@@ -121,6 +122,54 @@
   VERIFY( p == nullptr );
 }
 
+void test06()
+{
+  // The contained value of a std::any is always an object type,
+  // but std::any_cast does not forbid checking for function types.
+
+  any a(1);
+  void (*p1)() = any_cast<void()>(&a);
+  VERIFY( p1 == nullptr );
+  int (*p2)(int) = any_cast<int(int)>(&a);
+  VERIFY( p2 == nullptr );
+  int (*p3)() = any_cast<int()>(&std::as_const(a));
+  VERIFY( p3 == nullptr );
+
+  try {
+    any_cast<int(&)()>(a);
+    VERIFY( false );
+  } catch (const std::bad_any_cast&) {
+  }
+
+  try {
+    any_cast<int(&)()>(std::move(a));
+    VERIFY( false );
+  } catch (const std::bad_any_cast&) {
+  }
+
+  try {
+    any_cast<int(&)()>(std::as_const(a));
+    VERIFY( false );
+  } catch (const std::bad_any_cast&) {
+  }
+}
+
+void test07()
+{
+  int arr[3];
+  any a(arr);
+  VERIFY( a.type() == typeid(int*) );	// contained value is decayed
+
+  int (*p1)[3] = any_cast<int[3]>(&a);
+  VERIFY( a.type() != typeid(int[3]) ); // so any_cast should return nullptr
+  VERIFY( p1 == nullptr );
+  int (*p2)[] = any_cast<int[]>(&a);
+  VERIFY( a.type() != typeid(int[]) );	// so any_cast should return nullptr
+  VERIFY( p2 == nullptr );
+  const int (*p3)[] = any_cast<int[]>(&std::as_const(a));
+  VERIFY( p3 == nullptr );
+}
+
 int main()
 {
   test01();
@@ -128,4 +177,6 @@
   test03();
   test04();
   test05();
+  test06();
+  test07();
 }
Index: libstdc++-v3/testsuite/20_util/unique_ptr/cons/cv_qual_neg.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/unique_ptr/cons/cv_qual_neg.cc b/libstdc++-v3/testsuite/20_util/unique_ptr/cons/cv_qual_neg.cc
--- a/libstdc++-v3/testsuite/20_util/unique_ptr/cons/cv_qual_neg.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/20_util/unique_ptr/cons/cv_qual_neg.cc	(revision 278653)
@@ -39,7 +39,7 @@
   std::unique_ptr<const A[]> cA3(p); // { dg-error "no matching function" }
   std::unique_ptr<volatile A[]> vA3(p); // { dg-error "no matching function" }
   std::unique_ptr<const volatile A[]> cvA3(p); // { dg-error "no matching function" }
-  // { dg-error "no type" "" { target *-*-* } 473 }
+  // { dg-prune-output "no type" }
 }
 
 template<typename T>
Index: libstdc++-v3/testsuite/20_util/unique_ptr/assign/48635_neg.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/unique_ptr/assign/48635_neg.cc b/libstdc++-v3/testsuite/20_util/unique_ptr/assign/48635_neg.cc
--- a/libstdc++-v3/testsuite/20_util/unique_ptr/assign/48635_neg.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/20_util/unique_ptr/assign/48635_neg.cc	(revision 278653)
@@ -42,10 +42,9 @@
   std::unique_ptr<int, D&> ud(nullptr, d);
   ub = std::move(ud); // { dg-error "no match" }
   ub2 = ud; // { dg-error "no match" }
-// { dg-error "no type" "" { target *-*-* } 307 }
 
   std::unique_ptr<int[], B&> uba(nullptr, b);
   std::unique_ptr<int[], D&> uda(nullptr, d);
   uba = std::move(uda); // { dg-error "no match" }
-// { dg-error "no type" "" { target *-*-* } 566 }
 }
+// { dg-prune-output "no type" }
Index: libstdc++-v3/testsuite/20_util/unique_ptr/assign/91308.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/unique_ptr/assign/91308.cc b/libstdc++-v3/testsuite/20_util/unique_ptr/assign/91308.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/20_util/unique_ptr/assign/91308.cc	(revision 278653)
@@ -0,0 +1,46 @@
+// Copyright (C) 2019 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++11 } }
+
+#include <memory>
+
+struct D1
+{
+  void operator()(int* p) const noexcept { }
+};
+
+struct D2 : D1
+{
+  D2& operator=(D1&&) noexcept { return *this; }
+};
+
+void
+test01()
+{
+  std::unique_ptr<int, D1> d1;
+  std::unique_ptr<int, D2> d2;
+  d2 = std::move(d1);
+}
+
+void
+test02()
+{
+  std::unique_ptr<int[], D1> d1;
+  std::unique_ptr<int[], D2> d2;
+  d2 = std::move(d1);
+}
Index: libstdc++-v3/testsuite/20_util/variant/compile.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/variant/compile.cc b/libstdc++-v3/testsuite/20_util/variant/compile.cc
--- a/libstdc++-v3/testsuite/20_util/variant/compile.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/20_util/variant/compile.cc	(revision 278653)
@@ -129,10 +129,15 @@
   static_assert(noexcept(variant<int, DefaultNoexcept>(DefaultNoexcept{})), "");
 }
 
+struct none { none() = delete; };
+struct any { template <typename T> any(T&&) {} };
+
 void in_place_index_ctor()
 {
   variant<string, string> a(in_place_index<0>, "a");
   variant<string, string> b(in_place_index<1>, {'a'});
+
+  static_assert(!is_constructible_v<variant<none, any>, std::in_place_index_t<0>>, "PR libstdc++/90165");
 }
 
 void in_place_type_ctor()
@@ -140,6 +145,7 @@
   variant<int, string, int> a(in_place_type<string>, "a");
   variant<int, string, int> b(in_place_type<string>, {'a'});
   static_assert(!is_constructible_v<variant<string, string>, in_place_type_t<string>, const char*>, "");
+  static_assert(!is_constructible_v<variant<none, any>, std::in_place_type_t<none>>, "PR libstdc++/90165");
 }
 
 void dtor()
Index: libstdc++-v3/testsuite/20_util/tuple/cons/allocators.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/tuple/cons/allocators.cc b/libstdc++-v3/testsuite/20_util/tuple/cons/allocators.cc
--- a/libstdc++-v3/testsuite/20_util/tuple/cons/allocators.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/20_util/tuple/cons/allocators.cc	(revision 278653)
@@ -181,9 +181,23 @@
   test_type empty = make_tuple();
 }
 
+void test03()
+{
+  struct dr2586
+  {
+    using allocator_type = std::allocator<int>;
+    dr2586(std::allocator_arg_t, allocator_type&&) { }
+    dr2586(const allocator_type&) { }
+  };
+
+  const dr2586::allocator_type a;
+  std::tuple<dr2586> t{std::allocator_arg, a};
+}
+
 int main()
 {
   test01();
   test02();
+  test03();
   return 0;
 }
Index: libstdc++-v3/testsuite/20_util/is_trivially_default_constructible/value.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/is_trivially_default_constructible/value.cc b/libstdc++-v3/testsuite/20_util/is_trivially_default_constructible/value.cc
--- a/libstdc++-v3/testsuite/20_util/is_trivially_default_constructible/value.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/20_util/is_trivially_default_constructible/value.cc	(revision 278653)
@@ -62,4 +62,13 @@
 		construct::Nontrivial>(false), "");
   static_assert(test_category<is_trivially_default_constructible, 
 		HasTemplateCtor>(true), "");
+
+  static_assert(test_category<is_trivially_default_constructible,
+		int[]>(false), "PR c++/90532");
+  struct A { };
+  static_assert(test_category<is_trivially_default_constructible,
+		A[]>(false), "PR c++/90532");
+  struct B { B() { } };
+  static_assert(test_category<is_trivially_default_constructible,
+		B[]>(false), "PR c++/90532");
 }
Index: libstdc++-v3/testsuite/20_util/uses_allocator/cons_neg.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/uses_allocator/cons_neg.cc b/libstdc++-v3/testsuite/20_util/uses_allocator/cons_neg.cc
--- a/libstdc++-v3/testsuite/20_util/uses_allocator/cons_neg.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/20_util/uses_allocator/cons_neg.cc	(revision 278653)
@@ -43,4 +43,4 @@
 
   tuple<Type> t(allocator_arg, a, 1);
 }
-// { dg-error "static assertion failed" "" { target *-*-* } 90 }
+// { dg-error "failed: .* uses_allocator is true" "" { target *-*-* } 0 }
Index: libstdc++-v3/testsuite/20_util/uses_allocator/69293_neg.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/uses_allocator/69293_neg.cc b/libstdc++-v3/testsuite/20_util/uses_allocator/69293_neg.cc
--- a/libstdc++-v3/testsuite/20_util/uses_allocator/69293_neg.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/20_util/uses_allocator/69293_neg.cc	(revision 278653)
@@ -44,5 +44,5 @@
 {
   alloc_type a;
   std::tuple<X> t(std::allocator_arg, a); // this is required to be ill-formed
-  // { dg-error "static assertion failed" "" { target *-*-* } 90 }
+  // { dg-error "failed: .* uses_allocator is true" "" { target *-*-* } 0 }
 }
Index: libstdc++-v3/testsuite/20_util/is_default_constructible/value.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/is_default_constructible/value.cc b/libstdc++-v3/testsuite/20_util/is_default_constructible/value.cc
--- a/libstdc++-v3/testsuite/20_util/is_default_constructible/value.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/20_util/is_default_constructible/value.cc	(revision 278653)
@@ -138,3 +138,13 @@
 static_assert(!std::is_default_constructible<const DelCopy>::value, "Error");
 static_assert(!std::is_default_constructible<DelDtor>::value, "Error");
 static_assert(!std::is_default_constructible<const DelDtor>::value, "Error");
+
+static_assert(!std::is_default_constructible<int[]>::value, "PR c++/90532");
+static_assert(!std::is_default_constructible<Empty[]>::value, "PR c++/90532");
+static_assert(!std::is_default_constructible<B[]>::value, "PR c++/90532");
+static_assert(!std::is_default_constructible<D[]>::value, "PR c++/90532");
+static_assert(!std::is_default_constructible<U[]>::value, "PR c++/90532");
+static_assert(!std::is_default_constructible<Ukn[]>::value, "PR c++/90532");
+static_assert(!std::is_default_constructible<Ellipsis[]>::value, "PR c++/90532");
+static_assert(!std::is_default_constructible<Any[]>::value, "PR c++/90532");
+static_assert(!std::is_default_constructible<nAny[]>::value, "PR c++/90532");
Index: libstdc++-v3/testsuite/20_util/is_nothrow_invocable/value.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/is_nothrow_invocable/value.cc b/libstdc++-v3/testsuite/20_util/is_nothrow_invocable/value.cc
--- a/libstdc++-v3/testsuite/20_util/is_nothrow_invocable/value.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/20_util/is_nothrow_invocable/value.cc	(revision 278653)
@@ -119,9 +119,11 @@
   static_assert( ! is_nt_invocable_r< T,     F  >(), "call throws");
   static_assert( ! is_nt_invocable_r< NT,    F  >(), "call throws");
   static_assert( ! is_nt_invocable_r< Ex,    F  >(), "call throws");
+  static_assert( ! is_nt_invocable_r< void,  F  >(), "call throws");
   static_assert( ! is_nt_invocable_r< T,     CF >(), "conversion throws");
   static_assert(   is_nt_invocable_r< NT,    CF >(), "" );
   static_assert( ! is_nt_invocable_r< Ex,    CF >(), "conversion fails");
+  static_assert(   is_nt_invocable_r< void,  CF >(), "");
 
   static_assert( ! is_nt_invocable< F,   int >(), "call throws");
   static_assert(   is_nt_invocable< F&,  int >(), "");
@@ -140,6 +142,7 @@
 
   static_assert(   is_nt_invocable_r< char&,  CF,  int >(), "");
   static_assert(   is_nt_invocable_r< char&,  CF&, int >(), "");
+  static_assert(   is_nt_invocable_r< void,   CF&, int >(), "");
 
   static_assert( ! is_nt_invocable_r< T,      CF&, int >(),
 		   "conversion throws");
@@ -146,6 +149,7 @@
   static_assert(   is_nt_invocable_r< NT,     CF&, int >(), "");
   static_assert( ! is_nt_invocable_r< Ex,     CF&, int >(),
 		   "conversion fails, would use explicit constructor");
+  static_assert(   is_nt_invocable_r< void,   CF&, int >(), "");
 
   static_assert( ! is_nt_invocable< F, int, int >(),
 		   "would call private member");
Index: libstdc++-v3/testsuite/20_util/optional/constexpr/observers/4.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/optional/constexpr/observers/4.cc b/libstdc++-v3/testsuite/20_util/optional/constexpr/observers/4.cc
--- a/libstdc++-v3/testsuite/20_util/optional/constexpr/observers/4.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/20_util/optional/constexpr/observers/4.cc	(revision 278653)
@@ -25,10 +25,42 @@
   int i;
 };
 
-int main()
+void test01()
 {
   constexpr std::optional<value_type> o { value_type { 51 } };
   constexpr value_type fallback { 3 };
-  static_assert( o.value_or(fallback).i == 51, "" );
-  static_assert( o.value_or(fallback).i == (*o).i, "" );
+  static_assert( o.value_or(fallback).i == 51 );
+  static_assert( o.value_or(fallback).i == (*o).i );
 }
+
+void test02()
+{
+  constexpr std::optional<value_type> o;
+  constexpr value_type fallback { 3 };
+  static_assert( o.value_or(fallback).i == 3 );
+}
+
+template<typename T>
+  constexpr std::optional<value_type>
+  make_rvalue(T t)
+  { return std::optional<value_type>{t}; }
+
+void test03()
+{
+  constexpr value_type fallback { 3 };
+  static_assert( make_rvalue(value_type{51}).value_or(fallback).i == 51 );
+}
+
+void test04()
+{
+  constexpr value_type fallback { 3 };
+  static_assert( make_rvalue(std::nullopt).value_or(fallback).i == 3 );
+}
+
+int main()
+{
+  test01();
+  test02();
+  test03();
+  test04();
+}
Index: libstdc++-v3/testsuite/20_util/optional/observers/4.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/optional/observers/4.cc b/libstdc++-v3/testsuite/20_util/optional/observers/4.cc
--- a/libstdc++-v3/testsuite/20_util/optional/observers/4.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/20_util/optional/observers/4.cc	(revision 278653)
@@ -26,7 +26,7 @@
   int i;
 };
 
-int main()
+void test01()
 {
   std::optional<value_type> o { value_type { 51 } };
   value_type fallback { 3 };
@@ -33,3 +33,35 @@
   VERIFY( o.value_or(fallback).i == 51 );
   VERIFY( o.value_or(fallback).i == (*o).i );
 }
+
+void test02()
+{
+  std::optional<value_type> o;
+  value_type fallback { 3 };
+  VERIFY( o.value_or(fallback).i == 3 );
+}
+
+void test03()
+{
+  std::optional<value_type> o { value_type { 51 } };
+  value_type fallback { 3 };
+  VERIFY( std::move(o).value_or(fallback).i == 51 );
+  VERIFY( o.has_value() );
+  VERIFY( std::move(o).value_or(fallback).i == (*o).i );
+}
+
+void test04()
+{
+  std::optional<value_type> o;
+  value_type fallback { 3 };
+  VERIFY( std::move(o).value_or(fallback).i == 3 );
+  VERIFY( !o.has_value() );
+}
+
+int main()
+{
+  test01();
+  test02();
+  test03();
+  test04();
+}
Index: libstdc++-v3/testsuite/20_util/common_type/requirements/sfinae_friendly_1.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/common_type/requirements/sfinae_friendly_1.cc b/libstdc++-v3/testsuite/20_util/common_type/requirements/sfinae_friendly_1.cc
--- a/libstdc++-v3/testsuite/20_util/common_type/requirements/sfinae_friendly_1.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/20_util/common_type/requirements/sfinae_friendly_1.cc	(revision 278653)
@@ -159,7 +159,10 @@
   };
 }
 
+static_assert(is_type<std::common_type<int>, int>(), "");
+static_assert(is_type<std::common_type<const int>, int>(), "");
 static_assert(is_type<std::common_type<int, int>, int>(), "");
+static_assert(is_type<std::common_type<const int, int>, int>(), "");
 static_assert(is_type<std::common_type<ScEn, ScEn>, ScEn>(), "");
 static_assert(is_type<std::common_type<UnscEn, UnscEn>, UnscEn>(), "");
 static_assert(is_type<std::common_type<UnscEn, int>, int>(), "");
@@ -180,6 +183,8 @@
 	      const volatile int*>(), "");
 static_assert(is_type<std::common_type<void*, const volatile int*>,
 	      const volatile void*>(), "");
+static_assert(is_type<std::common_type<void>, void>(), "");
+static_assert(is_type<std::common_type<const void>, void>(), "");
 static_assert(is_type<std::common_type<void, void>, void>(), "");
 static_assert(is_type<std::common_type<const void, const void>, void>(), "");
 static_assert(is_type<std::common_type<int&, int&&>, int>(), "");
@@ -316,6 +321,14 @@
 static_assert(!has_type<std::common_type<std::initializer_list<int>,
 					 std::initializer_list<long>>>(), "");
 
+// PR libstdc++/89102
+static_assert(!has_type<std::common_type<int() &>>(), "");
+static_assert(!has_type<std::common_type<int() & noexcept>>(), "");
+static_assert(!has_type<std::common_type<int() const>>(), "");
+static_assert(!has_type<std::common_type<int(...) &>>(), "");
+static_assert(!has_type<std::common_type<int(...) & noexcept>>(), "");
+static_assert(!has_type<std::common_type<int(...) const>>(), "");
+
 void test(int i)
 {
   auto local_lmd1 = [=](int, double) { return i + i; };
Index: libstdc++-v3/testsuite/20_util/common_type/requirements/sfinae_friendly_2.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/common_type/requirements/sfinae_friendly_2.cc b/libstdc++-v3/testsuite/20_util/common_type/requirements/sfinae_friendly_2.cc
--- a/libstdc++-v3/testsuite/20_util/common_type/requirements/sfinae_friendly_2.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/20_util/common_type/requirements/sfinae_friendly_2.cc	(revision 278653)
@@ -25,7 +25,7 @@
 constexpr
 std::array<typename std::common_type<Args...>::type, 
   sizeof...(Args)>
-make_array(Args&&... args)  // { dg-error "invalid use" }
+make_array(Args&&... args)  // { dg-error "no type.*common_type<>" }
 {
   typedef typename std::common_type<Args...>::type CT;
   return std::array<CT, sizeof...(Args)>{static_cast<CT>
Index: libstdc++-v3/testsuite/20_util/common_type/requirements/explicit_instantiation.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/common_type/requirements/explicit_instantiation.cc b/libstdc++-v3/testsuite/20_util/common_type/requirements/explicit_instantiation.cc
--- a/libstdc++-v3/testsuite/20_util/common_type/requirements/explicit_instantiation.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/20_util/common_type/requirements/explicit_instantiation.cc	(revision 278653)
@@ -30,6 +30,7 @@
   typedef void test_type5;
   typedef const void test_type6;  
 
+  template struct common_type<>;
   template struct common_type<test_type1>;
   template struct common_type<test_type1, test_type2>;
   template struct common_type<test_type1, test_type2, test_type3>;
Index: libstdc++-v3/testsuite/20_util/is_trivially_constructible/value.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/is_trivially_constructible/value.cc b/libstdc++-v3/testsuite/20_util/is_trivially_constructible/value.cc
--- a/libstdc++-v3/testsuite/20_util/is_trivially_constructible/value.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/20_util/is_trivially_constructible/value.cc	(revision 278653)
@@ -180,4 +180,6 @@
 		MoveOnly, const MoveOnly&>(false), "");
   static_assert(test_property<is_trivially_constructible,
 		MoveOnly2>(false), "");
+  static_assert(test_property<is_trivially_constructible,
+		int[]>(false), "PR c++/90532");
 }
Index: libstdc++-v3/testsuite/20_util/is_constructible/value.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/is_constructible/value.cc b/libstdc++-v3/testsuite/20_util/is_constructible/value.cc
--- a/libstdc++-v3/testsuite/20_util/is_constructible/value.cc	(revision 278653)
+++ b/libstdc++-v3/testsuite/20_util/is_constructible/value.cc	(revision 278653)
@@ -35,4 +35,11 @@
   static_assert(test_property<is_constructible, ExplicitClass>(false), "");
   static_assert(test_property<is_constructible, ExplicitClass,
 		int, double>(false), "");
+  static_assert(test_property<is_constructible, int[]>(false), "PR c++/90532");
+  static_assert(test_property<is_constructible,
+		__gnu_test::construct::Empty[]>(false), "PR c++/90532");
+  static_assert(test_property<is_constructible,
+		__gnu_test::construct::Ukn[]>(false), "PR c++/90532");
+  static_assert(test_property<is_constructible,
+		__gnu_test::construct::nAny[]>(false), "PR c++/90532");
 }
Index: libstdc++-v3/config/os/bsd/darwin/ppc-extra.ver
===================================================================
diff --git a/libstdc++-v3/config/os/bsd/darwin/ppc-extra.ver b/libstdc++-v3/config/os/bsd/darwin/ppc-extra.ver
--- a/libstdc++-v3/config/os/bsd/darwin/ppc-extra.ver	(revision 278653)
+++ b/libstdc++-v3/config/os/bsd/darwin/ppc-extra.ver	(revision 278653)
@@ -1 +1,22 @@
   __eprintf;
+# 3.4
+  _ZNSt14numeric_limitsIgE*;
+  _ZNSirsERg;
+  _ZNSolsEg;
+  _ZNSt13basic_istreamIwSt11char_traitsIwEErsERg;
+  _ZNSt13basic_ostreamIwSt11char_traitsIwEElsEg;
+  _ZSt14__convert_to_vIgEvPKcRT_RSt12_Ios_IostateRKP*;
+  _ZStlsIg[cw]St11char_traitsI[cw]EERSt13basic_ostreamIT0_T1_ES6_RKSt7complexIT_E;
+  _ZStrsIg[cw]St11char_traitsI[cw]EERSt13basic_istreamIT0_T1_ES6_RSt7complexIT_E;
+# 3.4.7
+  _ZNSi10_M_extractIgEERSiRT_;
+  _ZNSt13basic_istreamIwSt11char_traitsIwEE10_M_extractIgEERS2_RT_;
+  _ZNSo9_M_insertIgEERSoT_;
+  _ZNSt13basic_ostreamIwSt11char_traitsIwEE9_M_insertIgEERS2_T_;
+# 3.4.10
+  _ZNKSt3tr14hashIgEclEg;
+  _ZNKSt4hashIgEclEg;
+# ldbl 1.3
+  _ZT[IS]g;
+  _ZT[IS]Pg;
+  _ZT[IS]PKg;
Index: libstdc++-v3/acinclude.m4
===================================================================
diff --git a/libstdc++-v3/acinclude.m4 b/libstdc++-v3/acinclude.m4
--- a/libstdc++-v3/acinclude.m4	(revision 278653)
+++ b/libstdc++-v3/acinclude.m4	(revision 278653)
@@ -642,28 +642,27 @@
 dnl
 AC_DEFUN([GLIBCXX_CONFIGURE_DOCBOOK], [
 
-AC_MSG_CHECKING([for docbook stylesheets for documentation creation])
-glibcxx_stylesheets=no
-if test x${XSLTPROC} = xyes && echo '<title/>' | xsltproc --noout --nonet --xinclude http://docbook.sourceforge.net/release/xsl-ns/current/xhtml-1_1/docbook.xsl - 2>/dev/null; then
-  glibcxx_stylesheets=yes
-fi
-AC_MSG_RESULT($glibcxx_stylesheets)
+glibcxx_docbook_url=http://docbook.sourceforge.net/release/xsl-ns/current/
 
 AC_MSG_CHECKING([for local stylesheet directory])
 glibcxx_local_stylesheets=no
-if test x"$glibcxx_stylesheets" = x"yes"; then
-  if test -d /usr/share/sgml/docbook/xsl-ns-stylesheets; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/sgml/docbook/xsl-ns-stylesheets
-  fi
-  if test -d /usr/share/xml/docbook/stylesheet/docbook-xsl-ns; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/xml/docbook/stylesheet/docbook-xsl-ns
-  fi
-  if test -d /usr/share/xml/docbook/stylesheet/nwalsh5/current; then
-    glibcxx_local_stylesheets=yes
-    XSL_STYLE_DIR=/usr/share/xml/docbook/stylesheet/nwalsh5/current
-  fi
+if test x${XMLCATALOG} = xyes && xsl_style_dir=`xmlcatalog "" $glibcxx_docbook_url 2>/dev/null`
+then
+  XSL_STYLE_DIR=`echo $xsl_style_dir | sed -n 's;^file://;;p'`
+  glibcxx_local_stylesheets=yes
+else
+  for dir in \
+    /usr/share/sgml/docbook/xsl-ns-stylesheets \
+    /usr/share/xml/docbook/stylesheet/docbook-xsl-ns \
+    /usr/share/xml/docbook/stylesheet/nwalsh5/current \
+    /usr/share/xml/docbook/stylesheet/nwalsh/current
+  do
+    if test -d $dir; then
+      glibcxx_local_stylesheets=yes
+      XSL_STYLE_DIR=$dir
+      break
+    fi
+  done
 fi
 AC_MSG_RESULT($glibcxx_local_stylesheets)
 
@@ -670,6 +669,16 @@
 if test x"$glibcxx_local_stylesheets" = x"yes"; then
   AC_SUBST(XSL_STYLE_DIR)
   AC_MSG_NOTICE($XSL_STYLE_DIR)
+
+  AC_MSG_CHECKING([for docbook stylesheets for documentation creation])
+  glibcxx_stylesheets=no
+  if test x${XMLCATALOG} = xno || xmlcatalog "" $glibcxx_docbook_url/xhtml/docbook.xsl >/dev/null 2>&1; then
+    if test x${XSLTPROC} = xyes && echo '<title/>' | xsltproc --noout --nonet --xinclude $glibcxx_docbook_url/xhtml/docbook.xsl - 2>/dev/null; then
+      glibcxx_stylesheets=yes
+    fi
+  fi
+  AC_MSG_RESULT($glibcxx_stylesheets)
+
 else
   glibcxx_stylesheets=no
 fi
Index: include/ChangeLog
===================================================================
diff --git a/include/ChangeLog b/include/ChangeLog
--- a/include/ChangeLog	(revision 278653)
+++ b/include/ChangeLog	(revision 278653)
@@ -1,3 +1,11 @@
+2019-04-08  Claudiu Zissulescu  <claziss@synopsys.com>
+
+	backport mainline
+	Vineet Gupta  <vgupta@synopsys.com>
+	PR 89877
+	* longlong.h [__arc__] (add_ssaaaa): Add cc clobber.
+	(sub_ddmmss): Likewise.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: include/longlong.h
===================================================================
diff --git a/include/longlong.h b/include/longlong.h
--- a/include/longlong.h	(revision 278653)
+++ b/include/longlong.h	(revision 278653)
@@ -199,7 +199,8 @@
 	   : "%r" ((USItype) (ah)),					\
 	     "rICal" ((USItype) (bh)),					\
 	     "%r" ((USItype) (al)),					\
-	     "rICal" ((USItype) (bl)))
+	     "rICal" ((USItype) (bl))					\
+	   : "cc")
 #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
   __asm__ ("sub.f	%1, %4, %5\n\tsbc	%0, %2, %3"		\
 	   : "=r" ((USItype) (sh)),					\
@@ -207,7 +208,8 @@
 	   : "r" ((USItype) (ah)),					\
 	     "rICal" ((USItype) (bh)),					\
 	     "r" ((USItype) (al)),					\
-	     "rICal" ((USItype) (bl)))
+	     "rICal" ((USItype) (bl))					\
+	   : "cc")
 
 #define __umulsidi3(u,v) ((UDItype)(USItype)u*(USItype)v)
 #ifdef __ARC_NORM__
Index: libiberty/simple-object-elf.c
===================================================================
diff --git a/libiberty/simple-object-elf.c b/libiberty/simple-object-elf.c
--- a/libiberty/simple-object-elf.c	(revision 278653)
+++ b/libiberty/simple-object-elf.c	(revision 278653)
@@ -549,6 +549,14 @@
       return NULL;
     }
 
+  if (eor->shstrndx == 0)
+    {
+      *errmsg = "invalid ELF shstrndx == 0";
+      *err = 0;
+      XDELETE (eor);
+      return NULL;
+    }
+
   return (void *) eor;
 }
 
Index: libiberty/ChangeLog
===================================================================
diff --git a/libiberty/ChangeLog b/libiberty/ChangeLog
--- a/libiberty/ChangeLog	(revision 278653)
+++ b/libiberty/ChangeLog	(revision 278653)
@@ -1,3 +1,12 @@
+2019-07-25  Richard Biener  <rguenther@suse.de>
+
+	PR lto/90924
+	Backport from mainline
+	2019-07-12  Ren Kimura  <rkx1209dev@gmail.com>
+
+	* simple-object-elf.c (simple_object_elf_match): Check zero value
+	shstrndx.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: contrib/ChangeLog
===================================================================
diff --git a/contrib/ChangeLog b/contrib/ChangeLog
--- a/contrib/ChangeLog	(revision 278653)
+++ b/contrib/ChangeLog	(revision 278653)
@@ -1,3 +1,7 @@
+2019-08-16  Uros Bizjak  <ubizjak@gmail.com>
+
+	* test_summary: Do not escape "=".
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: contrib/test_summary
===================================================================
diff --git a/contrib/test_summary b/contrib/test_summary
--- a/contrib/test_summary	(revision 278653)
+++ b/contrib/test_summary	(revision 278653)
@@ -127,7 +127,7 @@
   if (lang == "") lang = " "$2" "; else lang = " ";
 }
 $2 == "version" { save = $0; $1 = ""; $2 = ""; version = $0; gsub(/^ */, "", version); gsub(/\r$/, "", version); $0 = save; }
-/\===.*Summary/ { print ""; print; blanks=1; }
+/===.*Summary/ { print ""; print; blanks=1; }
 /tests ===/ || /^(Target|Host|Native)/ || $2 == "version" { print; blanks=1; }
 /^(XPASS|FAIL|UNRESOLVED|WARNING|ERROR|# of )/ { sub ("\r", ""); print; }
 /^using:/ { print ""; print; print ""; }
Index: libatomic/ChangeLog
===================================================================
diff --git a/libatomic/ChangeLog b/libatomic/ChangeLog
--- a/libatomic/ChangeLog	(revision 278653)
+++ b/libatomic/ChangeLog	(revision 278653)
@@ -1,3 +1,18 @@
+2019-03-20  Florian Weimer  <fweimer@redhat.com>
+
+	PR libgcc/60790
+	x86: Do not assume ELF constructors run before IFUNC resolvers.
+	* config/x86/host-config.h (libat_feat1_ecx, libat_feat1_edx):
+	Remove declarations.
+	(__libat_feat1, __libat_feat1_init): Declare.
+	(FEAT1_REGISTER): Define.
+	(load_feat1): New function.
+	(IFUNC_COND_1): Adjust.
+	* config/x86/init.c (libat_feat1_ecx, libat_feat1_edx)
+	(init_cpuid): Remove definitions.
+	(__libat_feat1): New variable.
+	(__libat_feat1_init): New function.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: libatomic/config/x86/init.c
===================================================================
diff --git a/libatomic/config/x86/init.c b/libatomic/config/x86/init.c
--- a/libatomic/config/x86/init.c	(revision 278653)
+++ b/libatomic/config/x86/init.c	(revision 278653)
@@ -26,13 +26,17 @@
 
 #if HAVE_IFUNC
 
-unsigned int libat_feat1_ecx, libat_feat1_edx;
+unsigned int __libat_feat1;
 
-static void __attribute__((constructor))
-init_cpuid (void)
+unsigned int
+__libat_feat1_init (void)
 {
-  unsigned int eax, ebx;
-  __get_cpuid (1, &eax, &ebx, &libat_feat1_ecx, &libat_feat1_edx);
+  unsigned int eax, ebx, ecx, edx;
+  FEAT1_REGISTER = 0;
+  __get_cpuid (1, &eax, &ebx, &ecx, &edx);
+  /* See the load in load_feat1.  */
+  __atomic_store_n (&__libat_feat1, FEAT1_REGISTER, __ATOMIC_RELAXED);
+  return FEAT1_REGISTER;
 }
 
 #endif /* HAVE_IFUNC */
Index: libatomic/config/x86/host-config.h
===================================================================
diff --git a/libatomic/config/x86/host-config.h b/libatomic/config/x86/host-config.h
--- a/libatomic/config/x86/host-config.h	(revision 278653)
+++ b/libatomic/config/x86/host-config.h	(revision 278653)
@@ -25,13 +25,39 @@
 #if HAVE_IFUNC
 #include <cpuid.h>
 
-extern unsigned int libat_feat1_ecx HIDDEN;
-extern unsigned int libat_feat1_edx HIDDEN;
+#ifdef __x86_64__
+# define FEAT1_REGISTER ecx
+#else
+# define FEAT1_REGISTER edx
+#endif
 
+/* Value of the CPUID feature register FEAT1_REGISTER for the cmpxchg
+   bit for IFUNC_COND1 below.  */
+extern unsigned int __libat_feat1 HIDDEN;
+
+/* Initialize libat_feat1 and return its value.  */
+unsigned int __libat_feat1_init (void) HIDDEN;
+
+/* Return the value of the relevant feature register for the relevant
+   cmpxchg bit, or 0 if there is no CPUID support.  */
+static inline unsigned int
+__attribute__ ((const))
+load_feat1 (void)
+{
+  /* See the store in __libat_feat1_init.  */
+  unsigned int feat1 = __atomic_load_n (&__libat_feat1, __ATOMIC_RELAXED);
+  if (feat1 == 0)
+    /* Assume that initialization has not happened yet.  This may get
+       called repeatedly if the CPU does not have any feature bits at
+       all.  */
+    feat1 = __libat_feat1_init ();
+  return feat1;
+}
+
 #ifdef __x86_64__
-# define IFUNC_COND_1	(libat_feat1_ecx & bit_CMPXCHG16B)
+# define IFUNC_COND_1	(load_feat1 () & bit_CMPXCHG16B)
 #else
-# define IFUNC_COND_1	(libat_feat1_edx & bit_CMPXCHG8B)
+# define IFUNC_COND_1	(load_feat1 () & bit_CMPXCHG8B)
 #endif
 
 #ifdef __x86_64__
Index: libgcc/config.host
===================================================================
diff --git a/libgcc/config.host b/libgcc/config.host
--- a/libgcc/config.host	(revision 278653)
+++ b/libgcc/config.host	(revision 278653)
@@ -1018,12 +1018,12 @@
 	  md_unwind_header=rs6000/darwin-unwind.h
 	  ;;
 	esac
-	tmake_file="$tmake_file rs6000/t-ibm-ldouble"
-	extra_parts="$extra_parts crt2.o"
+	tmake_file="$tmake_file rs6000/t-ppc64-fp rs6000/t-ibm-ldouble"
+	extra_parts="$extra_parts crt2.o crt3_2.o libef_ppc.a dw_ppc.o"
 	;;
 powerpc64-*-darwin*)
 	tmake_file="$tmake_file rs6000/t-darwin64 rs6000/t-ibm-ldouble"
-	extra_parts="$extra_parts crt2.o"
+	extra_parts="$extra_parts crt2.o crt3_2.o libef_ppc.a dw_ppc.o"
 	;;
 powerpc*-*-freebsd*)
 	tmake_file="${tmake_file} rs6000/t-ppccomm rs6000/t-savresfgpr rs6000/t-crtstuff rs6000/t-freebsd t-softfp-sfdf t-softfp-excl t-softfp"
Index: libgcc/ChangeLog
===================================================================
diff --git a/libgcc/ChangeLog b/libgcc/ChangeLog
--- a/libgcc/ChangeLog	(revision 278653)
+++ b/libgcc/ChangeLog	(revision 278653)
@@ -1,3 +1,85 @@
+2019-11-17  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/linux-atomic.c (__kernel_cmpxchg): Change argument 1 to
+	volatile void *.  Remove trap check.
+	(__kernel_cmpxchg2): Likewise.
+	(FETCH_AND_OP_2): Adjust operand types.
+	(OP_AND_FETCH_2): Likewise.
+	(FETCH_AND_OP_WORD): Likewise.
+	(OP_AND_FETCH_WORD): Likewise.
+	(COMPARE_AND_SWAP_2): Likewise.
+	(__sync_val_compare_and_swap_4): Likewise.
+	(__sync_bool_compare_and_swap_4): Likewise.
+	(SYNC_LOCK_TEST_AND_SET_2): Likewise.
+	(__sync_lock_test_and_set_4): Likewise.
+	(SYNC_LOCK_RELEASE_1): Likewise.  Use __kernel_cmpxchg2 for release.
+	(__sync_lock_release_4): Adjust operand types.  Use __kernel_cmpxchg
+	for release.
+	(__sync_lock_release_8): Remove.
+
+2019-11-04  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-10-12  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/lib2funcs.S (__gcc_plt_call): Load branch target to %r21.
+	Load PIC register after branch target.  Fix white space.
+	* config/pa/milli64.S ($$dyncall): Separate LINUX and non LINUX
+	implementations.  Load PIC register after branch target.  Don't
+	clobber function pointer when it points to function descriptor.
+	Use nullification instead of branch in LINUX implementation.
+
+2019-11-04  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-10-15  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/fptr.c (_dl_read_access_allowed): Change argument to
+	unsigned int.  Adjust callers.
+	(__canonicalize_funcptr_for_compare): Change plabel type to volatile
+	unsigned int *.  Load relocation offset before function pointer.
+	Add barrier to ensure ordering.
+
+2019-10-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-07-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config.host (powerpc-*-darwin*,powerpc64-*-darwin*): Revise crt
+	list.
+	* config/rs6000/t-darwin: Build crt3_2 for older systems.  Revise
+	mmacosx-version-min for crts to run across all system versions.
+	* config/rs6000/t-darwin64 (LIB2ADD): Remove.
+	* config/t-darwin: Revise mmacosx-version-min for crts to run across
+	system versions >= 10.4.
+
+2019-10-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-25  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config.host: Add libef_ppc.a to the extra files for powerpc-darwin.
+	* config/rs6000/t-darwin: (PPC_ENDFILE_SRC, PPC_ENDFILE_OBJS): New.
+	Build objects for the out of line save/restore register functions
+	so that they can be used for any supported Darwin version.
+	* config/t-darwin: Default the build Darwin version to Darwin8
+	(MacOS 10.4).
+
+2019-08-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/t-darwin: Ensure that the unwinder is built with
+	altivec enabled.
+
+2019-08-11  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-12  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin-vecsave.S: Set .machine appropriately.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: libgcc/config/t-darwin
===================================================================
diff --git a/libgcc/config/t-darwin b/libgcc/config/t-darwin
--- a/libgcc/config/t-darwin	(revision 278653)
+++ b/libgcc/config/t-darwin	(revision 278653)
@@ -1,22 +1,16 @@
 # Set this as a minimum (unless overriden by arch t-files) since it's a
 # reasonable lowest common denominator that works for all our archs.
-HOST_LIBGCC2_CFLAGS += -mmacosx-version-min=10.5
+HOST_LIBGCC2_CFLAGS += -mmacosx-version-min=10.4
 
 crt3.o: $(srcdir)/config/darwin-crt3.c
-	$(crt_compile) $(DARWIN_EXTRA_CRT_BUILD_CFLAGS) -c $<
+	$(crt_compile) -mmacosx-version-min=10.4 -c $<
 
 crttms.o: $(srcdir)/config/darwin-crt-tm.c
-	$(crt_compile) $(DARWIN_EXTRA_CRT_BUILD_CFLAGS) -DSTART -c $<
+	$(crt_compile) -mmacosx-version-min=10.4 -DSTART -c $<
 
 crttme.o: $(srcdir)/config/darwin-crt-tm.c
-	$(crt_compile) $(DARWIN_EXTRA_CRT_BUILD_CFLAGS) -DEND -c $<
+	$(crt_compile) -mmacosx-version-min=10.4 -DEND -c $<
 
-# -pipe because there's an assembler bug, 4077127, which causes
-# it to not properly process the first # directive, causing temporary
-# file names to appear in stabs, causing the bootstrap to fail.  Using -pipe
-# works around this by not having any temporary file names.
-HOST_LIBGCC2_CFLAGS += -pipe
-
 # Use unwind-dw2-fde-darwin
 LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/config/unwind-dw2-fde-darwin.c \
   $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c
Index: libgcc/config/rs6000/t-darwin
===================================================================
diff --git a/libgcc/config/rs6000/t-darwin b/libgcc/config/rs6000/t-darwin
--- a/libgcc/config/rs6000/t-darwin	(revision 278653)
+++ b/libgcc/config/rs6000/t-darwin	(revision 278653)
@@ -1,23 +1,58 @@
-DARWIN_EXTRA_CRT_BUILD_CFLAGS = -mlongcall -mmacosx-version-min=10.4
 
 crt2.o: $(srcdir)/config/rs6000/darwin-crt2.c
-	$(crt_compile) $(DARWIN_EXTRA_CRT_BUILD_CFLAGS) -c $<
+	$(crt_compile) -mmacosx-version-min=10.1 -c $<
 
+# The sources for this indicate that there are some parts that
+# don't apply >= 10.4
+crt3_2.o: $(srcdir)/config/darwin-crt3.c
+	$(crt_compile) -mmacosx-version-min=10.1 -c $<
+
+# The outlined register save/restore functions need to run anywhere, and
+# they must be leaf functions suitable for use in an endfile.
+
+PPC_ENDFILE_SRC = \
+  $(srcdir)/config/rs6000/darwin-gpsave.S \
+  $(srcdir)/config/rs6000/darwin-fpsave.S \
+  $(srcdir)/config/rs6000/darwin-vecsave.S
+
+PPC_ENDFILE_OBJS = \
+ darwin-gpsave.o \
+ darwin-fpsave.o \
+ darwin-vecsave.o
+
+darwin-gpsave.o: $(srcdir)/config/rs6000/darwin-gpsave.S
+	$(crt_compile) -mmacosx-version-min=10.1 -c $<
+
+darwin-fpsave.o: $(srcdir)/config/rs6000/darwin-fpsave.S
+	$(crt_compile) -mmacosx-version-min=10.1 -c $<
+
+darwin-vecsave.o: $(srcdir)/config/rs6000/darwin-vecsave.S
+	$(crt_compile) -mmacosx-version-min=10.1 -c $<
+
+# We build these into a library, so that they are only linked as needed and not
+# forced into every object.
+
+libef_ppc.a: $(PPC_ENDFILE_OBJS)
+	$(AR_CREATE_FOR_TARGET) $@ $(PPC_ENDFILE_OBJS)
+	$(RANLIB_FOR_TARGET) $@
+
+dw_ppc.o: $(srcdir)/config/rs6000/darwin-world.S
+	$(crt_compile) -mmacosx-version-min=10.1 -c $<
+
 LIB2ADD = $(srcdir)/config/rs6000/darwin-tramp.S \
 	  $(srcdir)/config/darwin-64.c \
-	  $(srcdir)/config/rs6000/darwin-fpsave.S  \
-	  $(srcdir)/config/rs6000/darwin-gpsave.S  \
-	  $(srcdir)/config/rs6000/darwin-world.S \
-	  $(srcdir)/config/rs6000/ppc64-fp.c
+	  $(srcdir)/config/rs6000/darwin-world.S
 
-LIB2ADD_ST = \
-	  $(srcdir)/config/rs6000/darwin-vecsave.S
-
 # The .S files above are designed to run on all processors, even though
 # they use AltiVec instructions.
 # -Wa is used because -force_cpusubtype_ALL doesn't work with -dynamiclib.
-# -mmacosx-version-min=10.4 is used to provide compatibility for code from
-# earlier OSX versions.
-HOST_LIBGCC2_CFLAGS += -Wa,-force_cpusubtype_ALL -mmacosx-version-min=10.4
 
+HOST_LIBGCC2_CFLAGS += -Wa,-force_cpusubtype_ALL
+
+# Although the default for 10.4 is G3, we need the unwinder to be built
+# with vector support so that the "save/rest_world" outlined functions are
+# correctly invoked.
+unwind-dw2_s.o: HOST_LIBGCC2_CFLAGS += -maltivec
+unwind-dw2.o: HOST_LIBGCC2_CFLAGS += -maltivec
+
 LIB2ADDEH += $(srcdir)/config/rs6000/darwin-fallback.c
Index: libgcc/config/rs6000/t-darwin64
===================================================================
diff --git a/libgcc/config/rs6000/t-darwin64 b/libgcc/config/rs6000/t-darwin64
--- a/libgcc/config/rs6000/t-darwin64	(revision 278653)
+++ b/libgcc/config/rs6000/t-darwin64	(revision 278653)
@@ -1,7 +1 @@
 LIB2_SIDITI_CONV_FUNCS = yes
-
-LIB2ADD = $(srcdir)/config/rs6000/darwin-tramp.S \
-	  $(srcdir)/config/darwin-64.c \
-	  $(srcdir)/config/rs6000/darwin-fpsave.S \
-	  $(srcdir)/config/rs6000/darwin-gpsave.S \
-	  $(srcdir)/config/rs6000/darwin-world.S
Index: libgcc/config/rs6000/darwin-vecsave.S
===================================================================
diff --git a/libgcc/config/rs6000/darwin-vecsave.S b/libgcc/config/rs6000/darwin-vecsave.S
--- a/libgcc/config/rs6000/darwin-vecsave.S	(revision 278653)
+++ b/libgcc/config/rs6000/darwin-vecsave.S	(revision 278653)
@@ -31,8 +31,14 @@
    (4 bytes) to do the operation; for Vector regs, 2 instructions are
    required (8 bytes.).   */
 
+/* With some assemblers, we need the correct machine directive to get the
+   right CPU type / subtype in the file header.  */
+#if	__ppc64__
+	.machine ppc64
+#else
 	.machine ppc7400
-.text
+#endif
+	.text
 	.align 2
 
 .private_extern saveVEC
Index: libgcc/config/pa/milli64.S
===================================================================
diff --git a/libgcc/config/pa/milli64.S b/libgcc/config/pa/milli64.S
--- a/libgcc/config/pa/milli64.S	(revision 278653)
+++ b/libgcc/config/pa/milli64.S	(revision 278653)
@@ -222,19 +222,26 @@
 	.proc
 	.callinfo	millicode
 	.entry
+#ifdef LINUX
+	extru,<>	%r22,30,1,%r0	; nullify if plabel bit set
+	bv,n	%r0(%r22)		; branch to target
+	ldw	-2(%r22),%r21		; load address of target
+	bv	%r0(%r21)		; branch to the real target
+	ldw	2(%r22),%r19		; load new LTP value
+#else
 	bb,>=,n %r22,30,LREF(1)		; branch if not plabel address
-	depi	0,31,2,%r22		; clear the two least significant bits
-	ldw	4(%r22),%r19		; load new LTP value
-	ldw	0(%r22),%r22		; load address of target
+	ldw	-2(%r22),%r21		; load address of target to r21
+	ldsid	(%sr0,%r21),%r1		; get the "space ident" selected by r21
+	ldw	2(%r22),%r19		; load new LTP value
+	mtsp	%r1,%sr0		; move that space identifier into sr0
+	be	0(%sr0,%r21)		; branch to the real target
+	stw	%r2,-24(%r30)		; save return address into frame marker
 LSYM(1)
-#ifdef LINUX
-	bv	%r0(%r22)		; branch to the real target
-#else
 	ldsid	(%sr0,%r22),%r1		; get the "space ident" selected by r22
 	mtsp	%r1,%sr0		; move that space identifier into sr0
-	be	0(%sr0,%r22)		; branch to the real target
+	be	0(%sr0,%r22)		; branch to the target
+	stw	%r2,-24(%r30)		; save return address into frame marker
 #endif
-	stw	%r2,-24(%r30)		; save return address into frame marker
 	.exit
 	.procend
 #endif
Index: libgcc/config/pa/lib2funcs.S
===================================================================
diff --git a/libgcc/config/pa/lib2funcs.S b/libgcc/config/pa/lib2funcs.S
--- a/libgcc/config/pa/lib2funcs.S	(revision 278653)
+++ b/libgcc/config/pa/lib2funcs.S	(revision 278653)
@@ -55,13 +55,13 @@
 	; An inline version of dyncall so we don't have to worry
 	; about long calls to millicode, PIC and other complexities.
 	bb,>=,n %r22,30,L$foo
-        depi 0,31,2,%r22
-        ldw 4(%r22),%r19
-        ldw 0(%r22),%r22
+	depi 0,31,2,%r22
+	ldw 0(%r22),%r21
+	ldw 4(%r22),%r19
 L$foo
-        ldsid (%r22),%r1
-        mtsp %r1,%sr0
-        ble 0(%sr0,%r22)
+	ldsid (%r21),%r1
+	mtsp %r1,%sr0
+	ble 0(%sr0,%r21)
 	copy %r31,%r2
 	ldw -8(%r30),%r2
 
Index: libgcc/config/pa/linux-atomic.c
===================================================================
diff --git a/libgcc/config/pa/linux-atomic.c b/libgcc/config/pa/linux-atomic.c
--- a/libgcc/config/pa/linux-atomic.c	(revision 278653)
+++ b/libgcc/config/pa/linux-atomic.c	(revision 278653)
@@ -41,7 +41,7 @@
 
 /* Kernel helper for compare-and-exchange a 32-bit value.  */
 static inline long
-__kernel_cmpxchg (int *mem, int oldval, int newval)
+__kernel_cmpxchg (volatile void *mem, int oldval, int newval)
 {
   register unsigned long lws_mem asm("r26") = (unsigned long) (mem);
   register int lws_old asm("r25") = oldval;
@@ -54,20 +54,18 @@
 	: "i" (LWS_CAS), "r" (lws_mem), "r" (lws_old), "r" (lws_new)
 	: "r1", "r20", "r22", "r23", "r29", "r31", "memory"
   );
-  if (__builtin_expect (lws_errno == -EFAULT || lws_errno == -ENOSYS, 0))
-    __builtin_trap ();
 
   /* If the kernel LWS call succeeded (lws_errno == 0), lws_ret contains
      the old value from memory.  If this value is equal to OLDVAL, the
      new value was written to memory.  If not, return -EBUSY.  */
   if (!lws_errno && lws_ret != oldval)
-    lws_errno = -EBUSY;
+    return -EBUSY;
 
   return lws_errno;
 }
 
 static inline long
-__kernel_cmpxchg2 (void *mem, const void *oldval, const void *newval,
+__kernel_cmpxchg2 (volatile void *mem, const void *oldval, const void *newval,
 		   int val_size)
 {
   register unsigned long lws_mem asm("r26") = (unsigned long) (mem);
@@ -88,9 +86,6 @@
   if (__builtin_expect (lws_ret == 0, 1))
     return 0;
 
-  if (__builtin_expect (lws_errno == -EFAULT || lws_errno == -ENOSYS, 0))
-    __builtin_trap ();
-
   /* If the kernel LWS call fails with no error, return -EBUSY */
   if (__builtin_expect (!lws_errno, 0))
     return -EBUSY;
@@ -108,13 +103,13 @@
 
 #define FETCH_AND_OP_2(OP, PFX_OP, INF_OP, TYPE, WIDTH, INDEX)		\
   TYPE HIDDEN								\
-  __sync_fetch_and_##OP##_##WIDTH (TYPE *ptr, TYPE val)			\
+  __sync_fetch_and_##OP##_##WIDTH (volatile void *ptr, TYPE val)	\
   {									\
     TYPE tmp, newval;							\
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
+      tmp = __atomic_load_n ((volatile TYPE *)ptr, __ATOMIC_RELAXED);	\
       newval = PFX_OP (tmp INF_OP val);					\
       failure = __kernel_cmpxchg2 (ptr, &tmp, &newval, INDEX);		\
     } while (failure != 0);						\
@@ -122,36 +117,36 @@
     return tmp;								\
   }
 
-FETCH_AND_OP_2 (add,   , +, long long, 8, 3)
-FETCH_AND_OP_2 (sub,   , -, long long, 8, 3)
-FETCH_AND_OP_2 (or,    , |, long long, 8, 3)
-FETCH_AND_OP_2 (and,   , &, long long, 8, 3)
-FETCH_AND_OP_2 (xor,   , ^, long long, 8, 3)
-FETCH_AND_OP_2 (nand, ~, &, long long, 8, 3)
+FETCH_AND_OP_2 (add,   , +, long long unsigned int, 8, 3)
+FETCH_AND_OP_2 (sub,   , -, long long unsigned int, 8, 3)
+FETCH_AND_OP_2 (or,    , |, long long unsigned int, 8, 3)
+FETCH_AND_OP_2 (and,   , &, long long unsigned int, 8, 3)
+FETCH_AND_OP_2 (xor,   , ^, long long unsigned int, 8, 3)
+FETCH_AND_OP_2 (nand, ~, &, long long unsigned int, 8, 3)
 
-FETCH_AND_OP_2 (add,   , +, short, 2, 1)
-FETCH_AND_OP_2 (sub,   , -, short, 2, 1)
-FETCH_AND_OP_2 (or,    , |, short, 2, 1)
-FETCH_AND_OP_2 (and,   , &, short, 2, 1)
-FETCH_AND_OP_2 (xor,   , ^, short, 2, 1)
-FETCH_AND_OP_2 (nand, ~, &, short, 2, 1)
+FETCH_AND_OP_2 (add,   , +, short unsigned int, 2, 1)
+FETCH_AND_OP_2 (sub,   , -, short unsigned int, 2, 1)
+FETCH_AND_OP_2 (or,    , |, short unsigned int, 2, 1)
+FETCH_AND_OP_2 (and,   , &, short unsigned int, 2, 1)
+FETCH_AND_OP_2 (xor,   , ^, short unsigned int, 2, 1)
+FETCH_AND_OP_2 (nand, ~, &, short unsigned int, 2, 1)
 
-FETCH_AND_OP_2 (add,   , +, signed char, 1, 0)
-FETCH_AND_OP_2 (sub,   , -, signed char, 1, 0)
-FETCH_AND_OP_2 (or,    , |, signed char, 1, 0)
-FETCH_AND_OP_2 (and,   , &, signed char, 1, 0)
-FETCH_AND_OP_2 (xor,   , ^, signed char, 1, 0)
-FETCH_AND_OP_2 (nand, ~, &, signed char, 1, 0)
+FETCH_AND_OP_2 (add,   , +, unsigned char, 1, 0)
+FETCH_AND_OP_2 (sub,   , -, unsigned char, 1, 0)
+FETCH_AND_OP_2 (or,    , |, unsigned char, 1, 0)
+FETCH_AND_OP_2 (and,   , &, unsigned char, 1, 0)
+FETCH_AND_OP_2 (xor,   , ^, unsigned char, 1, 0)
+FETCH_AND_OP_2 (nand, ~, &, unsigned char, 1, 0)
 
 #define OP_AND_FETCH_2(OP, PFX_OP, INF_OP, TYPE, WIDTH, INDEX)		\
   TYPE HIDDEN								\
-  __sync_##OP##_and_fetch_##WIDTH (TYPE *ptr, TYPE val)			\
+  __sync_##OP##_and_fetch_##WIDTH (volatile void *ptr, TYPE val)	\
   {									\
     TYPE tmp, newval;							\
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
+      tmp = __atomic_load_n ((volatile TYPE *)ptr, __ATOMIC_RELAXED);	\
       newval = PFX_OP (tmp INF_OP val);					\
       failure = __kernel_cmpxchg2 (ptr, &tmp, &newval, INDEX);		\
     } while (failure != 0);						\
@@ -159,36 +154,37 @@
     return PFX_OP (tmp INF_OP val);					\
   }
 
-OP_AND_FETCH_2 (add,   , +, long long, 8, 3)
-OP_AND_FETCH_2 (sub,   , -, long long, 8, 3)
-OP_AND_FETCH_2 (or,    , |, long long, 8, 3)
-OP_AND_FETCH_2 (and,   , &, long long, 8, 3)
-OP_AND_FETCH_2 (xor,   , ^, long long, 8, 3)
-OP_AND_FETCH_2 (nand, ~, &, long long, 8, 3)
+OP_AND_FETCH_2 (add,   , +, long long unsigned int, 8, 3)
+OP_AND_FETCH_2 (sub,   , -, long long unsigned int, 8, 3)
+OP_AND_FETCH_2 (or,    , |, long long unsigned int, 8, 3)
+OP_AND_FETCH_2 (and,   , &, long long unsigned int, 8, 3)
+OP_AND_FETCH_2 (xor,   , ^, long long unsigned int, 8, 3)
+OP_AND_FETCH_2 (nand, ~, &, long long unsigned int, 8, 3)
 
-OP_AND_FETCH_2 (add,   , +, short, 2, 1)
-OP_AND_FETCH_2 (sub,   , -, short, 2, 1)
-OP_AND_FETCH_2 (or,    , |, short, 2, 1)
-OP_AND_FETCH_2 (and,   , &, short, 2, 1)
-OP_AND_FETCH_2 (xor,   , ^, short, 2, 1)
-OP_AND_FETCH_2 (nand, ~, &, short, 2, 1)
+OP_AND_FETCH_2 (add,   , +, short unsigned int, 2, 1)
+OP_AND_FETCH_2 (sub,   , -, short unsigned int, 2, 1)
+OP_AND_FETCH_2 (or,    , |, short unsigned int, 2, 1)
+OP_AND_FETCH_2 (and,   , &, short unsigned int, 2, 1)
+OP_AND_FETCH_2 (xor,   , ^, short unsigned int, 2, 1)
+OP_AND_FETCH_2 (nand, ~, &, short unsigned int, 2, 1)
 
-OP_AND_FETCH_2 (add,   , +, signed char, 1, 0)
-OP_AND_FETCH_2 (sub,   , -, signed char, 1, 0)
-OP_AND_FETCH_2 (or,    , |, signed char, 1, 0)
-OP_AND_FETCH_2 (and,   , &, signed char, 1, 0)
-OP_AND_FETCH_2 (xor,   , ^, signed char, 1, 0)
-OP_AND_FETCH_2 (nand, ~, &, signed char, 1, 0)
+OP_AND_FETCH_2 (add,   , +, unsigned char, 1, 0)
+OP_AND_FETCH_2 (sub,   , -, unsigned char, 1, 0)
+OP_AND_FETCH_2 (or,    , |, unsigned char, 1, 0)
+OP_AND_FETCH_2 (and,   , &, unsigned char, 1, 0)
+OP_AND_FETCH_2 (xor,   , ^, unsigned char, 1, 0)
+OP_AND_FETCH_2 (nand, ~, &, unsigned char, 1, 0)
 
 #define FETCH_AND_OP_WORD(OP, PFX_OP, INF_OP)				\
-  int HIDDEN								\
-  __sync_fetch_and_##OP##_4 (int *ptr, int val)				\
+  unsigned int HIDDEN							\
+  __sync_fetch_and_##OP##_4 (volatile void *ptr, unsigned int val)	\
   {									\
-    int tmp;								\
+    unsigned int tmp;							\
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
+      tmp = __atomic_load_n ((volatile unsigned int *)ptr,		\
+			     __ATOMIC_RELAXED);				\
       failure = __kernel_cmpxchg (ptr, tmp, PFX_OP (tmp INF_OP val));	\
     } while (failure != 0);						\
 									\
@@ -203,14 +199,15 @@
 FETCH_AND_OP_WORD (nand, ~, &)
 
 #define OP_AND_FETCH_WORD(OP, PFX_OP, INF_OP)				\
-  int HIDDEN								\
-  __sync_##OP##_and_fetch_4 (int *ptr, int val)				\
+  unsigned int HIDDEN							\
+  __sync_##OP##_and_fetch_4 (volatile void *ptr, unsigned int val)	\
   {									\
-    int tmp;								\
+    unsigned int tmp;							\
     long failure;							\
 									\
     do {								\
-      tmp = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
+      tmp = __atomic_load_n ((volatile unsigned int *)ptr,		\
+			     __ATOMIC_RELAXED);				\
       failure = __kernel_cmpxchg (ptr, tmp, PFX_OP (tmp INF_OP val));	\
     } while (failure != 0);						\
 									\
@@ -228,7 +225,7 @@
 
 #define COMPARE_AND_SWAP_2(TYPE, WIDTH, INDEX)				\
   TYPE HIDDEN								\
-  __sync_val_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,		\
+  __sync_val_compare_and_swap_##WIDTH (volatile void *ptr, TYPE oldval,	\
 				       TYPE newval)			\
   {									\
     TYPE actual_oldval;							\
@@ -236,7 +233,8 @@
 									\
     while (1)								\
       {									\
-	actual_oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);	\
+	actual_oldval = __atomic_load_n ((volatile TYPE *)ptr,		\
+					 __ATOMIC_RELAXED);		\
 									\
 	if (__builtin_expect (oldval != actual_oldval, 0))		\
 	  return actual_oldval;						\
@@ -248,27 +246,29 @@
       }									\
   }									\
 									\
-  bool HIDDEN								\
-  __sync_bool_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,		\
-					TYPE newval)			\
+  _Bool HIDDEN								\
+  __sync_bool_compare_and_swap_##WIDTH (volatile void *ptr,		\
+					TYPE oldval, TYPE newval)	\
   {									\
     long failure = __kernel_cmpxchg2 (ptr, &oldval, &newval, INDEX);	\
     return (failure == 0);						\
   }
 
-COMPARE_AND_SWAP_2 (long long, 8, 3)
-COMPARE_AND_SWAP_2 (short, 2, 1)
-COMPARE_AND_SWAP_2 (char, 1, 0)
+COMPARE_AND_SWAP_2 (long long unsigned int, 8, 3)
+COMPARE_AND_SWAP_2 (short unsigned int, 2, 1)
+COMPARE_AND_SWAP_2 (unsigned char, 1, 0)
 
-int HIDDEN
-__sync_val_compare_and_swap_4 (int *ptr, int oldval, int newval)
+unsigned int HIDDEN
+__sync_val_compare_and_swap_4 (volatile void *ptr, unsigned int oldval,
+			       unsigned int newval)
 {
   long fail;
-  int actual_oldval;
+  unsigned int actual_oldval;
     
   while (1)
     {
-      actual_oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);
+      actual_oldval = __atomic_load_n ((volatile unsigned int *)ptr,
+				       __ATOMIC_RELAXED);
 
       if (__builtin_expect (oldval != actual_oldval, 0))
 	return actual_oldval;
@@ -280,8 +280,9 @@
     }
 }
 
-bool HIDDEN
-__sync_bool_compare_and_swap_4 (int *ptr, int oldval, int newval)
+_Bool HIDDEN
+__sync_bool_compare_and_swap_4 (volatile void *ptr, unsigned int oldval,
+				unsigned int newval)
 {
   long failure = __kernel_cmpxchg (ptr, oldval, newval);
   return (failure == 0);
@@ -289,13 +290,14 @@
 
 #define SYNC_LOCK_TEST_AND_SET_2(TYPE, WIDTH, INDEX)			\
 TYPE HIDDEN								\
-  __sync_lock_test_and_set_##WIDTH (TYPE *ptr, TYPE val)		\
+  __sync_lock_test_and_set_##WIDTH (volatile void *ptr, TYPE val)	\
   {									\
     TYPE oldval;							\
     long failure;							\
 									\
     do {								\
-      oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);			\
+      oldval = __atomic_load_n ((volatile TYPE *)ptr,			\
+				__ATOMIC_RELAXED);			\
       failure = __kernel_cmpxchg2 (ptr, &oldval, &val, INDEX);		\
     } while (failure != 0);						\
 									\
@@ -302,18 +304,18 @@
     return oldval;							\
   }
 
-SYNC_LOCK_TEST_AND_SET_2 (long long, 8, 3)
-SYNC_LOCK_TEST_AND_SET_2 (short, 2, 1)
-SYNC_LOCK_TEST_AND_SET_2 (signed char, 1, 0)
+SYNC_LOCK_TEST_AND_SET_2 (long long unsigned int, 8, 3)
+SYNC_LOCK_TEST_AND_SET_2 (short unsigned int, 2, 1)
+SYNC_LOCK_TEST_AND_SET_2 (unsigned char, 1, 0)
 
-int HIDDEN
-__sync_lock_test_and_set_4 (int *ptr, int val)
+unsigned int HIDDEN
+__sync_lock_test_and_set_4 (volatile void *ptr, unsigned int val)
 {
   long failure;
-  int oldval;
+  unsigned int oldval;
 
   do {
-    oldval = __atomic_load_n (ptr, __ATOMIC_RELAXED);
+    oldval = __atomic_load_n ((volatile unsigned int *)ptr, __ATOMIC_RELAXED);
     failure = __kernel_cmpxchg (ptr, oldval, val);
   } while (failure != 0);
 
@@ -320,24 +322,32 @@
   return oldval;
 }
 
-void HIDDEN
-__sync_lock_release_8 (long long *ptr)
-{
-  /* All accesses must be complete before we release the lock.  */
-  __sync_synchronize ();
-  *(double *)ptr = 0;
-}
-
-#define SYNC_LOCK_RELEASE_1(TYPE, WIDTH)			\
+#define SYNC_LOCK_RELEASE_1(TYPE, WIDTH, INDEX)			\
   void HIDDEN							\
-  __sync_lock_release_##WIDTH (TYPE *ptr)			\
+  __sync_lock_release_##WIDTH (volatile void *ptr)		\
   {								\
-    /* All accesses must be complete before we release		\
-       the lock.  */						\
-    __sync_synchronize ();					\
-    *ptr = 0;							\
+    TYPE oldval, val = 0;					\
+    long failure;						\
+								\
+    do {							\
+      oldval = __atomic_load_n ((volatile TYPE *)ptr,		\
+				__ATOMIC_RELAXED);		\
+      failure = __kernel_cmpxchg2 (ptr, &oldval, &val, INDEX);	\
+    } while (failure != 0);					\
   }
 
-SYNC_LOCK_RELEASE_1 (int, 4)
-SYNC_LOCK_RELEASE_1 (short, 2)
-SYNC_LOCK_RELEASE_1 (signed char, 1)
+SYNC_LOCK_RELEASE_1 (long long unsigned int, 8, 3)
+SYNC_LOCK_RELEASE_1 (short unsigned int, 2, 1)
+SYNC_LOCK_RELEASE_1 (unsigned char, 1, 0)
+
+void HIDDEN
+__sync_lock_release_4 (volatile void *ptr)
+{
+  long failure;
+  unsigned int oldval;
+
+  do {
+    oldval = __atomic_load_n ((volatile unsigned int *)ptr, __ATOMIC_RELAXED);
+    failure = __kernel_cmpxchg (ptr, oldval, 0);
+  } while (failure != 0);
+}
Index: libgcc/config/pa/fptr.c
===================================================================
diff --git a/libgcc/config/pa/fptr.c b/libgcc/config/pa/fptr.c
--- a/libgcc/config/pa/fptr.c	(revision 278653)
+++ b/libgcc/config/pa/fptr.c	(revision 278653)
@@ -53,7 +53,7 @@
 extern unsigned int _GLOBAL_OFFSET_TABLE_;
 
 static inline int
-_dl_read_access_allowed (unsigned int *addr)
+_dl_read_access_allowed (unsigned int addr)
 {
   int result;
 
@@ -76,7 +76,8 @@
 {
   static unsigned int fixup_plabel[2] __attribute__((used));
   fixup_t fixup;
-  unsigned int *got, *iptr, *plabel;
+  volatile unsigned int *plabel;
+  unsigned int *got, *iptr, reloc_offset;
   int i;
 
   /* -1 and page 0 are special.  -1 is used in crtend to mark the end of
@@ -91,8 +92,8 @@
      to the entry of the PLT stub just before the global offset table.
      The second word in the plabel contains the relocation offset for the
      function.  */
-  plabel = (unsigned int *) ((unsigned int) fptr & ~3);
-  if (!_dl_read_access_allowed (plabel))
+  plabel = (volatile unsigned int *) ((unsigned int) fptr & ~3);
+  if (!_dl_read_access_allowed ((unsigned int)plabel))
     return (unsigned int) fptr;
 
   /* Load first word of candidate descriptor.  It should be a pointer
@@ -99,9 +100,12 @@
      with word alignment and point to memory that can be read.  */
   got = (unsigned int *) plabel[0];
   if (((unsigned int) got & 3) != 0
-      || !_dl_read_access_allowed (got))
+      || !_dl_read_access_allowed ((unsigned int)got))
     return (unsigned int) fptr;
 
+  /* We need to load the relocation offset before the function address.  */
+  reloc_offset = plabel[1];
+  __sync_synchronize();
   got = (unsigned int *) (plabel[0] + GOT_FROM_PLT_STUB);
 
   /* Return the address of the function if the plabel has been resolved.  */
@@ -137,7 +141,7 @@
 
   /* Call fixup to resolve the function address.  got[1] contains the
      link_map pointer and plabel[1] the relocation offset.  */
-  fixup ((struct link_map *) got[1], plabel[1]);
+  fixup ((struct link_map *) got[1], reloc_offset);
 
   return plabel[0];
 }
Index: gcc/tree-vrp.c
===================================================================
diff --git a/gcc/tree-vrp.c b/gcc/tree-vrp.c
--- a/gcc/tree-vrp.c	(revision 278653)
+++ b/gcc/tree-vrp.c	(revision 278653)
@@ -1618,10 +1618,13 @@
 		max_ovf = 1;
 	    }
 
-	  /* If we have overflow for the constant part and the resulting
-	     range will be symbolic, drop to VR_VARYING.  */
-	  if ((min_ovf && sym_min_op0 != sym_min_op1)
-	      || (max_ovf && sym_max_op0 != sym_max_op1))
+	  /* If the resulting range will be symbolic, we need to eliminate any
+	     explicit or implicit overflow introduced in the above computation
+	     because compare_values could make an incorrect use of it.  That's
+	     why we require one of the ranges to be a singleton.  */
+	  if ((sym_min_op0 != sym_min_op1 || sym_max_op0 != sym_max_op1)
+	      && (min_ovf || max_ovf
+		  || (min_op0 != max_op0 && min_op1 != max_op1)))
 	    {
 	      set_value_range_to_varying (vr);
 	      return;
Index: gcc/attribs.c
===================================================================
diff --git a/gcc/attribs.c b/gcc/attribs.c
--- a/gcc/attribs.c	(revision 278653)
+++ b/gcc/attribs.c	(revision 278653)
@@ -1685,8 +1685,11 @@
 	     a function global scope, unless declared static.  */
 	  if (current_function_decl != NULL_TREE && !TREE_STATIC (node))
 	    TREE_PUBLIC (node) = 1;
-	  /* Clear TREE_STATIC because DECL_EXTERNAL is set.  */
-	  TREE_STATIC (node) = 0;
+	  /* Clear TREE_STATIC because DECL_EXTERNAL is set, unless
+	     it is a C++ static data member.  */
+	  if (DECL_CONTEXT (node) == NULL_TREE
+	      || !RECORD_OR_UNION_TYPE_P (DECL_CONTEXT (node)))
+	    TREE_STATIC (node) = 0;
 	}
 
       if (*no_add_attrs == false)
Index: gcc/doc/extend.texi
===================================================================
diff --git a/gcc/doc/extend.texi b/gcc/doc/extend.texi
--- a/gcc/doc/extend.texi	(revision 278653)
+++ b/gcc/doc/extend.texi	(revision 278653)
@@ -19708,20 +19708,33 @@
 @smallexample
 vector unsigned long long __builtin_crypto_vsbox (vector unsigned long long);
 
+vector unsigned char vec_sbox_be (vector unsigned char);
+
 vector unsigned long long __builtin_crypto_vcipher (vector unsigned long long,
                                                     vector unsigned long long);
 
+vector unsigned char vec_cipher_be (vector unsigned char, vector unsigned char);
+
 vector unsigned long long __builtin_crypto_vcipherlast
                                      (vector unsigned long long,
                                       vector unsigned long long);
 
+vector unsigned char vec_cipherlast_be (vector unsigned char,
+                                        vector unsigned char);
+
 vector unsigned long long __builtin_crypto_vncipher (vector unsigned long long,
                                                      vector unsigned long long);
 
+vector unsigned char vec_ncipher_be (vector unsigned char,
+                                     vector unsigned char);
+
 vector unsigned long long __builtin_crypto_vncipherlast
                                      (vector unsigned long long,
                                       vector unsigned long long);
 
+vector unsigned char vec_ncipherlast_be (vector unsigned char,
+                                         vector unsigned char);
+
 vector unsigned char __builtin_crypto_vpermxor (vector unsigned char,
                                                 vector unsigned char,
                                                 vector unsigned char);
Index: gcc/doc/invoke.texi
===================================================================
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
--- a/gcc/doc/invoke.texi	(revision 278653)
+++ b/gcc/doc/invoke.texi	(revision 278653)
@@ -554,7 +554,6 @@
 -fdisable-tree-@var{pass_name} @gol
 -fdisable-tree-@var{pass-name}=@var{range-list} @gol
 -fdump-noaddr  -fdump-unnumbered  -fdump-unnumbered-links @gol
--fdump-class-hierarchy@r{[}-@var{n}@r{]} @gol
 -fdump-final-insns@r{[}=@var{file}@r{]} @gol
 -fdump-ipa-all  -fdump-ipa-cgraph  -fdump-ipa-inline @gol
 -fdump-lang-all @gol
@@ -7374,7 +7373,7 @@
 would be rendered unable to decode location lists using it.
 
 @item -ginternal-reset-location-views
-@itemx -gnointernal-reset-location-views
+@itemx -gno-internal-reset-location-views
 @opindex ginternal-reset-location-views
 @opindex gno-internal-reset-location-views
 Attempt to determine location views that can be omitted from location
@@ -7681,8 +7680,7 @@
 
 @option{-Os} disables the following optimization flags:
 @gccoptlist{-falign-functions  -falign-jumps  -falign-loops @gol
--falign-labels  -freorder-blocks  -freorder-blocks-algorithm=stc @gol
--freorder-blocks-and-partition  -fprefetch-loop-arrays}
+-falign-labels  -fprefetch-loop-arrays}
 
 It also enables @option{-finline-functions}, causes the compiler to tune for
 code size rather than execution speed, and performs further optimizations
Index: gcc/opts-common.c
===================================================================
diff --git a/gcc/opts-common.c b/gcc/opts-common.c
--- a/gcc/opts-common.c	(revision 278653)
+++ b/gcc/opts-common.c	(revision 278653)
@@ -463,7 +463,8 @@
 
   extra_args = 0;
 
-  opt_index = find_opt (argv[0] + 1, lang_mask);
+  const char *opt_value = argv[0] + 1;
+  opt_index = find_opt (opt_value, lang_mask);
   i = 0;
   while (opt_index == OPT_SPECIAL_unknown
 	 && i < ARRAY_SIZE (option_map))
@@ -666,7 +667,24 @@
   /* Check if this is a switch for a different front end.  */
   if (!option_ok_for_language (option, lang_mask))
     errors |= CL_ERR_WRONG_LANG;
+  else if (strcmp (option->opt_text, "-Werror=") == 0
+	   && strchr (opt_value, ',') == NULL)
+    {
+      /* Verify that -Werror argument is a valid warning
+	 for a language.  */
+      char *werror_arg = xstrdup (opt_value + 6);
+      werror_arg[0] = 'W';
 
+      size_t warning_index = find_opt (werror_arg, lang_mask);
+      if (warning_index != OPT_SPECIAL_unknown)
+	{
+	  const struct cl_option *warning_option
+	    = &cl_options[warning_index];
+	  if (!option_ok_for_language (warning_option, lang_mask))
+	    errors |= CL_ERR_WRONG_LANG;
+	}
+    }
+
   /* Convert the argument to lowercase if appropriate.  */
   if (arg && option->cl_tolower)
     {
Index: gcc/c-family/ChangeLog
===================================================================
diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
--- a/gcc/c-family/ChangeLog	(revision 278653)
+++ b/gcc/c-family/ChangeLog	(revision 278653)
@@ -1,3 +1,54 @@
+2019-09-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-08-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR pch/61250
+	* c-lex.c (c_lex_with_flags):  Don't call
+	c_common_no_more_pch () from here.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-05-15  Richard Biener  <rguenther@suse.de>
+
+	PR c/90474
+	* c-common.c (c_common_mark_addressable_vec): Also mark
+	a COMPOUND_LITERAL_EXPR_DECL addressable similar to
+	c_mark_addressable.
+
+2019-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-06-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/90954
+	* c-omp.c (c_finish_omp_atomic): Allow tree_invariant_p in addition
+	to SAVE_EXPR in first operand of a COMPOUND_EXPR.
+
+2019-05-22  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2018-05-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR c++/85400
+	* c-attribs.c (handle_visibility_attribute): Do not set no_add_attrs.
+
+2019-04-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89946
+	* c-attribs.c (handle_patchable_function_entry_attribute): Add
+	function comment.  Warn if arguments of the attribute are not positive
+	integer constants.
+
+2019-04-09  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* c-ada-spec.c (print_destructor): Deal with deleting destructors.
+	(dump_ada_declaration) <FUNCTION_DECL>: Likewise.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: gcc/c-family/c-lex.c
===================================================================
diff --git a/gcc/c-family/c-lex.c b/gcc/c-family/c-lex.c
--- a/gcc/c-family/c-lex.c	(revision 278653)
+++ b/gcc/c-family/c-lex.c	(revision 278653)
@@ -392,7 +392,6 @@
 c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,
 		  int lex_flags)
 {
-  static bool no_more_pch;
   const cpp_token *tok;
   enum cpp_ttype type;
   unsigned char add_flags = 0;
@@ -626,12 +625,6 @@
   if (cpp_flags)
     *cpp_flags = tok->flags | add_flags;
 
-  if (!no_more_pch)
-    {
-      no_more_pch = true;
-      c_common_no_more_pch ();
-    }
-
   timevar_pop (TV_CPP);
 
   return type;
Index: gcc/c-family/c-common.c
===================================================================
diff --git a/gcc/c-family/c-common.c b/gcc/c-family/c-common.c
--- a/gcc/c-family/c-common.c	(revision 278653)
+++ b/gcc/c-family/c-common.c	(revision 278653)
@@ -6440,6 +6440,8 @@
     return;
   if (!VAR_P (t) || !DECL_HARD_REGISTER (t))
     TREE_ADDRESSABLE (t) = 1;
+  if (TREE_CODE (t) == COMPOUND_LITERAL_EXPR)
+    TREE_ADDRESSABLE (COMPOUND_LITERAL_EXPR_DECL (t)) = 1;
 }
 
 
Index: gcc/c-family/c-omp.c
===================================================================
diff --git a/gcc/c-family/c-omp.c b/gcc/c-family/c-omp.c
--- a/gcc/c-family/c-omp.c	(revision 278653)
+++ b/gcc/c-family/c-omp.c	(revision 278653)
@@ -300,7 +300,7 @@
   if (TREE_CODE (x) == COMPOUND_EXPR)
     {
       pre = TREE_OPERAND (x, 0);
-      gcc_assert (TREE_CODE (pre) == SAVE_EXPR);
+      gcc_assert (TREE_CODE (pre) == SAVE_EXPR || tree_invariant_p (pre));
       x = TREE_OPERAND (x, 1);
     }
   gcc_assert (TREE_CODE (x) == MODIFY_EXPR);
Index: gcc/c-family/c-attribs.c
===================================================================
diff --git a/gcc/c-family/c-attribs.c b/gcc/c-family/c-attribs.c
--- a/gcc/c-family/c-attribs.c	(revision 278653)
+++ b/gcc/c-family/c-attribs.c	(revision 278653)
@@ -2310,14 +2310,13 @@
 
 static tree
 handle_tls_model_attribute (tree *node, tree name, tree args,
-			    int ARG_UNUSED (flags), bool *no_add_attrs)
+			    int ARG_UNUSED (flags),
+			    bool *ARG_UNUSED (no_add_attrs))
 {
   tree id;
   tree decl = *node;
   enum tls_model kind;
 
-  *no_add_attrs = true;
-
   if (!VAR_P (decl) || !DECL_THREAD_LOCAL_P (decl))
     {
       warning (OPT_Wattributes, "%qE attribute ignored", name);
@@ -3562,9 +3561,28 @@
   return NULL_TREE;
 }
 
+/* Handle a "patchable_function_entry" attributes; arguments as in
+   struct attribute_spec.handler.  */
+
 static tree
-handle_patchable_function_entry_attribute (tree *, tree, tree, int, bool *)
+handle_patchable_function_entry_attribute (tree *, tree name, tree args,
+					   int, bool *no_add_attrs)
 {
-  /* Nothing to be done here.  */
+  for (; args; args = TREE_CHAIN (args))
+    {
+      tree val = TREE_VALUE (args);
+      if (val && TREE_CODE (val) != IDENTIFIER_NODE
+	  && TREE_CODE (val) != FUNCTION_DECL)
+	val = default_conversion (val);
+
+      if (!tree_fits_uhwi_p (val))
+	{
+	  warning (OPT_Wattributes,
+		   "%qE attribute argument %qE is not an integer constant",
+		   name, val);
+	  *no_add_attrs = true;
+	  return NULL_TREE;
+	}
+    }
   return NULL_TREE;
 }
Index: gcc/c-family/c-ada-spec.c
===================================================================
diff --git a/gcc/c-family/c-ada-spec.c b/gcc/c-family/c-ada-spec.c
--- a/gcc/c-family/c-ada-spec.c	(revision 278653)
+++ b/gcc/c-family/c-ada-spec.c	(revision 278653)
@@ -2686,6 +2686,8 @@
   tree decl_name = DECL_NAME (TYPE_NAME (type));
 
   pp_string (buffer, "Delete_");
+  if (strncmp (IDENTIFIER_POINTER (DECL_NAME (t)), "__dt_del", 8) == 0)
+    pp_string (buffer, "And_Free_");
   pp_ada_tree_identifier (buffer, decl_name, t, 0, false);
 }
 
@@ -2937,9 +2939,10 @@
 	  if (DECL_ARTIFICIAL (t))
 	    return 0;
 
-	  /* Only consider constructors/destructors for complete objects.  */
+	  /* Only consider complete constructors and deleting destructors.  */
 	  if (strncmp (IDENTIFIER_POINTER (decl_name), "__ct_comp", 9) != 0
-	      && strncmp (IDENTIFIER_POINTER (decl_name), "__dt_comp", 9) != 0)
+	      && strncmp (IDENTIFIER_POINTER (decl_name), "__dt_comp", 9) != 0
+	      && strncmp (IDENTIFIER_POINTER (decl_name), "__dt_del", 8) != 0)
 	    return 0;
 	}
 
Index: gcc/c/ChangeLog
===================================================================
diff --git a/gcc/c/ChangeLog b/gcc/c/ChangeLog
--- a/gcc/c/ChangeLog	(revision 278653)
+++ b/gcc/c/ChangeLog	(revision 278653)
@@ -1,3 +1,68 @@
+2019-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-08-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/91401
+	* c-parser.c (c_parser_omp_clause_dist_schedule): Fix up typos in the
+	check_no_duplicate_clause call.  Comment it out, instead emit a
+	warning for duplicate dist_schedule clauses.
+
+2019-09-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-08-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR pch/61250
+	* c-parser.c (c_parse_file): Call c_common_no_more_pch ()
+	after determining that the first token is not
+	PRAGMA_GCC_PCH_PREPROCESS.
+
+2019-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-04-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/90197
+	* c-tree.h (c_finish_loop): Add 2 further location_t arguments.
+	* c-parser.c (c_parser_while_statement): Adjust c_finish_loop caller.
+	(c_parser_do_statement): Likewise.
+	(c_parser_for_statement): Likewise.  Formatting fixes.
+	* c-typeck.c (c_finish_loop): Add COND_LOCUS and INCR_LOCUS arguments,
+	emit DEBUG_BEGIN_STMTs if needed.
+
+2019-07-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline
+	2019-07-18  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR c/53633
+	* c-decl.c (finish_function): Check targetm.warn_func_return
+	before issuing a -Wreturn-type warning.
+
+2019-04-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90108
+	* c-decl.c (merge_decls): If remove is main variant and
+	DECL_ORIGINAL_TYPE is some other type, remove a DECL_ORIGINAL_TYPE
+	variant that has newdecl as TYPE_NAME if any.
+
+	2019-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89933
+	* c-decl.c (merge_decls): When newdecl's type is its main variant,
+	don't try to remove it from the variant list, but instead assert
+	it has no variants.
+
+	2019-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89734
+	* c-decl.c (grokdeclarator): Call c_build_qualified_type on function
+	return type even if quals_used is 0.  Formatting fixes.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: gcc/c/c-parser.c
===================================================================
diff --git a/gcc/c/c-parser.c b/gcc/c/c-parser.c
--- a/gcc/c/c-parser.c	(revision 278653)
+++ b/gcc/c/c-parser.c	(revision 278653)
@@ -5933,7 +5933,8 @@
   location_t loc_after_labels;
   bool open_brace = c_parser_next_token_is (parser, CPP_OPEN_BRACE);
   body = c_parser_c99_block_statement (parser, if_p, &loc_after_labels);
-  c_finish_loop (loc, cond, NULL, body, c_break_label, c_cont_label, true);
+  c_finish_loop (loc, loc, cond, UNKNOWN_LOCATION, NULL, body,
+		 c_break_label, c_cont_label, true);
   add_stmt (c_end_compound_stmt (loc, block, flag_isoc99));
   c_parser_maybe_reclassify_token (parser);
 
@@ -5978,6 +5979,7 @@
   c_break_label = save_break;
   new_cont = c_cont_label;
   c_cont_label = save_cont;
+  location_t cond_loc = c_parser_peek_token (parser)->location;
   cond = c_parser_paren_condition (parser);
   if (ivdep && cond != error_mark_node)
     cond = build3 (ANNOTATE_EXPR, TREE_TYPE (cond), cond,
@@ -5991,7 +5993,8 @@
  		   build_int_cst (integer_type_node, unroll));
   if (!c_parser_require (parser, CPP_SEMICOLON, "expected %<;%>"))
     c_parser_skip_to_end_of_block_or_statement (parser);
-  c_finish_loop (loc, cond, NULL, body, new_break, new_cont, false);
+  c_finish_loop (loc, cond_loc, cond, UNKNOWN_LOCATION, NULL, body,
+		 new_break, new_cont, false);
   add_stmt (c_end_compound_stmt (loc, block, flag_isoc99));
 }
 
@@ -6064,7 +6067,9 @@
   /* Silence the bogus uninitialized warning.  */
   tree collection_expression = NULL;
   location_t loc = c_parser_peek_token (parser)->location;
-  location_t for_loc = c_parser_peek_token (parser)->location;
+  location_t for_loc = loc;
+  location_t cond_loc = UNKNOWN_LOCATION;
+  location_t incr_loc = UNKNOWN_LOCATION;
   bool is_foreach_statement = false;
   gcc_assert (c_parser_next_token_is_keyword (parser, RID_FOR));
   token_indent_info for_tinfo
@@ -6098,7 +6103,8 @@
 	      c_parser_consume_token (parser);
 	      is_foreach_statement = true;
 	      if (check_for_loop_decls (for_loc, true) == NULL_TREE)
-		c_parser_error (parser, "multiple iterating variables in fast enumeration");
+		c_parser_error (parser, "multiple iterating variables in "
+					"fast enumeration");
 	    }
 	  else
 	    check_for_loop_decls (for_loc, flag_isoc99);
@@ -6128,7 +6134,8 @@
 		  c_parser_consume_token (parser);
 		  is_foreach_statement = true;
 		  if (check_for_loop_decls (for_loc, true) == NULL_TREE)
-		    c_parser_error (parser, "multiple iterating variables in fast enumeration");
+		    c_parser_error (parser, "multiple iterating variables in "
+					    "fast enumeration");
 		}
 	      else
 		check_for_loop_decls (for_loc, flag_isoc99);
@@ -6150,8 +6157,10 @@
 		c_parser_consume_token (parser);
 		is_foreach_statement = true;
 		if (! lvalue_p (init_expression))
-		  c_parser_error (parser, "invalid iterating variable in fast enumeration");
-		object_expression = c_fully_fold (init_expression, false, NULL);
+		  c_parser_error (parser, "invalid iterating variable in "
+					  "fast enumeration");
+		object_expression
+		  = c_fully_fold (init_expression, false, NULL);
 	      }
 	    else
 	      {
@@ -6158,7 +6167,8 @@
 		ce = convert_lvalue_to_rvalue (loc, ce, true, false);
 		init_expression = ce.value;
 		c_finish_expr_stmt (loc, init_expression);
-		c_parser_skip_until_found (parser, CPP_SEMICOLON, "expected %<;%>");
+		c_parser_skip_until_found (parser, CPP_SEMICOLON,
+					   "expected %<;%>");
 	      }
 	  }
 	}
@@ -6167,18 +6177,19 @@
       gcc_assert (!parser->objc_could_be_foreach_context);
       if (!is_foreach_statement)
 	{
+	  cond_loc = c_parser_peek_token (parser)->location;
 	  if (c_parser_next_token_is (parser, CPP_SEMICOLON))
 	    {
 	      if (ivdep)
 		{
-		  c_parser_error (parser, "missing loop condition in loop with "
-				  "%<GCC ivdep%> pragma");
+		  c_parser_error (parser, "missing loop condition in loop "
+					  "with %<GCC ivdep%> pragma");
 		  cond = error_mark_node;
 		}
 	      else if (unroll)
 		{
-		  c_parser_error (parser, "missing loop condition in loop with "
-				  "%<GCC unroll%> pragma");
+		  c_parser_error (parser, "missing loop condition in loop "
+					  "with %<GCC unroll%> pragma");
 		  cond = error_mark_node;
 		}
 	      else
@@ -6207,11 +6218,13 @@
       /* Parse the increment expression (the third expression in a
 	 for-statement).  In the case of a foreach-statement, this is
 	 the expression that follows the 'in'.  */
+      loc = incr_loc = c_parser_peek_token (parser)->location;
       if (c_parser_next_token_is (parser, CPP_CLOSE_PAREN))
 	{
 	  if (is_foreach_statement)
 	    {
-	      c_parser_error (parser, "missing collection in fast enumeration");
+	      c_parser_error (parser,
+			      "missing collection in fast enumeration");
 	      collection_expression = error_mark_node;
 	    }
 	  else
@@ -6220,8 +6233,8 @@
       else
 	{
 	  if (is_foreach_statement)
-	    collection_expression = c_fully_fold (c_parser_expression (parser).value,
-						  false, NULL);
+	    collection_expression
+	      = c_fully_fold (c_parser_expression (parser).value, false, NULL);
 	  else
 	    {
 	      struct c_expr ce = c_parser_expression (parser);
@@ -6244,10 +6257,14 @@
   body = c_parser_c99_block_statement (parser, if_p, &loc_after_labels);
 
   if (is_foreach_statement)
-    objc_finish_foreach_loop (loc, object_expression, collection_expression, body, c_break_label, c_cont_label);
+    objc_finish_foreach_loop (for_loc, object_expression,
+			      collection_expression, body, c_break_label,
+			      c_cont_label);
   else
-    c_finish_loop (loc, cond, incr, body, c_break_label, c_cont_label, true);
-  add_stmt (c_end_compound_stmt (loc, block, flag_isoc99 || c_dialect_objc ()));
+    c_finish_loop (for_loc, cond_loc, cond, incr_loc, incr, body,
+		   c_break_label, c_cont_label, true);
+  add_stmt (c_end_compound_stmt (for_loc, block,
+				 flag_isoc99 || c_dialect_objc ()));
   c_parser_maybe_reclassify_token (parser);
 
   token_indent_info next_tinfo
@@ -13832,7 +13849,10 @@
     c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,
 			       "expected %<,%> or %<)%>");
 
-  check_no_duplicate_clause (list, OMP_CLAUSE_SCHEDULE, "schedule");
+  /* check_no_duplicate_clause (list, OMP_CLAUSE_DIST_SCHEDULE,
+				"dist_schedule"); */
+  if (omp_find_clause (list, OMP_CLAUSE_DIST_SCHEDULE))
+    warning_at (loc, 0, "too many %qs clauses", "dist_schedule");
   if (t == error_mark_node)
     return list;
 
@@ -18461,6 +18481,8 @@
 
   if (c_parser_peek_token (&tparser)->pragma_kind == PRAGMA_GCC_PCH_PREPROCESS)
     c_parser_pragma_pch_preprocess (&tparser);
+  else
+    c_common_no_more_pch ();
 
   the_parser = ggc_alloc<c_parser> ();
   *the_parser = tparser;
Index: gcc/c/c-typeck.c
===================================================================
diff --git a/gcc/c/c-typeck.c b/gcc/c/c-typeck.c
--- a/gcc/c/c-typeck.c	(revision 278653)
+++ b/gcc/c/c-typeck.c	(revision 278653)
@@ -10528,11 +10528,14 @@
    the beginning of the loop.  COND is the loop condition.  COND_IS_FIRST
    is false for DO loops.  INCR is the FOR increment expression.  BODY is
    the statement controlled by the loop.  BLAB is the break label.  CLAB is
-   the continue label.  Everything is allowed to be NULL.  */
+   the continue label.  Everything is allowed to be NULL.
+   COND_LOCUS is the location of the loop condition, INCR_LOCUS is the
+   location of the FOR increment expression.  */
 
 void
-c_finish_loop (location_t start_locus, tree cond, tree incr, tree body,
-	       tree blab, tree clab, bool cond_is_first)
+c_finish_loop (location_t start_locus, location_t cond_locus, tree cond,
+	       location_t incr_locus, tree incr, tree body, tree blab,
+	       tree clab, bool cond_is_first)
 {
   tree entry = NULL, exit = NULL, t;
 
@@ -10574,12 +10577,8 @@
 	    }
 
 	  t = build_and_jump (&blab);
-	  if (cond_is_first)
-	    exit = fold_build3_loc (start_locus,
-				COND_EXPR, void_type_node, cond, exit, t);
-	  else
-	    exit = fold_build3_loc (input_location,
-				COND_EXPR, void_type_node, cond, exit, t);
+	  exit = fold_build3_loc (cond_is_first ? start_locus : input_location,
+				  COND_EXPR, void_type_node, cond, exit, t);
 	}
       else
 	{
@@ -10600,9 +10599,23 @@
   if (clab)
     add_stmt (build1 (LABEL_EXPR, void_type_node, clab));
   if (incr)
-    add_stmt (incr);
+    {
+      if (MAY_HAVE_DEBUG_MARKER_STMTS && incr_locus != UNKNOWN_LOCATION)
+	{
+	  t = build0 (DEBUG_BEGIN_STMT, void_type_node);
+	  SET_EXPR_LOCATION (t, incr_locus);
+	  add_stmt (t);
+	}
+      add_stmt (incr);
+    }
   if (entry)
     add_stmt (entry);
+  if (MAY_HAVE_DEBUG_MARKER_STMTS && cond_locus != UNKNOWN_LOCATION)
+    {
+      t = build0 (DEBUG_BEGIN_STMT, void_type_node);
+      SET_EXPR_LOCATION (t, cond_locus);
+      add_stmt (t);
+    }
   if (exit)
     add_stmt (exit);
   if (blab)
Index: gcc/c/c-tree.h
===================================================================
diff --git a/gcc/c/c-tree.h b/gcc/c/c-tree.h
--- a/gcc/c/c-tree.h	(revision 278653)
+++ b/gcc/c/c-tree.h	(revision 278653)
@@ -684,7 +684,8 @@
 extern tree c_begin_compound_stmt (bool);
 extern tree c_end_compound_stmt (location_t, tree, bool);
 extern void c_finish_if_stmt (location_t, tree, tree, tree);
-extern void c_finish_loop (location_t, tree, tree, tree, tree, tree, bool);
+extern void c_finish_loop (location_t, location_t, tree, location_t, tree,
+			   tree, tree, tree, bool);
 extern tree c_begin_stmt_expr (void);
 extern tree c_finish_stmt_expr (location_t, tree);
 extern tree c_process_expr_stmt (location_t, tree);
Index: gcc/c/c-decl.c
===================================================================
diff --git a/gcc/c/c-decl.c b/gcc/c/c-decl.c
--- a/gcc/c/c-decl.c	(revision 278653)
+++ b/gcc/c/c-decl.c	(revision 278653)
@@ -2352,13 +2352,33 @@
       if (TYPE_NAME (TREE_TYPE (newdecl)) == newdecl)
 	{
 	  tree remove = TREE_TYPE (newdecl);
-	  for (tree t = TYPE_MAIN_VARIANT (remove); ;
-	       t = TYPE_NEXT_VARIANT (t))
-	    if (TYPE_NEXT_VARIANT (t) == remove)
-	      {
-		TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (remove);
-		break;
-	      }
+	  if (TYPE_MAIN_VARIANT (remove) == remove)
+	    {
+	      gcc_assert (TYPE_NEXT_VARIANT (remove) == NULL_TREE);
+	      /* If remove is the main variant, no need to remove that
+		 from the list.  One of the DECL_ORIGINAL_TYPE
+		 variants, e.g. created for aligned attribute, might still
+		 refer to the newdecl TYPE_DECL though, so remove that one
+		 in that case.  */
+	      if (DECL_ORIGINAL_TYPE (newdecl)
+		  && DECL_ORIGINAL_TYPE (newdecl) != remove)
+		for (tree t = TYPE_MAIN_VARIANT (DECL_ORIGINAL_TYPE (newdecl));
+		     t; t = TYPE_MAIN_VARIANT (t))
+		  if (TYPE_NAME (TYPE_NEXT_VARIANT (t)) == newdecl)
+		    {
+		      TYPE_NEXT_VARIANT (t)
+			= TYPE_NEXT_VARIANT (TYPE_NEXT_VARIANT (t));
+		      break;
+		    }
+	    }	    
+	  else
+	    for (tree t = TYPE_MAIN_VARIANT (remove); ;
+		 t = TYPE_NEXT_VARIANT (t))
+	      if (TYPE_NEXT_VARIANT (t) == remove)
+		{
+		  TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (remove);
+		  break;
+		}
 	}
     }
 
@@ -6436,10 +6456,12 @@
 		  quals_used &= TYPE_QUAL_ATOMIC;
 		if (quals_used && VOID_TYPE_P (type) && really_funcdef)
 		  pedwarn (specs_loc, 0,
-			   "function definition has qualified void return type");
+			   "function definition has qualified void "
+			   "return type");
 		else
 		  warning_at (specs_loc, OPT_Wignored_qualifiers,
-			   "type qualifiers ignored on function return type");
+			      "type qualifiers ignored on function "
+			      "return type");
 
 		/* Ensure an error for restrict on invalid types; the
 		   DR#423 resolution is not entirely clear about
@@ -6449,8 +6471,7 @@
 		    && (!POINTER_TYPE_P (type)
 			|| !C_TYPE_OBJECT_OR_INCOMPLETE_P (TREE_TYPE (type))))
 		  error_at (loc, "invalid use of %<restrict%>");
-		if (quals_used)
-		  type = c_build_qualified_type (type, quals_used);
+		type = c_build_qualified_type (type, quals_used);
 	      }
 	    type_quals = TYPE_UNQUALIFIED;
 
@@ -9485,7 +9506,8 @@
       && !C_FUNCTION_IMPLICIT_INT (fndecl)
       /* Normally, with -Wreturn-type, flow will complain, but we might
          optimize out static functions.  */
-      && !TREE_PUBLIC (fndecl))
+      && !TREE_PUBLIC (fndecl)
+      && targetm.warn_func_return (fndecl))
     {
       warning (OPT_Wreturn_type,
 	       "no return statement in function returning non-void");
Index: gcc/cgraph.c
===================================================================
diff --git a/gcc/cgraph.c b/gcc/cgraph.c
--- a/gcc/cgraph.c	(revision 278653)
+++ b/gcc/cgraph.c	(revision 278653)
@@ -3007,42 +3007,55 @@
   return redirect_callers;
 }
 
-/* Return TRUE if NODE2 a clone of NODE or is equivalent to it.  */
 
+/* Return TRUE if NODE2 a clone of NODE or is equivalent to it.  Return
+   optimistically true if this cannot be determined.  */
+
 static bool
 clone_of_p (cgraph_node *node, cgraph_node *node2)
 {
-  bool skipped_thunk = false;
   node = node->ultimate_alias_target ();
   node2 = node2->ultimate_alias_target ();
 
+  if (node2->clone_of == node
+      || node2->former_clone_of == node->decl)
+    return true;
+
+  if (!node->thunk.thunk_p && !node->former_thunk_p ())
+    {
+      while (node2 && node->decl != node2->decl)
+	node2 = node2->clone_of;
+      return node2 != NULL;
+    }
+
   /* There are no virtual clones of thunks so check former_clone_of or if we
      might have skipped thunks because this adjustments are no longer
      necessary.  */
-  while (node->thunk.thunk_p)
+  while (node->thunk.thunk_p || node->former_thunk_p ())
     {
-      if (node2->former_clone_of == node->decl)
-	return true;
       if (!node->thunk.this_adjusting)
 	return false;
+      /* In case of instrumented expanded thunks, which can have multiple calls
+	 in them, we do not know how to continue and just have to be
+	 optimistic.  */
+      if (node->callees->next_callee)
+	return true;
       node = node->callees->callee->ultimate_alias_target ();
-      skipped_thunk = true;
-    }
 
-  if (skipped_thunk)
-    {
       if (!node2->clone.args_to_skip
 	  || !bitmap_bit_p (node2->clone.args_to_skip, 0))
 	return false;
       if (node2->former_clone_of == node->decl)
 	return true;
-      else if (!node2->clone_of)
-	return false;
+
+      cgraph_node *n2 = node2;
+      while (n2 && node->decl != n2->decl)
+	n2 = n2->clone_of;
+      if (n2)
+	return true;
     }
 
-  while (node != node2 && node2)
-    node2 = node2->clone_of;
-  return node2 != NULL;
+  return false;
 }
 
 /* Verify edge count and frequency.  */
Index: gcc/cgraph.h
===================================================================
diff --git a/gcc/cgraph.h b/gcc/cgraph.h
--- a/gcc/cgraph.h	(revision 278653)
+++ b/gcc/cgraph.h	(revision 278653)
@@ -997,12 +997,17 @@
      If non-NULL BLOCK_TO_COPY determine what basic blocks to copy.
      If non_NULL NEW_ENTRY determine new entry BB of the clone.
 
+     If TARGET_ATTRIBUTES is non-null, when creating a new declaration,
+     add the attributes to DECL_ATTRIBUTES.  And call valid_attribute_p
+     that will promote value of the attribute DECL_FUNCTION_SPECIFIC_TARGET
+     of the declaration.
+
      Return the new version's cgraph node.  */
   cgraph_node *create_version_clone_with_body
     (vec<cgraph_edge *> redirect_callers,
      vec<ipa_replace_map *, va_gc> *tree_map, bitmap args_to_skip,
      bool skip_return, bitmap bbs_to_copy, basic_block new_entry_block,
-     const char *clone_name);
+     const char *clone_name, tree target_attributes = NULL_TREE);
 
   /* Insert a new cgraph_function_version_info node into cgraph_fnver_htab
      corresponding to cgraph_node.  */
@@ -1258,6 +1263,9 @@
      Note that at WPA stage, the function body may not be present in memory.  */
   inline bool has_gimple_body_p (void);
 
+  /* Return true if this node represents a former, i.e. an expanded, thunk.  */
+  inline bool former_thunk_p (void);
+
   /* Return true if function should be optimized for size.  */
   bool optimize_for_size_p (void);
 
@@ -2858,6 +2866,16 @@
   return definition && !thunk.thunk_p && !alias;
 }
 
+/* Return true if this node represents a former, i.e. an expanded, thunk.  */
+
+inline bool
+cgraph_node::former_thunk_p (void)
+{
+  return (!thunk.thunk_p
+	  && (thunk.fixed_offset
+	      || thunk.virtual_offset_p));
+}
+
 /* Walk all functions with body defined.  */
 #define FOR_EACH_FUNCTION_WITH_GIMPLE_BODY(node) \
    for ((node) = symtab->first_function_with_gimple_body (); (node); \
Index: gcc/cfgloopmanip.c
===================================================================
diff --git a/gcc/cfgloopmanip.c b/gcc/cfgloopmanip.c
--- a/gcc/cfgloopmanip.c	(revision 278653)
+++ b/gcc/cfgloopmanip.c	(revision 278653)
@@ -1019,6 +1019,7 @@
   target->warned_aggressive_loop_optimizations
     |= loop->warned_aggressive_loop_optimizations;
   target->in_oacc_kernels_region = loop->in_oacc_kernels_region;
+  target->owned_clique = loop->owned_clique;
 }
 
 /* Copies copy of LOOP as subloop of TARGET loop, placing newly
Index: gcc/optabs.c
===================================================================
diff --git a/gcc/optabs.c b/gcc/optabs.c
--- a/gcc/optabs.c	(revision 278653)
+++ b/gcc/optabs.c	(revision 278653)
@@ -5778,6 +5778,25 @@
   icode = get_vcond_icode (mode, cmp_op_mode, unsignedp);
   if (icode == CODE_FOR_nothing)
     {
+      if (tcode == LT_EXPR
+	  && op0a == op0
+	  && TREE_CODE (op0) == VECTOR_CST)
+	{
+	  /* A VEC_COND_EXPR condition could be folded from EQ_EXPR/NE_EXPR
+	     into a constant when only get_vcond_eq_icode is supported.
+	     Verify < 0 and != 0 behave the same and change it to NE_EXPR.  */
+	  unsigned HOST_WIDE_INT nelts;
+	  if (!VECTOR_CST_NELTS (op0).is_constant (&nelts))
+	    {
+	      if (VECTOR_CST_STEPPED_P (op0))
+		return 0;
+	      nelts = vector_cst_encoded_nelts (op0);
+	    }
+	  for (unsigned int i = 0; i < nelts; ++i)
+	    if (tree_int_cst_sgn (vector_cst_elt (op0, i)) == 1)
+	      return 0;
+	  tcode = NE_EXPR;
+	}
       if (tcode == EQ_EXPR || tcode == NE_EXPR)
 	icode = get_vcond_eq_icode (mode, cmp_op_mode);
       if (icode == CODE_FOR_nothing)
Index: gcc/DATESTAMP
===================================================================
diff --git a/gcc/DATESTAMP b/gcc/DATESTAMP
--- a/gcc/DATESTAMP	(revision 278653)
+++ b/gcc/DATESTAMP	(revision 278653)
@@ -1 +1 @@
-20190222
+20191124
Index: gcc/tree-ssa-loop-ch.c
===================================================================
diff --git a/gcc/tree-ssa-loop-ch.c b/gcc/tree-ssa-loop-ch.c
--- a/gcc/tree-ssa-loop-ch.c	(revision 278653)
+++ b/gcc/tree-ssa-loop-ch.c	(revision 278653)
@@ -99,7 +99,7 @@
     }
 
   last = last_stmt (header);
-  if (gimple_code (last) != GIMPLE_COND)
+  if (!last || gimple_code (last) != GIMPLE_COND)
     {
       if (dump_file && (dump_flags & TDF_DETAILS))
 	fprintf (dump_file,
@@ -376,11 +376,23 @@
 		{
 		  gimple *stmt = gsi_stmt (bsi);
 		  if (gimple_code (stmt) == GIMPLE_COND)
-		    gimple_set_no_warning (stmt, true);
+		    {
+		      tree lhs = gimple_cond_lhs (stmt);
+		      if (gimple_cond_code (stmt) != EQ_EXPR
+			  && gimple_cond_code (stmt) != NE_EXPR
+			  && INTEGRAL_TYPE_P (TREE_TYPE (lhs))
+			  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (lhs)))
+			gimple_set_no_warning (stmt, true);
+		    }
 		  else if (is_gimple_assign (stmt))
 		    {
 		      enum tree_code rhs_code = gimple_assign_rhs_code (stmt);
-		      if (TREE_CODE_CLASS (rhs_code) == tcc_comparison)
+		      tree rhs1 = gimple_assign_rhs1 (stmt);
+		      if (TREE_CODE_CLASS (rhs_code) == tcc_comparison
+			  && rhs_code != EQ_EXPR
+			  && rhs_code != NE_EXPR
+			  && INTEGRAL_TYPE_P (TREE_TYPE (rhs1))
+			  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (rhs1)))
 			gimple_set_no_warning (stmt, true);
 		    }
 		}
Index: gcc/tree-tailcall.c
===================================================================
diff --git a/gcc/tree-tailcall.c b/gcc/tree-tailcall.c
--- a/gcc/tree-tailcall.c	(revision 278653)
+++ b/gcc/tree-tailcall.c	(revision 278653)
@@ -37,6 +37,7 @@
 #include "tree-into-ssa.h"
 #include "tree-dfa.h"
 #include "except.h"
+#include "tree-eh.h"
 #include "dbgcnt.h"
 #include "cfgloop.h"
 #include "common/common-target.h"
@@ -472,6 +473,12 @@
       && !auto_var_in_fn_p (ass_var, cfun->decl))
     return;
 
+  /* If the call might throw an exception that wouldn't propagate out of
+     cfun, we can't transform to a tail or sibling call (82081).  */
+  if (stmt_could_throw_p (stmt)
+      && !stmt_can_throw_external (stmt))
+    return;
+
   /* We found the call, check whether it is suitable.  */
   tail_recursion = false;
   func = gimple_call_fndecl (call);
Index: gcc/tree-ssa-strlen.c
===================================================================
diff --git a/gcc/tree-ssa-strlen.c b/gcc/tree-ssa-strlen.c
--- a/gcc/tree-ssa-strlen.c	(revision 278653)
+++ b/gcc/tree-ssa-strlen.c	(revision 278653)
@@ -996,10 +996,18 @@
     return false;
 
   tree callee = gimple_call_fndecl (stmt);
+  tree decl = builtin_decl_explicit (DECL_FUNCTION_CODE (callee));
+  if (decl
+      && decl != callee
+      && !gimple_builtin_call_types_compatible_p (stmt, decl))
+    return false;
+
   switch (DECL_FUNCTION_CODE (callee))
     {
     case BUILT_IN_MEMCMP:
     case BUILT_IN_MEMCMP_EQ:
+    case BUILT_IN_STRCMP:
+    case BUILT_IN_STRNCMP:
     case BUILT_IN_STRCHR:
     case BUILT_IN_STRCHR_CHKP:
     case BUILT_IN_STRLEN:
@@ -1024,6 +1032,8 @@
     case BUILT_IN_STPCPY_CHK:
     case BUILT_IN_STPCPY_CHKP:
     case BUILT_IN_STPCPY_CHK_CHKP:
+    case BUILT_IN_STPNCPY:
+    case BUILT_IN_STPNCPY_CHK:
     case BUILT_IN_STRCAT:
     case BUILT_IN_STRCAT_CHK:
     case BUILT_IN_STRCAT_CHKP:
@@ -1032,6 +1042,10 @@
     case BUILT_IN_STRCPY_CHK:
     case BUILT_IN_STRCPY_CHKP:
     case BUILT_IN_STRCPY_CHK_CHKP:
+    case BUILT_IN_STRNCAT:
+    case BUILT_IN_STRNCAT_CHK:
+    case BUILT_IN_STRNCPY:
+    case BUILT_IN_STRNCPY_CHK:
       /* The above functions should be neither const nor pure.  Punt if they
 	 aren't.  */
       if (gimple_vdef (stmt) == NULL_TREE || gimple_vuse (stmt) == NULL_TREE)
Index: gcc/tree.c
===================================================================
diff --git a/gcc/tree.c b/gcc/tree.c
--- a/gcc/tree.c	(revision 278653)
+++ b/gcc/tree.c	(revision 278653)
@@ -5133,8 +5133,7 @@
 	  free_lang_data_in_binfo (TYPE_BINFO (type));
 	  /* We need to preserve link to bases and virtual table for all
 	     polymorphic types to make devirtualization machinery working.  */
-	  if (!BINFO_VTABLE (TYPE_BINFO (type))
-	      || !flag_devirtualize)
+	  if (!BINFO_VTABLE (TYPE_BINFO (type)))
 	    TYPE_BINFO (type) = NULL;
 	}
     }
Index: gcc/tree.h
===================================================================
diff --git a/gcc/tree.h b/gcc/tree.h
--- a/gcc/tree.h	(revision 278653)
+++ b/gcc/tree.h	(revision 278653)
@@ -909,6 +909,11 @@
   (TREE_CHECK2 (NODE, VAR_DECL, \
 		RESULT_DECL)->decl_common.decl_nonshareable_flag)
 
+/* In a PARM_DECL, set for Fortran hidden string length arguments that some
+   buggy callers don't pass to the callee.  */
+#define DECL_HIDDEN_STRING_LENGTH(NODE) \
+  (TREE_CHECK (NODE, PARM_DECL)->decl_common.decl_nonshareable_flag)
+
 /* In a CALL_EXPR, means that the call is the jump from a thunk to the
    thunked-to function.  */
 #define CALL_FROM_THUNK_P(NODE) (CALL_EXPR_CHECK (NODE)->base.protected_flag)
Index: gcc/ipa-cp.c
===================================================================
diff --git a/gcc/ipa-cp.c b/gcc/ipa-cp.c
--- a/gcc/ipa-cp.c	(revision 278653)
+++ b/gcc/ipa-cp.c	(revision 278653)
@@ -1082,7 +1082,6 @@
   if (TREE_CODE_CLASS (code) == tcc_binary)
     {
       tree type = TREE_TYPE (operand);
-      gcc_assert (INTEGRAL_TYPE_P (type));
       widest_int o_value, o_mask;
       get_value_and_mask (operand, &o_value, &o_mask);
 
@@ -2852,12 +2851,19 @@
   base_time -= time;
   if (base_time > 65535)
     base_time = 65535;
-  time_benefit = base_time.to_int ()
-    + devirtualization_time_bonus (node, known_csts, known_contexts,
-				   known_aggs_ptrs)
-    + hint_time_bonus (hints)
-    + removable_params_cost + est_move_cost;
 
+  /* Extern inline functions have no cloning local time benefits because they
+     will be inlined anyway.  The only reason to clone them is if it enables
+     optimization in any of the functions they call.  */
+  if (DECL_EXTERNAL (node->decl) && DECL_DECLARED_INLINE_P (node->decl))
+    time_benefit = 0;
+  else
+    time_benefit = base_time.to_int ()
+      + devirtualization_time_bonus (node, known_csts, known_contexts,
+				     known_aggs_ptrs)
+      + hint_time_bonus (hints)
+      + removable_params_cost + est_move_cost;
+
   gcc_checking_assert (size >=0);
   /* The inliner-heuristics based estimates may think that in certain
      contexts some functions do not have any size at all but we want
Index: gcc/tree-scalar-evolution.c
===================================================================
diff --git a/gcc/tree-scalar-evolution.c b/gcc/tree-scalar-evolution.c
--- a/gcc/tree-scalar-evolution.c	(revision 278653)
+++ b/gcc/tree-scalar-evolution.c	(revision 278653)
@@ -875,7 +875,7 @@
       gimple *stmt;
 
       stmt = last_stmt (exit_edge->src);
-      if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))
+      if (gcond *cond_stmt = safe_dyn_cast <gcond *> (stmt))
 	res = cond_stmt;
     }
 
@@ -1421,6 +1421,11 @@
       return build_polynomial_chrec (loop->num, init_cond, right);
     }
 
+  /* The affine code only deals with pointer and integer types.  */
+  if (!POINTER_TYPE_P (type)
+      && !INTEGRAL_TYPE_P (type))
+    return chrec_dont_know;
+
   /* Try harder to check if they are equal.  */
   tree_to_aff_combination_expand (left, type, &aff1, &peeled_chrec_map);
   tree_to_aff_combination_expand (step_val, type, &aff2, &peeled_chrec_map);
Index: gcc/rtlanal.c
===================================================================
diff --git a/gcc/rtlanal.c b/gcc/rtlanal.c
--- a/gcc/rtlanal.c	(revision 278653)
+++ b/gcc/rtlanal.c	(revision 278653)
@@ -358,10 +358,10 @@
   if (to == from)
     return 0;
 
-  /* It is not safe to call INITIAL_ELIMINATION_OFFSET
-     before the reload pass.  We need to give at least
-     an estimation for the resulting frame size.  */
-  if (! reload_completed)
+  /* It is not safe to call INITIAL_ELIMINATION_OFFSET before the epilogue
+     is completed, but we need to give at least an estimate for the stack
+     pointer based on the frame size.  */
+  if (!epilogue_completed)
     {
       offset1 = crtl->outgoing_args_size + get_frame_size ();
 #if !STACK_GROWS_DOWNWARD
@@ -4756,7 +4756,7 @@
 	       || ((extend_op = load_extend_op (inner_mode)) == SIGN_EXTEND
 		   ? val_signbit_known_set_p (inner_mode, nonzero)
 		   : extend_op != ZERO_EXTEND)
-	       || (!MEM_P (SUBREG_REG (x)) && !REG_P (SUBREG_REG (x))))
+	       || !MEM_P (SUBREG_REG (x)))
 	      && xmode_width > inner_width)
 	    nonzero
 	      |= (GET_MODE_MASK (GET_MODE (x)) & ~GET_MODE_MASK (inner_mode));
Index: gcc/configure
===================================================================
diff --git a/gcc/configure b/gcc/configure
--- a/gcc/configure	(revision 278653)
+++ b/gcc/configure	(revision 278653)
@@ -666,6 +666,7 @@
 all_selected_languages
 all_languages
 all_lang_makefrags
+all_lang_configurefrags
 all_gtfiles
 all_compilers
 srcdir
@@ -18448,7 +18449,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 18451 "configure"
+#line 18452 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -18554,7 +18555,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 18557 "configure"
+#line 18558 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -22799,17 +22800,13 @@
 	#
 	# ld: Software Generation Utilities - Solaris Link Editors: 5.11-1.1701:onnv-ab196087-6931056-03/25/10
 	#
-	# In Solaris 11.4, this was changed to
-	#
-	# ld: Solaris ELF Utilities: 11.4-1.3123
-	#
 	# ld and ld.so.1 are guaranteed to be updated in lockstep, so ld version
 	# numbers can be used in ld.so.1 feature checks even if a different
 	# linker is configured.
 	ld_ver=`$gcc_cv_ld -V 2>&1`
-	if echo "$ld_ver" | $EGREP 'Solaris Link Editors|Solaris ELF Utilities' > /dev/null; then
+	if echo "$ld_ver" | grep 'Solaris Link Editors' > /dev/null; then
 	  ld_vers=`echo $ld_ver | sed -n \
-	    -e 's,^.*: \(5\|1[0-9]\)\.[0-9][0-9]*-\([0-9]\.[0-9][0-9]*\).*$,\2,p'`
+	    -e 's,^.*: 5\.[0-9][0-9]*-\([0-9]\.[0-9][0-9]*\).*$,\1,p'`
 	  ld_vers_major=`expr "$ld_vers" : '\([0-9]*\)'`
 	  ld_vers_minor=`expr "$ld_vers" : '[0-9]*\.\([0-9]*\)'`
 	fi
@@ -29516,7 +29513,8 @@
 all_languages=
 all_compilers=
 all_outputs='Makefile'
-# List of language makefile fragments.
+# List of language configure and makefile fragments.
+all_lang_configurefrags=
 all_lang_makefrags=
 # Additional files for gengtype
 all_gtfiles="$target_gtfiles"
@@ -29602,6 +29600,7 @@
 	esac
 	$ok || continue
 
+	all_lang_configurefrags="$all_lang_configurefrags \$(srcdir)/$gcc_subdir/config-lang.in"
 	all_lang_makefrags="$all_lang_makefrags \$(srcdir)/$gcc_subdir/Make-lang.in"
 	if test -f $srcdir/$gcc_subdir/lang.opt; then
 	    lang_opt_files="$lang_opt_files $srcdir/$gcc_subdir/lang.opt"
@@ -29752,6 +29751,7 @@
 
 
 
+
 
 
 
Index: gcc/internal-fn.c
===================================================================
diff --git a/gcc/internal-fn.c b/gcc/internal-fn.c
--- a/gcc/internal-fn.c	(revision 278653)
+++ b/gcc/internal-fn.c	(revision 278653)
@@ -1385,7 +1385,7 @@
   /* s1 * s2 -> ur  */
   if (!uns0_p && !uns1_p && unsr_p)
     {
-      rtx tem, tem2;
+      rtx tem;
       switch (pos_neg0 | pos_neg1)
 	{
 	case 1: /* Both operands known to be non-negative.  */
@@ -1415,10 +1415,8 @@
 	      ops.op2 = NULL_TREE;
 	      ops.location = loc;
 	      res = expand_expr_real_2 (&ops, NULL_RTX, mode, EXPAND_NORMAL);
-	      tem = expand_binop (mode, and_optab, op0, op1, NULL_RTX, false,
-				  OPTAB_LIB_WIDEN);
-	      do_compare_rtx_and_jump (tem, const0_rtx, EQ, true, mode,
-				       NULL_RTX, NULL, done_label,
+	      do_compare_rtx_and_jump (pos_neg0 == 1 ? op0 : op1, const0_rtx, EQ,
+				       true, mode, NULL_RTX, NULL, done_label,
 				       profile_probability::very_likely ());
 	      goto do_error_label;
 	    }
@@ -1449,16 +1447,23 @@
 	  arg1 = error_mark_node;
 	  emit_jump (do_main_label);
 	  emit_label (after_negate_label);
-	  tem2 = expand_binop (mode, xor_optab, op0, op1, NULL_RTX, false,
-			       OPTAB_LIB_WIDEN);
-	  do_compare_rtx_and_jump (tem2, const0_rtx, GE, false, mode, NULL_RTX,
-				   NULL, do_main_label, profile_probability::very_likely ());
+	  tem = expand_binop (mode, xor_optab, op0, op1, NULL_RTX, false,
+			      OPTAB_LIB_WIDEN);
+	  do_compare_rtx_and_jump (tem, const0_rtx, GE, false, mode, NULL_RTX,
+				   NULL, do_main_label,
+				   profile_probability::very_likely ());
 	  /* One argument is negative here, the other positive.  This
 	     overflows always, unless one of the arguments is 0.  But
 	     if e.g. s2 is 0, (U) s1 * 0 doesn't overflow, whatever s1
 	     is, thus we can keep do_main code oring in overflow as is.  */
-	  do_compare_rtx_and_jump (tem, const0_rtx, EQ, true, mode, NULL_RTX,
-				   NULL, do_main_label, profile_probability::very_likely ());
+	  if (pos_neg0 != 2)
+	    do_compare_rtx_and_jump (op0, const0_rtx, EQ, true, mode, NULL_RTX,
+				     NULL, do_main_label,
+				     profile_probability::very_unlikely ());
+	  if (pos_neg1 != 2)
+	    do_compare_rtx_and_jump (op1, const0_rtx, EQ, true, mode, NULL_RTX,
+				     NULL, do_main_label,
+				     profile_probability::very_unlikely ());
 	  expand_arith_set_overflow (lhs, target);
 	  emit_label (do_main_label);
 	  goto do_main;
Index: gcc/builtins.c
===================================================================
diff --git a/gcc/builtins.c b/gcc/builtins.c
--- a/gcc/builtins.c	(revision 278653)
+++ b/gcc/builtins.c	(revision 278653)
@@ -2560,7 +2560,7 @@
   tree arg;
 
   if (!validate_arglist (exp, REAL_TYPE, VOID_TYPE))
-    gcc_unreachable ();
+    return NULL_RTX;
 
   arg = CALL_EXPR_ARG (exp, 0);
 
@@ -2696,7 +2696,7 @@
   enum built_in_function fallback_fn = BUILT_IN_NONE;
 
   if (!validate_arglist (exp, REAL_TYPE, VOID_TYPE))
-     gcc_unreachable ();
+    return NULL_RTX;
 
   arg = CALL_EXPR_ARG (exp, 0);
 
@@ -10088,6 +10088,9 @@
 static void
 maybe_emit_free_warning (tree exp)
 {
+  if (call_expr_nargs (exp) != 1)
+    return;
+
   tree arg = CALL_EXPR_ARG (exp, 0);
 
   STRIP_NOPS (arg);
Index: gcc/input.c
===================================================================
diff --git a/gcc/input.c b/gcc/input.c
--- a/gcc/input.c	(revision 278653)
+++ b/gcc/input.c	(revision 278653)
@@ -3538,6 +3538,34 @@
   ASSERT_EQ (num_cases_tested, 2 * 12);
 }
 
+/* Verify that when presented with a consecutive pair of locations with
+   a very large line offset, we don't attempt to consolidate them into
+   a single ordinary linemap where the line offsets within the line map
+   would lead to overflow (PR lto/88147).  */
+
+static void
+test_line_offset_overflow ()
+{
+  line_table_test ltt (line_table_case (5, 0));
+
+  linemap_add (line_table, LC_ENTER, false, "foo.c", 0);
+  linemap_line_start (line_table, 1, 100);
+  location_t loc_a = linemap_line_start (line_table, 2578, 255);
+  assert_loceq ("foo.c", 2578, 0, loc_a);
+
+  const line_map_ordinary *ordmap_a = LINEMAPS_LAST_ORDINARY_MAP (line_table);
+  ASSERT_EQ (ordmap_a->m_column_and_range_bits, 13);
+  ASSERT_EQ (ordmap_a->m_range_bits, 5);
+
+  location_t loc_b = linemap_line_start (line_table, 404198, 512);
+  assert_loceq ("foo.c", 404198, 0, loc_b);
+
+  /* We should have started a new linemap, rather than attempting to store
+     a very large line offset.  */
+  const line_map_ordinary *ordmap_b = LINEMAPS_LAST_ORDINARY_MAP (line_table);
+  ASSERT_NE (ordmap_a, ordmap_b);
+}
+
 /* Run all of the selftests within this file.  */
 
 void
@@ -3577,6 +3605,8 @@
   for_each_line_table_case (test_lexer_char_constants);
 
   test_reading_source_line ();
+
+  test_line_offset_overflow ();
 }
 
 } // namespace selftest
Index: gcc/cfghooks.c
===================================================================
diff --git a/gcc/cfghooks.c b/gcc/cfghooks.c
--- a/gcc/cfghooks.c	(revision 278653)
+++ b/gcc/cfghooks.c	(revision 278653)
@@ -1066,7 +1066,7 @@
    AFTER.  */
 
 basic_block
-duplicate_block (basic_block bb, edge e, basic_block after)
+duplicate_block (basic_block bb, edge e, basic_block after, copy_bb_data *id)
 {
   edge s, n;
   basic_block new_bb;
@@ -1082,7 +1082,7 @@
 
   gcc_checking_assert (can_duplicate_block_p (bb));
 
-  new_bb = cfg_hooks->duplicate_block (bb);
+  new_bb = cfg_hooks->duplicate_block (bb, id);
   if (after)
     move_block_after (new_bb, after);
 
@@ -1337,6 +1337,7 @@
   unsigned i, j;
   basic_block bb, new_bb, dom_bb;
   edge e;
+  copy_bb_data id;
 
   /* Mark the blocks to be copied.  This is used by edge creation hooks
      to decide whether to reallocate PHI nodes capacity to avoid reallocating
@@ -1349,7 +1350,7 @@
     {
       /* Duplicate.  */
       bb = bbs[i];
-      new_bb = new_bbs[i] = duplicate_block (bb, NULL, after);
+      new_bb = new_bbs[i] = duplicate_block (bb, NULL, after, &id);
       after = new_bb;
       if (bb->loop_father)
 	{
Index: gcc/cfghooks.h
===================================================================
diff --git a/gcc/cfghooks.h b/gcc/cfghooks.h
--- a/gcc/cfghooks.h	(revision 278653)
+++ b/gcc/cfghooks.h	(revision 278653)
@@ -54,7 +54,20 @@
   bool run;
 };
 
+typedef int_hash <unsigned short, 0> dependence_hash;
 
+/* Optional data for duplicate_block.   */
+
+struct copy_bb_data
+{
+  copy_bb_data() : dependence_map (NULL) {}
+  ~copy_bb_data () { delete dependence_map; }
+
+  /* A map from the copied BBs dependence info cliques to
+     equivalents in the BBs duplicated to.  */
+  hash_map<dependence_hash, unsigned short> *dependence_map;
+};
+
 struct cfg_hooks
 {
   /* Name of the corresponding ir.  */
@@ -112,7 +125,7 @@
   bool (*can_duplicate_block_p) (const_basic_block a);
 
   /* Duplicate block A.  */
-  basic_block (*duplicate_block) (basic_block a);
+  basic_block (*duplicate_block) (basic_block a, copy_bb_data *);
 
   /* Higher level functions representable by primitive operations above if
      we didn't have some oddities in RTL and Tree representations.  */
@@ -227,7 +240,8 @@
 extern void predict_edge (edge e, enum br_predictor predictor, int probability);
 extern bool predicted_by_p (const_basic_block bb, enum br_predictor predictor);
 extern bool can_duplicate_block_p (const_basic_block);
-extern basic_block duplicate_block (basic_block, edge, basic_block);
+extern basic_block duplicate_block (basic_block, edge, basic_block,
+				    copy_bb_data * = NULL);
 extern bool block_ends_with_call_p (basic_block bb);
 extern bool empty_block_p (basic_block);
 extern basic_block split_block_before_cond_jump (basic_block);
Index: gcc/fold-const.c
===================================================================
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
--- a/gcc/fold-const.c	(revision 278653)
+++ b/gcc/fold-const.c	(revision 278653)
@@ -3179,10 +3179,16 @@
       switch (TREE_CODE (arg0))
 	{
 	case INDIRECT_REF:
-	  if (!(flags & OEP_ADDRESS_OF)
-	      && (TYPE_ALIGN (TREE_TYPE (arg0))
-		  != TYPE_ALIGN (TREE_TYPE (arg1))))
-	    return 0;
+	  if (!(flags & OEP_ADDRESS_OF))
+	    {
+	      if (TYPE_ALIGN (TREE_TYPE (arg0))
+		  != TYPE_ALIGN (TREE_TYPE (arg1)))
+		return 0;
+	      /* Verify that the access types are compatible.  */
+	      if (TYPE_MAIN_VARIANT (TREE_TYPE (arg0))
+		  != TYPE_MAIN_VARIANT (TREE_TYPE (arg1)))
+		return 0;
+	    }
 	  flags &= ~OEP_ADDRESS_OF;
 	  return OP_SAME (0);
 
@@ -4239,7 +4245,7 @@
      There are problems with FP fields since the type_for_size call
      below can fail for, e.g., XFmode.  */
   if (! INTEGRAL_TYPE_P (TREE_TYPE (exp)))
-    return 0;
+    return NULL_TREE;
 
   /* We are interested in the bare arrangement of bits, so strip everything
      that doesn't affect the machine mode.  However, record the type of the
@@ -4255,7 +4261,7 @@
       exp = TREE_OPERAND (exp, 0);
       STRIP_NOPS (exp); STRIP_NOPS (and_mask);
       if (TREE_CODE (and_mask) != INTEGER_CST)
-	return 0;
+	return NULL_TREE;
     }
 
   poly_int64 poly_bitsize, poly_bitpos;
@@ -4271,8 +4277,12 @@
       || (! AGGREGATE_TYPE_P (TREE_TYPE (inner))
 	  && compare_tree_int (TYPE_SIZE (TREE_TYPE (inner)),
 			       *pbitpos + *pbitsize) < 0))
-    return 0;
+    return NULL_TREE;
 
+  unsigned_type = lang_hooks.types.type_for_size (*pbitsize, 1);
+  if (unsigned_type == NULL_TREE)
+    return NULL_TREE;
+
   *exp_ = exp;
 
   /* If the number of bits in the reference is the same as the bitsize of
@@ -4282,7 +4292,6 @@
     *punsignedp = TYPE_UNSIGNED (outer_type);
 
   /* Compute the mask to access the bitfield.  */
-  unsigned_type = lang_hooks.types.type_for_size (*pbitsize, 1);
   precision = TYPE_PRECISION (unsigned_type);
 
   mask = build_int_cst_type (unsigned_type, -1);
@@ -5515,12 +5524,15 @@
   /* On machines where the branch cost is expensive, if this is a
      short-circuited branch and the underlying object on both sides
      is the same, make a non-short-circuit operation.  */
-  else if (LOGICAL_OP_NON_SHORT_CIRCUIT
-	   && !flag_sanitize_coverage
-	   && lhs != 0 && rhs != 0
-	   && (code == TRUTH_ANDIF_EXPR
-	       || code == TRUTH_ORIF_EXPR)
-	   && operand_equal_p (lhs, rhs, 0))
+  bool logical_op_non_short_circuit = LOGICAL_OP_NON_SHORT_CIRCUIT;
+  if (PARAM_VALUE (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT) != -1)
+    logical_op_non_short_circuit
+      = PARAM_VALUE (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT);
+  if (logical_op_non_short_circuit
+      && !flag_sanitize_coverage
+      && lhs != 0 && rhs != 0
+      && (code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR)
+      && operand_equal_p (lhs, rhs, 0))
     {
       /* If simple enough, just rewrite.  Otherwise, make a SAVE_EXPR
 	 unless we are at top level or LHS contains a PLACEHOLDER_EXPR, in
@@ -8165,7 +8177,11 @@
   if ((tem = fold_truth_andor_1 (loc, code, type, arg0, arg1)) != 0)
     return tem;
 
-  if (LOGICAL_OP_NON_SHORT_CIRCUIT
+  bool logical_op_non_short_circuit = LOGICAL_OP_NON_SHORT_CIRCUIT;
+  if (PARAM_VALUE (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT) != -1)
+    logical_op_non_short_circuit
+      = PARAM_VALUE (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT);
+  if (logical_op_non_short_circuit
       && !flag_sanitize_coverage
       && (code == TRUTH_AND_EXPR
           || code == TRUTH_ANDIF_EXPR
@@ -13994,13 +14010,13 @@
 	    {
 	      tree elem0 = VECTOR_CST_ELT (op0, i);
 	      tree elem1 = VECTOR_CST_ELT (op1, i);
-	      tree tmp = fold_relational_const (code, type, elem0, elem1);
+	      tree tmp = fold_relational_const (EQ_EXPR, type, elem0, elem1);
 	      if (tmp == NULL_TREE)
 		return NULL_TREE;
 	      if (integer_zerop (tmp))
-		return constant_boolean_node (false, type);
+		return constant_boolean_node (code == NE_EXPR, type);
 	    }
-	  return constant_boolean_node (true, type);
+	  return constant_boolean_node (code == EQ_EXPR, type);
 	}
       tree_vector_builder elts;
       if (!elts.new_binary_operation (type, op0, op1, false))
@@ -14671,6 +14687,7 @@
   tree type = build_vector_type (inner_type, 4);
   tree zero = build_zero_cst (type);
   tree one = build_one_cst (type);
+  tree index = build_index_vector (type, 0, 1);
 
   /* Verify equality tests that return a scalar boolean result.  */
   tree res_type = boolean_type_node;
@@ -14678,6 +14695,13 @@
   ASSERT_TRUE (integer_nonzerop (fold_build2 (EQ_EXPR, res_type, zero, zero)));
   ASSERT_TRUE (integer_nonzerop (fold_build2 (NE_EXPR, res_type, zero, one)));
   ASSERT_FALSE (integer_nonzerop (fold_build2 (NE_EXPR, res_type, one, one)));
+  ASSERT_TRUE (integer_nonzerop (fold_build2 (NE_EXPR, res_type, index, one)));
+  ASSERT_FALSE (integer_nonzerop (fold_build2 (EQ_EXPR, res_type,
+					       index, one)));
+  ASSERT_FALSE (integer_nonzerop (fold_build2 (NE_EXPR, res_type,
+					      index, index)));
+  ASSERT_TRUE (integer_nonzerop (fold_build2 (EQ_EXPR, res_type,
+					      index, index)));
 }
 
 /* Verify folding of VEC_DUPLICATE_EXPRs.  */
Index: gcc/gimple-ssa-sprintf.c
===================================================================
diff --git a/gcc/gimple-ssa-sprintf.c b/gcc/gimple-ssa-sprintf.c
--- a/gcc/gimple-ssa-sprintf.c	(revision 278653)
+++ b/gcc/gimple-ssa-sprintf.c	(revision 278653)
@@ -376,9 +376,14 @@
      overlong strings just like the translated strings are.  */
   if (target_to_host_charmap['\0'] == 1)
     {
-      strncpy (hostr, targstr, hostsz - 4);
-      if (strlen (targstr) >= hostsz)
-	strcpy (hostr + hostsz - 4, "...");
+      size_t len = strlen (targstr);
+      if (len >= hostsz)
+	{
+	  memcpy (hostr, targstr, hostsz - 4);
+	  strcpy (hostr + hostsz - 4, "...");
+	}
+      else
+	memcpy (hostr, targstr, len + 1);
       return hostr;
     }
 
@@ -392,10 +397,9 @@
       if (!*targstr)
 	break;
 
-      if (size_t (ph - hostr) == hostsz - 4)
+      if (size_t (ph - hostr) == hostsz)
 	{
-	  *ph = '\0';
-	  strcat (ph, "...");
+	  strcpy (ph - 4, "...");
 	  break;
 	}
     }
@@ -3662,10 +3666,10 @@
 	 are badly declared.  */
       && !stmt_ends_bb_p (info.callstmt))
     {
-      tree cst = build_int_cst (integer_type_node, retval[0]);
+      tree cst = build_int_cst (lhs ? TREE_TYPE (lhs) : integer_type_node,
+				retval[0]);
 
-      if (lhs == NULL_TREE
-	  && info.nowrite)
+      if (lhs == NULL_TREE && info.nowrite)
 	{
 	  /* Remove the call to the bounded function with a zero size
 	     (e.g., snprintf(0, 0, "%i", 123)) if there is no lhs.  */
@@ -3706,7 +3710,7 @@
 	    }
 	}
     }
-  else if (lhs)
+  else if (lhs && types_compatible_p (TREE_TYPE (lhs), integer_type_node))
     {
       bool setrange = false;
 
Index: gcc/omp-low.c
===================================================================
diff --git a/gcc/omp-low.c b/gcc/omp-low.c
--- a/gcc/omp-low.c	(revision 278653)
+++ b/gcc/omp-low.c	(revision 278653)
@@ -851,6 +851,7 @@
       ctx->cb.copy_decl = omp_copy_decl;
       ctx->cb.eh_lp_nr = 0;
       ctx->cb.transform_call_graph_edges = CB_CGE_MOVE;
+      ctx->cb.dont_remap_vla_if_no_change = true;
       ctx->depth = 1;
     }
 
Index: gcc/objc/ChangeLog
===================================================================
diff --git a/gcc/objc/ChangeLog b/gcc/objc/ChangeLog
--- a/gcc/objc/ChangeLog	(revision 278653)
+++ b/gcc/objc/ChangeLog	(revision 278653)
@@ -1,3 +1,22 @@
+2019-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR pch/90326
+	* config-lang.in (gtfiles): Add c-family/c-format.c.
+
+2019-08-28  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* objc/objc-act.h (OCTI_INSTANCE_TYPE, OCTI_INSTANCETYPE_NAME): New.
+	(objc_global_trees): Add instance type and name.
+	(INSTANCE_TYPEDEF_NAME): New.
+	* objc/objc-act.c (synth_module_prologue): Build decls for
+	objc_instancetype_type and objc_instancetype_name.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: gcc/objc/config-lang.in
===================================================================
diff --git a/gcc/objc/config-lang.in b/gcc/objc/config-lang.in
--- a/gcc/objc/config-lang.in	(revision 278653)
+++ b/gcc/objc/config-lang.in	(revision 278653)
@@ -35,4 +35,4 @@
 # Order is important.  If you change this list, make sure you test
 # building without C++ as well; that is, remove the gcc/cp directory,
 # and build with --enable-languages=c,objc.
-gtfiles="\$(srcdir)/objc/objc-map.h \$(srcdir)/c-family/c-objc.h \$(srcdir)/objc/objc-act.h \$(srcdir)/objc/objc-act.c \$(srcdir)/objc/objc-runtime-shared-support.c \$(srcdir)/objc/objc-gnu-runtime-abi-01.c \$(srcdir)/objc/objc-next-runtime-abi-01.c \$(srcdir)/objc/objc-next-runtime-abi-02.c \$(srcdir)/c/c-parser.h \$(srcdir)/c/c-parser.c \$(srcdir)/c/c-tree.h \$(srcdir)/c/c-decl.c \$(srcdir)/c/c-lang.h \$(srcdir)/c/c-objc-common.c \$(srcdir)/c-family/c-common.c \$(srcdir)/c-family/c-common.h \$(srcdir)/c-family/c-cppbuiltin.c \$(srcdir)/c-family/c-pragma.h \$(srcdir)/c-family/c-pragma.c"
+gtfiles="\$(srcdir)/objc/objc-map.h \$(srcdir)/c-family/c-objc.h \$(srcdir)/objc/objc-act.h \$(srcdir)/objc/objc-act.c \$(srcdir)/objc/objc-runtime-shared-support.c \$(srcdir)/objc/objc-gnu-runtime-abi-01.c \$(srcdir)/objc/objc-next-runtime-abi-01.c \$(srcdir)/objc/objc-next-runtime-abi-02.c \$(srcdir)/c/c-parser.h \$(srcdir)/c/c-parser.c \$(srcdir)/c/c-tree.h \$(srcdir)/c/c-decl.c \$(srcdir)/c/c-lang.h \$(srcdir)/c/c-objc-common.c \$(srcdir)/c-family/c-common.c \$(srcdir)/c-family/c-common.h \$(srcdir)/c-family/c-cppbuiltin.c \$(srcdir)/c-family/c-pragma.h \$(srcdir)/c-family/c-pragma.c \$(srcdir)/c-family/c-format.c"
Index: gcc/objc/objc-act.c
===================================================================
diff --git a/gcc/objc/objc-act.c b/gcc/objc/objc-act.c
--- a/gcc/objc/objc-act.c	(revision 278653)
+++ b/gcc/objc/objc-act.c	(revision 278653)
@@ -2944,12 +2944,14 @@
   objc_class_reference = xref_tag (RECORD_TYPE, objc_class_id);
 
   objc_object_type = build_pointer_type (objc_object_reference);
+  objc_instancetype_type = build_pointer_type (objc_object_reference);
   objc_class_type = build_pointer_type (objc_class_reference);
 
   objc_object_name = get_identifier (OBJECT_TYPEDEF_NAME);
+  objc_instancetype_name = get_identifier (INSTANCE_TYPEDEF_NAME);
   objc_class_name = get_identifier (CLASS_TYPEDEF_NAME);
 
-  /* Declare the 'id' and 'Class' typedefs.  */
+  /* Declare the 'id', 'instancetype' and 'Class' typedefs.  */
   type = lang_hooks.decls.pushdecl (build_decl (input_location,
 						TYPE_DECL,
 						objc_object_name,
@@ -2958,6 +2960,12 @@
 
   type = lang_hooks.decls.pushdecl (build_decl (input_location,
 						TYPE_DECL,
+						objc_instancetype_name,
+						objc_instancetype_type));
+  TREE_NO_WARNING (type) = 1;
+
+  type = lang_hooks.decls.pushdecl (build_decl (input_location,
+						TYPE_DECL,
 						objc_class_name,
 						objc_class_type));
   TREE_NO_WARNING (type) = 1;
Index: gcc/objc/objc-act.h
===================================================================
diff --git a/gcc/objc/objc-act.h b/gcc/objc/objc-act.h
--- a/gcc/objc/objc-act.h	(revision 278653)
+++ b/gcc/objc/objc-act.h	(revision 278653)
@@ -313,6 +313,7 @@
     OCTI_SUPER_TYPE,
     OCTI_SEL_TYPE,
     OCTI_ID_TYPE,
+    OCTI_INSTANCE_TYPE,
     OCTI_CLS_TYPE,
     OCTI_NST_TYPE,
     OCTI_PROTO_TYPE,
@@ -368,6 +369,7 @@
     OCTI_OBJ_ID,
     OCTI_CLS_ID,
     OCTI_ID_NAME,
+    OCTI_INSTANCETYPE_NAME,
     OCTI_CLASS_NAME,
     OCTI_CNST_STR_ID,
     OCTI_CNST_STR_TYPE,
@@ -443,6 +445,7 @@
 #define objc_super_type		objc_global_trees[OCTI_SUPER_TYPE]
 #define objc_selector_type		objc_global_trees[OCTI_SEL_TYPE]
 #define objc_object_type	objc_global_trees[OCTI_ID_TYPE]
+#define objc_instancetype_type	objc_global_trees[OCTI_INSTANCE_TYPE]
 #define objc_class_type		objc_global_trees[OCTI_CLS_TYPE]
 #define objc_instance_type	objc_global_trees[OCTI_NST_TYPE]
 #define objc_protocol_type	objc_global_trees[OCTI_PROTO_TYPE]
@@ -570,7 +573,8 @@
 
 #define objc_object_id		objc_global_trees[OCTI_OBJ_ID]
 #define objc_class_id		objc_global_trees[OCTI_CLS_ID]
-#define objc_object_name		objc_global_trees[OCTI_ID_NAME]
+#define objc_object_name        objc_global_trees[OCTI_ID_NAME]
+#define objc_instancetype_name	objc_global_trees[OCTI_INSTANCETYPE_NAME]
 #define objc_class_name		objc_global_trees[OCTI_CLASS_NAME]
 
 /* Constant string classes.  */
@@ -608,6 +612,7 @@
 /* Reserved tag definitions.  */
 
 #define OBJECT_TYPEDEF_NAME		"id"
+#define INSTANCE_TYPEDEF_NAME		"instancetype"
 #define CLASS_TYPEDEF_NAME		"Class"
 
 #define TAG_OBJECT			"objc_object"
Index: gcc/gcov.c
===================================================================
diff --git a/gcc/gcov.c b/gcc/gcov.c
--- a/gcc/gcov.c	(revision 278653)
+++ b/gcc/gcov.c	(revision 278653)
@@ -604,27 +604,11 @@
 typedef vector<arc_info *> arc_vector_t;
 typedef vector<const block_info *> block_vector_t;
 
-/* Enum with types of loop in CFG.  */
-
-enum loop_type
-{
-  NO_LOOP = 0,
-  LOOP = 1,
-  NEGATIVE_LOOP = 3
-};
-
-/* Loop_type operator that merges two values: A and B.  */
-
-inline loop_type& operator |= (loop_type& a, loop_type b)
-{
-    return a = static_cast<loop_type> (a | b);
-}
-
 /* Handle cycle identified by EDGES, where the function finds minimum cs_count
    and subtract the value from all counts.  The subtracted value is added
    to COUNT.  Returns type of loop.  */
 
-static loop_type
+static void
 handle_cycle (const arc_vector_t &edges, int64_t &count)
 {
   /* Find the minimum edge of the cycle, and reduce all nodes in the cycle by
@@ -640,7 +624,7 @@
   for (unsigned i = 0; i < edges.size (); i++)
     edges[i]->cs_count -= cycle_count;
 
-  return cycle_count < 0 ? NEGATIVE_LOOP : LOOP;
+  gcc_assert (cycle_count > 0);
 }
 
 /* Unblock a block U from BLOCKED.  Apart from that, iterate all blocks
@@ -666,17 +650,28 @@
     unblock (*it, blocked, block_lists);
 }
 
+/* Return true when PATH contains a zero cycle arc count.  */
+
+static bool
+path_contains_zero_cycle_arc (arc_vector_t &path)
+{
+  for (unsigned i = 0; i < path.size (); i++)
+    if (path[i]->cs_count == 0)
+      return true;
+  return false;
+}
+
 /* Find circuit going to block V, PATH is provisional seen cycle.
    BLOCKED is vector of blocked vertices, BLOCK_LISTS contains vertices
    blocked by a block.  COUNT is accumulated count of the current LINE.
    Returns what type of loop it contains.  */
 
-static loop_type
+static bool
 circuit (block_info *v, arc_vector_t &path, block_info *start,
 	 block_vector_t &blocked, vector<block_vector_t> &block_lists,
 	 line_info &linfo, int64_t &count)
 {
-  loop_type result = NO_LOOP;
+  bool loop_found = false;
 
   /* Add v to the block list.  */
   gcc_assert (find (blocked.begin (), blocked.end (), v) == blocked.end ());
@@ -686,26 +681,35 @@
   for (arc_info *arc = v->succ; arc; arc = arc->succ_next)
     {
       block_info *w = arc->dst;
-      if (w < start || !linfo.has_block (w))
+      if (w < start
+	  || arc->cs_count == 0
+	  || !linfo.has_block (w))
 	continue;
 
       path.push_back (arc);
       if (w == start)
-	/* Cycle has been found.  */
-	result |= handle_cycle (path, count);
-      else if (find (blocked.begin (), blocked.end (), w) == blocked.end ())
-	result |= circuit (w, path, start, blocked, block_lists, linfo, count);
+	{
+	  /* Cycle has been found.  */
+	  handle_cycle (path, count);
+	  loop_found = true;
+	}
+      else if (!path_contains_zero_cycle_arc (path)
+	       &&  find (blocked.begin (), blocked.end (), w) == blocked.end ())
+	loop_found |= circuit (w, path, start, blocked, block_lists, linfo,
+			       count);
 
       path.pop_back ();
     }
 
-  if (result != NO_LOOP)
+  if (loop_found)
     unblock (v, blocked, block_lists);
   else
     for (arc_info *arc = v->succ; arc; arc = arc->succ_next)
       {
 	block_info *w = arc->dst;
-	if (w < start || !linfo.has_block (w))
+	if (w < start
+	    || arc->cs_count == 0
+	    || !linfo.has_block (w))
 	  continue;
 
 	size_t index
@@ -716,14 +720,13 @@
 	  list.push_back (v);
       }
 
-  return result;
+  return loop_found;
 }
 
-/* Find cycles for a LINFO.  If HANDLE_NEGATIVE_CYCLES is set and the line
-   contains a negative loop, then perform the same function once again.  */
+/* Find cycles for a LINFO.  */
 
 static gcov_type
-get_cycles_count (line_info &linfo, bool handle_negative_cycles = true)
+get_cycles_count (line_info &linfo)
 {
   /* Note that this algorithm works even if blocks aren't in sorted order.
      Each iteration of the circuit detection is completely independent
@@ -731,7 +734,7 @@
      Therefore, operating on a permuted order (i.e., non-sorted) only
      has the effect of permuting the output cycles.  */
 
-  loop_type result = NO_LOOP;
+  bool loop_found = false;
   gcov_type count = 0;
   for (vector<block_info *>::iterator it = linfo.blocks.begin ();
        it != linfo.blocks.end (); it++)
@@ -739,14 +742,10 @@
       arc_vector_t path;
       block_vector_t blocked;
       vector<block_vector_t > block_lists;
-      result |= circuit (*it, path, *it, blocked, block_lists, linfo,
-			 count);
+      loop_found |= circuit (*it, path, *it, blocked, block_lists, linfo,
+			     count);
     }
 
-  /* If we have a negative cycle, repeat the find_cycles routine.  */
-  if (result == NEGATIVE_LOOP && handle_negative_cycles)
-    count += get_cycles_count (linfo, false);
-
   return count;
 }
 
Index: gcc/toplev.c
===================================================================
diff --git a/gcc/toplev.c b/gcc/toplev.c
--- a/gcc/toplev.c	(revision 278653)
+++ b/gcc/toplev.c	(revision 278653)
@@ -2110,6 +2110,34 @@
 	else
 	  int_n_enabled_p[i] = false;
 
+      /* Initialize mpfrs exponent range.  This is important to get
+         underflow/overflow in a reasonable timeframe.  */
+      machine_mode mode;
+      int min_exp = -1;
+      int max_exp = 1;
+      FOR_EACH_MODE_IN_CLASS (mode, MODE_FLOAT)
+	if (SCALAR_FLOAT_MODE_P (mode))
+	  {
+	    const real_format *fmt = REAL_MODE_FORMAT (mode);
+	    if (fmt)
+	      {
+		/* fmt->emin - fmt->p + 1 should be enough but the
+		   back-and-forth dance in real_to_decimal_for_mode we
+		   do for checking fails due to rounding effects then.  */
+		if ((fmt->emin - fmt->p) < min_exp)
+		  min_exp = fmt->emin - fmt->p;
+		if (fmt->emax > max_exp)
+		  max_exp = fmt->emax;
+	      }
+	  }
+      /* E.g. mpc_norm assumes it can square a number without bothering with
+	 with range scaling, so until that is fixed, double the minimum
+	 and maximum exponents, plus add some buffer for arithmetics
+	 on the squared numbers.  */
+      if (mpfr_set_emin (2 * (min_exp - 1))
+	  || mpfr_set_emax (2 * (max_exp + 1)))
+	sorry ("mpfr not configured to handle all float modes");
+
       /* Set up the back-end if requested.  */
       if (!no_backend)
 	backend_init ();
Index: gcc/tree-chrec.c
===================================================================
diff --git a/gcc/tree-chrec.c b/gcc/tree-chrec.c
--- a/gcc/tree-chrec.c	(revision 278653)
+++ b/gcc/tree-chrec.c	(revision 278653)
@@ -979,10 +979,11 @@
     return false;
 }
 
-/* Determines whether the chrec contains symbolic names or not.  */
+/* Determines whether the chrec contains symbolic names or not.  If LOOP isn't
+   NULL, we also consider chrec wrto outer loops of LOOP as symbol.  */
 
 bool
-chrec_contains_symbols (const_tree chrec)
+chrec_contains_symbols (const_tree chrec, struct loop *loop)
 {
   int i, n;
 
@@ -999,9 +1000,14 @@
       || TREE_CODE (chrec) == FIELD_DECL)
     return true;
 
+  if (loop != NULL
+      && TREE_CODE (chrec) == POLYNOMIAL_CHREC
+      && flow_loop_nested_p (get_chrec_loop (chrec), loop))
+    return true;
+
   n = TREE_OPERAND_LENGTH (chrec);
   for (i = 0; i < n; i++)
-    if (chrec_contains_symbols (TREE_OPERAND (chrec, i)))
+    if (chrec_contains_symbols (TREE_OPERAND (chrec, i), loop))
       return true;
   return false;
 }
Index: gcc/tree-chrec.h
===================================================================
diff --git a/gcc/tree-chrec.h b/gcc/tree-chrec.h
--- a/gcc/tree-chrec.h	(revision 278653)
+++ b/gcc/tree-chrec.h	(revision 278653)
@@ -80,7 +80,7 @@
 /* Observers.  */
 extern bool eq_evolutions_p (const_tree, const_tree);
 extern bool is_multivariate_chrec (const_tree);
-extern bool chrec_contains_symbols (const_tree);
+extern bool chrec_contains_symbols (const_tree, struct loop * = NULL);
 extern bool chrec_contains_symbols_defined_in_loop (const_tree, unsigned);
 extern bool chrec_contains_undetermined (const_tree);
 extern bool tree_contains_chrecs (const_tree, int *);
Index: gcc/tree-ssa-sccvn.c
===================================================================
diff --git a/gcc/tree-ssa-sccvn.c b/gcc/tree-ssa-sccvn.c
--- a/gcc/tree-ssa-sccvn.c	(revision 278653)
+++ b/gcc/tree-ssa-sccvn.c	(revision 278653)
@@ -69,6 +69,7 @@
 #include "tree-cfgcleanup.h"
 #include "tree-ssa-loop.h"
 #include "tree-scalar-evolution.h"
+#include "builtins.h"
 #include "tree-ssa-sccvn.h"
 
 /* This algorithm is based on the SCC algorithm presented by Keith
@@ -1857,23 +1858,11 @@
       /* If we reach a clobbering statement try to skip it and see if
          we find a VN result with exactly the same value as the
 	 possible clobber.  In this case we can ignore the clobber
-	 and return the found value.
-	 Note that we don't need to worry about partial overlapping
-	 accesses as we then can use TBAA to disambiguate against the
-	 clobbering statement when looking up a load (thus the
-	 VN_WALKREWRITE guard).  */
+	 and return the found value.  */
       if (vn_walk_kind == VN_WALKREWRITE
 	  && is_gimple_reg_type (TREE_TYPE (lhs))
 	  && types_compatible_p (TREE_TYPE (lhs), vr->type)
-	  /* The overlap restriction breaks down when either access
-	     alias-set is zero.  Still for accesses of the size of
-	     an addressable unit there can be no overlaps.  Overlaps
-	     between different union members are not an issue since
-	     activation of a union member via a store makes the
-	     values of untouched bytes unspecified.  */
-	  && (known_eq (ref->size, BITS_PER_UNIT)
-	      || (get_alias_set (lhs) != 0
-		  && ao_ref_alias_set (ref) != 0)))
+	  && ref->ref)
 	{
 	  tree *saved_last_vuse_ptr = last_vuse_ptr;
 	  /* Do not update last_vuse_ptr in vn_reference_lookup_2.  */
@@ -1891,7 +1880,14 @@
 	      vn_reference_t vnresult = (vn_reference_t) res;
 	      if (vnresult->result
 		  && operand_equal_p (vnresult->result,
-				      gimple_assign_rhs1 (def_stmt), 0))
+				      gimple_assign_rhs1 (def_stmt), 0)
+		  /* We have to honor our promise about union type punning
+		     and also support arbitrary overlaps with
+		     -fno-strict-aliasing.  So simply resort to alignment to
+		     rule out overlaps.  Do this check last because it is
+		     quite expensive compared to the hash-lookup above.  */
+		  && multiple_p (get_object_alignment (ref->ref), ref->size)
+		  && multiple_p (get_object_alignment (lhs), ref->size))
 		return res;
 	    }
 	}
@@ -2031,9 +2027,20 @@
 	  tree rhs = gimple_assign_rhs1 (def_stmt);
 	  if (TREE_CODE (rhs) == SSA_NAME)
 	    rhs = SSA_VAL (rhs);
-	  len = native_encode_expr (gimple_assign_rhs1 (def_stmt),
+	  unsigned pad = 0;
+	  if (BYTES_BIG_ENDIAN
+	      && is_a <scalar_mode> (TYPE_MODE (TREE_TYPE (rhs))))
+	    {
+	      /* On big-endian the padding is at the 'front' so
+		 just skip the initial bytes.  */
+	      fixed_size_mode mode
+		  = as_a <fixed_size_mode> (TYPE_MODE (TREE_TYPE (rhs)));
+	      pad = GET_MODE_SIZE (mode) - size2 / BITS_PER_UNIT;
+	    }
+	  len = native_encode_expr (rhs,
 				    buffer, sizeof (buffer),
-				    (offseti - offset2) / BITS_PER_UNIT);
+				    ((offseti - offset2) / BITS_PER_UNIT
+				     + pad));
 	  if (len > 0 && len * BITS_PER_UNIT >= maxsizei)
 	    {
 	      tree type = vr->type;
@@ -5207,6 +5214,57 @@
   auto_vec<tree> avail_stack;
 };
 
+/* Return true if the reference operation REF may trap.  */
+
+bool
+vn_reference_may_trap (vn_reference_t ref)
+{
+  switch (ref->operands[0].opcode)
+    {
+    case MODIFY_EXPR:
+    case CALL_EXPR:
+      /* We do not handle calls.  */
+    case ADDR_EXPR:
+      /* And toplevel address computations never trap.  */
+      return false;
+    default:;
+    }
+
+  vn_reference_op_t op;
+  unsigned i;
+  FOR_EACH_VEC_ELT (ref->operands, i, op)
+    {
+      switch (op->opcode)
+	{
+	case WITH_SIZE_EXPR:
+	case TARGET_MEM_REF:
+	  /* Always variable.  */
+	  return true;
+	case COMPONENT_REF:
+	  if (op->op1 && TREE_CODE (op->op1) == SSA_NAME)
+	    return true;
+	  break;
+	case ARRAY_RANGE_REF:
+	case ARRAY_REF:
+	  if (TREE_CODE (op->op0) == SSA_NAME)
+	    return true;
+	  break;
+	case MEM_REF:
+	  /* Nothing interesting in itself, the base is separate.  */
+	  break;
+	/* The following are the address bases.  */
+	case SSA_NAME:
+	  return true;
+	case ADDR_EXPR:
+	  if (op->op0)
+	    return tree_could_trap_p (TREE_OPERAND (op->op0, 0));
+	  return false;
+	default:;
+	}
+    }
+  return false;
+}
+
 eliminate_dom_walker::eliminate_dom_walker (cdi_direction direction,
 					    bitmap inserted_exprs_)
   : dom_walker (direction), do_pre (inserted_exprs_ != NULL),
Index: gcc/tree-ssa-sccvn.h
===================================================================
diff --git a/gcc/tree-ssa-sccvn.h b/gcc/tree-ssa-sccvn.h
--- a/gcc/tree-ssa-sccvn.h	(revision 278653)
+++ b/gcc/tree-ssa-sccvn.h	(revision 278653)
@@ -239,6 +239,7 @@
 bool vn_nary_op_eq (const_vn_nary_op_t const vno1,
 		    const_vn_nary_op_t const vno2);
 bool vn_nary_may_trap (vn_nary_op_t);
+bool vn_reference_may_trap (vn_reference_t);
 bool vn_reference_eq (const_vn_reference_t const, const_vn_reference_t const);
 unsigned int get_max_value_id (void);
 unsigned int get_next_value_id (void);
Index: gcc/ChangeLog
===================================================================
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
--- a/gcc/ChangeLog	(revision 278653)
+++ b/gcc/ChangeLog	(revision 278653)
@@ -1,3 +1,2482 @@
+2019-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91355
+	* tree-ssa-sink.c (select_best_block): Use >= rather than >
+	for early_bb scaled count with best_bb count comparison.
+
+	Backported from mainline
+	2019-11-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/90840
+	* expmed.c (store_bit_field_1): Handle the case where op0 is not a MEM
+	and has a mode that doesn't have corresponding integral type.
+
+	PR target/90867
+	* config/i386/i386.c (ix86_valid_target_attribute_tree): Don't
+	clear opts->x_ix86_isa_flags{,2} here...
+	(ix86_valid_target_attribute_inner_p): ... but here when seeing
+	arch=.  Also clear opts->x_ix86_isa_flags{,2}_explicit.
+
+	PR c/90898
+	* tree-ssa-ccp.c (insert_clobber_before_stack_restore): Remove
+	assertion.
+	(insert_clobbers_for_var): Fix a typo in function comment.
+
+	2019-11-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/91450
+	* internal-fn.c (expand_mul_overflow): For s1 * s2 -> ur, if one
+	operand is negative and one non-negative, compare the non-negative
+	one against 0 rather than comparing s1 & s2 against 0.  Otherwise,
+	don't compare (s1 & s2) == 0, but compare separately both s1 == 0
+	and s2 == 0, unless one of them is known to be negative.  Remove
+	tem2 variable, use tem where tem2 has been used before.
+
+	2019-11-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92384
+	* function.c (assign_parm_setup_block, assign_parm_setup_stack): Don't
+	copy TYPE_EMPTY_P arguments from data->entry_parm to data->stack_parm
+	slot.
+	(assign_parms): For TREE_ADDRESSABLE parms with TYPE_EMPTY_P type
+	force creation of a unique data.stack_parm slot.
+
+	2019-10-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/92056
+	* tree-object-size.c (cond_expr_object_size): Return early if then_
+	processing resulted in unknown size.
+
+	2019-09-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91665
+	* tree-vect-loop.c (vectorizable_reduction): Punt if base has type
+	incompatible with the type of PHI result.
+
+	2019-09-06  Jakub Jelinek  <jakub@redhat.com>
+
+	* function.c (assign_parm_find_data_types): Use RECORD_OR_UNION_TYPE_P
+	before testing TYPE_TRANSPARENT_AGGR.
+	* calls.c (initialize_argument_information, load_register_parameters):
+	Likewise.
+
+	2019-09-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/91001
+	PR middle-end/91105
+	PR middle-end/91106
+	* calls.c (load_register_parameters): For TYPE_TRANSPARENT_AGGR
+	types, use type of their first field instead of type of
+	args[i].tree_value.
+
+	2019-09-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/91623
+	* optabs.c (expand_vec_cond_expr): If op0 is a VECTOR_CST and only
+	EQ_EXPR/NE_EXPR is supported, verify that op0 only contains
+	zeros or negative elements and use NE_EXPR instead of LT_EXPR against
+	zero vector.
+
+2019-11-20  Peter Bergner <bergner@linux.ibm.com>
+
+	Backport from mainline
+	2019-11-07  Peter Bergner <bergner@linux.ibm.com>
+
+	PR other/92090
+	* config/rs6000/predicates.md (input_operand): Allow MODE_PARTIAL_INT
+	modes for integer constants.
+
+2019-11-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* doc/invoke.texi (-gno-internal-reset-location-views): Fix typo.
+
+2019-11-14  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-11-14  Martin Liska  <mliska@suse.cz>
+
+	PR target/92389
+	* config/i386/i386.h: Add PTA_AVX512VPOPCNTDQ to
+	PTA_ICELAKE_CLIENT which is later interited by
+	PTA_ICELAKE_SERVER and PTA_TIGERLAKE.
+
+2019-11-13  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	Backport from mainline
+	* config/mips/mips.md (rotr<mode>3): Sanitize the constant argument
+	instead of asserting its value.
+
+2019-11-11  H.J. Lu  <hjl.tools@gmail.com>
+
+	Backport from trunk:
+	PR target/87833
+	* config/i386/intelmic-mkoffload.c (prepare_target_image): Put
+	-fPIC and -shared the last to create offload image.
+
+2019-11-11  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backport from trunk:
+	* gimplify.c (gimplify_scan_omp_clauses): Assert 'offset2' instead
+	of 'offset'.
+
+	Backport from trunk:
+	* Makefile.in (LANG_CONFIGUREFRAGS): Define.
+	(config.status): Use/depend on it.
+	* configure.ac (all_lang_configurefrags): Track, 'AC_SUBST'.
+	* configure: Regenerate.
+
+2019-11-09  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-11-07  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md (memory_barrier): Revise to use ldcw barriers.
+	Enhance comment.
+	(memory_barrier_coherent, memory_barrier_64, memory_barrier_32): New
+	insn patterns using ldcw instruction.
+	(memory_barrier): Remove insn pattern using sync instruction.
+	* config/pa/pa.opt (coherent-ldcw): New option.
+	(ordered): New option.
+
+2019-11-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/92095
+	* config/sparc/sparc-protos.h (output_load_pcrel_sym): Declare.
+	* config/sparc/sparc.c (sparc_cannot_force_const_mem): Revert latest
+ 	change.
+	(got_helper_needed): New static variable.
+	(output_load_pcrel_sym): New function.
+	(get_pc_thunk_name): Remove after inlining...
+	(load_got_register): ...here.  Rework the initialization of the GOT
+	register and of the GOT helper.
+	(save_local_or_in_reg_p): Test the REGNO of the GOT register.
+	(sparc_file_end): Test got_helper_needed to decide whether the GOT
+	helper must be emitted.  Use output_asm_insn instead of fprintf.
+	(sparc_init_pic_reg): In PIC mode, always initialize the PIC register
+	if optimization is enabled.
+	* config/sparc/sparc.md (load_pcrel_sym<P:mode>): Emit the assembly
+	by calling output_load_pcrel_sym.
+
+2019-11-06  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2018-09-19  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR rtl-optimization/85458
+	* config/pa/pa.c (pa_adjust_priority): Delete.
+	(TARGET_SCHED_ADJUST_PRIORITY): Delete define.
+
+2019-11-05  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-10-24  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* config/rs6000/altivec.md (altivec_vavgu<VI_char>): Rename to...
+	(uavg<mode>3_ceil): ... This.
+	(altivec_vavgs<VI_char>): Rename to...
+	(avg<mode>3_ceil): ... This.
+	* config/rs6000/rs6000-builtin.def (VAVGUB, VAVGSB, VAVGUH, VAVGSH,
+	VAVGUW, VAVGSW): Adjust.
+
+2019-11-05  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-10-26  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/91289
+	* config/rs6000/rs6000.c (rs6000_emit_allocate_stack): Don't add an
+	immediate to r0; use r11 instead.  Save and restore r11 to r0 around
+	this.
+
+2019-11-04  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-10-03  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.h (MAX_PCREL17F_OFFSET): Adjust.
+
+2019-11-04  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-10-03  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_output_call): Remove 64-bit sibcall sequence.
+	(pa_attr_length_call): Adjust length for 64-bit plabel sequence.
+
+2019-11-04 John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-10-12  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_output_call): Load descriptor address to register
+	%r22.  Load function address before global pointer.
+	(pa_attr_length_indirect_call): Adjust length of inline versions of
+	$$dyncall.
+	(pa_output_indirect_call): Remove fast inline version of $$dyncall
+	before normal cases.  Update inline $$dyncall sequences to preserve
+	function descriptor address in register %r22.
+	(TRAMPOLINE_CODE_SIZE): Adjust.
+	(pa_asm_trampoline_template): Revise 32-bit trampoline.  Don't assume
+	register %r22 contains trampoline address.
+	(pa_trampoline_init): Adjust offsets.
+	(pa_trampoline_adjust_address): Likewise.
+	* config/pa/pa.h (TRAMPOLINE_SIZE): Adjust 32-bit size.
+
+	2019-10-17  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_output_indirect_call): Fix typos in last change.
+
+2019-11-1  Delia Burduv  <Delia.Burduv@arm.com>
+
+         Backport from trunk
+         2019-02-20  Andre Vieira <andre.simoesdiasvieira@arm.com>
+
+         PR target/86487
+         * lra-constraints.c(uses_hard_regs_p): Fix handling of
+         paradoxical SUBREGS.
+
+2019-10-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirection_name): Rework the
+	function to emit linker-visible symbols only for indirections
+	in the data section.  Clean up the code and update comments.
+
+2019-10-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-09  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (darwin_override_options): Make the check for
+	Objective-C ABI version more specific for 64bit code.
+
+	Backport from mainline
+	2019-10-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (darwin_override_options): Adjust objective-c
+	ABI version error messages to avoid punctuation and contracted
+	negations.
+
+2019-10-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-07-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.h (REAL_LIBGCC_SPEC): Adjust for earlier Darwin.
+	(STARTFILE_SPEC): Split crt3 into a separate spec.
+	(DARWIN_EXTRA_SPECS): Add crt2 and crt3 spec.
+	(DARWIN_CRT2_SPEC): New.
+	(DARWIN_CRT3_SPEC): New.
+	(MIN_LD64_OMIT_STUBS): Revise to 62.1.
+	* config/rs6000/darwin.h (DARWIN_CRT2_SPEC): Revise conditions.
+	(DARWIN_CRT3_SPEC): New.
+
+2019-10-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin.h (ENDFILE_SPEC): Correct whitespace in the
+	spec.
+
+	Backport from mainline
+	2019-06-25  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin.h (ENDFILE_SPEC): New.
+
+2019-10-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (darwin_emit_unwind_label): New default to false.
+	(darwin_override_options): Set darwin_emit_unwind_label as needed.
+
+2019-10-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-08-13 Iain Sandoe <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirect_call_target): Rename symbol stub
+	flag.
+	(darwin_override_options): Likewise.
+	* config/darwin.h: Likewise.
+	* config/darwin.opt: Likewise.
+	* config/i386/i386.c (output_pic_addr_const): Likewise.
+	* config/rs6000/darwin.h: Likewise.
+	* config/rs6000/rs6000.c (rs6000_call_darwin_1): Likewise.
+	* config/i386/darwin.h (TARGET_MACHO_PICSYM_STUBS): Rename to ...
+	... this TARGET_MACHO_SYMBOL_STUBS.
+	(FUNCTION_PROFILER):Likewise.
+	* config/i386/i386.h: Likewise.
+
+	Backport from mainline
+	2019-06-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirect_call_target): Use renamed
+	darwin_picsymbol_stubs to decide on output.
+	(darwin_override_options): Handle darwin_picsymbol_stubs.
+	* config/darwin.h (MIN_LD64_OMIT_STUBS): New.
+	(LD64_VERSION): Revise default.
+	* config/darwin.opt: (mpic-symbol-stubs): New option.
+	(darwin_picsymbol_stubs): New variable.
+	* config/i386/darwin.h (TARGET_MACHO_BRANCH_ISLANDS):
+	rename to TARGET_MACHO_PICSYM_STUBS.
+	* config/i386/i386.c (output_pic_addr_const): Likewise.
+	* config/i386/i386.h Likewise.
+	* config/rs6000/darwin.h: Likewise.
+	* config/rs6000/rs6000.c (rs6000_call_darwin_1): Use renamed
+	darwin_picsymbol_stubs.
+
+2019-10-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/rs6000.c (darwin_rs6000_override_options): Honour
+	user-specified float mode choice for kernel mode code.
+
+2019-10-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin.h: Handle GCC target pragma.
+
+2019-10-30  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	Backport from mainline
+	2019-07-09  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	* cfgcleanup.c (old_insns_match_p): Check if used hard regs set is equal
+	for both call instructions.
+
+2019-10-28  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-17  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/65342
+	* config/rs6000/darwin.md (movdi_low, movsi_low_st): Delete.
+	(movdi_low_st): Delete.
+	* config/rs6000/rs6000.c
+	(darwin_rs6000_legitimate_lo_sum_const_p): New.
+	(mem_operand_gpr): Validate Mach-O LO_SUM cases separately.
+	* config/rs6000/rs6000.md (movsi_low): Delete.
+
+2019-10-28  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-12  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/67183
+	* config/darwin.c (machopic_indirection): New field to flag
+	non-lazy-symbol-pointers in the data section.
+	(machopic_indirection_name): Compute if an indirection should
+	appear in the data section.
+	(machopic_output_data_section_indirection): New callback split
+	from machopic_output_indirection.
+	(machopic_output_stub_indirection): Likewise.
+	(machopic_output_indirection): Retain the code for non-lazy
+	symbol pointers in their regular section.
+	(machopic_finish): Use the new callbacks to order the indirection
+	output.
+
+2019-10-28  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-12  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin-protos.h (machopic_finish): Delete.
+	* config/darwin.c (machopic_finish): Make static.
+
+	Backport from mainline
+	2019-10-09  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirect_data_reference): Set flag to
+	indicate that the new symbol is an indirection.
+	(machopic_indirect_call_target): Likewise.
+	* config/darwin.h (MACHO_SYMBOL_FLAG_INDIRECTION): New.
+	(MACHO_SYMBOL_INDIRECTION_P): New.
+	(MACHO_SYMBOL_FLAG_STATIC): Adjust bit number.
+
+	Backport from mainline
+	2019-10-08  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_indirect_data_reference): Check for
+	required indirections before making direct access to defined
+	values.
+	(machopic_output_indirection): Place the indirected pointes for
+	required indirections into the non-lazy symbol pointers section.
+	(darwin_encode_section_info):
+	* config/darwin.h (MACHO_SYMBOL_FLAG_MUST_INDIRECT): New.
+	(MACHO_SYMBOL_MUST_INDIRECT_P): New.
+
+	Backport from mainline
+	2019-10-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_output_indirection): Don't put
+	hidden symbol indirections into the .data section, use the
+	non-lazy symbol pointers section as normal.
+	(darwin_encode_section_info): Record if a symbol is hidden.
+	* config/darwin.h (MACHO_SYMBOL_FLAG_HIDDEN_VIS): New.
+	(MACHO_SYMBOL_HIDDEN_VIS_P): New.
+
+	Backport from mainline
+	2019-10-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_symbol_defined_p): Use symbol flag
+	predicates instead of accessing bits directly.
+	(machopic_indirect_call_target): Likewise.
+	(machopic_output_indirection): Likewise.
+	(darwin_encode_section_info): Improve description.  Use renamed
+	symbol flags.  Use predicate macros for variables and functions.
+	* config/darwin.h:
+	Rename MACHO_SYMBOL_VARIABLE to MACHO_SYMBOL_FLAG_VARIABLE.
+	Rename MACHO_SYMBOL_DEFINED to MACHO_SYMBOL_FLAG_DEFINED.
+	Rename MACHO_SYMBOL_STATIC to MACHO_SYMBOL_FLAG_STATIC.
+	(MACHO_SYMBOL_VARIABLE_P): New.
+	(MACHO_SYMBOL_DEFINED_P):New.
+	(MACHO_SYMBOL_STATIC_P): New.
+	* config/i386/darwin.h (MACHO_SYMBOL_FLAG_VARIABLE): Delete.
+	(SYMBOL_FLAG_SUBT_DEP): New.
+	* config/rs6000/darwin.h (SYMBOL_FLAG_SUBT_DEP): New.
+
+2019-10-28  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/59888
+	* config/darwin.c (darwin_rodata_section): Add relocation flag,
+	choose const_data section for constants with relocations.
+	(machopic_select_section): Pass relocation flag to
+	darwin_rodata_section ().
+
+2019-10-28  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-09-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (machopic_legitimize_pic_address): Check
+	for lra, rather than reload.
+
+2019-10-28  Peter Bergner <bergner@linux.ibm.com>
+	    Jiufu Guo  <guojiufu@linux.ibm.com>
+
+	PR target/70010
+	* config/rs6000/rs6000.c (rs6000_can_inline_p): Prohibit inlining if
+	the callee explicitly disables some isa_flags the caller is using.
+
+2019-10-25  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin.h (ASM_OUTPUT_MAX_SKIP_ALIGN):Guard
+	against out of range max skip or log values.
+
+2019-10-25  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backport from mainline
+	2019-05-08  Mihail Ionescu  <mihail.ionescu@arm.com>
+	    Richard Earnshaw  <rearnsha@arm.com>
+	PR target/88167
+	* config/arm/arm.c (thumb1_prologue_unused_call_clobbered_lo_regs): New
+	function.
+	(thumb1_epilogue_unused_call_clobbered_lo_regs): New function.
+	(thumb1_compute_save_core_reg_mask): Don't force a spare work
+	register if both the epilogue and prologue can use call-clobbered
+	regs.
+	(thumb1_unexpanded_epilogue): Use
+	thumb1_epilogue_unused_call_clobbered_lo_regs.  Reverse the logic for
+	picking temporaries for restoring high regs to match that of the
+	prologue where possible.
+	(thumb1_expand_prologue): Add any usable call-clobbered low registers to
+	the list of work registers.  Detect if the return address is still live
+	at the end of the prologue and avoid using it for a work register if so.
+	If the return address is not live, add LR to the list of pushable regs
+	after the first pass.
+
+2019-10-23  Peter Bergner  <bergner@linux.ibm.com>
+
+	Backport from mainline
+	2019-10-08  Tulio Magno Quites Machado Filho  <tuliom@linux.ibm.com>
+
+	* config.gcc: Move -L usage from LINK_OS_EXTRA_SPEC32 and
+	LINK_OS_EXTRA_SPEC64 to MD_STARTFILE_PREFIX and
+	MD_STARTFILE_PREFIX_1 when using --with-advance-toolchain.
+
+2019-10-23  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-10-17  Richard Biener  <rguenther@suse.de>
+
+	PR debug/91887
+	* dwarf2out.c (gen_formal_parameter_die): Also try to match
+	context_die against a DW_TAG_GNU_formal_parameter_pack parent.
+
+	2019-09-19  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91812
+	* tree-ssa-phiprop.c (propagate_with_phi): Do not replace
+	volatile loads.
+
+	2019-09-17  Richard Biener  <rguenther@suse.de>
+
+	PR debug/91772
+	* dwarf2out.c (dwarf2out_late_global_decl): If early dwarf
+	was missing generate locations only once.
+
+2019-10-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR tree-optimization/92131
+	* tree-vrp.c (extract_range_from_plus_minus_expr): If the resulting
+	range would be symbolic, drop to varying for any explicit overflow
+	in the constant part or if neither range is a singleton.
+
+2019-10-20  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-10-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/87243
+	* config/darwin-driver.c (maybe_get_sysroot_from_sdkroot): New.
+	(darwin_driver_init): Use the sysroot provided by SDKROOT when that
+	is available and the user has not set one on the command line.
+
+2019-10-20  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-07-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.h (DRIVER_SELF_SPECS): Remove the linker cases.
+	(RDYNAMIC): Rename to, DARWIN_RDYNAMIC.
+	(DARWIN_PIE_SPEC, DARWIN_NOPIE_SPEC): Adjust to remove the Xlinker
+	clauses.
+	(LINK_COMMAND_SPEC_A): Add DARWIN_RDYNAMIC, DARWIN_PIE_SPEC and
+	DARWIN_NOPIE_SPEC.
+
+	Backport from mainline
+	2019-06-19  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.h (DRIVER_SELF_SPECS): Add RDYNAMIC, DARWIN_PIE_SPEC
+	and DARWIN_NOPIE_SPEC.
+	(RDYNAMIC): New, modified from DARWIN_EXPORT_DYNAMIC.
+	(DARWIN_PIE_SPEC): Collate from darwin.h and darwin9.h.
+	(DARWIN_NOPIE_SPEC): Collate from darwin10.h.
+	(DARWIN_NOCOMPACT_UNWIND): New from darwin10.h
+	(DARWIN_EXPORT_DYNAMIC): Delete.
+	* config/darwin10.h (LINK_GCC_C_SEQUENCE_SPEC): Move no_compact_unwind
+	and pie options processing to  darwin.h.
+	* config/darwin9.h (DARWIN_PIE_SPEC): Move pie processing to darwin.h
+
+2019-10-18  Georg-Johann Lay  <avr@gjlay.de>
+
+	Backport from 2019-10-18 trunk r277143.
+
+	PR target/86040
+	* config/avr/avr.c (avr_out_lpm): Do not shortcut-return.
+
+2019-10-17  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-03-15  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR rtl-optimization/89721
+	* lra-constraints (invariant_p): Return false if side_effects_p holds.
+
+2019-10-17  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backport from mainline
+	2019-05-03  Richard Earnshaw  <rearnsha@arm.com>
+
+	PR target/89400
+	* config/arm/arm.md (unaligned_loadsi): Add variant for thumb1.
+	Restrict 'all' variant to 32-bit configurations.
+	(unaligned_loadhiu): Likewise.
+	(unaligned_storehi): Likewise.
+	(unaligned_storesi): Likewise.
+	(unaligned_loadhis): Disable when compiling for thumb1.
+
+2019-10-14  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	Backport from trunk
+	2019-09-26  Will Schmidt <will_schmidt@vnet.ibm.com>
+
+	* config/rs6000/rs6000-builtin.def: (LVSL, LVSR, LVEBX, LVEHX,
+	LVEWX, LVXL, LVXL_V2DF, LVXL_V2DI, LVXL_V4SF, LVXL_V4SI, LVXL_V8HI,
+	LVXL_V16QI, LVX, LVX_V1TI, LVX_V2DF, LVX_V2DI, LVX_V4SF, LVX_V4SI,
+	LVX_V8HI, LVX_V16QI, LVLX, LVLXL, LVRX, LVRXL, LXSDX, LXVD2X_V1TI,
+	LXVD2X_V2DF, LXVD2X_V2DI, LXVDSX, LXVW4X_V4SF, LXVW4X_V4SI,
+	LXVW4X_V8HI, LXVW4X_V16QI, LD_ELEMREV_V1TI, LD_ELEMREV_V2DF,
+	LD_ELEMREV_V2DI, LD_ELEMREV_V4SF, LD_ELEMREV_V4SI, LD_ELEMREV_V8HI,
+	LD_ELEMREV_V16QI): Use the PURE attribute.
+
+2019-10-10  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/92022
+	* config/alpha/alpha.c (alpha_handle_trap_shadows): Skip DEBUG_INSN.
+
+2019-10-10  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2019-10-10  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/88630
+	* config/sh/sh.h (TARGET_FPU_SH4_300): New macro.
+	* config/sh/sh.c (sh_option_override): Enable fsca and fsrra insns
+	also for TARGET_FPU_SH4_300.
+	(sh_emit_mode_set): Check for TARGET_FPU_SH4_300 instead of
+	TARGET_SH4_300.
+	* config/sh/sh.md (toggle_pr): Add TARGET_FPU_SH4_300 condition.
+	(negsf2): Expand to either negsf2_fpscr or negsf2_no_fpscr.
+	(*negsf2_i): Split into ...
+	(negsf2_fpscr, negsf2_no_fpscr): ... these new patterns.
+	(abssf2): Expand to either abssf2_fpsc or abssf2_no_fpsc.
+	(**abssf2_i): Split into ...
+	(abssf2_fpscr, abssf2_no_fpscr): ... these new patterns.
+	(negdf2): Expand to either negdf2_fpscr or negdf2_no_fpscr.
+	(*negdf2_i): Split into ...
+	(negdf2_fpscr, negdf2_no_fpscr): ... these new patterns.
+	(absdf2): Expand to either absdf2_fpscr or absdf2_no_fpsc.
+	(**abssf2_i): Split into ...
+	(absdf2_fpscr, absdf2_no_fpscr): ... these new patterns.
+
+2019-10-07  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2019-10-01  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/91275
+	* config/rs6000/rs6000-p8swap.c (rtx_is_swappable_p): Don't swap
+	vpmsumd.
+
+2019-10-01  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+
+	2019-10-01  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/88562
+	* config/sh/sh.c (sh_extending_set_of_reg::use_as_extended_reg): Use
+	sh_check_add_incdec_notes to preserve REG_INC notes when replacing
+	a memory access insn.
+
+2019-10-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-09-24  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/aarch64.md (mov<mode>): Don't call
+	aarch64_split_dimode_const_store on volatile MEM.
+
+2019-10-01  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/91854
+	Backport from mainline
+	2019-09-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/91269
+	* config/sparc/sparc.h (HARD_REGNO_CALLER_SAVE_MODE): Define.
+
+2019-09-28  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2019-09-28  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/80672
+	* config/sh/sh.c (parse_validate_atomic_model_option): Use
+	std::string::compare instead of std::string::find.
+
+2019-09-28  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2018-07-15  Jeff Law  <law@redhat.com>
+
+	PR target/85993
+	* config/sh/sh.c (output_mi_thunk): Remove dead conditional
+	block.
+
+2019-09-26  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.opt (prebind, noprebind, seglinkedit,
+	noseglinkedit): Add RejectNegative.
+
+	Backport from mainline
+	2019-06-14  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.opt: Add RejectNegative where needed, reorder
+	and add minimal functional descriptions.
+
+2019-09-25  Kyrylo Tkachov <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-08-22  Kyrylo Tkachov <kyrylo.tkachov@arm.com>
+
+	* config/arm/arm_acle.h: Use arch=armv8-a+crc+simd pragma for CRC32
+	intrinsics if __ARM_FP.
+	Use __ARM_FEATURE_CRC32 ifdef guard.
+
+2019-09-23  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backport from mainline
+	2019-06-18  Max Filippov  <jcmvbkbc@gmail.com>
+
+	* config/xtensa/xtensa.c (xtensa_expand_prologue): Add stack
+	pointer adjustment for the case of no callee-saved registers and
+	stack frame bigger than 128 bytes.
+
+2019-09-20  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (pa_trampoline_init): Remove spurious extended
+	character.
+
+2019-09-20  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-06-06  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	PR rtl-optimization/88751
+	* ira.c (ira): Use the number of the actually referenced registers
+	when calculating the threshold.
+
+2019-09-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/89795
+	* rtlanal.c (nonzero_bits1) <SUBREG>: Do not propagate results from
+	inner REGs to paradoxical SUBREGs if WORD_REGISTER_OPERATIONS is set.
+
+2019-09-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/87853
+	* config/i386/emmintrin.h (_mm_cmpeq_epi8): Use casts to __v16qi
+	instead of __v16qs.
+
+	PR target/91704
+	* config/i386/avxintrin.h (__v32qs): New typedef.
+	* config/i386/avx2intrin.h (_mm256_cmpgt_epi8): Use casts to __v32qs
+	instead of __v32qi.
+
+2019-09-04  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backport from mainline
+	2019-08-13  Wilco Dijkstra  <wdijkstr@arm.com>
+	 
+	PR target/81800
+	* gcc/config/aarch64/aarch64.md (lrint): Disable lrint pattern if GPF
+	operand is larger than a long int.
+
+2019-09-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-08-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR pch/61250
+	* ggc-page.c (ggc_pch_read): Read the ggc_pch_ondisk structure
+	and issue any diagnostics needed before collecting the pre-PCH
+	state.
+
+2019-09-01  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/91472
+	* config/sparc/sparc.c (sparc_cannot_force_const_mem): Return true
+	during LRA/reload in PIC mode if the PIC register hasn't been used yet.
+	(sparc_pic_register_p): Test reload_in_progress for consistency's sake.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-06-21  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90930
+	* tree-ssa-reassoc.c (rewrite_expr_tree_parallel): Set visited
+	flag on new stmts to avoid re-processing them.
+
+	2019-05-27  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90637
+	* tree-ssa-sink.c (statement_sink_location): Honor the
+	computed sink location for single-uses.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-07-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91108
+	* tree-ssa-sccvn.c: Include builtins.h.
+	(vn_reference_lookup_3): Use only alignment constraints to
+	verify same-valued store disambiguation.
+
+2019-08-30  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-08-22  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/91481
+	* config/rs6000/rs6000.md (unspec): Delete UNSPEC_DARN, UNSPEC_DARN_32,
+	and UNSPEC_DARN_RAW.
+	(unspecv): New enumerator values UNSPECV_DARN, UNSPECV_DARN_32, and
+	UNSPECV_DARN_RAW.
+	(darn_32): Use an unspec_volatile, and UNSPECV_DARN_32.
+	(darn_raw): Use an unspec_volatile, and UNSPECV_DARN_RAW.
+	(darn): Use an unspec_volatile, and UNSPECV_DARN.
+
+2019-08-30  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-08-22  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* config/rs6000/altivec.md (unspec): Delete UNSPEC_DARN, UNSPEC_DARN_32,
+	UNSPEC_DARN_RAW, UNSPEC_CMPRB, UNSPEC_CMPRB2, UNSPEC_CMPEQB; move to...
+	* config/rs6000/rs6000.md (unspec): ... here.
+	* config/rs6000/altivec.md (darn_32, darn_raw, darn, cmprb,
+	*cmprb_internal, setb_signed, setb_unsigned, cmprb2, *cmprb2_internal,
+	cmpeqb, *cmpeqb_internal): Delete, move to...
+	* config/rs6000/rs6000.md (darn_32, darn_raw, darn, cmprb,
+	*cmprb_internal, setb_signed, setb_unsigned, cmprb2, *cmprb2_internal,
+	cmpeqb, *cmpeqb_internal): ... here.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-01-07  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/88567
+	* tree-vect-loop.c (get_initial_defs_for_reduction): Pass the
+	output vector directly to duplicate_and_interleave instead of
+	going through a temporary.  Postpone insertion of ctor_seq to
+	the end of the loop.
+
+	2018-12-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/88315
+	* tree-vect-loop.c (get_initial_defs_for_reduction): Simplify
+	and fix initialization vector for SAD and DOT_PROD SLP reductions.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-06-18  Richard Biener  <rguenther@suse.de>
+
+	PR debug/90900
+	* cfgexpand.c (expand_debug_expr): Treat NOTE_P DECL_RTL
+	as if optimized away.
+
+	2019-04-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90278
+	* tree-ssa-forwprop.c (pass_forwprop::execute): Transfer/clean
+	EH on comparison simplification.
+
+	2019-04-25  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/90194
+	* match.pd: Add pattern to simplify view-conversion of an
+	empty constructor.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-08-12  Richard Biener  <rguenther@suse.de>
+
+	PR lto/91375
+	* tree.c (free_lang_data_in_type): Do not free TYPE_BINFO dependent on
+	flag_devirtualize.
+
+	2019-07-31  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91293
+	* tree-vect-slp.c (vect_build_slp_tree_2): Do not swap operands
+	of reduction stmts.
+
+	2019-07-31  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91280
+	* tree-ssa-structalias.c (get_constraint_for_component_ref):
+	Decompose MEM_REF manually for offset handling.
+
+	2019-07-19  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91200
+	* tree-ssa-phiopt.c (cond_store_replacement): Check we have
+	no PHI nodes in middle-bb.
+
+	2019-07-15  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/91162
+	* tree-cfg.c (move_block_to_fn): When releasing a virtual PHI
+	node make sure to replace all uses with something valid.
+
+	2019-07-11  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/91131
+	* gimplify.c (gimplify_compound_literal_expr): Force a temporary
+	when the object is volatile and we have not cleared it even though
+	there are no nonzero elements.
+
+	2019-07-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91126
+	* tree-ssa-sccvn.c (vn_reference_lookup_3): Adjust
+	native encoding offset for BYTES_BIG_ENDIAN.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	* lto-streamer.h (LTO_minor_version): Bump.
+
+	Backport from mainline
+	2019-05-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90328
+	* tree-data-ref.h (dr_may_alias_p): Pass in the actual loop nest.
+	* tree-data-ref.c (dr_may_alias_p): Check whether the clique
+	is valid in the loop nest before using it.
+	(initialize_data_dependence_relation): Adjust.
+	* graphite-scop-detection.c (build_alias_set): Pass the SCOP enclosing
+	loop as loop-nest to dr_may_alias_p.
+
+	2019-03-08  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89578
+	* cfgloop.h (struct loop): Add owned_clique field.
+	* cfgloopmanip.c (copy_loop_info): Copy it.
+	* tree-cfg.c (gimple_duplicate_bb): Do not remap owned_clique
+	cliques.
+	* tree-inline.c (copy_loops): Remap owned_clique.
+	* lto-streamer-in.c (input_cfg): Stream owned_clique.
+	* lto-streamer-out.c (output_cfg): Likewise.
+
+	2019-02-22  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/87609
+	* tree-cfg.c (gimple_duplicate_bb): Only remap inlined cliques.
+
+	2019-02-22  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/87609
+	* cfghooks.h (dependence_hash): New typedef.
+	(struct copy_bb_data): New type.
+	(cfg_hooks::duplicate_block): Adjust to take a copy_bb_data argument.
+	(duplicate_block): Likewise.
+	* cfghooks.c (duplicate_block): Pass down copy_bb_data.
+	(copy_bbs): Create and pass down copy_bb_data.
+	* cfgrtl.c (cfg_layout_duplicate_bb): Adjust.
+	(rtl_duplicate_bb): Likewise.
+	* tree-cfg.c (gimple_duplicate_bb): If the copy_bb_data arg is not NULL
+	remap dependence info.
+
+	2019-02-22  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/87609
+	* tree-core.h (tree_base): Document special clique values.
+	* tree-inline.c (remap_dependence_clique): Do not use the
+	special clique value of one.
+	(maybe_set_dependence_info): Use clique one.
+	(clear_dependence_clique): New callback.
+	(compute_dependence_clique): Clear clique one from all refs
+	before assigning it (again).
+
+2019-08-30  Bin Cheng  <bin.linux@linux.alibaba.com>
+
+	Backport from mainline
+	2019-07-18  Bin Cheng  <bin.linux@linux.alibaba.com>
+
+	PR tree-optimization/91137
+	* tree-ssa-loop-ivopts.c (struct ivopts_data): New field.
+	(tree_ssa_iv_optimize_init, alloc_iv, tree_ssa_iv_optimize_finalize):
+	Init, use and fini the above new field.
+	(determine_base_object_1): New function.
+	(determine_base_object): Reimplement using walk_tree.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-04-09  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* tree-vect-data-refs.c (vect_get_smallest_scalar_type): Always
+	use gimple_expr_type for load and store calls.  Skip over the
+	condition argument in a conditional internal function.
+	Protect use of TREE_INT_CST_LOW.
+
+	2019-04-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90006
+	* tree-vect-data-refs.c (vect_get_smallest_scalar_type): Handle
+	calls like lrint.
+
+	2019-04-01  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	PR tree-optimization/89725
+	* tree-chrec.c (chrec_contains_symbols): New parameter.  Handle outer
+	loop's chrec as invariant symbol.
+	* tree-chrec.h (chrec_contains_symbols): New parameter.
+	* tree-data-ref.c (analyze_miv_subscript): Pass new argument.
+	(build_classic_dist_vector_1, add_other_self_distances): Bypass access
+	function of loops not in DDR's loop_nest.
+
+	2019-03-26  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	PR tree-optimization/81740
+	* tree-vect-data-refs.c (vect_analyze_data_ref_dependence):
+	In case of outer loop vectorization, check for backward dependence
+	at the inner loop if outer loop dependence is reversed.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-04-24  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/90213
+	* gimple-fold.c (fold_const_aggregate_ref_1): Do multiplication
+	by size and BITS_PER_UNIT on poly-wide-ints.
+
+	2019-04-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90020
+	* tree-ssa-sccvn.c (vn_reference_may_trap): New function.
+	* tree-ssa-sccvn.h (vn_reference_may_trap): Declare.
+	* tree-ssa-pre.c (compute_avail): Use it to not put
+	possibly trapping references after a call that might not
+	return into EXP_GEN.
+	* gcse.c (compute_hash_table_work): Do not elide
+	marking a block containing a call if the call might not
+	return.
+
+2019-08-29  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-07-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR bootstrap/87030
+	* config/i386/darwin.h (REAL_LIBGCC_SPEC): Revert change from r273749.
+
+	PR bootstrap/87030
+	* config/i386/darwin.h (REAL_LIBGCC_SPEC): Move from here...
+	* config/i386/darwin32-biarch.h .. to here.
+	* config/i386/darwin64-biarch.h: Adjust comments.
+	* config/rs6000/darwin32-biarch.h: Likewise.
+	* config/rs6000/darwin64-biarch.h: Likewise.
+	* config.gcc: Missed commit from r273746
+	(*-*-darwin*): Don't include CPU t-darwin here.
+	(i[34567]86-*-darwin*): Adjust to use biarch files. Produce
+	an error message if i686-darwin configuration is attempted for
+	Darwin >= 18.
+
+	Backport from mainline
+	2019-07-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR bootstrap/87030
+	* config.gcc (*-*-darwin*): Don't include CPU t-darwin here.
+	(i[34567]86-*-darwin*): Adjust to use biarch files. Produce
+	an error message if i686-darwin configuration is attempted for
+	Darwin >= 18.
+	(x86_64-*-darwin*): Switch to single multilib for Darwin >= 18.
+	(powerpc-*-darwin*): Use biarch files where needed.
+	(powerpc64-*-darwin*): Likewise.
+	* config/i386/darwin.h (REAL_LIBGCC_SPEC): Move to new biarch file.
+	(DARWIN_ARCH_SPEC, DARWIN_SUBARCH_SPEC): Revise for default single
+	arch case.
+	* config/i386/darwin32-biarch.h: New.
+	* config/i386/darwin64.h: Rename.
+	* gcc/config/i386/darwin64-biarch.h: To this.
+	* config/i386/t-darwin: Rename.
+	* gcc/config/i386/t-darwin32-biarch: To this.
+	* config/i386/t-darwin64: Rename.
+	* gcc/config/i386/t-darwin64-biarch: To this.
+	* config/rs6000/darwin32-biarch.h: New.
+	* config/rs6000/darwin64.h: Rename.
+	* config/rs6000/darwin64-biarch.h: To this.
+	(DARWIN_ARCH_SPEC, DARWIN_SUBARCH_SPEC): Revise for default single
+	arch case.
+	* config/rs6000/t-darwin8: Rename.
+	* config/rs6000/t-darwin32-biarch: To this.
+	* config/rs6000/t-darwin64 Rename.
+	* config/rs6000/t-darwin64-biarch: To this.
+
+2019-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-07-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/91150
+	* config/i386/i386.c (expand_vec_perm_blend): Change mask type
+	from unsigned to unsigned HOST_WIDE_INT.  For E_V64QImode cast
+	comparison to unsigned HOST_WIDE_INT before shifting it left.
+
+	2019-07-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/78884
+	* gimplify.c (struct gimplify_omp_ctx): Add add_safelen1 member.
+	(gimplify_bind_expr): If seeing TREE_ADDRESSABLE VLA inside of simd
+	loop body, set ctx->add_safelen1 instead of making it GOVD_PRIVATE.
+	(gimplify_adjust_omp_clauses): Add safelen (1) clause if
+	ctx->add_safelen1 is set.
+
+	PR rtl-optimization/90756
+	* explow.c (promote_ssa_mode): Always use TYPE_MODE, don't bypass it
+	for VECTOR_TYPE_P.
+
+	2019-06-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/90760
+	* symtab.c (symtab_node::set_section): Allow being called on aliases
+	as long as they aren't analyzed yet.
+
+	2019-06-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/90733
+	* var-tracking.c (vt_expand_loc_callback): Don't create raw subregs
+	with VOIDmode inner operands.
+
+	2019-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/90139
+	* tree-outof-ssa.c (get_temp_reg): If reg_mode is BLKmode, return
+	assign_temp instead of gen_reg_rtx.
+
+2019-08-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-07-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (darwin_override_options): Make a final check on PIC
+	options.
+
+2019-08-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-07-07  Iain Sandoe  <iain@sandoe.co.uk>
+	* config/darwin.c (darwin_override_options): Don't jam symbol stubs
+	on for kernel code.
+
+2019-08-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/rs6000.c (darwin_rs6000_override_options): Do not
+	use longcall for 64b code.
+
+2019-08-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-08-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin.h (TARGET_OS_CPP_BUILTINS): Add asserts
+	for cpu and machine.  Factor 64/32b builtins.
+
+	Backport from mainline
+	2019-06-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/darwin.h: (__PPC__, __PPC64__): New.
+
+2019-08-25  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-19  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin-driver.c (darwin_driver_init): Fix off-by-one errors
+	in computing the number of options to be moved.
+
+	Backport from mainline
+	2019-06-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin-driver.c (validate_macosx_version_min): New.
+	(darwin_default_min_version): Cleanup and validate supplied version.
+	(darwin_driver_init): Likewise and push cleaned version into opts.
+
+2019-08-25  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/91533
+	Backport from mainline
+	2019-06-30  Uroš Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/sse.md (ssse3_abs<mode>2): Rename from abs<mode>2.
+	* config/i386/i386-builtin.def (__builtin_ia32_pabsb):
+	Use CODE_FOR_ssse3_absv8qi2.
+	(__builtin_ia32_pabsw): Use CODE_FOR_ssse3_absv4hi2.
+	(__builtin_ia32_pabsd): Use CODE_FOR_ssse3_absv2si2.
+
+2019-08-23  Mihailo Stojanovic  <mistojanovic@wavecomp.com>
+
+	Backport from mainline
+	2019-08-23  Mihailo Stojanovic  <mistojanovic@wavecomp.com>
+
+	* config/mips/mips.md (mips_get_fcsr, *mips_get_fcsr): Use SI
+	machine mode for unspec_volatile operand.
+
+2019-08-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-12-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/i386/darwin.h (TARGET_ASM_OUTPUT_IDENT): New.
+
+2019-08-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-05-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/i386/darwin.h (ASM_OUTPUT_MAX_SKIP_ALIGN): New.
+
+2019-08-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-05-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin-c.c (darwin_register_objc_includes): Do not
+	prepend the sysroot when building gnu-runtime header search
+	paths.
+
+2019-08-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-05-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/darwin.c (darwin_file_end): Use switch_to_section ()
+	instead of direct output of the asm.
+
+2019-08-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/91347
+	* dse.c (scan_insn): Call add_wild_read for non-const/memset tail calls
+	before reload if HARD_FRAME_POINTER_IS_ARG_POINTER.
+
+2019-08-16  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-04-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* config/rs6000/rs6000.md (group_end_nop): Emit insn register
+	names using operand format, rather than hard-wired.
+	(speculation_barrier): Likewise.
+
+2019-08-14  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2018-08-22 Iain Sandoe <iain@sandoe.co.uk>
+
+	* config/darwin.h (LINK_COMMAND_SPEC_A): Update lto options
+	to match gcc/gcc.c.
+
+2019-08-05  Kito Cheng  <kito.cheng@sifive.com>
+
+	Backport from mainline
+	2019-08-05  Kito Cheng  <kito.cheng@sifive.com>
+
+	* config/riscv/riscv.c (riscv_promote_function_mode): New.
+	(TARGET_PROMOTE_FUNCTION_MODE): Use riscv_promote_function_mode.
+
+2019-08-04  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-05-02  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* config/rs6000/rs6000.c (rs6000_dbx_register_number): Return the
+	correct numbers for TFHAR, TFIAR, TEXASR.
+
+2019-07-23  Matthew Beliveau  <mbelivea@redhat.com>
+
+	Backported from mainline
+	2019-07-16  Jeff Law  <law@redhat.com>
+
+	PR rtl-optimization/91173
+	* tree-ssa-address.c (addr_for_mem_ref): If the base is an
+	SSA_NAME with a constant value, fold its value into the offset
+	and clear the base before calling gen_addr_rtx.
+	* g++.dg/pr91173.C: New test.
+
+2019-07-23  Richard Biener  <rguenther@suse.de>
+
+	PR debug/91231
+	* lto-streamer-in.c (input_function): Drop inline-entry markers
+	that ended up with an unknown location block.
+
+2019-07-22  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-07-22  Martin Liska  <mliska@suse.cz>
+
+	PR driver/91172
+	* opts-common.c (decode_cmdline_option): Decode
+	argument of -Werror and check it for a wrong language.
+	* opts-global.c (complain_wrong_lang): Remove such case.
+
+2019-07-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline
+	2019-07-10  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* fold-const.c (fold_relational_const): Fix folding of
+	vector-to-scalar NE_EXPRs.
+	(test_vector_folding): Add more tests.
+
+2019-07-19  Jason Merrill  <jason@redhat.com>
+
+	PR c++/82081 - tail call optimization breaks noexcept
+	* tree-tailcall.c (find_tail_calls): Don't turn a call from a
+	nothrow function to a might-throw function into a tail call.
+
+2019-07-16  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backport from mainline
+	PR target/89222
+	* config/arm/arm.md (movsi): Use targetm.cannot_force_const_mem
+	to decide when to split off a non-zero offset from a symbol.
+	* config/arm/arm.c (arm_cannot_force_const_mem): Disallow offsets
+	in function symbols.
+
+2019-07-16  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backport from mainline
+	2019-02-13  Wilco Dijkstra  <wdijkstr@arm.com>
+	PR target/89190
+	* config/arm/arm.c (ldm_stm_operation_p) Set
+	addr_reg_in_reglist correctly for first register.
+	(load_multiple_sequence): Remove dead base check.
+	(gen_ldm_seq): Correctly set write_back for Thumb-1.
+
+2019-07-15  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-07-01  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/vector.md: Fix shift count operand printing.
+
+2019-07-15  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backport from mainline
+	2019-01-23  Bin Cheng  <bin.cheng@arm.com>
+		    Steve Ellcey  <sellcey@marvell.com>
+
+	PR target/85711
+	* recog.c (address_operand): Return false on wrong mode for address.
+	(constrain_operands): Check for mode with 'p' constraint.
+
+2019-07-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/91136
+	* df-core.c (ACCESSING REFS): Fix typos in comment.
+	* resource.c (mark_target_live_reg): Add artificial defs that occur at
+	the beginning of the block to the initial set of live registers.
+
+2019-07-04  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-07-03  Martin Liska  <mliska@suse.cz>
+
+	PR middle-end/90899
+	* multiple_target.c (create_dispatcher_calls): Add to comdat
+	group only if set for ifunc.
+
+2019-06-28  Jeff Law  <law@redhat.com>
+
+	Backport from mainline
+	2019-06-21  Jeff Law  <law@redhat.com>
+
+	PR tree-optimization/90949
+	* tree-ssa-copy.c (fini_copy_prop): Use reset_flow_sensitive_info.
+	* tree-ssanames.c (reset_flow_sensitive_info): Reset non-null state.
+
+2019-06-26  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-06-25  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/90939
+	* ipa-cp.c (ipcp_bits_lattice::meet_with): Remove assert.
+
+2019-06-26  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline
+	2019-06-17  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* configure.ac (ld_vers) <*-*-solaris2*>: Remove support for
+	alternative Solaris 11.4 format.
+	* configure: Regenerate.
+
+2019-06-16  Jeff Law  <law@redhat.com>
+
+	Backport from mainline
+	2019-06-16  Prachi Godbole  <prachi.godbole@imgtec.com>
+		    Robert Suchanek  <robert.suchanek@mips.com>
+	* config/mips/mips.c (mips_expand_builtin_insn): Swap the 1st
+	and 3rd operands of the fmadd/fmsub/maddv builtin.
+
+2019-06-16  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR middle-end/64242
+	* config/pa/pa.md (nonlocal_goto): Restore frame pointer last.  Add
+	frame clobbers and schedule block.
+	(builtin_longjmp): Likewise.
+
+2019-06-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/90811
+	* config/nvptx/nvptx.c (nvptx_output_softstack_switch): Use and.b%d
+	instead of and.u%d.
+
+2019-06-07  John David Anglin  <danglin@gcc.gnu.orig>
+
+	PR target/90751
+	* config/pa/pa-linux.h (ASM_DECLARE_FUNCTION_NAME): Update comment.
+	Call pa_output_function_label.
+	(TARGET_ASM_FUNCTION_PROLOGUE): define.
+	* config/pa/pa-protos.h (pa_output_function_label): Declare.
+	* config/pa/pa.c (pa_output_function_prologue): Add ATTRIBUTE_UNUSED
+	to declaration.
+	(pa_linux_output_function_prologue): Declare.
+	(TARGET_ASM_FUNCTION_PROLOGUE): Delete define.
+	(pa_output_function_label): New.
+	(pa_output_function_prologue): Revise to use pa_output_function_label.
+	(pa_linux_output_function_prologue): New.
+	* config/pa/pa.h (TARGET_ASM_FUNCTION_PROLOGUE): Define.
+
+2019-06-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-12  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/82920
+	* config/i386/darwin.h (CC1_SPEC): Report -mx32 as an error for
+	Darwin.
+
+2019-06-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-12  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/82920
+	* config/i386/i386.c (ix86_output_jmp_thunk_or_indirect): New.
+	(ix86_output_indirect_branch_via_reg): Use output mechanism
+	accounting for __USER_LABEL_PREFIX__.
+	(ix86_output_indirect_branch_via_push): Likewise.
+	(ix86_output_function_return): Likewise.
+	(ix86_output_indirect_function_return): Likewise.
+
+2019-05-30  Jakub Jelinek  <jakub@redhat.com>
+
+	* tree-predcom.c (is_inv_store_elimination_chain): Fix a typo - lenght
+	to length.
+
+2019-05-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/90329
+	* lto-streamer.h (LTO_minor_version): Bump to 2.
+
+	Backported from mainline
+	2019-05-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/90329
+	* tree-core.h (struct tree_decl_common): Document
+	decl_nonshareable_flag for PARM_DECLs.
+	* tree.h (DECL_HIDDEN_STRING_LENGTH): Define.
+	* calls.c (expand_call): Don't try tail call if caller
+	has any DECL_HIDDEN_STRING_LENGTH PARM_DECLs that are or might be
+	passed on the stack and callee needs to pass any arguments on the
+	stack.
+	* tree-streamer-in.c (unpack_ts_decl_common_value_fields): Use
+	else if instead of series of mutually exclusive ifs.  Handle
+	DECL_HIDDEN_STRING_LENGTH for PARM_DECLs.
+	* tree-streamer-out.c (pack_ts_decl_common_value_fields): Likewise.
+
+2019-05-28  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (hppa_profile_hook): Remove offset adjustment.
+
+2019-05-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* dwarf2out.c (resolve_args_picking_1): Deal with DW_OP_GNU_addr_index
+	and DW_OP_GNU_const_index opcodes.
+
+2019-05-24  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/90530
+	* config/pa/pa.c (pa_can_change_mode_class): Accept mode changes from
+	DImode to SImode in floating-point registers on 64-bit target.
+	* config/pa/pa.md (umulsidi3): Change nonimmediate_operand to
+	register_operand in xmpyu patterns.
+
+2019-05-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-05-23  Martin Liska  <mliska@suse.cz>
+
+	PR sanitizer/90570
+	* gimplify.c (gimplify_target_expr): Skip TREE_STATIC target
+	expression similarly to gimplify_decl_expr.
+
+2019-05-23  Uroš Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2019-05-21  Uroš Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/cpuid.h (__cpuid): For 32bit targets, zero
+	%ebx and %ecx bafore calling cpuid with leaf 1 or
+	non-constant leaf argument.
+
+	2019-05-21  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/90547
+	* config/i386/i386.md (anddi_1 to andsi_1_zext splitter):
+	Avoid calling gen_lowpart with CONST operand.
+
+2019-05-21  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backported from mainline
+	2019-05-16  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/arm/t-rtems: Replace ARMv7-M multilibs with Cortex-M
+	multilibs.
+
+2019-05-20  Jeff Law  <law@redhat.com>
+
+	Backport from mainline
+	2019-05-17  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	* config/mips/mips.c (mips_dwarf_frame_reg_mode): Replace
+	TARGET_FLOAT64 with !TARGET_FLOAT32, thus handling both fp64
+	and fpxx modes.
+
+2019-05-16  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-05-07  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89765
+	* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):
+	In handling of ALTIVEC_BUILTIN_VEC_INSERT, use modular arithmetic
+	to compute vector element selector for both constant and variable
+	operands.
+
+2019-05-15  David Edelsohn  <dje.gcc@gmail.com>
+
+	Backport from mainline
+	2019-04-11  David Edelsohn  <dje.gcc@gmail.com>
+	* xcoffout.h (xcoff_private_rodata_section_name): Declare.
+	* xcoffout.c (xcoff_private_rodata_section_name): Define.
+	* config/rs6000/rs6000.c (rs6000_xcoff_asm_init_sections): Create
+	read_only_private_data_section using coff_private_rodata_section_name.
+	(rs6000_xcoff_file_start): Generate coff_private_rodata_section_name.
+
+	2018-12-04  David Edelsohn  <dje.gcc@gmail.com>
+	2018-12-13  David Edelsohn  <dje.gcc@gmail.com>
+	PR target/61976
+	* config/rs6000/rs6000.c (rs6000_function_arg): Don't pass aggregates
+	in FPRs on AIX. Ensure type is non-NULL.
+	(rs6000_arg_partial_bytes): Same.
+
+2019-05-14  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-05-13  Martin Liska  <mliska@suse.cz>
+
+	PR gcov-profile/90380
+	* gcov.c (handle_cycle): Do not support zero cycle count,
+	it should not be possible.
+	(path_contains_zero_cycle_arc): New function.
+	(circuit): Ignore zero cycle arc counts.
+
+2019-05-14  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-05-13  Martin Liska  <mliska@suse.cz>
+
+	PR gcov-profile/90380
+	* gcov.c (enum loop_type): Remove the enum and
+	the operator.
+	(handle_cycle): Assert that we should not reach
+	a negative count.
+	(circuit): Use loop_found instead of a tri-state loop_type.
+	(get_cycles_count): Do not handle NEGATIVE_LOOP as it can't
+	happen.
+
+2019-05-11  Andreas Tobler <andreast@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-04-25  Andreas Tobler  <andreast@gcc.gnu.org>
+
+	* config/i386/freebsd64.h: Add bits for 32-bit multilib support.
+	* config/i386/t-freebsd64: New file.
+	* config.gcc: Add the t-freebsd64 for multilib support.
+
+2019-05-08  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-05-06  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89424
+	* config/rs6000/rs6000.c (rs6000_expand_vector_extract): Add
+	handling of V1TImode.
+
+2019-05-06  Richard Biener  <rguenther@suse.de>
+
+	PR bootstrap/90359
+	Backport from mainline
+	2019-03-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89655
+	PR bootstrap/89656
+	* vr-values.c (vr_values::update_value_range): If
+	old_vr->varying_p (), don't update it, make new_vr also VARYING
+	and return false.
+
+2019-05-03  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89698
+	* fold-const.c (operand_equal_p): For INDIRECT_REF check
+	that the access types are similar.
+
+	2019-03-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89595
+	* tree-ssa-dom.c (dom_opt_dom_walker::optimize_stmt): Take
+	stmt iterator as reference, take boolean output parameter to
+	indicate whether the stmt was removed and thus the iterator
+	already advanced.
+	(dom_opt_dom_walker::before_dom_children): Re-iterate over
+	stmts created by folding.
+
+	2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89710
+	* tree-ssa-loop-ch.c (should_duplicate_loop_header_p): Use
+	safe_dyn_cast.
+
+	2019-04-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90071
+	* tree-ssa-reassoc.c (init_range_entry): Do not pick up
+	abnormal operands from def stmts.
+
+	2018-08-20  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR target/86984
+	* expr.c (expand_assignment): Assert that bitpos is positive.
+	(store_field): Likewise
+	(expand_expr_real_1): Make sure that bitpos is positive.
+	* config/alpha/alpha.h (CONSTANT_ADDRESS_P): Avoid signed
+	integer overflow.
+
+	2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR target/89711
+	* config/i386/i386.c (make_resolver_func): Properly set
+	DECL_CONTEXT on the RESULT_DECL.
+	* config/rs6000/rs6000.c (make_resolver_func): Likewise.
+
+2019-04-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-04-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/90193
+	* rtl.c (classify_insn): Return JUMP_INSN for asm goto.
+	* emit-rtl.c (try_split): Copy over REG_LABEL_TARGET.
+
+	PR target/90187
+	* config/i386/i386.c (ix86_expand_sse_fp_minmax): Force if_true into
+	a register if both if_true and if_false are MEMs.
+
+	PR tree-optimization/90208
+	* tree-cfg.c (remove_bb): Move forced labels from removed bbs
+	after labels of new_bb, not before them.
+
+	2019-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/90082
+	* dce.c (can_delete_call): New function.
+	(deletable_insn_p, mark_insn): Use it.
+
+	PR tree-optimization/90090
+	* tree-ssa-math-opts.c (is_division_by): Ignore divisions that can
+	throw internally.
+	(is_division_by_square): Likewise.  Formatting fix.
+
+	2019-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/89965
+	* dce.c: Include rtl-iter.h.
+	(struct check_argument_load_data): New type.
+	(check_argument_load): New function.
+	(find_call_stack_args): Check for loads from stack slots still tracked
+	in sp_bytes and punt if any is found.
+
+	PR c/89946
+	* varasm.c (assemble_start_function): Don't use tree_fits_uhwi_p
+	and gcc_unreachable if it fails, just call tree_to_uhwi which
+	verifies that too.  Test TREE_CHAIN instead of list_length > 1.
+	Start warning message with a lower-case letter.  Formatting fixes.
+
+	PR rtl-optimization/90026
+	* cfgcleanup.c (try_optimize_cfg): When removing empty bb with no
+	successors, look for BARRIERs inside of the whole BB_FOOTER chain
+	rather than just at the start of it.  If e->src BB_FOOTER is not NULL
+	in cfglayout mode, use emit_barrier_after_bb.
+
+	2019-04-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/89965
+	* dce.c (sp_based_mem_offset): New function.
+	(find_call_stack_args): Use sp_based_mem_offset.
+
+	2019-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90010
+	* gimple-ssa-sprintf.c (target_to_host): Fix handling of targstr
+	with strlen in between hostsz-3 and hostsz-1 inclusive when no
+	translation is needed, and when translation is needed, only append
+	... if the string length is hostsz or more bytes long.  Avoid using
+	strncpy or strcat.
+
+	2019-04-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/89998
+	* gimple-ssa-sprintf.c (try_substitute_return_value): Use lhs type
+	instead of integer_type_node if possible, don't add ranges if return
+	type is not compatible with int.
+	* gimple-fold.c (gimple_fold_builtin_sprintf,
+	gimple_fold_builtin_snprintf): Use lhs type instead of hardcoded
+	integer_type_node.
+
+	2019-03-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89872
+	* gimplify.c (gimplify_compound_literal_expr): Don't optimize a
+	non-addressable complit into its initializer if it is volatile.
+
+	2019-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89621
+	* tree-inline.h (struct copy_body_data): Add
+	dont_remap_vla_if_no_change flag.
+	* tree-inline.c (remap_type_3, remap_type_2): New functions.
+	(remap_type): Don't remap vla types if id->dont_remap_vla_if_no_change
+	and remap_type_2 returns false.
+	* omp-low.c (new_omp_context): Set ctx->cb.dont_remap_vla_if_no_change.
+
+	2019-03-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/89752
+	* lra-constraints.c (process_alt_operands) <reg>: For BLKmode, don't
+	update this_alternative nor this_alternative_set.
+
+	2019-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/89768
+	* loop-unroll.c (unroll_loop_constant_iterations): Use gen_int_mode
+	instead of GEN_INT.
+	(unroll_loop_runtime_iterations): Likewise.
+
+	PR target/89752
+	* gimplify.c (gimplify_asm_expr): For output argument with
+	TREE_ADDRESSABLE type, clear allows_reg if it allows memory, otherwise
+	diagnose error.
+
+	PR target/89726
+	* config/i386/i386.c (ix86_expand_floorceildf_32): In ceil
+	compensation use x2 += 1 instead of x2 -= -1 and when honoring
+	signed zeros, do another copysign after the compensation.
+
+	2019-03-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/89704
+	* dwarf2out.c (add_const_value_attribute): Return false for MINUS,
+	SIGN_EXTEND and ZERO_EXTEND.
+
+	2019-03-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/89684
+	* multiple_target.c (create_dispatcher_calls): Change
+	references_to_redirect from vector of ipa_ref * to vector of ipa_ref.
+	In the node->iterate_referring loop, push *ref rather than ref, call
+	ref->remove_reference () and always pass 0 to iterate_referring.
+
+	PR rtl-optimization/89679
+	* expmed.c (expand_mult_const): Don't add a REG_EQUAL note if it
+	would contain a paradoxical SUBREG.
+
+	PR tree-optimization/89703
+	* tree-ssa-strlen.c (valid_builtin_call): Punt if stmt call types
+	aren't compatible also with builtin_decl_explicit.  Check pure
+	or non-pure status of BUILT_IN_STR{{,N}CMP,N{LEN,{CAT,CPY}{,_CHK}}}
+	and BUILT_IN_STPNCPY{,_CHK}.
+
+	2019-03-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/89498
+	* dwarf2out.c (size_of_die): For dw_val_class_view_list always use
+	DWARF_OFFSET_SIZE.
+	(value_format): For dw_val_class_view_list never use DW_FORM_loclistx.
+
+	PR middle-end/88588
+	* omp-simd-clone.c (ipa_simd_modify_stmt_ops): Handle PHI args.
+	(ipa_simd_modify_function_body): Handle PHIs.
+
+	2019-03-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89663
+	* builtins.c (expand_builtin_int_roundingfn,
+	expand_builtin_int_roundingfn_2): Return NULL_RTX instead of
+	gcc_unreachable if validate_arglist fails.
+
+	2019-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/88568
+	* attribs.c (handle_dll_attribute): Don't clear TREE_STATIC for
+	dllimport on VAR_DECLs with RECORD_TYPE or UNION_TYPE DECL_CONTEXT.
+
+	2019-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/89587
+	* config/rs6000/t-linux (MULTIARCH_DIRNAME): Set to non-empty only
+	if_multiarch.
+
+	PR middle-end/89590
+	* builtins.c (maybe_emit_free_warning): Punt if free doesn't have
+	exactly one argument.
+
+	2019-02-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89520
+	* convert.c (convert_to_real_1, convert_to_integer_1): Punt for
+	builtins if they don't have a single scalar floating point argument.
+	Formatting fixes.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89412
+	* expr.c (expand_assignment): If result is a MEM, use change_address
+	instead of simplify_gen_subreg.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+		    David Malcolm  <dmalcolm@redhat.com>
+
+	PR middle-end/89091
+	* fold-const.c (decode_field_reference): Return NULL_TREE if
+	lang_hooks.types.type_for_size returns NULL.  Check it before
+	overwriting *exp_.  Use return NULL_TREE instead of return 0.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/88074
+	PR middle-end/89415
+	* toplev.c (do_compile): Double the emin/emax exponents to workaround
+	buggy mpc_norm.
+
+	2019-02-19  Richard Biener  <rguenther@suse.de>
+
+        PR middle-end/88074
+	* toplev.c (do_compile): Initialize mpfr's exponent range
+	based on available float modes.
+
+2019-04-30  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from mainline.
+	2019-04-30  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+	PR target/86538
+	* config/aarch64/aarch64-c.c (aarch64_update_cpp_builtins):
+	Define __ARM_FEATURE_ATOMICS.
+
+2019-04-30  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	Backport from mainline
+	2018-12-11  Richard Earnshaw  <Richard.Earnshaw@arm.com>
+
+	PR target/37369
+	* config/aarch64/iterators.md (sizem1): Add sizes for
+	SFmode and DFmode.
+	(Vbtype): Add SFmode mapping.
+	* config/aarch64/aarch64.md (copysigndf3, copysignsf3): Delete.
+	(copysign<GPF:mode>3): New expand pattern.
+	(copysign<GPF:mode>3_insn): New insn pattern.
+
+2019-04-29  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline:
+	2019-01-25  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/89037
+	* varasm.c (output_constructor_bitfield): Use wi::extract_uhwi
+	instead of accessing TREE_INT_CST_ELT directly.
+
+2019-04-29  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline:
+	2018-08-23  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/85910
+	* config/aarch64/aarch64.c (aarch64_expand_vec_perm_const_1): Fix
+	aarch64_evpc_tbl guard.
+
+2019-04-29  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline:
+	2019-03-08  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR debug/89631
+	* dwarf2cfi.c (dwarf2out_frame_debug_expr): Use CONST_POLY_INT
+	instead of POLY_INT_CST.
+
+2019-04-26  Roman Zhuykov  <zhroma@ispras.ru>
+
+	Backport from mainline
+	2019-04-23  Roman Zhuykov  <zhroma@ispras.ru>
+
+	PR rtl-optimization/87979
+	* modulo-sched.c (sms_schedule): Start ii value "mii" should
+	not equal zero.
+
+	PR rtl-optimization/84032
+	* modulo-sched.c (ps_insn_find_column): Change condition so that
+	branch will always be the last insn in a row inside partial
+	schedule.
+
+2019-04-19  Pat Haugen  <pthaugen@us.ibm.com>
+
+	Backport from mainline:
+	2019-04-16  Pat Haugen  <pthaugen@us.ibm.com>
+
+	PR target/84369
+	* config/rs6000/power9.md: Add store forwarding bypass.
+
+2019-04-17  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-10  Martin Jambor  <mjambor@suse.cz>
+
+        PR tree-optimization/85762
+        PR tree-optimization/87008
+        PR tree-optimization/85459
+        * tree-sra.c (contains_vce_or_bfcref_p): New parameter, set the bool
+        it points to if there is a type changing MEM_REF.  Adjust all callers.
+        (build_accesses_from_assign): Disable total scalarization if
+        contains_vce_or_bfcref_p returns true through the new parameter, for
+        both rhs and lhs.
+
+2019-04-17  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-03-15  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/87532
+	* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin):
+	When handling vec_extract, use modular arithmetic to allow
+	constant selectors greater than vector length.
+	* config/rs6000/rs6000.c (rs6000_expand_vector_extract): Allow
+	V1TImode vectors to have constant selector values greater than 0.
+	Use modular arithmetic to compute vector index.
+	(rs6000_split_vec_extract_var): Use modular arithmetic to compute
+	index for in-memory vectors.  Correct code generation for
+	in-register vectors.  Use inner mode of vector rather than mode of
+	destination for move instruction.
+	(altivec_expand_vec_ext_builtin): Use modular arithmetic to
+	compute index.
+
+	2019-04-12  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/87532
+	* config/rs6000/vsx.md (*vsx_extract_<mode>_<VS_scalar>mode_var):
+	Use QI inner mode with V16QI vector mode.
+
+2019-04-15  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-04-15  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/89693
+	* cgraph.c (clone_of_p): Loop over clone chain for each step in
+	the thunk chain.
+
+2019-04-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-01-18  Martin Liska  <mliska@suse.cz>
+		    Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/88587
+	* cgraph.h (create_version_clone_with_body): Add new argument
+	with attributes.
+	* cgraphclones.c (cgraph_node::create_version_clone): Add
+	DECL_ATTRIBUTES to a newly created decl.  And call
+	valid_attribute_p so that proper cl_target_optimization_node
+	is set for the newly created declaration.
+	* multiple_target.c (create_target_clone): Set DECL_ATTRIBUTES
+	for declaration.
+	(expand_target_clones): Do not call valid_attribute_p, it must
+	be already done.
+	* tree-inline.c (copy_decl_for_dup_finish): Reset mode for
+	vector types.
+
+2019-04-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90018
+	* tree-vect-data-refs.c (vect_preserves_scalar_order_p):
+	Test both SLP and interleaving variants.
+
+2019-04-10  Matthew Malcomson  <matthew.malcomson@arm.com>
+
+	PR target/90024
+	* config/arm/arm.c (neon_valid_immediate): Disallow VOIDmode parameter.
+	* config/arm/constraints.md (Dm, DN, Dn): Split previous Dn constraint
+	into three.
+	* config/arm/neon.md (*neon_mov<mode>): Account for TImode and DImode
+	differences directly.
+	(*smax<mode>3_neon, vashl<mode>3, vashr<mode>3_imm): Use Dm constraint.
+
+2019-04-07  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/89945
+	* config/i386/i386.md (anddi_1 to andsi_1_zext splitter):
+	Avoid calling gen_lowpart with SYMBOL_REF and LABEL_REF operand.
+
+2019-04-04  Martin Sebor  <msebor@redhat.com>
+
+	PR middle-end/89934
+	* gimple-ssa-warn-restrict.c (builtin_access::builtin_access): Bail
+	out if the number of arguments is less than expected.
+
+2019-04-03  Richard Biener  <rguenther@suse.de>
+
+	PR lto/89896
+	* lto-wrapper.c (run_gcc): Avoid implicit rules making
+	the all target phony.
+
+2019-04-02  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/89902
+	PR target/89903
+	* config/i386/i386.c (dimode_scalar_to_vector_candidate_p):
+	Return false for variable DImode shifts.
+	(dimode_scalar_chain::compute_convert_gain): Do not handle
+	register count operand in variable DImode shifts.
+	(dimode_scalar_chain::make_vector_copies): Remove support to copy
+	count argument of a variable shift instruction to a vector register.
+	(dimode_scalar_chain::convert_reg): Remove support to convert
+	count argument of a variable shift instruction.
+
+2019-03-29  Kugan Vivekanandarajah  <kuganv@linaro.org>
+
+	Backport from mainline
+	2019-03-29  Kugan Vivekanandarajah  <kuganv@linaro.org>
+		    Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/89862
+	* rtl.h (word_register_operation_p): Exclude CONST_INT from operations
+	that operates on the full registers for WORD_REGISTER_OPERATIONS
+	architectures.
+
+2019-03-28  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/89848
+	* config/i386/i386.c (dimode_scalar_chain::make_vector_copies):
+	Also process XEXP (src, 0) of a shift insn.
+
+2019-03-28  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-11-05  Martin Liska  <mliska@suse.cz>
+
+	PR web/87829
+	* doc/invoke.texi: Remove options that are
+	not disabled with -Os.
+
+2019-03-26  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/89827
+	* config/i386/i386.c (dimode_scalar_chain::convert_reg):
+	Also process XEXP (src, 0) of a shift insn.
+
+2019-03-25  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-03-20  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	PR target/89775
+	* config/s390/s390.c (global_not_special_regno_p): Move to make it
+	available to ...
+	(s390_optimize_register_info): Use global_not_special_regno_p to
+	check for global regs.
+
+2019-03-22  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2019-03-22  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	* config/rs6000/mmintrin.h (_mm_sub_pi32): Fix typo.
+
+2019-03-21  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+        Backport from mainline
+        2019-03-08  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+        * config/rs6000/rs6000-p8swap.c (rs6000_analyze_swaps): Rebuild
+        ud- and du-chains between phases.
+
+2019-03-19  Richard Biener  <rguenther@suse.de>
+
+	PR debug/88389
+	* opts.c (finish_options): Disable -gsplit-dwarf when doing LTO.
+
+2019-03-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/89753
+	* loop-unroll.c (decide_unroll_constant_iterations): Make guard for
+	explicit unrolling factor even more robust.
+
+2019-03-18  Martin Sebor  <msebor@redhat.com>
+
+	PR middle-end/88273
+	* gimple-ssa-warn-restrict.c (builtin_memref::extend_offset_range):
+	Handle anti-ranges the same as no range at all.
+
+2019-03-18  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-18  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/89546
+	* tree-sra.c (propagate_subaccesses_across_link): Requeue new_acc if
+	any propagation to its children took place.
+
+2019-03-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2019-03-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/89523
+	* config/i386/i386.c (ix86_print_operand): Handle 'M' to add
+	addr32 prefix to VSIB address for X32.
+	* config/i386/sse.md (*avx512pf_gatherpf<mode>sf_mask): Prepend
+	"%M2" to opcode.
+	(*avx512pf_gatherpf<mode>df_mask): Likewise.
+	(*avx512pf_scatterpf<mode>sf_mask): Likewise.
+	(*avx512pf_scatterpf<mode>df_mask): Likewise.
+	(*avx2_gathersi<mode>): Prepend "%M3" to opcode.
+	(*avx2_gathersi<mode>_2): Prepend "%M2" to opcode.
+	(*avx2_gatherdi<mode>): Prepend "%M3" to opcode.
+	(*avx2_gatherdi<mode>_2): Prepend "%M2" to opcode.
+	(*avx2_gatherdi<mode>_3): Prepend "%M3" to opcode.
+	(*avx2_gatherdi<mode>_4): Prepend "%M2" to opcode.`
+	(*avx512f_gathersi<mode>): Prepend "%M4" to opcode.
+	(*avx512f_gathersi<mode>_2): Prepend "%M3" to opcode.
+	(*avx512f_gatherdi<mode>): Prepend "%M4" to opcode.
+	(*avx512f_gatherdi<mode>_2): Prepend "%M3" to opcode.
+	(*avx512f_scattersi<mode>): Prepend "%M0" to opcode.
+	(*avx512f_scatterdi<mode>): Likewise.
+
+2019-03-15  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-11-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR testsuite/85368
+	* params.def (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT): New param.
+	* tree-ssa-ifcombine.c (ifcombine_ifandif): If
+	--param logical-op-non-short-circuit is present, override
+	LOGICAL_OP_NON_SHORT_CIRCUIT value from the param.
+	* fold-const.c (fold_range_test, fold_truth_andor): Likewise.
+
+2019-03-15  Martin Liska  <mliska@suse.cz>
+
+	PR other/89712
+	* doc/invoke.texi: Remove -fdump-class-hierarchy option.
+
+2019-03-14  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-07  Martin Jambor  <mjambor@suse.cz>
+
+	PR lto/87525
+	* ipa-cp.c (perform_estimation_of_a_value): Account zero time benefit
+	for extern inline functions.
+
+2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89572
+	* tree-scalar-evolution.c (get_loop_exit_condition): Use
+	safe_dyn_cast.
+	* tree-ssa-loop-ivcanon.c (canonicalize_loop_induction_variables):
+	Use gimple_location_safe.
+
+2019-03-13  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR target/85860
+	* lra-constraints.c (inherit_in_ebb): Update
+	potential_reload_hard_regs along with live_hard_regs.
+
+2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-03-13  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89677
+	* tree-scalar-evolution.c (simplify_peeled_chrec): Do not
+	throw FP expressions at tree-affine.
+
+	2019-03-01  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89497
+	* tree-cfgcleanup.h (cleanup_tree_cfg): Add SSA update flags
+	argument, defaulted to zero.
+	* passes.c (execute_function_todo): Pass down SSA update flags
+	to cleanup_tree_cfg.
+	* tree-cfgcleanup.c: Include tree-into-ssa.h and tree-cfgcleanup.h.
+	(cleanup_tree_cfg_1): After cleanup_control_flow_pre update SSA
+	form if requested.
+	(cleanup_tree_cfg_noloop): Pass down SSA update flags.
+	(cleanup_tree_cfg): Get and pass down SSA update flags.
+
+	2019-02-18  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89296
+	* tree-ssa-loop-ch.c (ch_base::copy_headers): Restrict setting
+	of no-warning flag to cases that might emit the bogus warning.
+
+2019-03-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-03-11  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/s390.c (s390_expand_builtin): Do the copy_to_reg not
+	only on the else branch.
+
+2019-03-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-02-07  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/s390-builtin-types.def: Add new types.
+	* config/s390/s390-builtins.def: (s390_vec_xl, s390_vec_xld2)
+	(s390_vec_xlw4): Make the memory operand into a const pointer.
+	(s390_vec_xld2, s390_vec_xlw4): Add a variant for single precision
+	float.
+	* config/s390/s390-c.c (s390_expand_overloaded_builtin): Generate
+	a new vector type with the alignment of the scalar memory operand.
+
+2019-03-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89664
+	* tree-ssa-math-opts.c (execute_cse_reciprocals_1): Properly
+	free the occurance tree after the early out.
+
+2019-03-12  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2019-03-08  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* config/arm/arm.h (TARGET_FP16_TO_DOUBLE): Add TARGET_VFP_DOUBLE
+	requirement.
+
+2019-03-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/89588
+	* loop-unroll.c (decide_unroll_constant_iterations): Make guard for
+	explicit unrolling factor more robust.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-03-08  Martin Liska  <mliska@suse.cz>
+
+	PR target/86952
+	* config/i386/i386.c (ix86_option_override_internal): Disable
+	jump tables when retpolines are used.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  David Malcolm  <dmalcolm@redhat.com>
+
+	PR lto/88147
+	* input.c (selftest::test_line_offset_overflow): New selftest.
+	(selftest::input_c_tests): Call it.
+
+2019-03-08  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-07  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/88235
+	* cgraph.h (cgraph_node): New inline method former_thunk_p.
+	* cgraph.c (cgraph_node::dump): Dump a note if node is a former thunk.
+	(clone_of_p): Treat expanded thunks like thunks, be optimistic if they
+	have multiple callees.  At the end check if declarations match as
+	opposed to cgraph_nodes.
+
+2019-03-06  Tamar Christina  <tamar.christina@arm.com>
+
+	Backport from trunk.
+	2019-02-25  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/88530
+	* common/config/aarch64/aarch64-common.c
+	(struct aarch64_option_extension): Add is_synthetic.
+	(all_extensions): Use it.
+	(TARGET_OPTION_INIT_STRUCT): Define hook.
+	(struct gcc_targetm_common): Moved to end.
+	(all_extensions_by_on): New.
+	(opt_ext_cmp, typedef opt_ext): New.
+	(aarch64_option_init_struct): New.
+	(aarch64_contains_opt): New.
+	(aarch64_get_extension_string_for_isa_flags): Output smallest set.
+	* config/aarch64/aarch64-option-extensions.def
+	(AARCH64_OPT_EXTENSION): Explicitly include AES and SHA2 in crypto.
+	(fp, simd, crc, lse, fp16, rcpc, rdma, dotprod, aes, sha2, sha3,
+	sm4, fp16fml, sve):
+	Set is_synthetic to false.
+	(crypto): Set is_synthetic to true.
+	* config/aarch64/driver-aarch64.c (AARCH64_OPT_EXTENSION): Add
+	SYNTHETIC.
+
+2019-03-06  Tamar Christina  <tamar.christina@arm.com>
+
+	Backport from trunk.
+	2019-02-28  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/88530
+	* config/aarch64/aarch64-option-extensions.def: Document it.
+	* config/aarch64/driver-aarch64.c (host_detect_local_cpu): Skip feature
+	if empty hwcaps.
+
+2019-03-06  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport of r268834 from mainline to gcc-8-branch.
+	2019-02-13  Xiong Hu Luo  <luoxhu@linux.vnet.ibm.com>
+
+	* config/rs6000/altivec.h (vec_sbox_be, vec_cipher_be,
+	vec_cipherlast_be, vec_ncipher_be, vec_ncipherlast_be): New #defines.
+	* config/rs6000/crypto.md (CR_vqdi): New define_mode_iterator.
+	(crypto_vsbox_<mode>, crypto_<CR_insn>_<mode>): New define_insns.
+	* config/rs6000/rs6000-builtin.def (VSBOX_BE): New BU_CRYPTO_1.
+	(VCIPHER_BE, VCIPHERLAST_BE, VNCIPHER_BE, VNCIPHERLAST_BE):
+	New BU_CRYPTO_2.
+	* config/rs6000/rs6000.c (builtin_function_type)
+	<CRYPTO_BUILTIN_VSBOX_BE, CRYPTO_BUILTIN_VCIPHER_BE,
+	CRYPTO_BUILTIN_VCIPHERLAST_BE, CRYPTO_BUILTIN_VNCIPHER_BE,
+	CRYPTO_BUILTIN_VNCIPHERLAST_BE>: New switch options.
+	* doc/extend.texi (vec_sbox_be, vec_cipher_be, vec_cipherlast_be,
+	vec_ncipher_be, vec_ncipherlast_be): New builtin functions.
+
+2019-03-05  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-02-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89505
+	* tree-ssa-structalias.c (compute_dependence_clique): Make sure
+	to handle restrict pointed-to vars with multiple subvars
+	correctly.
+
+2019-03-01  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/89517
+	* config/aarch64/aarch64-option-extensions.def (fp, simd, crypto,
+	fp16): Collapse line.
+
+2019-03-01  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-03-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR bootstrap/89539
+	* dwarf2out.c (output_comdat_type_unit): Add ATTRIBUTE_UNUSED to
+	early_lto_debug argument.
+
+	2019-02-27  Richard Biener  <rguenther@suse.de>
+
+	PR debug/88878
+	* dwarf2out.c (use_debug_types): Disable when in_lto_p.
+
+	2019-02-27  Richard Biener  <rguenther@suse.de>
+
+	PR debug/88878
+	* dwarf2out.c (output_comdat_type_unit): Add early_lto_debug
+	parameter, prefix section name with .gnu.debuglto_ if true.
+	(dwarf2out_finish): Pass false to output_comdat_type_unit.
+	(dwarf2out_early_finish): Pass true to output_comdat_type_unit.
+
+	2019-02-27  Richard Biener  <rguenther@suse.de>
+
+	PR debug/89514
+	* dwarf2out.c (size_of_die): Key on AT_ref (a)->comdat_type_p
+	rather than on use_debug_types, doing what output_die does.
+	(value_format): Likewise.
+
+2019-02-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR tree-optimization/89536
+	* tree-ssa-dom.c (edge_info::derive_equivalences) <BIT_NOT_EXPR>: Test
+	only whether bit #0 of the value is 0 instead of the entire value.
+
+2019-02-28  Li Jia He  <helijia@linux.ibm.com>
+
+	Backport from trunk
+	2019-02-20  Li Jia He  <helijia@linux.ibm.com>
+
+	PR target/88100
+	* gcc/config/rs6000/rs6000.c (rs6000_gimple_fold_builtin)
+	<case ALTIVEC_BUILTIN_VSPLTISB, ALTIVEC_BUILTIN_VSPLTISH,
+	ALTIVEC_BUILTIN_VSPLTISW>: Don't convert the operand before
+	range checking it.
+
+2019-02-27  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/89397
+	* config/i386/i386.c (ix86_atomic_assign_expand_fenv): Check
+	TARGET_SSE in addition to TARGET_SSE_MATH.
+
+	(ix86_excess_precision): Ditto.
+	(ix86_float_exceptions_rounding_supported_p): Ditto.
+	(use_rsqrt_p): Ditto.
+	* config/i386/sse.md (rsqrt<mode>2): Ditto.
+
+2019-02-27  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-02-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/89361
+	* config/s390/s390.c (s390_indirect_branch_attrvalue,
+	s390_indirect_branch_settings): Define unconditionally.
+	(s390_set_current_function): Likewise, but guard the whole body except
+	the s390_indirect_branch_settings call with
+	#if S390_USE_TARGET_ATTRIBUTE.
+	(TARGET_SET_CURRENT_FUNCTION): Redefine unconditionally.
+
+2019-02-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2019-02-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* rtlanal.c (get_initial_register_offset): Fall back to the estimate
+	as long as the epilogue isn't completed.
+
+2019-02-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* tree-ssa-dom.c (edge_info::derive_equivalences) <BIT_IOR_EXPR>: Fix
+	and move around comment.
+	<BIT_AND_EXPR>: Likewise.
+	<BIT_NOT_EXPR>: Add specific handling for boolean types.
+
+2019-02-24  Alan Modra  <amodra@gmail.com>
+
+	PR target/89271
+	* config/rs6000/rs6000.md (<bd>_<mode> split): Check for an int
+	output reg on add insn.
+	(<bd>tf_<mode> split): Likewise.  Match predicates with insn.
+
+2019-02-22  Jakub Jelinek  <jakub@redhat.com>
+
+	* BASE-VER: Set to 8.3.1.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
@@ -568,7 +3047,7 @@
 
 	Backport from mainline
 	2018-11-20  Richard Biener  <rguenther@suse.de>
- 
+
 	PR tree-optimization/88105
 	* tree-ssa-dom.c (pass_dominator::execute): Do not walk
 	backedges.
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-18d.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18d.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18d.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18d.c	(revision 278653)
@@ -0,0 +1,148 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Unsigned Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned int s3 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector unsigned int s1 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector unsigned int s21 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned int s30 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned int ms3 (vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector unsigned int ms1(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector unsigned int ms21(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned int ms30(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned int ci (vector unsigned int v, int i, unsigned int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned int mci(vector unsigned int *vp, int i, unsigned int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, unsigned char *argv[]) {
+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };
+
+  sv = s3 (sv, CONST2);
+  if (sv [3] != CONST2)
+    abort ();
+
+  sv = s1 (sv, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST1);
+  if (sv [2] != CONST1)
+    abort ();
+
+  sv = ms3 (&sv, CONST0);
+  if (sv [3] != CONST0)
+    abort ();
+
+  sv = ms1 (&sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ms21 (&sv, CONST1);
+  if (sv [1] != CONST1)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = ci (sv, 2, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 15, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = mci (&sv, 12, CONST2);
+  if (sv [0] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 25, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 16, CONST1);
+  if (sv [0] != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-19c.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19c.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19c.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19c.c	(revision 278653)
@@ -0,0 +1,122 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+#define CONST2		(3 * 31415926539LL)
+#define CONST3		(4 * 31415926539LL)
+#define CONST4		(5 * 31415926539LL)
+#define CONST5		(6 * 31415926539LL)
+#define CONST6		(7 * 31415926539LL)
+#define CONST7		(8 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned long long int
+e0 (vector unsigned long long int v, unsigned long long int x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned long long int
+e3 (vector unsigned long long int v, unsigned long long int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned long long int
+me0 (vector unsigned long long int *vp, unsigned long long int x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned long long int
+me3 (vector unsigned long long int *vp, unsigned long long int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned long long int
+ei (vector unsigned long long int v, int i, unsigned long long int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned long long int
+mei (vector unsigned long long int *vp, int i, unsigned long long int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned long long int dv = { CONST0, CONST1 };
+  unsigned long long int d;
+
+  dv = e0 (dv, CONST7);
+  if (dv [0] != CONST7)
+    abort ();
+
+  dv = e3 (dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = me0 (&dv, CONST4);
+  if (dv [0] != CONST4)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST5);
+  if (dv [0] != CONST5)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST6);
+  if (dv [1] != CONST6)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-10a.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10a.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10a.c	(revision 278653)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+short s3 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 3);
+}
+
+short s7 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 7);
+}
+
+short s21 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 21);
+}
+
+short s30 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+short ms3 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 3);
+}
+
+short ms7 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 7);
+}
+
+short ms21 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 21);
+}
+
+short ms30 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+short ci (vector short v, int i)
+{
+  return __builtin_vec_ext_v8hi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+short mci (vector short *vp, int i)
+{
+  return __builtin_vec_ext_v8hi (*vp, i);
+}
+
+
+int main (int argc, short *argv[]) {
+  vector short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr80125.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr80125.c b/gcc/testsuite/gcc.target/powerpc/pr80125.c
--- a/gcc/testsuite/gcc.target/powerpc/pr80125.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/powerpc/pr80125.c	(revision 278653)
@@ -16,7 +16,7 @@
   vector int k = vec_mergel (i, j);
   vector int l = vec_sl (k, c);
   vector int m = vec_sl (l, d);
-  vector char o;
+  vector unsigned char o;
   vector int p = vec_perm (m, n, o);
   e = vec_sra (p, c);
   vec_st (e, 0, a);
Index: gcc/testsuite/gcc.target/powerpc/darn-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/darn-3.c b/gcc/testsuite/gcc.target/powerpc/darn-3.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/darn-3.c	(revision 278653)
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-aix* } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-O2 -mcpu=power9" } */
+
+static int darn32(void) { return __builtin_darn_32(); }
+
+int four(void)
+{
+	int sum = 0;
+	int i;
+	for (i = 0; i < 4; i++)
+		sum += darn32();
+	return sum;
+}
+
+/* { dg-final { scan-assembler-times {(?n)\mdarn .*,0\M} 4 } } */
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-20a.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20a.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20a.c	(revision 278653)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+extern void abort (void);
+
+#define CONST0		(((unsigned __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned __int128 e0 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned __int128 e3 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned __int128 me0 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned __int128 me3 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned __int128 ei (vector unsigned __int128 v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned __int128 mei (vector unsigned __int128 *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector unsigned __int128 dv = { CONST0 };
+  unsigned __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-10c.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10c.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10c.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10c.c	(revision 278653)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector short s3 (vector short v, short x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector short s7 (vector short v, short x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector short s21 (vector short v, short x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector short s30 (vector short v, short x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector short ms3 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector short ms7 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 7);
+}
+
+vector short ms21 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector short ms30 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector short ci (vector short v, int i, short x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector short mci (vector short *vp, int i, short x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, short *argv[]) {
+  vector short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  short s;
+
+  sv = s3 (sv, CONST6);
+  if (sv [3] != CONST6)
+    abort ();
+
+  sv = s7 (sv, CONST4);
+  if (sv [7] != CONST4)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST2);
+  if (sv [6] != CONST2)
+    abort ();
+
+  sv = ms3 (&sv, CONST5);
+  if (sv [3] != CONST5)
+    abort ();
+
+  sv = ms7 (&sv, CONST1);
+  if (sv [7] != CONST1)
+    abort ();
+
+  sv = ms21 (&sv, CONST2);
+  if (sv [5] != CONST2)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [6] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST6);
+  if (sv [5] != CONST6)
+    abort ();
+
+  sv = ci (sv, 2, CONST4);
+  if (sv [2] != CONST4)
+    abort ();
+
+  sv = ci (sv, 15, CONST3);
+  if (sv [7] != CONST3)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [4] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 12, CONST7);
+  if (sv [4] != CONST7)
+    abort ();
+
+  sv = mci (&sv, 25, CONST6);
+  if (sv [1] != CONST6)
+    abort ();
+
+  sv = mci (&sv, 16, CONST5);
+  if (sv [0] != CONST5)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-11b.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11b.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11b.c	(revision 278653)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+int s3 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 3);
+}
+
+int s1 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 1);
+}
+
+int s21 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 21);
+}
+
+int s30 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+int ms3 (vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 3);
+}
+
+int ms1(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 1);
+}
+
+int ms21(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 21);
+}
+
+int ms30(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+int ci (vector int v, int i)
+{
+  return __builtin_vec_ext_v4si (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+int mci(vector int *vp, int i)
+{
+  return __builtin_vec_ext_v4si (*vp, i);
+}
+
+
+int main (int argc, int *argv[]) {
+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };
+  int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pure-builtin-redundant-load.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pure-builtin-redundant-load.c b/gcc/testsuite/gcc.target/powerpc/pure-builtin-redundant-load.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pure-builtin-redundant-load.c	(revision 278653)
@@ -0,0 +1,47 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-O2 -fdump-tree-fre-all -mvsx" } */
+
+/* Verify we remove a redundant load that occurs both before and after
+we call a vector load builtin.
+This testcase is introduced as we updated a number of our vector load
+built-ins with the attribute of PURE instead of MEM, to indicate that
+those builtins only read from memory, versus reading from and writing
+to the same.
+This means we can identify the redundant load instructions in an earlier
+pass, and optimize them away.  */
+
+#include <altivec.h>
+
+vector signed short load_data;
+
+vector signed short foo()
+{
+	vector signed short r11,r12,r13;
+	r11 = load_data;
+	r12 = vec_xl (0, &load_data[0]);
+	r13 = load_data;
+	return (r11 + r12 + r13);
+}
+
+vector signed short biz()
+{
+	vector signed short r21,r22,r23;
+	r21 = load_data;
+	r22 = vec_lvehx (0, &load_data[0]);
+	r23 = load_data;
+	return (r21 + r22 + r23);
+}
+
+vector signed short bar()
+{
+	vector signed short r31,r32,r33;
+	r31 = load_data;
+	r32 = vec_lvx (0, &load_data[0]);
+	r33 = load_data;
+	return (r31 + r32 + r33);
+}
+
+/* { dg-final { scan-tree-dump-times "Removing dead stmt r13_. = load_data;" 1 "fre1" } } */
+/* { dg-final { scan-tree-dump-times "Removing dead stmt r23_. = load_data;" 1 "fre1" } } */
+/* { dg-final { scan-tree-dump-times "Removing dead stmt r33_. = load_data;" 1 "fre1" } } */
Index: gcc/testsuite/gcc.target/powerpc/builtins-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/builtins-2.c b/gcc/testsuite/gcc.target/powerpc/builtins-2.c
--- a/gcc/testsuite/gcc.target/powerpc/builtins-2.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/powerpc/builtins-2.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do run { target { powerpc*-*-* } } } */
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-require-effective-target vsx_hw } */
 /* { dg-options "-mcpu=power8 " } */
 
 #include <altivec.h>
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-9b.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9b.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9b.c	(revision 278653)
@@ -0,0 +1,164 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+signed char c0 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 0);
+}
+
+signed char c9 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 9);
+}
+
+signed char c21 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 21);
+}
+
+signed char c30 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+signed char mc0 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 0);
+}
+
+signed char mc9 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 9);
+}
+
+signed char mc21 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 21);
+}
+
+signed char mc30 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+signed char ci (vector signed char v, int i)
+{
+  return __builtin_vec_ext_v16qi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+signed char mci(vector signed char *vp, int i) {
+  return __builtin_vec_ext_v16qi (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  signed char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-12a.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12a.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12a.c	(revision 278653)
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+long long int e0 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 0);
+}
+
+long long int e3 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+long long int me0 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 0);
+}
+
+long long int me3 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+long long int ei (vector long long int v, int i)
+{
+  return __builtin_vec_ext_v2di (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+long long int mei (vector long long int *vp, int i)
+{
+  return __builtin_vec_ext_v2di (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector long long int dv = { CONST0, CONST1 };
+  long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr64205.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr64205.c b/gcc/testsuite/gcc.target/powerpc/pr64205.c
--- a/gcc/testsuite/gcc.target/powerpc/pr64205.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/powerpc/pr64205.c	(revision 278653)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { powerpc*-*-* && ilp32 } } } */
+/* { dg-require-effective-target dfp } */
 /* { dg-skip-if "" { powerpc*-*-aix* } } */
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=G5" } } */
 /* { dg-options "-O2 -mcpu=G5 -maltivec" } */
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-20c.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20c.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20c.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20c.c	(revision 278653)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(((unsigned __int128) 31415926539) << 60)
+#define CONST1		(((unsigned __int128) 31415926539) << 54)
+#define CONST2		(((unsigned __int128) 31415926539) << 48)
+#define CONST3		(((unsigned __int128) 31415926539) << 32)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned __int128 e0 (vector unsigned __int128 v, unsigned __int128 x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned __int128 e3 (vector unsigned __int128 v, unsigned __int128 x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned __int128
+me0 (vector unsigned __int128 *vp, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned __int128
+me3 (vector unsigned __int128 *vp, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned __int128
+ei (vector unsigned __int128 v, int i, unsigned __int128 x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned __int128
+mei (vector unsigned __int128 *vp, int i, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned __int128 dv = { CONST0 };
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me0 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST0);
+  if (dv [0] != CONST0)
+    abort ();
+
+  dv = ei (dv, 1, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = ei (dv, 3, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 0, CONST0);
+  if (dv [0] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 1, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 3, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-11d.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11d.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11d.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11d.c	(revision 278653)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector int s3 (vector int v, int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector int s1 (vector int v, int x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector int s21 (vector int v, int x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector int s30 (vector int v, int x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector int ms3  (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector int ms1 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector int ms21 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector int ms30 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector int ci (vector int v, int i, int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector int mci(vector int *vp, int i, int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, int *argv[]) {
+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };
+  int s;
+
+  sv = s3 (sv, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = s1 (sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = s21 (sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = s30 (sv, CONST1);
+  if (sv [2] != CONST1)
+    abort ();
+
+  sv = ms3 (&sv, CONST2);
+  if (sv [3] != CONST2)
+    abort ();
+
+  sv = ms1 (&sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ms21 (&sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ci (sv, 2, CONST3);
+  if (sv [2] != CONST3)
+    abort ();
+
+  sv = ci (sv, 15, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 12, CONST1);
+  if (sv [0] != CONST1)
+    abort ();
+
+  sv = mci (&sv, 25, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 16, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr70010.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr70010.c b/gcc/testsuite/gcc.target/powerpc/pr70010.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr70010.c	(revision 278653)
@@ -0,0 +1,20 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -finline-functions -Wno-psabi -mvsx" } */
+/* { dg-final { scan-assembler {\mbl \.?vadd_no_vsx\M} } } */
+
+
+typedef int vec_t __attribute__((vector_size(16)));
+
+static vec_t
+__attribute__((__target__("no-vsx")))
+vadd_no_vsx (vec_t a, vec_t b)
+{
+  return a + b;
+}
+
+vec_t
+__attribute__((__target__("vsx")))
+call_vadd_no_vsx (vec_t x, vec_t y, vec_t z)
+{
+  return vadd_no_vsx (x, y) - z;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr71785.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr71785.c b/gcc/testsuite/gcc.target/powerpc/pr71785.c
--- a/gcc/testsuite/gcc.target/powerpc/pr71785.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/powerpc/pr71785.c	(revision 278653)
@@ -1,6 +1,11 @@
 /* { dg-do compile { target { powerpc*-*-* } } } */
 /* { dg-options "-O2" } */
-/* { dg-final { scan-assembler-not {\mb\M} } } */
+/* We have to lose the default pic codegen on Darwin.  */
+/* { dg-additional-options "-mdynamic-no-pic" { target powerpc*-*-darwin* } } */
+/* ... and account for the out-of-line GPR restore.  */
+/* { dg-final { scan-assembler-times {\mb[ \t]*restGPR} 1 { target powerpc*-*-darwin* } } } */
+/* { dg-final { scan-assembler-not {\mb[ \t]L} { target powerpc*-*-darwin* } } } */
+/* { dg-final { scan-assembler-not {\mb\M} { target { ! powerpc*-*-darwin* } } } } */
 
 /* Check that all computed gotos in this testcase end up unfactored completely.
    If some is not there will be a unconditional jump left; if all works fine,
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-9d.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9d.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9d.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9d.c	(revision 278653)
@@ -0,0 +1,164 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector signed char c0 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector signed char c9 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 9);
+}
+
+vector signed char c21 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector signed char c30 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector signed char mc0 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector signed char mc9 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 9);
+}
+
+vector signed char mc21 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector signed char mc30 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector signed char ci (vector signed char v, int i, signed char x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector signed char mci(vector signed char *vp, int i, signed char x) {
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  signed char c;
+
+  cv = c0 (cv, CONSTF);
+  if (cv [0] != CONSTF)
+    abort ();
+
+  cv = c9 (cv, CONST7);
+  if (cv [9] != CONST7)
+    abort ();
+
+  cv = c21 (cv, CONSTA);
+  if (cv [5] != CONSTA)
+    abort ();
+
+  cv = c30 (cv, CONSTC);
+  if (cv [14] != CONSTC)
+    abort ();
+
+  cv = mc0 (&cv, CONSTB);
+  if (cv [0] != CONSTB)
+    abort ();
+
+  cv = mc9 (&cv, CONST1);
+  if (cv [9] != CONST1)
+    abort ();
+
+  cv = mc21 (&cv, CONST7);
+  if (cv [5] != CONST7)
+    abort ();
+
+  cv = mc30 (&cv, CONST2);
+  if (cv [14] != CONST2)
+    abort ();
+
+  cv = ci (cv, 8, CONST4);
+  if (cv [8] != CONST4)
+    abort ();
+
+  cv = ci (cv, 13, CONSTB);
+  if (cv [13] != CONSTB)
+    abort ();
+
+  cv = ci (cv, 23, CONST3);
+  if (cv [7] != CONST3)
+    abort ();
+
+  cv = ci (cv, 31, CONST2);
+  if (cv [15] != CONST2)
+    abort ();
+
+  cv = mci (&cv, 5, CONST1);
+  if (cv [5] != CONST1)
+    abort ();
+
+  cv = mci (&cv, 12, CONST3);
+  if (cv [12] != CONST3)
+    abort ();
+
+  cv = mci (&cv, 25, CONST5);
+  if (cv [9] != CONST5)
+    abort ();
+
+  cv = mci (&cv, 16, CONSTD);
+  if (cv [0] != CONSTD)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-12c.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12c.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12c.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12c.c	(revision 278653)
@@ -0,0 +1,112 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+#define CONST2		(3 * 31415926539LL)
+#define CONST3		(4 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector long long int e0 (vector long long int v, long long int x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector long long int e3 (vector long long int v, long long int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector long long int me0 (vector long long int *vp, long long int x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector long long int me3 (vector long long int *vp, long long int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector long long int ei (vector long long int v, int i, long long int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector long long int mei (vector long long int *vp, int i, long long int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector long long int dv = { CONST0, CONST1 };
+  long long int d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = me0 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 0, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 3, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-13b.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13b.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13b.c	(revision 278653)
@@ -0,0 +1,124 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+/* Define this after PR89626 is addressed.  */
+#undef PR89626
+
+#ifdef PR89626
+#define SIGNED
+#else
+#define SIGNED signed
+#endif
+
+extern void abort (void);
+
+#define CONST0		(((SIGNED __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+SIGNED __int128 e0 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 0);
+}
+
+SIGNED __int128 e3 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+SIGNED __int128 me0 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 0);
+}
+
+SIGNED __int128 me3 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+SIGNED __int128 ei (vector SIGNED __int128 v, int i)
+{
+  return __builtin_vec_ext_v1ti (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+SIGNED __int128 mei (vector SIGNED __int128 *vp, int i)
+{
+  return __builtin_vec_ext_v1ti (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  SIGNED __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-14a.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14a.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14a.c	(revision 278653)
@@ -0,0 +1,126 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		((float) (3.1415926539))
+#define CONST1		((float) (3.1415926539 * 2))
+#define CONST2		((float) (3.1415926539 * 3))
+#define CONST3		((float) (3.1415926539 * 4))
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+float e0(vector float v){ return __builtin_vec_ext_v4sf (v, 0); }
+float e1(vector float v){ return __builtin_vec_ext_v4sf (v, 1); }
+float e7(vector float v){ return __builtin_vec_ext_v4sf (v, 7); }
+float e8(vector float v){ return __builtin_vec_ext_v4sf (v, 8); }
+
+/* Test for vector residing in memory.  */
+float me0(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 0); }
+float me1(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 1); }
+
+float me13(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 13);
+}
+
+float me15(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 15);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+float ei(vector float v, int i)
+{
+  return __builtin_vec_ext_v4sf (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+float mei(vector float *vp, int i)
+{
+  return __builtin_vec_ext_v4sf (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };
+  float d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e7 (dv);
+  if (d != CONST3)
+    abort ();
+
+  d = e8 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me13 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me15 (&dv);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST2)
+    abort ();
+
+  d = ei (dv, 11);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 17);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 15);
+  if (d != CONST3)
+    abort ();
+
+  d = mei (&dv, 6);
+  if (d != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2a.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2a.c b/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2a.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2a.c	(revision 278653)
@@ -0,0 +1,14 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx" } */
+
+#define TYPE unsigned char
+/* ELEMENTS is number of elements in a vector of TYPE.  */
+#define ELEMENTS 16
+#define INITIAL \
+  {  3, 2, 3, 4, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 }
+
+#define DO_TRACE
+#define DISABLE_INLINE_OF_GET_AUTO_N
+
+#include "vec-extract-v16qiu-v2.h"
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-13d.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13d.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13d.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13d.c	(revision 278653)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+#define SIGNED signed
+
+extern void abort (void);
+
+#define CONST0		(((SIGNED __int128) 31415926539) << 60)
+#define CONST1		(((SIGNED __int128) 31415926539) << 55)
+#define CONST2		(((SIGNED __int128) 31415926539) << 50)
+#define CONST3		(((SIGNED __int128) 31415926539) << 45)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector SIGNED __int128 e0 (vector SIGNED __int128 v, SIGNED __int128 x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector SIGNED __int128 e3 (vector SIGNED __int128 v, SIGNED __int128 x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector SIGNED __int128 me0 (vector SIGNED __int128 *vp, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector SIGNED __int128 me3 (vector SIGNED __int128 *vp, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector SIGNED __int128
+ei (vector SIGNED __int128 v, int i, SIGNED __int128 x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector SIGNED __int128
+mei (vector SIGNED __int128 *vp, int i, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  SIGNED __int128 d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 0, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 1, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr70010-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr70010-4.c b/gcc/testsuite/gcc.target/powerpc/pr70010-4.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr70010-4.c	(revision 278653)
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mvsx" } */
+
+vector int c, a, b;
+
+static inline void __attribute__ ((__always_inline__, target ("no-vsx")))
+foo () /* { dg-error "inlining failed in call to .* target specific option mismatch" } */
+{
+  c = a + b;
+}
+
+int
+main ()
+{
+  foo (); /* { dg-message "called from here" } */
+  c = a + b;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-14c.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14c.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14c.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14c.c	(revision 278653)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		((float) (3.1415926539))
+#define CONST1		((float) (3.1415926539 * 2))
+#define CONST2		((float) (3.1415926539 * 3))
+#define CONST3		((float) (3.1415926539 * 4))
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector float e0(vector float v, float x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector float e1(vector float v, float x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector float e7(vector float v, float x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector float e8(vector float v, float x)
+{
+  return vec_insert (x, v, 8);
+}
+
+/* Test for vector residing in memory.  */
+vector float me0(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector float me1(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector float me13(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 13);
+}
+
+vector float me15(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 15);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector float ei(vector float v, int i, float x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector float mei(vector float *vp, int i, float x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };
+  float d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e1 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = e7 (dv, CONST2);
+  if (dv [3] != CONST2)
+    abort ();
+
+  dv = e8 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me1 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = me13 (&dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = me15 (&dv, CONST1);
+  if (dv [3] != CONST1)
+    abort ();
+
+  dv = ei (dv, 0, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 2, CONST1);
+  if (dv [2] != CONST1)
+    abort ();
+
+  dv = ei (dv, 11, CONST0);
+  if (dv [3] != CONST0)
+    abort ();
+
+  dv = ei (dv, 17, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 15, CONST1);
+  if (dv [3] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 6, CONST0);
+  if (dv [2] != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/bmi2-bzhi64-1a.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/bmi2-bzhi64-1a.c b/gcc/testsuite/gcc.target/powerpc/bmi2-bzhi64-1a.c
--- a/gcc/testsuite/gcc.target/powerpc/bmi2-bzhi64-1a.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/powerpc/bmi2-bzhi64-1a.c	(revision 278653)
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O3" } */
+/* { dg-options "-O3 -maltivec -mvsx" } */
 /* { dg-require-effective-target lp64 } */
 
 #define NO_WARN_X86_INTRINSICS 1
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-15b.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15b.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15b.c	(revision 278653)
@@ -0,0 +1,113 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(3.1415926539)
+#define CONST1		(3.1415926539 * 2)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+double e0(vector double v){ return __builtin_vec_ext_v2df (v, 0); }
+double e1(vector double v){ return __builtin_vec_ext_v2df (v, 1); }
+double e2(vector double v){ return __builtin_vec_ext_v2df (v, 2); }
+double e3(vector double v){ return __builtin_vec_ext_v2df (v, 3); }
+
+/* Test for vector residing in memory.  */
+double me0(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 0); }
+double me1(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 1); }
+double me2(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 2); }
+double me3(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 3); }
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+double ei(vector double v, int i){ return __builtin_vec_ext_v2df (v, i); }
+
+/* Test for variable selector and vector residing in memory.  */
+double mei(vector double *vp, int i){ return __builtin_vec_ext_v2df (*vp, i); }
+
+
+int main (int argc, char *argv[]) {
+  vector double dv;
+  double d;
+  dv[0] = CONST0;
+  dv[1] = CONST1;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e2 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me2 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr92090-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr92090-2.c b/gcc/testsuite/gcc.target/powerpc/pr92090-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr92090-2.c	(revision 278653)
@@ -0,0 +1,45 @@
+/* { dg-do compile } */
+/* { dg-options "-mcpu=power8 -Os -w" } */
+/* { dg-additional-options "-mbig" { target powerpc64le-*-* } } */
+
+/* Verify that we don't ICE.  */
+
+int a;
+static _Atomic long double b, c, d, m;
+double n;
+extern int foo (void);
+extern void bar (int, int, int, int);
+
+void
+bug (void)
+{
+  b = 1.79769313486231580793728971405301199e308L;
+  for (int i = 0; i < 10000; i++)
+    if (__builtin_isinf (n))
+      b;
+  c = 1;
+  int e, f, g, h;
+  while (a)
+    ;
+  for (int i; i; i++)
+    {
+      double j = c /= foo ();
+      if (__builtin_isinf (j))
+	{
+	  if (foo == 1 << 31)
+	    e++;
+	  f++;
+	  c = 0;
+	}
+      else
+	{
+	  if (foo == 1 << 30)
+	    g++;
+	  h++;
+	  c = 1;
+	}
+    }
+  bar (e, f, g, h);
+  d = 1.79769313486231580793728971405301199e308L;
+  m = 1;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-16a.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16a.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16a.c	(revision 278653)
@@ -0,0 +1,165 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned char c0 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned char c9 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 9);
+}
+
+unsigned char c21 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned char c30 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned char mc0 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned char mc9 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 9);
+}
+
+unsigned char mc21 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned char mc30 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned char ci (vector unsigned char v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned char mci (vector unsigned char *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  unsigned char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-15d.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15d.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15d.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15d.c	(revision 278653)
@@ -0,0 +1,151 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(3.1415926539)
+#define CONST1		(3.1415926539 * 2)
+#define CONST2		(3.1415926539 * 3)
+#define CONST3		(3.1415926539 * 4)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector double e0(vector double v, double x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector double e1(vector double v, double x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector double e2(vector double v, double x)
+{
+  return vec_insert (x, v, 2);
+}
+
+vector double e3(vector double v, double x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector double me0(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector double me1(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector double me2(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 2);
+}
+
+vector double me3(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector double ei(vector double v, int i, double x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector double mei(vector double *vp, int i, double x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector double dv;
+  double d;
+  dv[0] = CONST0;
+  dv[1] = CONST1;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e1 (dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = e2 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = e3 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me1 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = me2 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = ei (dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 3, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-16c.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16c.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16c.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16c.c	(revision 278653)
@@ -0,0 +1,180 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <stdio.h>
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned char c0 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned char c9 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 9);
+}
+
+vector unsigned char c21 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned char c30 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned char mc0 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned char mc9 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 9);
+}
+
+vector unsigned char mc21 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned char mc30 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned char ci (vector unsigned char v, int i, unsigned char x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned char mci (vector unsigned char *vp, int i, unsigned char x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,
+			      CONST4, CONST5, CONST6, CONST7,
+			      CONST8, CONST9, CONSTA, CONSTB,
+			      CONSTC, CONSTD, CONSTE, CONSTF };
+  printf ("A\n");
+  cv = c0 (cv, CONST3);
+  if (cv [0] != CONST3)
+    abort ();
+
+  printf ("B\n");
+  cv = c9 (cv, CONST2);
+  if (cv [9] != CONST2)
+    abort ();
+
+  printf ("C\n");
+  cv = c21 (cv, CONSTF);
+  if (cv [5] != CONSTF)
+    abort ();
+
+  printf ("D\n");
+  cv = c30 (cv, CONST3);
+  if (cv [14] != CONST3)
+    abort ();
+
+  printf ("E\n");
+  cv = mc0 (&cv, CONST4);
+  if (cv [0] != CONST4)
+    abort ();
+
+  printf ("F\n");
+  cv = mc9 (&cv, CONST3);
+  if (cv [9] != CONST3)
+    abort ();
+
+  printf ("G\n");
+  cv = mc21 (&cv, CONST1);
+  if (cv [5] != CONST1)
+    abort ();
+
+  printf ("H\n");
+  cv = mc30 (&cv, CONSTC);
+  if (cv [14] != CONSTC)
+    abort ();
+
+  printf ("I\n");
+  cv = ci (cv, 8, CONSTD);
+  if (cv [8] != CONSTD)
+    abort ();
+
+  printf ("J\n");
+  cv = ci (cv, 13, CONST5);
+  if (cv [13] != CONST5)
+    abort ();
+
+  printf ("K\n");
+  cv = ci (cv, 23, CONST6);
+  if (cv [7] != CONST6)
+    abort ();
+
+  printf ("L\n");
+  cv = ci (cv, 31, CONST7);
+  if (cv [15] != CONST7)
+    abort ();
+
+  printf ("M\n");
+  cv = mci (&cv, 5, CONST8);
+  if (cv [5] != CONST8)
+    abort ();
+
+  printf ("N\n");
+  cv = mci (&cv, 12, CONST9);
+  if (cv [12] != CONST9)
+    abort ();
+
+  printf ("O\n");
+  cv = mci (&cv, 25, CONSTA);
+  if (cv [9] != CONSTA)
+    abort ();
+
+  printf ("P\n");
+  cv = mci (&cv, 16, CONSTB);
+  if (cv [0] != CONSTB)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-17b.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17b.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17b.c	(revision 278653)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned short s3 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned short s7 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 7);
+}
+
+unsigned short s21 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned short s30 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned short ms3 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned short ms7 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 7);
+}
+
+unsigned short ms21 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned short ms30 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned short ci (vector unsigned short v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned short mci (vector unsigned short *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, unsigned short *argv[]) {
+  vector unsigned short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  unsigned short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-18a.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18a.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18a.c	(revision 278653)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Unsigned Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned int s3 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned int s1 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 1);
+}
+
+unsigned int s21 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned int s30 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned int ms3 (vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned int ms1(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 1);
+}
+
+unsigned int ms21(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned int ms30(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned int ci (vector unsigned int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned int mci(vector unsigned int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+unsigned int main (int argc, unsigned char *argv[]) {
+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };
+  unsigned int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr87532-mc.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr87532-mc.c b/gcc/testsuite/gcc.target/powerpc/pr87532-mc.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr87532-mc.c	(revision 278653)
@@ -0,0 +1,258 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O2" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <stdlib.h>
+#include <stddef.h>
+#include <altivec.h>
+
+#include <stdio.h>
+
+static vector unsigned __int128
+deoptimize_uint128 (vector unsigned __int128  a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned long long int
+deoptimize_ulong (vector unsigned long long int a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned int
+deoptimize_uint (vector unsigned int a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned char
+deoptimize_uchar (vector unsigned char a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned short
+deoptimize_ushort (vector unsigned short a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+__attribute ((noinline)) unsigned __int128
+get_auto_n_uint128 (vector unsigned __int128 a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline)) unsigned long long int
+get_auto_n_ulong (vector unsigned long long int a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned int get_auto_n_uint (vector unsigned int a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned char get_auto_n_uchar (vector unsigned char a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned short get_auto_n_ushort (vector unsigned short a, int n)
+{
+  return __builtin_vec_extract (a, n);
+}
+
+
+int check_uint128_element (int i, unsigned __int128 entry)
+{
+  printf ("checking uint128 entry at index %d\n", i);
+
+  return (entry == ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)
+		    | 0x0706050403020100ULL));
+}
+
+int check_ulong_element (int i, unsigned long long int entry)
+{
+  printf ("checking ulong entry 0x%llx at index %d\n", entry, i);
+
+  switch (i % 2)
+    {
+      case 0: return (entry == 0x9999901010ULL);
+      case 1: return (entry == 0x7777733333ULL);
+      default:
+	return 0;
+    }
+}
+
+int check_uint_element (int i, unsigned int entry)
+{
+  printf ("checking uint entry 0x%x at index %d\n", entry, i);
+
+  switch (i % 4)
+    {
+    case 0: return (entry == 0x99999);
+    case 1: return (entry == 0x01010);
+    case 2: return (entry == 0x77777);
+    case 3: return (entry == 0x33333);
+    default:
+      return 0;
+    }
+}
+
+int check_uchar_element (int i, unsigned char entry)
+{
+  printf ("checking uchar entry 0x%x at index %d\n", entry, i);
+  switch (i % 16)
+    {
+    case 0: return (entry == 0x90);
+    case 1: return (entry == 0x80);
+    case 2: return (entry == 0x70);
+    case 3: return (entry == 0x60);
+    case 4: return (entry == 0x50);
+    case 5: return (entry == 0x40);
+    case 6: return (entry == 0x30);
+    case 7: return (entry == 0x20);
+    case 8: return (entry == 0x10);
+    case 9: return (entry == 0xf0);
+    case 10: return (entry == 0xe0);
+    case 11: return (entry == 0xd0);
+    case 12: return (entry == 0xc0);
+    case 13: return (entry == 0xb0);
+    case 14: return (entry == 0xa0);
+    case 15: return (entry == 0xff);
+    default:
+      return 0;
+    }
+}
+
+int check_ushort_element (int i, unsigned short entry)
+{
+  printf ("checking ushort entry 0x%x at index %d\n", entry, i);
+  switch (i % 8)
+    {
+    case 0: return (entry == 0x9988);
+    case 1: return (entry == 0x8877);
+    case 2: return (entry == 0x7766);
+    case 3: return (entry == 0x6655);
+    case 4: return (entry == 0x5544);
+    case 5: return (entry == 0x4433);
+    case 6: return (entry == 0x3322);
+    case 7: return (entry == 0x2211);
+    default:
+      return 0;
+    }
+}
+
+void do_auto_uint128 ( vector unsigned __int128 a )
+{
+  int i;
+  unsigned __int128 c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uint128 (a,i);
+      if (!check_uint128_element (i, c)) abort ();
+    }
+ }
+
+void do_auto_ulong ( vector unsigned long long int a )
+{
+  int i;
+  unsigned long long int c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_ulong (a,i);
+      if (!check_ulong_element (i, c)) abort ();
+    }
+ }
+
+void do_auto_uint ( vector unsigned int a )
+{
+  int i;
+  unsigned int c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uint (a,i);
+      if (!check_uint_element (i, c)) abort ();
+    }
+ }
+
+void do_auto_ushort ( vector unsigned short a )
+{
+  int i;
+  unsigned short c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_ushort (a,i);
+      if (!check_ushort_element (i, c)) abort ();
+    }
+}
+
+void do_auto_uchar ( vector unsigned char a )
+{
+  int i;
+  unsigned char c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uchar (a,i);
+      if (!check_uchar_element (i, c)) abort ();
+    }
+}
+
+int
+main (void)
+{
+  size_t i;
+
+  vector unsigned __int128 u = {
+    ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)
+     | 0x0706050403020100ULL) };
+  vector unsigned __int128 du;
+
+  vector unsigned long long int v = { 0x9999901010ULL, 0x7777733333ULL };
+  vector unsigned long long int dv;
+
+  vector unsigned int x = { 0x99999, 0x01010, 0x77777, 0x33333 };
+  vector unsigned int dx;
+
+  vector unsigned char y = { 0x90, 0x80, 0x70, 0x60, 0x50, 0x40, 0x30, 0x20,
+			     0x10, 0xf0, 0xe0, 0xd0, 0xc0, 0xb0, 0xa0, 0xff };
+  vector unsigned char dy;
+
+  vector unsigned short z = { 0x9988, 0x8877, 0x7766, 0x6655,
+			      0x5544, 0x4433, 0x3322, 0x2211 };
+  vector unsigned short dz;
+
+  do_auto_uint128 (u);
+  do_auto_ulong (v);
+  do_auto_uint (x);
+  do_auto_uchar (y);
+  do_auto_ushort (z);
+
+  du = deoptimize_uint128 (u);
+  dv = deoptimize_ulong (v);
+  dx = deoptimize_uint (x);
+  dy = deoptimize_uchar (y);
+  dz = deoptimize_ushort (z);
+
+  do_auto_uint128 (du);
+  do_auto_ulong (dv);
+  do_auto_uint (dx);
+  do_auto_uchar (dy);
+  do_auto_ushort (dz);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/ppc-fortran/ppc-fortran.exp
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/ppc-fortran/ppc-fortran.exp b/gcc/testsuite/gcc.target/powerpc/ppc-fortran/ppc-fortran.exp
--- a/gcc/testsuite/gcc.target/powerpc/ppc-fortran/ppc-fortran.exp	(revision 278653)
+++ b/gcc/testsuite/gcc.target/powerpc/ppc-fortran/ppc-fortran.exp	(revision 278653)
@@ -36,7 +36,7 @@
     global gfortran_test_path
     global gfortran_aux_module_flags
     if { [llength $args] != 2 } {
-	error "dg-set-target-env-var: needs one argument"
+	error "dg-compile-aux-modules: needs one argument"
 	return
     }
 
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-17d.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17d.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17d.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17d.c	(revision 278653)
@@ -0,0 +1,154 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned short s3 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector unsigned short s7 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector unsigned short s21 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned short s30 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned short ms3 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector unsigned short ms7 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 7);
+}
+
+vector unsigned short ms21 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned short ms30 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned short ci (vector unsigned short v, int i, unsigned short x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned short mci (vector unsigned short *vp, int i, unsigned short x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, unsigned short *argv[]) {
+  vector unsigned short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+
+  sv = s3 (sv, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = s7 (sv, CONST2);
+  if (sv [7] != CONST2)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST4);
+  if (sv [6] != CONST4)
+    abort ();
+
+  sv = ms3 (&sv, CONST5);
+  if (sv [3] != CONST5)
+    abort ();
+
+  sv = ms7 (&sv, CONST6);
+  if (sv [7] != CONST6)
+    abort ();
+
+  sv = ms21 (&sv, CONST7);
+  if (sv [5] != CONST7)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [6] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST1);
+  if (sv [5] != CONST1)
+    abort ();
+
+  sv = ci (sv, 2, CONST3);
+  if (sv [2] != CONST3)
+    abort ();
+
+  sv = ci (sv, 15, CONST2);
+  if (sv [7] != CONST2)
+    abort ();
+
+  sv = ci (sv, 28, CONST5);
+  if (sv [4] != CONST5)
+    abort ();
+
+  sv = mci (&sv, 5, CONST4);
+  if (sv [5] != CONST4)
+    abort ();
+
+  sv = mci (&sv, 12, CONST6);
+  if (sv [4] != CONST6)
+    abort ();
+
+  sv = mci (&sv, 25, CONST7);
+  if (sv [1] != CONST7)
+    abort ();
+
+  sv = mci (&sv, 16, CONST4);
+  if (sv [0] != CONST4)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr89424-0.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr89424-0.c b/gcc/testsuite/gcc.target/powerpc/pr89424-0.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr89424-0.c	(revision 278653)
@@ -0,0 +1,76 @@
+/* { dg-do run { target { powerpc*-*-* && lp64 } } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+/* Define PR89626 after that pr is addressed.  */
+#ifdef PR89626
+#define SIGNED
+#else
+#define SIGNED signed
+#endif
+
+#define CONST0		(((__int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+__int128 ei (vector SIGNED __int128 v, int i)
+{
+  return __builtin_vec_ext_v1ti (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__int128 mei (vector SIGNED __int128 *vp, int i)
+{
+  return __builtin_vec_ext_v1ti (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  __int128 d;
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-18c.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18c.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18c.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18c.c	(revision 278653)
@@ -0,0 +1,148 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Unsigned Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned int s3 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector unsigned int s1 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector unsigned int s21 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned int s30 (vector unsigned int v, unsigned int x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned int ms3 (vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector unsigned int ms1(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector unsigned int ms21(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned int ms30(vector unsigned int *vp, unsigned int x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned int ci (vector unsigned int v, int i, unsigned int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned int mci(vector unsigned int *vp, int i, unsigned int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, unsigned char *argv[]) {
+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };
+
+  sv = s3 (sv, CONST2);
+  if (sv [3] != CONST2)
+    abort ();
+
+  sv = s1 (sv, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST1);
+  if (sv [2] != CONST1)
+    abort ();
+
+  sv = ms3 (&sv, CONST0);
+  if (sv [3] != CONST0)
+    abort ();
+
+  sv = ms1 (&sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ms21 (&sv, CONST1);
+  if (sv [1] != CONST1)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = ci (sv, 2, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 15, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = mci (&sv, 12, CONST2);
+  if (sv [0] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 25, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 16, CONST1);
+  if (sv [0] != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c
--- a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c	(revision 278653)
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-skip-if "not implemented for Darwin" { powerpc*-*-darwin* } } */
 /* { dg-additional-options "-mno-speculate-indirect-jumps" } */
 /* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-19b.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19b.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19b.c	(revision 278653)
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned long long int e0 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned long long int e3 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned long long int me0 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned long long int me3 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned long long int ei (vector unsigned long long int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned long long int mei (vector unsigned long long int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned long long int dv = { CONST0, CONST1 };
+  unsigned long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr91275.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr91275.c b/gcc/testsuite/gcc.target/powerpc/pr91275.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr91275.c	(revision 278653)
@@ -0,0 +1,26 @@
+/* Test that we generate vpmsumd correctly without a swap error.  */
+
+/* { dg-do run { target { p8vector_hw } } } */
+/* { dg-options "-O2 -std=gnu11" } */
+
+#include <altivec.h>
+
+int main() {
+
+  const unsigned long long r0l = 0x8e7dfceac070e3a0;
+  vector unsigned long long r0 = (vector unsigned long long) {r0l, 0}, v;
+  const vector unsigned long long pd
+    = (vector unsigned long long) {0xc2LLU << 56, 0};
+
+  v = __builtin_crypto_vpmsumd ((vector unsigned long long) {r0[0], 0}, pd);
+
+#if __LITTLE_ENDIAN__
+  if (v[0] != 0x4000000000000000 || v[1] != 0x65bd7ab605a4a8ff)
+    __builtin_abort ();
+#else
+  if (v[1] != 0x4000000000000000 || v[0] != 0x65bd7ab605a4a8ff)
+    __builtin_abort ();
+#endif
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-19d.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19d.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19d.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19d.c	(revision 278653)
@@ -0,0 +1,122 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+#define CONST2		(3 * 31415926539LL)
+#define CONST3		(4 * 31415926539LL)
+#define CONST4		(5 * 31415926539LL)
+#define CONST5		(6 * 31415926539LL)
+#define CONST6		(7 * 31415926539LL)
+#define CONST7		(8 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned long long int
+e0 (vector unsigned long long int v, unsigned long long int x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned long long int
+e3 (vector unsigned long long int v, unsigned long long int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned long long int
+me0 (vector unsigned long long int *vp, unsigned long long int x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned long long int
+me3 (vector unsigned long long int *vp, unsigned long long int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned long long int
+ei (vector unsigned long long int v, int i, unsigned long long int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned long long int
+mei (vector unsigned long long int *vp, int i, unsigned long long int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned long long int dv = { CONST0, CONST1 };
+  unsigned long long int d;
+
+  dv = e0 (dv, CONST7);
+  if (dv [0] != CONST7)
+    abort ();
+
+  dv = e3 (dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = me0 (&dv, CONST4);
+  if (dv [0] != CONST4)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST5);
+  if (dv [0] != CONST5)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST6);
+  if (dv [1] != CONST6)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-10b.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10b.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10b.c	(revision 278653)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+short s3 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 3);
+}
+
+short s7 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 7);
+}
+
+short s21 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 21);
+}
+
+short s30 (vector short v)
+{
+  return __builtin_vec_ext_v8hi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+short ms3 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 3);
+}
+
+short ms7 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 7);
+}
+
+short ms21 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 21);
+}
+
+short ms30 (vector short *vp)
+{
+  return __builtin_vec_ext_v8hi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+short ci (vector short v, int i)
+{
+  return __builtin_vec_ext_v8hi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+short mci (vector short *vp, int i)
+{
+  return __builtin_vec_ext_v8hi (*vp, i);
+}
+
+
+int main (int argc, short *argv[]) {
+  vector short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-11a.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11a.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11a.c	(revision 278653)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+int s3 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 3);
+}
+
+int s1 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 1);
+}
+
+int s21 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 21);
+}
+
+int s30 (vector int v)
+{
+  return __builtin_vec_ext_v4si (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+int ms3 (vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 3);
+}
+
+int ms1(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 1);
+}
+
+int ms21(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 21);
+}
+
+int ms30(vector int *vp)
+{
+  return __builtin_vec_ext_v4si (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+int ci (vector int v, int i)
+{
+  return __builtin_vec_ext_v4si (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+int mci(vector int *vp, int i)
+{
+  return __builtin_vec_ext_v4si (*vp, i);
+}
+
+
+int main (int argc, int *argv[]) {
+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };
+  int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-9a.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9a.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9a.c	(revision 278653)
@@ -0,0 +1,164 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+signed char c0 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 0);
+}
+
+signed char c9 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 9);
+}
+
+signed char c21 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 21);
+}
+
+signed char c30 (vector signed char v)
+{
+  return __builtin_vec_ext_v16qi (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+signed char mc0 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 0);
+}
+
+signed char mc9 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 9);
+}
+
+signed char mc21 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 21);
+}
+
+signed char mc30 (vector signed char *vp)
+{
+  return __builtin_vec_ext_v16qi (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+signed char ci (vector signed char v, int i)
+{
+  return __builtin_vec_ext_v16qi (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+signed char mci(vector signed char *vp, int i) {
+  return __builtin_vec_ext_v16qi (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  signed char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c b/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c
--- a/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1.c	(revision 278653)
@@ -4,6 +4,7 @@
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
 /* { dg-options "-mcpu=power8 -O2 -ftree-vectorize -fvect-cost-model=dynamic -fno-unroll-loops -fno-unroll-all-loops" } */
 
+#include <altivec.h>
 typedef vector unsigned long long	crypto_t;
 typedef vector unsigned long long	v2di_t;
 typedef vector unsigned int		v4si_t;
@@ -10,31 +11,56 @@
 typedef vector unsigned short		v8hi_t;
 typedef vector unsigned char		v16qi_t;
 
-crypto_t crpyto1 (crypto_t a)
+crypto_t crypto1 (crypto_t a)
 {
   return __builtin_crypto_vsbox (a);
 }
 
+v16qi_t crypto1_be (v16qi_t a)
+{
+  return vec_sbox_be (a);
+}
+
 crypto_t crypto2 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vcipher (a, b);
 }
 
+v16qi_t crypto2_be (v16qi_t a, v16qi_t b)
+{
+  return vec_cipher_be (a, b);
+}
+
 crypto_t crypto3 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vcipherlast (a, b);
 }
 
+v16qi_t crypto3_be (v16qi_t a, v16qi_t b)
+{
+  return vec_cipherlast_be (a, b);
+}
+
 crypto_t crypto4 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vncipher (a, b);
 }
 
+v16qi_t crypto4_be (v16qi_t a, v16qi_t b)
+{
+  return vec_ncipher_be (a, b);
+}
+
 crypto_t crypto5 (crypto_t a, crypto_t b)
 {
   return __builtin_crypto_vncipherlast (a, b);
 }
 
+v16qi_t crypto5_be (v16qi_t a, v16qi_t b)
+{
+  return vec_ncipherlast_be (a, b);
+}
+
 v16qi_t crypto6a (v16qi_t a, v16qi_t b, v16qi_t c)
 {
   return __builtin_crypto_vpermxor (a, b, c);
@@ -117,15 +143,15 @@
 
 /* Note space is used after the instruction so that vcipherlast does not match
    vcipher.  */
-/* { dg-final { scan-assembler-times "vcipher "      1 } } */
-/* { dg-final { scan-assembler-times "vcipherlast "  1 } } */
-/* { dg-final { scan-assembler-times "vncipher "     1 } } */
-/* { dg-final { scan-assembler-times "vncipherlast " 1 } } */
+/* { dg-final { scan-assembler-times "vcipher "      2 } } */
+/* { dg-final { scan-assembler-times "vcipherlast "  2 } } */
+/* { dg-final { scan-assembler-times "vncipher "     2 } } */
+/* { dg-final { scan-assembler-times "vncipherlast " 2 } } */
 /* { dg-final { scan-assembler-times "vpermxor "     4 } } */
 /* { dg-final { scan-assembler-times "vpmsumb "      2 } } */
 /* { dg-final { scan-assembler-times "vpmsumd "      2 } } */
 /* { dg-final { scan-assembler-times "vpmsumh "      2 } } */
 /* { dg-final { scan-assembler-times "vpmsumw "      2 } } */
-/* { dg-final { scan-assembler-times "vsbox "        1 } } */
+/* { dg-final { scan-assembler-times "vsbox "        2 } } */
 /* { dg-final { scan-assembler-times "vshasigmad "   2 } } */
 /* { dg-final { scan-assembler-times "vshasigmaw "   2 } } */
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-20b.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20b.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20b.c	(revision 278653)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+extern void abort (void);
+
+#define CONST0		(((unsigned __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned __int128 e0 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned __int128 e3 (vector unsigned __int128 v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned __int128 me0 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned __int128 me3 (vector unsigned __int128 *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned __int128 ei (vector unsigned __int128 v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned __int128 mei (vector unsigned __int128 *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector unsigned __int128 dv = { CONST0 };
+  unsigned __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-10d.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10d.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10d.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-10d.c	(revision 278653)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector short s3 (vector short v, short x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector short s7 (vector short v, short x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector short s21 (vector short v, short x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector short s30 (vector short v, short x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector short ms3 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector short ms7 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 7);
+}
+
+vector short ms21 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector short ms30 (vector short *vp, short x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector short ci (vector short v, int i, short x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector short mci (vector short *vp, int i, short x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, short *argv[]) {
+  vector short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  short s;
+
+  sv = s3 (sv, CONST6);
+  if (sv [3] != CONST6)
+    abort ();
+
+  sv = s7 (sv, CONST4);
+  if (sv [7] != CONST4)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST2);
+  if (sv [6] != CONST2)
+    abort ();
+
+  sv = ms3 (&sv, CONST5);
+  if (sv [3] != CONST5)
+    abort ();
+
+  sv = ms7 (&sv, CONST1);
+  if (sv [7] != CONST1)
+    abort ();
+
+  sv = ms21 (&sv, CONST2);
+  if (sv [5] != CONST2)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [6] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST6);
+  if (sv [5] != CONST6)
+    abort ();
+
+  sv = ci (sv, 2, CONST4);
+  if (sv [2] != CONST4)
+    abort ();
+
+  sv = ci (sv, 15, CONST3);
+  if (sv [7] != CONST3)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [4] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 12, CONST7);
+  if (sv [4] != CONST7)
+    abort ();
+
+  sv = mci (&sv, 25, CONST6);
+  if (sv [1] != CONST6)
+    abort ();
+
+  sv = mci (&sv, 16, CONST5);
+  if (sv [0] != CONST5)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-11c.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11c.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11c.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-11c.c	(revision 278653)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector int s3 (vector int v, int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector int s1 (vector int v, int x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector int s21 (vector int v, int x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector int s30 (vector int v, int x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector int ms3  (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector int ms1 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector int ms21 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector int ms30 (vector int *vp, int x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector int ci (vector int v, int i, int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector int mci(vector int *vp, int i, int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, int *argv[]) {
+  vector int sv = { CONST0, CONST1, CONST2, CONST3 };
+  int s;
+
+  sv = s3 (sv, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = s1 (sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = s21 (sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = s30 (sv, CONST1);
+  if (sv [2] != CONST1)
+    abort ();
+
+  sv = ms3 (&sv, CONST2);
+  if (sv [3] != CONST2)
+    abort ();
+
+  sv = ms1 (&sv, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ms21 (&sv, CONST3);
+  if (sv [1] != CONST3)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [2] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST0);
+  if (sv [1] != CONST0)
+    abort ();
+
+  sv = ci (sv, 2, CONST3);
+  if (sv [2] != CONST3)
+    abort ();
+
+  sv = ci (sv, 15, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = ci (sv, 28, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  sv = mci (&sv, 5, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 12, CONST1);
+  if (sv [0] != CONST1)
+    abort ();
+
+  sv = mci (&sv, 25, CONST2);
+  if (sv [1] != CONST2)
+    abort ();
+
+  sv = mci (&sv, 16, CONST3);
+  if (sv [0] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/mmx-psubd-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/mmx-psubd-2.c b/gcc/testsuite/gcc.target/powerpc/mmx-psubd-2.c
--- a/gcc/testsuite/gcc.target/powerpc/mmx-psubd-2.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/powerpc/mmx-psubd-2.c	(revision 278653)
@@ -23,20 +23,28 @@
   return _mm_sub_pi32 (s1, s2);
 }
 
+static __m64
+__attribute__((noinline, unused))
+test_alias (__m64 s1, __m64 s2)
+{
+  return _m_psubd (s1, s2);
+}
+
 static void
 TEST (void)
 {
   __m64_union u, s1, s2;
-  __m64_union e;
+  __m64_union e, v;
   int i;
    
   s1.as_m64 = _mm_setr_pi32 (30, 90);
   s2.as_m64 = _mm_setr_pi32 (76, -100);
   u.as_m64 = test (s1.as_m64, s2.as_m64);
-   
+  v.as_m64 = test_alias (s1.as_m64, s2.as_m64);
+
   for (i = 0; i < 2; i++)
      e.as_int[i] = s1.as_int[i] - s2.as_int[i];
 
-  if (u.as_m64 != e.as_m64)
+  if (u.as_m64 != e.as_m64 || u.as_m64 != v.as_m64)
     abort ();
 }
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-9c.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9c.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9c.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-9c.c	(revision 278653)
@@ -0,0 +1,164 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector signed char c0 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector signed char c9 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 9);
+}
+
+vector signed char c21 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector signed char c30 (vector signed char v, signed char x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector signed char mc0 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector signed char mc9 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 9);
+}
+
+vector signed char mc21 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector signed char mc30 (vector signed char *vp, signed char x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector signed char ci (vector signed char v, int i, signed char x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector signed char mci(vector signed char *vp, int i, signed char x) {
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector signed char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  signed char c;
+
+  cv = c0 (cv, CONSTF);
+  if (cv [0] != CONSTF)
+    abort ();
+
+  cv = c9 (cv, CONST7);
+  if (cv [9] != CONST7)
+    abort ();
+
+  cv = c21 (cv, CONSTA);
+  if (cv [5] != CONSTA)
+    abort ();
+
+  cv = c30 (cv, CONSTC);
+  if (cv [14] != CONSTC)
+    abort ();
+
+  cv = mc0 (&cv, CONSTB);
+  if (cv [0] != CONSTB)
+    abort ();
+
+  cv = mc9 (&cv, CONST1);
+  if (cv [9] != CONST1)
+    abort ();
+
+  cv = mc21 (&cv, CONST7);
+  if (cv [5] != CONST7)
+    abort ();
+
+  cv = mc30 (&cv, CONST2);
+  if (cv [14] != CONST2)
+    abort ();
+
+  cv = ci (cv, 8, CONST4);
+  if (cv [8] != CONST4)
+    abort ();
+
+  cv = ci (cv, 13, CONSTB);
+  if (cv [13] != CONSTB)
+    abort ();
+
+  cv = ci (cv, 23, CONST3);
+  if (cv [7] != CONST3)
+    abort ();
+
+  cv = ci (cv, 31, CONST2);
+  if (cv [15] != CONST2)
+    abort ();
+
+  cv = mci (&cv, 5, CONST1);
+  if (cv [5] != CONST1)
+    abort ();
+
+  cv = mci (&cv, 12, CONST3);
+  if (cv [12] != CONST3)
+    abort ();
+
+  cv = mci (&cv, 25, CONST5);
+  if (cv [9] != CONST5)
+    abort ();
+
+  cv = mci (&cv, 16, CONSTD);
+  if (cv [0] != CONSTD)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-12b.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12b.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12b.c	(revision 278653)
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+long long int e0 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 0);
+}
+
+long long int e3 (vector long long int v)
+{
+  return __builtin_vec_ext_v2di (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+long long int me0 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 0);
+}
+
+long long int me3 (vector long long int *vp)
+{
+  return __builtin_vec_ext_v2di (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+long long int ei (vector long long int v, int i)
+{
+  return __builtin_vec_ext_v2di (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+long long int mei (vector long long int *vp, int i)
+{
+  return __builtin_vec_ext_v2di (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector long long int dv = { CONST0, CONST1 };
+  long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c
--- a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c	(revision 278653)
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-skip-if "not implemented for Darwin" { powerpc*-*-darwin* } } */
 /* { dg-additional-options "-mno-speculate-indirect-jumps" } */
 /* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-13a.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13a.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13a.c	(revision 278653)
@@ -0,0 +1,124 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+/* Define this after PR89424 is addressed.  */
+#define PR89424
+
+/* Define this after PR89626 is addressed.  */
+#undef PR89626
+
+#ifdef PR89626
+#define SIGNED
+#else
+#define SIGNED signed
+#endif
+
+extern void abort (void);
+
+#define CONST0		(((SIGNED __int128) 31415926539) << 60)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+SIGNED __int128 e0 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 0);
+}
+
+SIGNED __int128 e3 (vector SIGNED __int128 v)
+{
+  return __builtin_vec_ext_v1ti (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+SIGNED __int128 me0 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 0);
+}
+
+SIGNED __int128 me3 (vector SIGNED __int128 *vp)
+{
+  return __builtin_vec_ext_v1ti (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+#ifdef PR89424
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+SIGNED __int128 ei (vector SIGNED __int128 v, int i)
+{
+  return __builtin_vec_ext_v1ti (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+SIGNED __int128 mei (vector SIGNED __int128 *vp, int i)
+{
+  return __builtin_vec_ext_v1ti (*vp, i);
+}
+#endif
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  SIGNED __int128 d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST0)
+    abort ();
+
+#ifdef PR89424
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST0)
+    abort ();
+#endif
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr70010-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr70010-1.c b/gcc/testsuite/gcc.target/powerpc/pr70010-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr70010-1.c	(revision 278653)
@@ -0,0 +1,18 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -flto -mvsx" } */
+/* { dg-require-effective-target lto } */
+
+vector int c, a, b;
+
+static inline void __attribute__ ((__always_inline__, target ("no-vsx")))
+foo () /* { dg-error "inlining failed in call to .* target specific option mismatch" } */
+{
+  c = a + b;
+}
+
+int
+main ()
+{
+  foo (); /* { dg-message "called from here" } */
+  c = a + b;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr79909.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr79909.c b/gcc/testsuite/gcc.target/powerpc/pr79909.c
--- a/gcc/testsuite/gcc.target/powerpc/pr79909.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/powerpc/pr79909.c	(revision 278653)
@@ -1,6 +1,7 @@
 /* PR rtl-optimization/79909 */
 /* { dg-do compile } */
 /* { dg-options "-O2 -mxl-compat" } */
+/* { dg-require-effective-target dfp } */
 /* { dg-skip-if "DFP" { powerpc*-*-aix* } } */
 
 typedef float T __attribute__ ((mode (TD)));
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-20d.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20d.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20d.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-20d.c	(revision 278653)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(((unsigned __int128) 31415926539) << 60)
+#define CONST1		(((unsigned __int128) 31415926539) << 54)
+#define CONST2		(((unsigned __int128) 31415926539) << 48)
+#define CONST3		(((unsigned __int128) 31415926539) << 32)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned __int128 e0 (vector unsigned __int128 v, unsigned __int128 x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned __int128 e3 (vector unsigned __int128 v, unsigned __int128 x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned __int128
+me0 (vector unsigned __int128 *vp, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned __int128
+me3 (vector unsigned __int128 *vp, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned __int128
+ei (vector unsigned __int128 v, int i, unsigned __int128 x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned __int128
+mei (vector unsigned __int128 *vp, int i, unsigned __int128 x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned __int128 dv = { CONST0 };
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me0 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST0);
+  if (dv [0] != CONST0)
+    abort ();
+
+  dv = ei (dv, 1, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = ei (dv, 3, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 0, CONST0);
+  if (dv [0] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 1, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 3, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-12d.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12d.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12d.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-12d.c	(revision 278653)
@@ -0,0 +1,112 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O3" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+#define CONST2		(3 * 31415926539LL)
+#define CONST3		(4 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector long long int e0 (vector long long int v, long long int x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector long long int e3 (vector long long int v, long long int x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector long long int me0 (vector long long int *vp, long long int x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector long long int me3 (vector long long int *vp, long long int x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector long long int ei (vector long long int v, int i, long long int x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector long long int mei (vector long long int *vp, int i, long long int x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector long long int dv = { CONST0, CONST1 };
+  long long int d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = me0 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 0, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 3, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-13c.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13c.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13c.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-13c.c	(revision 278653)
@@ -0,0 +1,115 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+#define SIGNED signed
+
+extern void abort (void);
+
+#define CONST0		(((SIGNED __int128) 31415926539) << 60)
+#define CONST1		(((SIGNED __int128) 31415926539) << 55)
+#define CONST2		(((SIGNED __int128) 31415926539) << 50)
+#define CONST3		(((SIGNED __int128) 31415926539) << 45)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector SIGNED __int128 e0 (vector SIGNED __int128 v, SIGNED __int128 x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector SIGNED __int128 e3 (vector SIGNED __int128 v, SIGNED __int128 x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector SIGNED __int128 me0 (vector SIGNED __int128 *vp, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector SIGNED __int128 me3 (vector SIGNED __int128 *vp, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector SIGNED __int128
+ei (vector SIGNED __int128 v, int i, SIGNED __int128 x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector SIGNED __int128
+mei (vector SIGNED __int128 *vp, int i, SIGNED __int128 x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector SIGNED __int128 dv = { CONST0 };
+  SIGNED __int128 d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e3 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me3 (&dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 1, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 0, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 1, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = mei (&dv, 2, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 3, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr70010-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr70010-3.c b/gcc/testsuite/gcc.target/powerpc/pr70010-3.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr70010-3.c	(revision 278653)
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mno-vsx" } */
+
+vector int c, a, b;
+
+static inline void __attribute__ ((__always_inline__, target ("no-vsx")))
+foo ()
+{
+  c = a + b;
+}
+
+int
+main ()
+{
+  foo ();
+  c = a + b;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-14b.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14b.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14b.c	(revision 278653)
@@ -0,0 +1,126 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		((float) (3.1415926539))
+#define CONST1		((float) (3.1415926539 * 2))
+#define CONST2		((float) (3.1415926539 * 3))
+#define CONST3		((float) (3.1415926539 * 4))
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+float e0(vector float v){ return __builtin_vec_ext_v4sf (v, 0); }
+float e1(vector float v){ return __builtin_vec_ext_v4sf (v, 1); }
+float e7(vector float v){ return __builtin_vec_ext_v4sf (v, 7); }
+float e8(vector float v){ return __builtin_vec_ext_v4sf (v, 8); }
+
+/* Test for vector residing in memory.  */
+float me0(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 0); }
+float me1(vector float *vp){ return __builtin_vec_ext_v4sf (*vp, 1); }
+
+float me13(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 13);
+}
+
+float me15(vector float *vp)
+{
+  return __builtin_vec_ext_v4sf (*vp, 15);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+float ei(vector float v, int i)
+{
+  return __builtin_vec_ext_v4sf (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+float mei(vector float *vp, int i)
+{
+  return __builtin_vec_ext_v4sf (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };
+  float d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e7 (dv);
+  if (d != CONST3)
+    abort ();
+
+  d = e8 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me13 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me15 (&dv);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST2)
+    abort ();
+
+  d = ei (dv, 11);
+  if (d != CONST3)
+    abort ();
+
+  d = ei (dv, 17);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 15);
+  if (d != CONST3)
+    abort ();
+
+  d = mei (&dv, 6);
+  if (d != CONST2)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/stabs-attrib-vect-darwin.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/stabs-attrib-vect-darwin.c b/gcc/testsuite/gcc.target/powerpc/stabs-attrib-vect-darwin.c
--- a/gcc/testsuite/gcc.target/powerpc/stabs-attrib-vect-darwin.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/powerpc/stabs-attrib-vect-darwin.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* Test Attribute Vector associated with vector type stabs.  */
 /* { dg-do compile { target powerpc*-*-darwin* } } */
+/* { dg-require-effective-target stabs } */
 /* { dg-options "-gstabs+ -fno-eliminate-unused-debug-types -faltivec" } */
 
 int main ()
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-15a.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15a.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15a.c	(revision 278653)
@@ -0,0 +1,113 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(3.1415926539)
+#define CONST1		(3.1415926539 * 2)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+double e0(vector double v){ return __builtin_vec_ext_v2df (v, 0); }
+double e1(vector double v){ return __builtin_vec_ext_v2df (v, 1); }
+double e2(vector double v){ return __builtin_vec_ext_v2df (v, 2); }
+double e3(vector double v){ return __builtin_vec_ext_v2df (v, 3); }
+
+/* Test for vector residing in memory.  */
+double me0(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 0); }
+double me1(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 1); }
+double me2(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 2); }
+double me3(vector double *vp){ return __builtin_vec_ext_v2df (*vp, 3); }
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+double ei(vector double v, int i){ return __builtin_vec_ext_v2df (v, i); }
+
+/* Test for variable selector and vector residing in memory.  */
+double mei(vector double *vp, int i){ return __builtin_vec_ext_v2df (*vp, i); }
+
+
+int main (int argc, char *argv[]) {
+  vector double dv;
+  double d;
+  dv[0] = CONST0;
+  dv[1] = CONST1;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e1 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = e2 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me1 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me2 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2b.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2b.c b/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2b.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2b.c	(revision 278653)
@@ -0,0 +1,14 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-O2 -mvsx" } */
+
+#define TYPE unsigned char
+/* ELEMENTS is number of elements in a vector of TYPE.  */
+#define ELEMENTS 16
+#define INITIAL \
+  {  3, 2, 3, 4, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 }
+
+#define DO_TRACE
+#undef DISABLE_INLINE_OF_GET_AUTO_N
+
+#include "vec-extract-v16qiu-v2.h"
Index: gcc/testsuite/gcc.target/powerpc/bfp/bfp.exp
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/bfp/bfp.exp b/gcc/testsuite/gcc.target/powerpc/bfp/bfp.exp
--- a/gcc/testsuite/gcc.target/powerpc/bfp/bfp.exp	(revision 278653)
+++ b/gcc/testsuite/gcc.target/powerpc/bfp/bfp.exp	(revision 278653)
@@ -16,9 +16,11 @@
 # along with GCC; see the file COPYING3.  If not see
 # <http://www.gnu.org/licenses/>.
 
-# Exit immediately if this isn't a PowerPC target or if the target is aix.
+# Exit immediately if this isn't a PowerPC target or if the target is
+# aix or Darwin.
 if { (![istarget powerpc*-*-*] && ![istarget rs6000-*-*])
-     || [istarget "powerpc*-*-aix*"] } then {
+     || [istarget "powerpc*-*-aix*"]
+     || [istarget "powerpc*-*-darwin*"]  } then {
   return
 }
 
Index: gcc/testsuite/gcc.target/powerpc/pr87532.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr87532.c b/gcc/testsuite/gcc.target/powerpc/pr87532.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr87532.c	(revision 278653)
@@ -0,0 +1,72 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <stdlib.h>
+#include <stddef.h>
+#include <altivec.h>
+#include <stdio.h>
+
+static void
+check (unsigned char, unsigned char) __attribute__((__noinline__));
+
+static __attribute__((altivec(vector__))) unsigned char
+deoptimize (__attribute__((altivec(vector__))) unsigned char)
+__attribute__((__noinline__));
+
+static __attribute__((altivec(vector__))) unsigned char
+deoptimize (__attribute__((altivec(vector__))) unsigned char a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+// Toggle this attribute inline/noinline to see pass/fail.
+// fails with the noinline attribute applied.
+__attribute__ ((__noinline__))
+unsigned char
+get_auto_n (__attribute__((altivec(vector__))) unsigned char a, size_t n)
+{
+  return (unsigned char) __builtin_vec_extract (a, n);
+}
+
+void
+do_auto (__attribute__((altivec(vector__))) unsigned char a)
+{
+  size_t i;
+  for (i = 1; i < 3 ; i++)
+  {
+    do
+      {
+	printf ("get_auto_n (a, %d) produces 0x0%x\n",
+		i, (int) get_auto_n (a, i));
+
+	if ((int) get_auto_n (a,i) > 250) abort();
+      } while (0);
+  }
+}
+
+int
+main (void)
+{
+  size_t i;
+  __attribute__((altivec(vector__))) unsigned char x =
+    { 3, 2, 3, 8, 5, 6, 7, 8, 240, 241, 242, 243, 244, 245, 246, 247 };
+  __attribute__((altivec(vector__))) unsigned char a;
+
+  printf (" first elements of x are: %d %d %d %d %d\n",
+	  x[0], x[1], x[2], x[3], x[4]);
+
+  a = deoptimize (x);
+
+  printf (" after deoptimization, first elements of a are: %d %d %d %d %d\n",
+	  a[0], a[1], a[2], a[3], a[4]);
+
+  do_auto (a);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-14d.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14d.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14d.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-14d.c	(revision 278653)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		((float) (3.1415926539))
+#define CONST1		((float) (3.1415926539 * 2))
+#define CONST2		((float) (3.1415926539 * 3))
+#define CONST3		((float) (3.1415926539 * 4))
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector float e0(vector float v, float x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector float e1(vector float v, float x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector float e7(vector float v, float x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector float e8(vector float v, float x)
+{
+  return vec_insert (x, v, 8);
+}
+
+/* Test for vector residing in memory.  */
+vector float me0(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector float me1(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector float me13(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 13);
+}
+
+vector float me15(vector float *vp, float x)
+{
+  return vec_insert (x, *vp, 15);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector float ei(vector float v, int i, float x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector float mei(vector float *vp, int i, float x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector float dv = { CONST0, CONST1, CONST2, CONST3 };
+  float d;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e1 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = e7 (dv, CONST2);
+  if (dv [3] != CONST2)
+    abort ();
+
+  dv = e8 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me1 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = me13 (&dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = me15 (&dv, CONST1);
+  if (dv [3] != CONST1)
+    abort ();
+
+  dv = ei (dv, 0, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 2, CONST1);
+  if (dv [2] != CONST1)
+    abort ();
+
+  dv = ei (dv, 11, CONST0);
+  if (dv [3] != CONST0)
+    abort ();
+
+  dv = ei (dv, 17, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 15, CONST1);
+  if (dv [3] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 6, CONST0);
+  if (dv [2] != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-15c.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15c.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15c.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-15c.c	(revision 278653)
@@ -0,0 +1,151 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(3.1415926539)
+#define CONST1		(3.1415926539 * 2)
+#define CONST2		(3.1415926539 * 3)
+#define CONST3		(3.1415926539 * 4)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector double e0(vector double v, double x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector double e1(vector double v, double x)
+{
+  return vec_insert (x, v, 1);
+}
+
+vector double e2(vector double v, double x)
+{
+  return vec_insert (x, v, 2);
+}
+
+vector double e3(vector double v, double x)
+{
+  return vec_insert (x, v, 3);
+}
+
+/* Test for vector residing in memory.  */
+vector double me0(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector double me1(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 1);
+}
+
+vector double me2(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 2);
+}
+
+vector double me3(vector double *vp, double x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector double ei(vector double v, int i, double x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector double mei(vector double *vp, int i, double x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector double dv;
+  double d;
+  dv[0] = CONST0;
+  dv[1] = CONST1;
+
+  dv = e0 (dv, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = e1 (dv, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = e2 (dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = e3 (dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = me0 (&dv, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = me1 (&dv, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  dv = me2 (&dv, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = me3 (&dv, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = ei (dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = ei (dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = ei (dv, 2, CONST3);
+  if (dv [0] != CONST3)
+    abort ();
+
+  dv = ei (dv, 3, CONST2);
+  if (dv [1] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 0, CONST1);
+  if (dv [0] != CONST1)
+    abort ();
+
+  dv = mei (&dv, 1, CONST0);
+  if (dv [1] != CONST0)
+    abort ();
+
+  dv = mei (&dv, 2, CONST2);
+  if (dv [0] != CONST2)
+    abort ();
+
+  dv = mei (&dv, 3, CONST3);
+  if (dv [1] != CONST3)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-16b.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16b.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16b.c	(revision 278653)
@@ -0,0 +1,165 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned char c0 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned char c9 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 9);
+}
+
+unsigned char c21 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned char c30 (vector unsigned char v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned char mc0 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned char mc9 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 9);
+}
+
+unsigned char mc21 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned char mc30 (vector unsigned char *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned char ci (vector unsigned char v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned char mci (vector unsigned char *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,
+			    CONST4, CONST5, CONST6, CONST7,
+			    CONST8, CONST9, CONSTA, CONSTB,
+			    CONSTC, CONSTD, CONSTE, CONSTF };
+  unsigned char c;
+
+  c = c0 (cv);
+  if (c != CONST0)
+    abort ();
+
+  c = c9 (cv);
+  if (c != CONST9)
+    abort ();
+
+  c = c21 (cv);
+  if (c != CONST5)
+    abort ();
+
+  c = c30 (cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = mc0 (&cv);
+  if (c != CONST0)
+    abort ();
+
+  c = mc9 (&cv);
+  if (c != CONST9)
+    abort ();
+
+  c = mc21 (&cv);
+  if (c != CONST5)
+    abort ();
+
+  c = mc30 (&cv);
+  if (c != CONSTE)
+    abort ();
+
+  c = ci (cv, 8);
+  if (c != CONST8)
+    abort ();
+
+  c = ci (cv, 13);
+  if (c != CONSTD)
+    abort ();
+
+  c = ci (cv, 23);
+  if (c != CONST7)
+    abort ();
+
+  c = ci (cv, 31);
+  if (c != CONSTF)
+    abort ();
+
+  c = mci (&cv, 5);
+  if (c != CONST5)
+    abort ();
+
+  c = mci (&cv, 12);
+  if (c != CONSTC)
+    abort ();
+
+  c = mci (&cv, 25);
+  if (c != CONST9)
+    abort ();
+
+  c = mci (&cv, 16);
+  if (c != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/dfp/dfp.exp
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/dfp/dfp.exp b/gcc/testsuite/gcc.target/powerpc/dfp/dfp.exp
--- a/gcc/testsuite/gcc.target/powerpc/dfp/dfp.exp	(revision 278653)
+++ b/gcc/testsuite/gcc.target/powerpc/dfp/dfp.exp	(revision 278653)
@@ -16,8 +16,11 @@
 # along with GCC; see the file COPYING3.  If not see
 # <http://www.gnu.org/licenses/>.
 
-# Exit immediately if this isn't a PowerPC target.
-if { ![istarget powerpc*-*-*] && ![istarget rs6000-*-*] } then {
+# Exit immediately if this isn't a PowerPC target, also exit if we
+# are on Darwin which doesn't support decimal float.
+if { (![istarget powerpc*-*-*] && ![istarget rs6000-*-*])
+    || [istarget "powerpc*-*-darwin*"]
+} then {
   return
 }
 
Index: gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2.h
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2.h b/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vec-extract-v16qiu-v2.h	(revision 278653)
@@ -0,0 +1,253 @@
+#include <stdlib.h>
+#include <stddef.h>
+#include <altivec.h>
+
+#ifndef RTYPE
+#define RTYPE TYPE
+#endif
+
+#ifdef DO_TRACE
+#include <stdio.h>
+
+#define TRACE(STRING, NUM)						\
+do									\
+  {									\
+    fprintf (stderr, "%s: %2d\n", STRING, (int) NUM);			\
+    fflush (stderr);							\
+  }									\
+while (0)
+
+#ifndef FAIL_FORMAT
+#define FAIL_FORMAT "%ld"
+#define FAIL_CAST(X) ((long)(X))
+#endif
+
+#define FAIL(EXP, GOT)							 \
+do									 \
+  {									 \
+    fprintf (stderr, "Expected: " FAIL_FORMAT ", got " FAIL_FORMAT "\n", \
+	     FAIL_CAST (EXP), FAIL_CAST (GOT));				 \
+    fflush (stderr);							 \
+    abort ();								 \
+  }									 \
+while (0)
+
+#else
+#define TRACE(STRING, NUM)
+#define FAIL(EXP, GOT) abort ()
+#endif
+
+static void
+check (RTYPE, RTYPE) __attribute__((__noinline__));
+
+static vector TYPE
+deoptimize (vector TYPE) __attribute__((__noinline__));
+
+static vector TYPE
+*deoptimize_ptr (vector TYPE *)	__attribute__((__noinline__));
+
+static void
+check (RTYPE expected, RTYPE got)
+{
+  if (expected != got)
+    FAIL (expected, got);
+}
+
+static vector TYPE
+deoptimize (vector TYPE a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector TYPE *
+deoptimize_ptr (vector TYPE *p)
+{
+  __asm__ (" # %0" : "+r" (p));
+  return p;
+}
+
+
+RTYPE
+get_auto_0 (vector TYPE a)
+{
+  TRACE ("get_auto_", 0);
+  return (RTYPE) vec_extract (a, 0);
+}
+
+RTYPE
+get_auto_1 (vector TYPE a)
+{
+  TRACE ("get_auto_", 1);
+  return (RTYPE) vec_extract (a, 1);
+}
+
+#if ELEMENTS >= 4
+RTYPE
+get_auto_2 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 2);
+}
+
+RTYPE
+get_auto_3 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 3);
+}
+
+#if ELEMENTS >= 8
+RTYPE
+get_auto_4 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 4);
+}
+
+RTYPE
+get_auto_5 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 5);
+}
+
+RTYPE
+get_auto_6 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 6);
+}
+
+RTYPE
+get_auto_7 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 7);
+}
+
+#if ELEMENTS >= 16
+RTYPE
+get_auto_8 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 8);
+}
+
+RTYPE
+get_auto_9 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 9);
+}
+
+RTYPE
+get_auto_10 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 10);
+}
+
+RTYPE
+get_auto_11 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 11);
+}
+
+RTYPE
+get_auto_12 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 12);
+}
+
+RTYPE
+get_auto_13 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 13);
+}
+
+RTYPE
+get_auto_14 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 14);
+}
+
+RTYPE
+get_auto_15 (vector TYPE a)
+{
+  return (RTYPE) vec_extract (a, 15);
+}
+
+#endif
+#endif
+#endif
+
+
+/* Tests for the normal case of vec_extract where the vector is in a register
+   and returning the result in a register as a return value.  */
+#ifdef DISABLE_INLINE_OF_GET_AUTO_N
+__attribute__ ((__noinline__))
+#else
+/* gcc issues warning: always_inline function might not be inlinable
+
+   __attribute__ ((__always_inline__))
+*/
+#endif
+RTYPE
+get_auto_n (vector TYPE a, ssize_t n)
+{
+  return (RTYPE) vec_extract (a, n);
+}
+
+typedef RTYPE (*auto_func_type) (vector TYPE);
+
+static auto_func_type get_auto_const[] = {
+  get_auto_0,
+  get_auto_1,
+#if ELEMENTS >= 4
+  get_auto_2,
+  get_auto_3,
+#if ELEMENTS >= 8
+  get_auto_4,
+  get_auto_5,
+  get_auto_6,
+  get_auto_7,
+#if ELEMENTS >= 16
+  get_auto_8,
+  get_auto_9,
+  get_auto_10,
+  get_auto_11,
+  get_auto_12,
+  get_auto_13,
+  get_auto_14,
+  get_auto_15,
+#endif
+#endif
+#endif
+};
+
+extern void do_auto (vector TYPE a) __attribute__((__noinline__));
+
+void
+do_auto (vector TYPE a)
+{
+  size_t i;
+
+  for (i = 1; i < 40; i += 3)
+    {
+      TRACE ("do_auto, i: ", i);
+      TRACE ("  get_auto_const[i] returns: ",
+	     (*get_auto_const [i % ELEMENTS]) (a));
+      TRACE ("  get_auto_n returns", get_auto_n (a, i));
+      check (get_auto_n (a, i), (*get_auto_const [i % ELEMENTS]) (a));
+    }
+}
+
+
+
+/* Main program to test all of the possibilities.  */
+int
+main (void)
+{
+  size_t i;
+  vector TYPE x = INITIAL;
+  vector TYPE *p, *p2, a, y;
+  vector TYPE z[2];
+
+  a = deoptimize (x);
+
+  do_auto (a);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-17a.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17a.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17a.c	(revision 278653)
@@ -0,0 +1,155 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned short s3 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned short s7 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 7);
+}
+
+unsigned short s21 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned short s30 (vector unsigned short v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned short ms3 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned short ms7 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 7);
+}
+
+unsigned short ms21 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned short ms30 (vector unsigned short *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned short ci (vector unsigned short v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned short mci (vector unsigned short *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+int main (int argc, unsigned short *argv[]) {
+  vector unsigned short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+  unsigned short s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s7 (sv);
+  if (s != CONST7)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST5)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms7 (&sv);
+  if (s != CONST7)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST5)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST6)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST7)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST5)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST4)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/spec-barr-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/spec-barr-1.c b/gcc/testsuite/gcc.target/powerpc/spec-barr-1.c
--- a/gcc/testsuite/gcc.target/powerpc/spec-barr-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/powerpc/spec-barr-1.c	(revision 278653)
@@ -7,4 +7,4 @@
   __builtin_ppc_speculation_barrier ();
 }
 
-/* { dg-final { scan-assembler "ori 31,31,0" } } */
+/* { dg-final { scan-assembler {ori\s+r?31,r?31,r?0} } } */
Index: gcc/testsuite/gcc.target/powerpc/pr92090.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr92090.c b/gcc/testsuite/gcc.target/powerpc/pr92090.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr92090.c	(revision 278653)
@@ -0,0 +1,43 @@
+/* { dg-do compile } */
+/* { dg-options "-mcpu=power8 -Os" } */
+/* { dg-additional-options "-mbig" { target powerpc64le-*-* } } */
+
+/* Verify that we don't ICE.  */
+
+_Atomic int a;
+_Atomic long double b, c;
+int j;
+void foo (void);
+void bar (int, int, int, int);
+
+void
+bug (void)
+{
+  b = 1;
+  int d, e, f, g;
+  while (a)
+    ;
+  for (int h = 0; h < 10000; h++)
+    {
+      double i = b /= 3;
+      foo ();
+      if (i)
+	{
+	  if (i == 1)
+	    d++;
+	  e++;
+	  b = 0;
+	}
+      else
+	{
+	  if (i == 2)
+	    f++;
+	  g++;
+	  b = 1;
+	}
+    }
+  bar (d, e, f, g);
+  c = 1;
+  for (int h; h; h++)
+    j = 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-16d.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16d.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16d.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-16d.c	(revision 278653)
@@ -0,0 +1,163 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+#define CONST8		(8)
+#define CONST9		(9)
+#define CONSTA		(10)
+#define CONSTB		(11)
+#define CONSTC		(12)
+#define CONSTD		(13)
+#define CONSTE		(14)
+#define CONSTF		(15)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned char c0 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 0);
+}
+
+vector unsigned char c9 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 9);
+}
+
+vector unsigned char c21 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned char c30 (vector unsigned char v, unsigned char x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned char mc0 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 0);
+}
+
+vector unsigned char mc9 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 9);
+}
+
+vector unsigned char mc21 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned char mc30 (vector unsigned char *vp, unsigned char x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned char ci (vector unsigned char v, int i, unsigned char x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned char mci (vector unsigned char *vp, int i, unsigned char x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, char *argv[]) {
+  vector unsigned char cv = { CONST0, CONST1, CONST2, CONST3,
+			      CONST4, CONST5, CONST6, CONST7,
+			      CONST8, CONST9, CONSTA, CONSTB,
+			      CONSTC, CONSTD, CONSTE, CONSTF };
+  cv = c0 (cv, CONST3);
+  if (cv [0] != CONST3)
+    abort ();
+
+  cv = c9 (cv, CONST2);
+  if (cv [9] != CONST2)
+    abort ();
+
+  cv = c21 (cv, CONSTF);
+  if (cv [5] != CONSTF)
+    abort ();
+
+  cv = c30 (cv, CONST3);
+  if (cv [14] != CONST3)
+    abort ();
+
+  cv = mc0 (&cv, CONST4);
+  if (cv [0] != CONST4)
+    abort ();
+
+  cv = mc9 (&cv, CONST3);
+  if (cv [9] != CONST3)
+    abort ();
+
+  cv = mc21 (&cv, CONST1);
+  if (cv [5] != CONST1)
+    abort ();
+
+  cv = mc30 (&cv, CONSTC);
+  if (cv [14] != CONSTC)
+    abort ();
+
+  cv = ci (cv, 8, CONSTD);
+  if (cv [8] != CONSTD)
+    abort ();
+
+  cv = ci (cv, 13, CONST5);
+  if (cv [13] != CONST5)
+    abort ();
+
+  cv = ci (cv, 23, CONST6);
+  if (cv [7] != CONST6)
+    abort ();
+
+  cv = ci (cv, 31, CONST7);
+  if (cv [15] != CONST7)
+    abort ();
+
+  cv = mci (&cv, 5, CONST8);
+  if (cv [5] != CONST8)
+    abort ();
+
+  cv = mci (&cv, 12, CONST9);
+  if (cv [12] != CONST9)
+    abort ();
+
+  cv = mci (&cv, 25, CONSTA);
+  if (cv [9] != CONSTA)
+    abort ();
+
+  cv = mci (&cv, 16, CONSTB);
+  if (cv [0] != CONSTB)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr88100.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr88100.c b/gcc/testsuite/gcc.target/powerpc/pr88100.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr88100.c	(revision 278653)
@@ -0,0 +1,44 @@
+/* PR88100.  Verify that rs6000 gimple-folding code handles the
+   vec_splat_{su}{8,16,32} invalid data properly. */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-maltivec" } */
+
+#include <altivec.h>
+
+vector unsigned char
+splatu1 (void)
+{
+  return vec_splat_u8(0x100);/* { dg-error "argument 1 must be a 5-bit signed literal" } */
+}
+
+vector unsigned short
+splatu2 (void)
+{
+  return vec_splat_u16(0x10000);/* { dg-error "argument 1 must be a 5-bit signed literal" } */
+}
+
+vector unsigned int
+splatu3 (void)
+{
+  return vec_splat_u32(0x10000000);/* { dg-error "argument 1 must be a 5-bit signed literal" } */
+}
+
+vector signed char
+splats1 (void)
+{
+  return vec_splat_s8(0x100);/* { dg-error "argument 1 must be a 5-bit signed literal" } */
+}
+
+vector signed short
+splats2 (void)
+{
+  return vec_splat_s16(0x10000);/* { dg-error "argument 1 must be a 5-bit signed literal" } */
+}
+
+vector signed int
+splats3 (void)
+{
+  return vec_splat_s32(0x10000000);/* { dg-error "argument 1 must be a 5-bit signed literal" } */
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-17c.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17c.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17c.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-17c.c	(revision 278653)
@@ -0,0 +1,154 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec" } */
+
+/* This test should run the same on any target that supports altivec/vmx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+#define CONST4		(4)
+#define CONST5		(5)
+#define CONST6		(6)
+#define CONST7		(7)
+
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+vector unsigned short s3 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 3);
+}
+
+vector unsigned short s7 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 7);
+}
+
+vector unsigned short s21 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 21);
+}
+
+vector unsigned short s30 (vector unsigned short v, unsigned short x)
+{
+  return vec_insert (x, v, 30);
+}
+
+/* Test for vector residing in memory.  */
+vector unsigned short ms3 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 3);
+}
+
+vector unsigned short ms7 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 7);
+}
+
+vector unsigned short ms21 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 21);
+}
+
+vector unsigned short ms30 (vector unsigned short *vp, unsigned short x)
+{
+  return vec_insert (x, *vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+vector unsigned short ci (vector unsigned short v, int i, unsigned short x)
+{
+  return vec_insert (x, v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+vector unsigned short mci (vector unsigned short *vp, int i, unsigned short x)
+{
+  return vec_insert (x, *vp, i);
+}
+
+
+int main (int argc, unsigned short *argv[]) {
+  vector unsigned short sv = {
+    CONST0, CONST1, CONST2, CONST3, CONST4, CONST5, CONST6, CONST7 };
+
+  sv = s3 (sv, CONST1);
+  if (sv [3] != CONST1)
+    abort ();
+
+  sv = s7 (sv, CONST2);
+  if (sv [7] != CONST2)
+    abort ();
+
+  sv = s21 (sv, CONST3);
+  if (sv [5] != CONST3)
+    abort ();
+
+  sv = s30 (sv, CONST4);
+  if (sv [6] != CONST4)
+    abort ();
+
+  sv = ms3 (&sv, CONST5);
+  if (sv [3] != CONST5)
+    abort ();
+
+  sv = ms7 (&sv, CONST6);
+  if (sv [7] != CONST6)
+    abort ();
+
+  sv = ms21 (&sv, CONST7);
+  if (sv [5] != CONST7)
+    abort ();
+
+  sv = ms30 (&sv, CONST0);
+  if (sv [6] != CONST0)
+    abort ();
+
+  sv = ci (sv, 5, CONST1);
+  if (sv [5] != CONST1)
+    abort ();
+
+  sv = ci (sv, 2, CONST3);
+  if (sv [2] != CONST3)
+    abort ();
+
+  sv = ci (sv, 15, CONST2);
+  if (sv [7] != CONST2)
+    abort ();
+
+  sv = ci (sv, 28, CONST5);
+  if (sv [4] != CONST5)
+    abort ();
+
+  sv = mci (&sv, 5, CONST4);
+  if (sv [5] != CONST4)
+    abort ();
+
+  sv = mci (&sv, 12, CONST6);
+  if (sv [4] != CONST6)
+    abort ();
+
+  sv = mci (&sv, 25, CONST7);
+  if (sv [1] != CONST7)
+    abort ();
+
+  sv = mci (&sv, 16, CONST4);
+  if (sv [0] != CONST4)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr89765-mc.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr89765-mc.c b/gcc/testsuite/gcc.target/powerpc/pr89765-mc.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr89765-mc.c	(revision 278653)
@@ -0,0 +1,400 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx -O2" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <stdlib.h>
+#include <stddef.h>
+#include <altivec.h>
+
+#include <stdio.h>
+
+static vector unsigned __int128
+deoptimize_uint128 (vector unsigned __int128  a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned long long int
+deoptimize_ulong (vector unsigned long long int a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned int
+deoptimize_uint (vector unsigned int a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned char
+deoptimize_uchar (vector unsigned char a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+static vector unsigned short
+deoptimize_ushort (vector unsigned short a)
+{
+  __asm__ (" # %x0" : "+v" (a));
+  return a;
+}
+
+__attribute ((noinline))
+vector unsigned __int128
+set_auto_n_uint128 (vector unsigned __int128 a, int n, unsigned __int128 x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+vector unsigned long long int
+set_auto_n_ulong (vector unsigned long long int a, int n,
+		  unsigned long long int x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+vector unsigned int
+set_auto_n_uint (vector unsigned int a, int n, unsigned int x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+vector unsigned char
+set_auto_n_uchar (vector unsigned char a, int n, unsigned char x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+vector unsigned short
+set_auto_n_ushort (vector unsigned short a, int n, unsigned short x)
+{
+  return vec_insert (x, a, n);
+}
+
+__attribute ((noinline))
+unsigned __int128
+get_auto_n_uint128 (vector unsigned __int128 a, int n)
+{
+  return vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned long long int
+get_auto_n_ulong (vector unsigned long long int a, int n)
+{
+  return vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned int
+get_auto_n_uint (vector unsigned int a, int n)
+{
+  return vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned char
+get_auto_n_uchar (vector unsigned char a, int n)
+{
+  return vec_extract (a, n);
+}
+
+__attribute ((noinline))
+unsigned short
+get_auto_n_ushort (vector unsigned short a, int n)
+{
+  return vec_extract (a, n);
+}
+
+int check_uint128_element (int i, unsigned __int128 entry)
+{
+  printf ("checking uint128 entry at index %d\n", i);
+
+  return (entry == ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)
+		    | 0x0706050403020100ULL));
+}
+
+unsigned __int128 get_uint128_element (int i)
+{
+  return ((((unsigned __int128) 0xffeeddccbbaa9988ULL) << 64)
+	  | 0x0706050403020100ULL);
+}
+
+int check_ulong_element (int i, unsigned long long int entry)
+{
+  printf ("checking ulong entry 0x%llx at index %d\n", entry, i);
+
+  switch (i % 2)
+    {
+      case 0: return (entry == 0x9999901010ULL);
+      case 1: return (entry == 0x7777733333ULL);
+      default:
+	return 0;
+    }
+}
+
+unsigned long long int get_ulong_element (int i)
+{
+  switch (i % 2)
+    {
+    case 0: return 0x9999901010ULL;
+    case 1: return 0x7777733333ULL;
+    }
+}
+
+int check_uint_element (int i, unsigned int entry)
+{
+  printf ("checking uint entry 0x%x at index %d\n", entry, i);
+
+  switch (i % 4)
+    {
+    case 0: return (entry == 0x99999);
+    case 1: return (entry == 0x01010);
+    case 2: return (entry == 0x77777);
+    case 3: return (entry == 0x33333);
+    default:
+      return 0;
+    }
+}
+
+unsigned int get_uint_element (int i)
+{
+  switch (i % 4)
+    {
+    case 0: return 0x99999;
+    case 1: return 0x01010;
+    case 2: return 0x77777;
+    case 3: return 0x33333;
+    }
+}
+
+int check_uchar_element (int i, unsigned char entry)
+{
+  printf ("checking uchar entry 0x%x at index %d\n", entry, i);
+  switch (i % 16)
+    {
+    case 0: return (entry == 0x90);
+    case 1: return (entry == 0x80);
+    case 2: return (entry == 0x70);
+    case 3: return (entry == 0x60);
+    case 4: return (entry == 0x50);
+    case 5: return (entry == 0x40);
+    case 6: return (entry == 0x30);
+    case 7: return (entry == 0x20);
+    case 8: return (entry == 0x10);
+    case 9: return (entry == 0xf0);
+    case 10: return (entry == 0xe0);
+    case 11: return (entry == 0xd0);
+    case 12: return (entry == 0xc0);
+    case 13: return (entry == 0xb0);
+    case 14: return (entry == 0xa0);
+    case 15: return (entry == 0xff);
+    default:
+      return 0;
+    }
+}
+
+unsigned char get_uchar_element (int i)
+{
+  switch (i % 16)
+    {
+    case 0: return 0x90;
+    case 1: return 0x80;
+    case 2: return 0x70;
+    case 3: return 0x60;
+    case 4: return 0x50;
+    case 5: return 0x40;
+    case 6: return 0x30;
+    case 7: return 0x20;
+    case 8: return 0x10;
+    case 9: return 0xf0;
+    case 10: return 0xe0;
+    case 11: return 0xd0;
+    case 12: return 0xc0;
+    case 13: return 0xb0;
+    case 14: return 0xa0;
+    case 15: return 0xff;
+    }
+}
+
+int check_ushort_element (int i, unsigned short entry)
+{
+  printf ("checking ushort entry 0x%x at index %d\n", entry, i);
+  switch (i % 8)
+    {
+    case 0: return (entry == 0x9988);
+    case 1: return (entry == 0x8877);
+    case 2: return (entry == 0x7766);
+    case 3: return (entry == 0x6655);
+    case 4: return (entry == 0x5544);
+    case 5: return (entry == 0x4433);
+    case 6: return (entry == 0x3322);
+    case 7: return (entry == 0x2211);
+    default:
+      return 0;
+    }
+}
+
+unsigned short get_ushort_element (int i)
+{
+  switch (i % 8)
+    {
+    case 0: return 0x9988;
+    case 1: return 0x8877;
+    case 2: return 0x7766;
+    case 3: return 0x6655;
+    case 4: return 0x5544;
+    case 5: return 0x4433;
+    case 6: return 0x3322;
+    case 7: return 0x2211;
+    }
+}
+
+vector unsigned __int128
+init_auto_uint128 (vector unsigned __int128 a)
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_uint128 (a, i, get_uint128_element (i));
+  return a;
+}
+
+void do_auto_uint128 (vector unsigned __int128 a)
+{
+  int i;
+  unsigned __int128 c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uint128 (a, i);
+      if (!check_uint128_element (i, c)) abort ();
+    }
+}
+
+vector unsigned long long int
+init_auto_ulong (vector unsigned long long int a)
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_ulong (a, i, get_ulong_element (i));
+  return a;
+}
+
+void do_auto_ulong (vector unsigned long long int a)
+{
+  int i;
+  unsigned long long int c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_ulong (a, i);
+      if (!check_ulong_element (i, c)) abort ();
+    }
+ }
+
+vector unsigned int init_auto_uint (vector unsigned int a)
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_uint (a, i, get_uint_element (i));
+  return a;
+}
+
+void do_auto_uint (vector unsigned int a)
+{
+  int i;
+  unsigned int c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uint (a, i);
+      if (!check_uint_element (i, c)) abort ();
+    }
+ }
+
+vector unsigned short init_auto_ushort ( vector unsigned short a )
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_ushort (a, i, get_ushort_element (i));
+  return a;
+}
+
+void do_auto_ushort (vector unsigned short a)
+{
+  int i;
+  unsigned short c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_ushort (a, i);
+      if (!check_ushort_element (i, c)) abort ();
+    }
+}
+
+vector unsigned char init_auto_uchar (vector unsigned char a)
+{
+  int i;
+  for (i = 0; i < 32; i += 3)
+    a = set_auto_n_uchar (a, i, get_uchar_element (i));
+  return a;
+}
+
+void do_auto_uchar (vector unsigned char a)
+{
+  int i;
+  unsigned char c;
+  for (i = 0; i < 32; i += 3)
+    {
+      c = get_auto_n_uchar (a, i);
+      if (!check_uchar_element (i, c)) abort ();
+    }
+}
+
+int
+main (void)
+{
+  size_t i;
+
+  vector unsigned __int128 u = { 0 };
+  vector unsigned __int128 du;
+
+  vector unsigned long long int v = { 0, 0 };
+  vector unsigned long long int dv;
+
+  vector unsigned int x = { 0, 0, 0, 0 };
+  vector unsigned int dx;
+
+  vector unsigned char y = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+  vector unsigned char dy;
+
+  vector unsigned short z = { 0, 0, 0, 0, 0, 0, 0, 0 };
+  vector unsigned short dz;
+
+  du = init_auto_uint128 (u);
+  dv = init_auto_ulong (v);
+  dx = init_auto_uint (x);
+  dy = init_auto_uchar (y);
+  dz = init_auto_ushort (z);
+
+  du = deoptimize_uint128 (du);
+  dv = deoptimize_ulong (dv);
+  dx = deoptimize_uint (dx);
+  dy = deoptimize_uchar (dy);
+  dz = deoptimize_ushort (dz);
+
+  do_auto_uint128 (du);
+  do_auto_ulong (dv);
+  do_auto_uint (dx);
+  do_auto_uchar (dy);
+  do_auto_ushort (dz);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-18b.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18b.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18b.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-18b.c	(revision 278653)
@@ -0,0 +1,149 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vmx_hw } */
+/* { dg-options "-maltivec -O3" } */
+
+/* This test should run the same on any target that supports altivec/dfp
+   instructions.  Unsigned Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(0)
+#define CONST1		(1)
+#define CONST2		(2)
+#define CONST3		(3)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned int s3 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+unsigned int s1 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 1);
+}
+
+unsigned int s21 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 21);
+}
+
+unsigned int s30 (vector unsigned int v)
+{
+  return __builtin_vec_extract (v, 30);
+}
+
+/* Test for vector residing in memory.  */
+unsigned int ms3 (vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+unsigned int ms1(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 1);
+}
+
+unsigned int ms21(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 21);
+}
+
+unsigned int ms30(vector unsigned int *vp)
+{
+  return __builtin_vec_extract (*vp, 30);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned int ci (vector unsigned int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+__attribute__((noinline))
+unsigned int mci(vector unsigned int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+
+unsigned int main (int argc, unsigned char *argv[]) {
+  vector unsigned int sv = { CONST0, CONST1, CONST2, CONST3 };
+  unsigned int s;
+
+  s = s3 (sv);
+  if (s != CONST3)
+    abort ();
+
+  s = s1 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s21 (sv);
+  if (s != CONST1)
+    abort ();
+
+  s = s30 (sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ms3 (&sv);
+  if (s != CONST3)
+    abort ();
+
+  s = ms1 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms21 (&sv);
+  if (s != CONST1)
+    abort ();
+
+  s = ms30 (&sv);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = ci (sv, 2);
+  if (s != CONST2)
+    abort ();
+
+  s = ci (sv, 15);
+  if (s != CONST3)
+    abort ();
+
+  s = ci (sv, 28);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 5);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 12);
+  if (s != CONST0)
+    abort ();
+
+  s = mci (&sv, 25);
+  if (s != CONST1)
+    abort ();
+
+  s = mci (&sv, 16);
+  if (s != CONST0)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/darwin-bool-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/darwin-bool-1.c b/gcc/testsuite/gcc.target/powerpc/darwin-bool-1.c
--- a/gcc/testsuite/gcc.target/powerpc/darwin-bool-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/powerpc/darwin-bool-1.c	(revision 278653)
@@ -1,6 +1,8 @@
 /* Check that sizeof(bool) is 4 if we don't use special options. */
 /* Matt Austern  <austern@apple.com> */
 /* { dg-do run { target { powerpc*-*-darwin* && ilp32 } } } */
+/* We do need to suppress the ISO C doesn't support _Bool message tho.  */
+/* { dg-options "-Wno-pedantic" } */
 
 int dummy1[sizeof(_Bool) - 3];
 int dummy2[5 - sizeof(_Bool)];
Index: gcc/testsuite/gcc.target/powerpc/vsx-builtin-19a.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19a.c b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19a.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/vsx-builtin-19a.c	(revision 278653)
@@ -0,0 +1,109 @@
+/* { dg-do run { target int128 } } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-options "-mvsx" } */
+
+/* This test should run the same on any target that supports vsx
+   instructions.  Intentionally not specifying cpu in order to test
+   all code generation paths.  */
+
+#include <altivec.h>
+
+extern void abort (void);
+
+#define CONST0		(31415926539LL)
+#define CONST1		(2 * 31415926539LL)
+
+/* Test that indices > length of vector are applied modulo the vector
+   length.  */
+
+/* Test for vector residing in register.  */
+unsigned long long int e0 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 0);
+}
+
+unsigned long long int e3 (vector unsigned long long int v)
+{
+  return __builtin_vec_extract (v, 3);
+}
+
+/* Test for vector residing in memory.  */
+unsigned long long int me0 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 0);
+}
+
+unsigned long long int me3 (vector unsigned long long int *vp)
+{
+  return __builtin_vec_extract (*vp, 3);
+}
+
+/* Test the same with variable indices.  */
+
+/* Test for variable selector and vector residing in register.  */
+__attribute__((noinline))
+unsigned long long int ei (vector unsigned long long int v, int i)
+{
+  return __builtin_vec_extract (v, i);
+}
+
+/* Test for variable selector and vector residing in memory.  */
+unsigned long long int mei (vector unsigned long long int *vp, int i)
+{
+  return __builtin_vec_extract (*vp, i);
+}
+
+int main (int argc, char *argv[]) {
+  vector unsigned long long int dv = { CONST0, CONST1 };
+  unsigned long long int d;
+
+  d = e0 (dv);
+  if (d != CONST0)
+    abort ();
+
+  d = e3 (dv);
+  if (d != CONST1)
+    abort ();
+
+  d = me0 (&dv);
+  if (d != CONST0)
+    abort ();
+
+  d = me3 (&dv);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = ei (dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = ei (dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 0);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 1);
+  if (d != CONST1)
+    abort ();
+
+  d = mei (&dv, 2);
+  if (d != CONST0)
+    abort ();
+
+  d = mei (&dv, 3);
+  if (d != CONST1)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/arm/acle/crc_hf_1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/arm/acle/crc_hf_1.c b/gcc/testsuite/gcc.target/arm/acle/crc_hf_1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/arm/acle/crc_hf_1.c	(revision 278653)
@@ -0,0 +1,14 @@
+/* Test that using an Armv8-a hard-float target doesn't
+   break CRC intrinsics.  */
+
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_hard_vfp_ok }  */
+/* { dg-options "-mfloat-abi=hard -march=armv8-a+simd+crc" } */
+
+#include <arm_acle.h>
+
+uint32_t
+foo (uint32_t a, uint32_t b)
+{
+  return __crc32cw (a, b);
+}
Index: gcc/testsuite/gcc.target/arm/pr86487.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/arm/pr86487.c b/gcc/testsuite/gcc.target/arm/pr86487.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/arm/pr86487.c	(revision 278653)
@@ -0,0 +1,10 @@
+/* { dg-skip-if "" { *-*-* } { "-march=armv[0-6]*" "-mthumb" } { "" } } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-options "-O1 -mbig-endian" } */
+/* { dg-add-options arm_neon } */
+int a, b, c, d;
+long long fn1(long long p2) { return p2 == 0 ? -1 : -1 % p2; }
+void fn2(long long p1, short p2, long p3) {
+  b = fn1((d || 6) & a);
+  c = b | p3;
+}
Index: gcc/testsuite/gcc.target/arm/pr88167-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/arm/pr88167-1.c b/gcc/testsuite/gcc.target/arm/pr88167-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/arm/pr88167-1.c	(revision 278653)
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb1_ok } */
+/* { dg-options "-O2 -mthumb" }  */
+
+void *retaddr;
+
+void foo (void) {
+  retaddr = __builtin_return_address (0);
+
+  /* Used for enforcing registers stacking.  */
+  asm volatile ("" : : : "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
+			 "r8", "r9", "r10", "r11", "r12");
+}
+
+/* { dg-final { scan-assembler-not "mov\tlr," } } */
Index: gcc/testsuite/gcc.target/arm/pr88167-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/arm/pr88167-2.c b/gcc/testsuite/gcc.target/arm/pr88167-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/arm/pr88167-2.c	(revision 278653)
@@ -0,0 +1,18 @@
+/* { dg-do run } */
+/* { dg-options "-O2" }  */
+/* { dg-skip-if "" { ! { arm_thumb1 } } } */
+
+int __attribute__((noclone, noinline))
+foo (int a, long long b) {
+  /* Used for enforcing registers stacking.  */
+  asm volatile ("" : : : "r0", "r1", "r2", "r3",
+			 "r8", "r9", "r10", "r11", "r12");
+  return (int) b;
+}
+
+int main ()
+{
+  if (foo (1, 0x1000000000000003LL) != 3)
+    __builtin_abort ();
+  __builtin_exit (0);
+}
Index: gcc/testsuite/gcc.target/arm/pr89222.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/arm/pr89222.c b/gcc/testsuite/gcc.target/arm/pr89222.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/arm/pr89222.c	(revision 278653)
@@ -0,0 +1,32 @@
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void g (void);
+
+void f1 (int x)
+{
+  if (x != (int) g + 3)
+    return;
+  g();
+}
+
+void (*a2)(void);
+
+void f2 (void)
+{
+  a2 = &g + 3;
+}
+
+typedef void (*__sighandler_t)(int);
+void handler (int);
+
+void f3 (int x)
+{
+  __sighandler_t h = &handler;
+  if (h != (__sighandler_t) 2 && h != (__sighandler_t) 1)
+    h (x);
+}
+
+/* { dg-final { scan-assembler-times {add(?:s)?\tr[0-9]+, r[0-9]+, #3} 2 } } */
+/* { dg-final { scan-assembler-not {.word\tg\+3} } } */
+/* { dg-final { scan-assembler-not {.word\thandler-1} } } */
Index: gcc/testsuite/gcc.target/arm/arm.exp
===================================================================
diff --git a/gcc/testsuite/gcc.target/arm/arm.exp b/gcc/testsuite/gcc.target/arm/arm.exp
Index: gcc/testsuite/gcc.target/arm/f16_f64_conv_no_dp.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/arm/f16_f64_conv_no_dp.c b/gcc/testsuite/gcc.target/arm/f16_f64_conv_no_dp.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/arm/f16_f64_conv_no_dp.c	(revision 278653)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_fp16_ok } */
+/* { dg-skip-if "do not override fpu" { *-*-* } { "-mfpu=*" } { "-mfpu=fpv5-sp-d16" } } */
+/* { dg-skip-if "do not disable fpu" { *-*-* } { "-mfloat-abi=soft" } { * } } */
+/* { dg-skip-if "do not override fp16-format" { *-*-* } { "-mfp16-format=*" } { "-mfp16-format=ieee" } } */
+/* { dg-options "-O1 -mfpu=fpv5-sp-d16 -mfloat-abi=hard -mfp16-format=ieee" } */
+
+__fp16 foo (double a)
+{
+  return a;
+}
+
+double bar (__fp16 a)
+{
+  return a;
+}
Index: gcc/testsuite/gcc.target/arm/pr89190.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/arm/pr89190.c b/gcc/testsuite/gcc.target/arm/pr89190.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/arm/pr89190.c	(revision 278653)
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_arch_v8m_base_ok } */
+/* { dg-options "-O2" } */
+/* { dg-add-options arm_arch_v8m_base } */
+
+long long a;
+int b, c;
+int d(int e, int f) { return e << f; }
+void g() {
+  long long h;
+  char i = d(b >= 7, 2);
+  c = i == 0 ?: 1 / i;
+  h = c && a ?: c + a;
+  b = h;
+}
Index: gcc/testsuite/gcc.target/alpha/pr86984.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/alpha/pr86984.c b/gcc/testsuite/gcc.target/alpha/pr86984.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/alpha/pr86984.c	(revision 278653)
@@ -0,0 +1,96 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wall -Wwrite-strings -Werror -fmerge-all-constants -fno-stack-protector -mieee -fdump-rtl-expand" } */
+
+struct expression {
+  unsigned long int num;
+};
+union YYSTYPE {
+  unsigned long int num;
+  struct expression *exp;
+};
+
+typedef union YYSTYPE YYSTYPE;
+
+struct expression * new_exp_0 (int);
+
+union yyalloc {
+  short yyss_alloc;
+};
+
+static const signed char yypact[] = {
+  -9, -9, -10, -10, -9, 8, 36, -10, 13, -10, -9, -9, -9, -9, -9, -9, -9, -10, 26, 41, 45, 18, -2, 14, -10, -9, 36 };
+static const unsigned char yydefact[] = {
+  0, 0, 12, 11, 0, 0, 2, 10, 0, 1, 0, 0, 0, 0, 0, 0, 0, 13, 0, 4, 5, 6, 7, 8, 9, 0, 3 };
+
+static const signed char yypgoto[3] = "\366\366\377";
+static const signed char yydefgoto[3] = "\377\005\006";
+
+static const unsigned char yytable[] = {
+  7, 1, 2, 8, 3, 4, 15, 16, 9, 18, 19, 20, 21, 22, 23, 24, 10, 11, 12, 13, 14, 15, 16, 16, 26, 14, 15, 16, 17, 10, 11, 12, 13, 14, 15, 16, 0, 0, 25, 10, 11, 12, 13, 14, 15, 16, 12, 13, 14, 15, 16, 13, 14, 15, 16 };
+
+static const signed char yycheck[] = {
+  1, 10, 11, 4, 13, 14, 8, 9, 0, 10, 11, 12, 13, 14, 15, 16, 3, 4, 5, 6, 7, 8, 9, 9, 25, 7, 8, 9, 15, 3, 4, 5, 6, 7, 8, 9, -1, -1, 12, 3, 4, 5, 6, 7, 8, 9, 5, 6, 7, 8, 9, 6, 7, 8, 9 };
+
+static const unsigned char yyr1[] = {
+  0, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18 };
+
+static const unsigned char yyr2[] = {
+  0, 2, 1, 5, 3, 3, 3, 3, 3, 3, 2, 1, 1, 3 };
+
+int __gettextparse (void)
+{
+  int yystate = 0;
+  short yyssa[200];
+  short *yyss = yyss;
+  short *yyssp = yyssa;
+  YYSTYPE yyvsa[200];
+  YYSTYPE *yyvsp = yyvsa;
+  enum { yystacksize = 200 };
+  int yylen = 0;
+  goto yysetstate;
+ yynewstate: yyssp++;
+ yysetstate: *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      long unsigned int yysize = yyssp - yyss + 1;
+      {
+	short *yyss1 = yyss;
+	union yyalloc *yyptr = (union yyalloc *) __builtin_malloc ((yystacksize * (sizeof (short) + sizeof (YYSTYPE)) + (sizeof (union yyalloc) - 1)));
+	if (!yyptr) return 0;
+	__builtin_memcpy (&yyptr->yyss_alloc, yyss, yysize * sizeof *(yyss));
+	yyss = &yyptr->yyss_alloc;
+	if (yyss1 != yyssa) __builtin_free (yyss1);
+      }
+      if (yyss + yystacksize - 1 <= yyssp)
+	return 0;
+    }
+
+  int yyn = yypact[yystate];
+  if (yyn == -10)
+    goto yydefault;
+
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    goto yyreduce;
+
+ yydefault: yyn = yydefact[yystate];
+ yyreduce: yylen = yyr2[yyn];
+
+  YYSTYPE yyval;
+  if (yyn == 12 && (yyval.exp = new_exp_0 (0)) != 0)
+    (yyval.exp)->num = (yyvsp[0].num);
+
+  (yyvsp -= yylen, yyssp -= yylen);
+  yyn = yyr1[yyn];
+  yystate = yypgoto[yyn - 16] + *yyssp;
+  if (0 <= yystate && yystate <= 54 && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - 16];
+
+  goto yynewstate;
+}
+
+/* { dg-final { scan-rtl-dump-not "const_int 230584300921" "expand" } } */
+/* { dg-final { scan-assembler-not "yypgoto\\+230584300921" } } */
Index: gcc/testsuite/gcc.target/s390/pr89775-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/pr89775-1.c b/gcc/testsuite/gcc.target/s390/pr89775-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/pr89775-1.c	(revision 278653)
@@ -0,0 +1,17 @@
+/* PR target/89775 */
+/* { dg-do run } */
+/* { dg-options "-O0 -fomit-frame-pointer" } */
+/* { dg-additional-sources "pr89775-2.c" } */
+
+register void *sp __asm ("15");
+
+__attribute__((noipa)) int
+foo (const char *a, const char *b)
+{
+  while (1)
+    {
+      char c = *a++;
+      if (c != *b++) return 0;
+      if (c == '\0') return 1;
+    }
+}
Index: gcc/testsuite/gcc.target/s390/pr89775-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/pr89775-2.c b/gcc/testsuite/gcc.target/s390/pr89775-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/pr89775-2.c	(revision 278653)
@@ -0,0 +1,25 @@
+/* PR target/89775 */
+/* { dg-do compile } */
+
+extern int foo (const char *, const char *);
+
+__attribute__((noipa)) void
+bar (const char *p)
+{
+  static const char *x;
+  if (!x)
+    x = p;
+  else if (p != x)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  char a[8] = "abcdefg";
+  bar (a);
+  if (foo (a, a) != 1)
+    __builtin_abort ();
+  bar (a);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/s390/zvector/vec-addc-u128.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/zvector/vec-addc-u128.c b/gcc/testsuite/gcc.target/s390/zvector/vec-addc-u128.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/zvector/vec-addc-u128.c	(revision 278653)
@@ -0,0 +1,10 @@
+/* { dg-do compile { target { s390*-*-* } } } */
+/* { dg-options "-O3 -mzarch -march=z13 -mzvector -fno-asynchronous-unwind-tables" } */
+
+#include <vecintrin.h>
+
+vector unsigned char test(void)
+{
+   vector unsigned char a = { 0 };
+   return __builtin_s390_vec_addc_u128 (a, a);
+}
Index: gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-1.c b/gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-1.c	(revision 278653)
@@ -0,0 +1,45 @@
+/* { dg-do compile { target { s390*-*-* } } } */
+/* { dg-options "-O3 -mzarch -march=z14 -mzvector" } */
+
+#include <vecintrin.h>
+
+vector float
+foo (float *a)
+{
+  return vec_xl (0, a);
+}
+
+vector float
+bar (const float *a)
+{
+  return vec_xl (0, a);
+}
+
+void
+baz (float *f, vector float a)
+{
+  vec_xst (a, 0, f);
+}
+
+vector float
+foo2 (float *a)
+{
+  return vec_xlw4 (0, a);
+}
+
+vector float
+bar2 (const float *a)
+{
+  return vec_xlw4 (0, a);
+}
+
+void
+baz2 (float *f, vector float a)
+{
+  vec_xstw4 (a, 0, f);
+}
+
+/* Make sure no alignment hints are generated.  */
+
+/* { dg-final { scan-assembler-not "vl.*,3" } } */
+/* { dg-final { scan-assembler-not "vst.*,3" } } */
Index: gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-2.c b/gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/zvector/xl-xst-align-2.c	(revision 278653)
@@ -0,0 +1,48 @@
+/* { dg-do compile { target { s390*-*-* } } } */
+/* { dg-options "-O3 -mzarch -march=z14 -mzvector" } */
+
+#include <vecintrin.h>
+
+typedef float __attribute__((aligned(8))) float_aligned;
+
+vector float
+foo (float_aligned *a)
+{
+  return vec_xl (0, a);
+}
+
+vector float
+bar (const float_aligned *a)
+{
+  return vec_xl (0, a);
+}
+
+void
+baz (float_aligned *f, vector float a)
+{
+  vec_xst (a, 0, f);
+}
+
+vector float
+foo2 (float_aligned *a)
+{
+  return vec_xlw4 (0, a);
+}
+
+vector float
+bar2 (const float_aligned *a)
+{
+  return vec_xlw4 (0, a);
+}
+
+void
+baz2 (float_aligned *f, vector float a)
+{
+  vec_xstw4 (a, 0, f);
+}
+
+/* Make sure alignment hints are generated if the source or target
+   operand is properly aligned.  */
+
+/* { dg-final { scan-assembler-times "vl\t%v\[0-9\]*,0\\(%r2\\),3" 4 } } */
+/* { dg-final { scan-assembler-times "vst\t%v\[0-9\]*,0\\(%r2\\),3" 2 } } */
Index: gcc/testsuite/gcc.target/s390/vector/vec-shift-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/vector/vec-shift-2.c b/gcc/testsuite/gcc.target/s390/vector/vec-shift-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/vector/vec-shift-2.c	(revision 278653)
@@ -0,0 +1,24 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -mzarch -march=z13 --save-temps" } */
+
+/* { dg-final { scan-assembler-times "veslf" 1 } } */
+
+typedef __attribute__((vector_size(16))) signed int v4si;
+
+v4si __attribute__((noinline,noclone))
+shift_left_by_scalar (v4si in, int shift_count)
+{
+  return in << (3 + shift_count);
+}
+
+int
+main ()
+{
+  v4si a = { 1, 2, 3, 4 };
+  v4si result = shift_left_by_scalar (a, 1);
+
+  if (result[1] != 32)
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/sparc/overflow-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/sparc/overflow-1.c b/gcc/testsuite/gcc.target/sparc/overflow-1.c
--- a/gcc/testsuite/gcc.target/sparc/overflow-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/sparc/overflow-1.c	(revision 278653)
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O -mcpu=v8" } */
+/* { dg-options "-O -fno-pie -mcpu=v8" } */
 /* { dg-require-effective-target ilp32 } */
 
 #include <stdbool.h>
Index: gcc/testsuite/gcc.target/sparc/overflow-5.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/sparc/overflow-5.c b/gcc/testsuite/gcc.target/sparc/overflow-5.c
--- a/gcc/testsuite/gcc.target/sparc/overflow-5.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/sparc/overflow-5.c	(revision 278653)
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O -mvis3" } */
+/* { dg-options "-O -fno-pie -mvis3" } */
 /* { dg-require-effective-target lp64 } */
 
 #include <stdbool.h>
Index: gcc/testsuite/gcc.target/sparc/overflow-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/sparc/overflow-2.c b/gcc/testsuite/gcc.target/sparc/overflow-2.c
--- a/gcc/testsuite/gcc.target/sparc/overflow-2.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/sparc/overflow-2.c	(revision 278653)
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O -mcpu=v8" } */
+/* { dg-options "-O -fno-pie -mcpu=v8" } */
 /* { dg-require-effective-target ilp32 } */
 
 #include <stdbool.h>
Index: gcc/testsuite/gcc.target/sparc/overflow-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/sparc/overflow-3.c b/gcc/testsuite/gcc.target/sparc/overflow-3.c
--- a/gcc/testsuite/gcc.target/sparc/overflow-3.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/sparc/overflow-3.c	(revision 278653)
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O" } */
+/* { dg-options "-O -fno-pie" } */
 /* { dg-require-effective-target lp64 } */
 
 #include <stdbool.h>
Index: gcc/testsuite/gcc.target/sparc/overflow-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/sparc/overflow-4.c b/gcc/testsuite/gcc.target/sparc/overflow-4.c
--- a/gcc/testsuite/gcc.target/sparc/overflow-4.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/sparc/overflow-4.c	(revision 278653)
@@ -1,5 +1,5 @@
 /* { dg-do compile } */
-/* { dg-options "-O -mno-vis3" } */
+/* { dg-options "-O -fno-pie -mno-vis3" } */
 /* { dg-require-effective-target lp64 } */
 
 #include <stdbool.h>
Index: gcc/testsuite/gcc.target/sparc/20161111-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/sparc/20161111-1.c b/gcc/testsuite/gcc.target/sparc/20161111-1.c
--- a/gcc/testsuite/gcc.target/sparc/20161111-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/sparc/20161111-1.c	(revision 278653)
@@ -14,4 +14,4 @@
   return retval;
 }
 
-/* { dg-final { scan-assembler-not "and\t%" } } */
+/* { dg-final { scan-assembler-not "and\t%" { xfail *-*-* } } } */
Index: gcc/testsuite/gcc.target/mips/dwarfregtable-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/mips/dwarfregtable-3.c b/gcc/testsuite/gcc.target/mips/dwarfregtable-3.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/mips/dwarfregtable-3.c	(revision 278653)
@@ -0,0 +1,5 @@
+/* Check if content of dwarf reg size table matches the expected.  */
+/* { dg-do run } */
+/* { dg-options "-mabi=32 -mfp64" } */
+
+#include "dwarfregtable.h"
Index: gcc/testsuite/gcc.target/mips/dwarfregtable-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/mips/dwarfregtable-4.c b/gcc/testsuite/gcc.target/mips/dwarfregtable-4.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/mips/dwarfregtable-4.c	(revision 278653)
@@ -0,0 +1,5 @@
+/* Check if content of dwarf reg size table matches the expected.  */
+/* { dg-do run } */
+/* { dg-options "-mabi=32 -mfp64 -modd-spreg" } */
+
+#include "dwarfregtable.h"
Index: gcc/testsuite/gcc.target/mips/msa-fmadd-o32.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/mips/msa-fmadd-o32.c b/gcc/testsuite/gcc.target/mips/msa-fmadd-o32.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/mips/msa-fmadd-o32.c	(revision 278653)
@@ -0,0 +1,101 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=32 -mfp64 -mhard-float -mmsa -EL -flax-vector-conversions" } */
+/* { dg-skip-if "uses global registers" { *-*-* } { "-O0" } { "" } } */
+
+typedef int v4i32 __attribute__ ((vector_size(16)));
+typedef float v4f32 __attribute__ ((vector_size(16)));
+typedef double v2f64 __attribute__ ((vector_size(16)));
+
+/* Test that MSA FMADD-like intrinsics do not use first operand for multiplication.  */
+
+register v4i32 a __asm__("$f20");
+register v4i32 b __asm__("$f22");
+register v4f32 c __asm__("$f24");
+register v4f32 d __asm__("$f26");
+register v2f64 e __asm__("$f28");
+register v2f64 f __asm__("$f30");
+
+void
+maddv_b_msa (void)
+{
+  a = __builtin_msa_maddv_b (a, b, b);
+}
+/* { dg-final { scan-assembler "maddv\\\.b\t\\\$w20,\\\$w22,\\\$w22" } }  */
+
+void
+maddv_h_msa (void)
+{
+  a = __builtin_msa_maddv_h (a, b, b);
+}
+/* { dg-final { scan-assembler "maddv\\\.h\t\\\$w20,\\\$w22,\\\$w22" } }  */
+
+void
+maddv_w_msa (void)
+{
+  a = __builtin_msa_maddv_w (a, b, b);
+}
+/* { dg-final { scan-assembler "maddv\\\.w\t\\\$w20,\\\$w22,\\\$w22" } }  */
+
+void
+maddv_d_msa (void)
+{
+  a = __builtin_msa_maddv_d (a, b, b);
+}
+/* { dg-final { scan-assembler "maddv\\\.d\t\\\$w20,\\\$w22,\\\$w22" } }  */
+
+void
+msubv_b_msa (void)
+{
+  a = __builtin_msa_msubv_b (a, b, b);
+}
+/* { dg-final { scan-assembler "msubv\\\.b\t\\\$w20,\\\$w22,\\\$w22" } }  */
+
+void
+msubv_h_msa (void)
+{
+  a = __builtin_msa_msubv_h (a, b, b);
+}
+/* { dg-final { scan-assembler "msubv\\\.h\t\\\$w20,\\\$w22,\\\$w22" } }  */
+
+void
+msubv_w_msa (void)
+{
+  a = __builtin_msa_msubv_w (a, b, b);
+}
+/* { dg-final { scan-assembler "msubv\\\.w\t\\\$w20,\\\$w22,\\\$w22" } }  */
+
+void
+msubv_d_msa (void)
+{
+  a = __builtin_msa_msubv_d (a, b, b);
+}
+/* { dg-final { scan-assembler "msubv\\\.d\t\\\$w20,\\\$w22,\\\$w22" } }  */
+
+void
+fmadd_w_msa (void)
+{
+  c = __builtin_msa_fmadd_w (c, d, d);
+}
+/* { dg-final { scan-assembler "fmadd\\\.w\t\\\$w24,\\\$w26,\\\$w26" } }  */
+
+void
+fmadd_d_msa (void)
+{
+  e = __builtin_msa_fmadd_d (e, f, f);
+}
+/* { dg-final { scan-assembler "fmadd\\\.d\t\\\$w28,\\\$w30,\\\$w30" } }  */
+
+void
+fmsub_w_msa (void)
+{
+  c = __builtin_msa_fmsub_w (c, d, d);
+}
+/* { dg-final { scan-assembler "fmsub\\\.w\t\\\$w24,\\\$w26,\\\$w26" } }  */
+
+void
+fmsub_d_msa (void)
+{
+  e = __builtin_msa_fmsub_d (e, f, f);
+}
+/* { dg-final { scan-assembler "fmsub\\\.d\t\\\$w28,\\\$w30,\\\$w30" } }  */
+
Index: gcc/testsuite/gcc.target/mips/msa-fmadd-n64.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/mips/msa-fmadd-n64.c b/gcc/testsuite/gcc.target/mips/msa-fmadd-n64.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/mips/msa-fmadd-n64.c	(revision 278653)
@@ -0,0 +1,101 @@
+/* { dg-do compile } */
+/* { dg-options "-mabi=64 -mfp64 -mhard-float -mmsa -EL -flax-vector-conversions" } */
+/* { dg-skip-if "uses global registers" { *-*-* } { "-O0" } { "" } } */
+
+typedef int v4i32 __attribute__ ((vector_size(16)));
+typedef float v4f32 __attribute__ ((vector_size(16)));
+typedef double v2f64 __attribute__ ((vector_size(16)));
+
+/* Test that MSA FMADD-like intrinsics do not use first operand for multiplication.  */
+
+register v4i32 a __asm__("$f24");
+register v4i32 b __asm__("$f25");
+register v4f32 c __asm__("$f26");
+register v4f32 d __asm__("$f27");
+register v2f64 e __asm__("$f28");
+register v2f64 f __asm__("$f29");
+
+void
+maddv_b_msa (void)
+{
+  a = __builtin_msa_maddv_b (a, b, b);
+}
+/* { dg-final { scan-assembler "maddv\\\.b\t\\\$w24,\\\$w25,\\\$w25" } }  */
+
+void
+maddv_h_msa (void)
+{
+  a = __builtin_msa_maddv_h (a, b, b);
+}
+/* { dg-final { scan-assembler "maddv\\\.h\t\\\$w24,\\\$w25,\\\$w25" } }  */
+
+void
+maddv_w_msa (void)
+{
+  a = __builtin_msa_maddv_w (a, b, b);
+}
+/* { dg-final { scan-assembler "maddv\\\.w\t\\\$w24,\\\$w25,\\\$w25" } }  */
+
+void
+maddv_d_msa (void)
+{
+  a = __builtin_msa_maddv_d (a, b, b);
+}
+/* { dg-final { scan-assembler "maddv\\\.d\t\\\$w24,\\\$w25,\\\$w25" } }  */
+
+void
+msubv_b_msa (void)
+{
+  a = __builtin_msa_msubv_b (a, b, b);
+}
+/* { dg-final { scan-assembler "msubv\\\.b\t\\\$w24,\\\$w25,\\\$w25" } }  */
+
+void
+msubv_h_msa (void)
+{
+  a = __builtin_msa_msubv_h (a, b, b);
+}
+/* { dg-final { scan-assembler "msubv\\\.h\t\\\$w24,\\\$w25,\\\$w25" } }  */
+
+void
+msubv_w_msa (void)
+{
+  a = __builtin_msa_msubv_w (a, b, b);
+}
+/* { dg-final { scan-assembler "msubv\\\.w\t\\\$w24,\\\$w25,\\\$w25" } }  */
+
+void
+msubv_d_msa (void)
+{
+  a = __builtin_msa_msubv_d (a, b, b);
+}
+/* { dg-final { scan-assembler "msubv\\\.d\t\\\$w24,\\\$w25,\\\$w25" } }  */
+
+void
+fmadd_w_msa (void)
+{
+  c = __builtin_msa_fmadd_w (c, d, d);
+}
+/* { dg-final { scan-assembler "fmadd\\\.w\t\\\$w26,\\\$w27,\\\$w27" } }  */
+
+void
+fmadd_d_msa (void)
+{
+  e = __builtin_msa_fmadd_d (e, f, f);
+}
+/* { dg-final { scan-assembler "fmadd\\\.d\t\\\$w28,\\\$w29,\\\$w29" } }  */
+
+void
+fmsub_w_msa (void)
+{
+  c = __builtin_msa_fmsub_w (c, d, d);
+}
+/* { dg-final { scan-assembler "fmsub\\\.w\t\\\$w26,\\\$w27,\\\$w27" } }  */
+
+void
+fmsub_d_msa (void)
+{
+  e = __builtin_msa_fmsub_d (e, f, f);
+}
+/* { dg-final { scan-assembler "fmsub\\\.d\t\\\$w28,\\\$w29,\\\$w29" } }  */
+
Index: gcc/testsuite/gcc.target/mips/get-fcsr-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/mips/get-fcsr-3.c b/gcc/testsuite/gcc.target/mips/get-fcsr-3.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/mips/get-fcsr-3.c	(revision 278653)
@@ -0,0 +1,9 @@
+/* { dg-options "-mabi=64 -mhard-float" } */
+
+NOMIPS16 unsigned int
+foo (void)
+{
+  return __builtin_mips_get_fcsr () & 0x1;
+}
+
+/* { dg-final { scan-assembler "cfc1" } } */
Index: gcc/testsuite/gcc.target/mips/cfgcleanup-jalr1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/mips/cfgcleanup-jalr1.c b/gcc/testsuite/gcc.target/mips/cfgcleanup-jalr1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/mips/cfgcleanup-jalr1.c	(revision 278653)
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-mabicalls -fpic -mno-mips16 -mno-micromips" } */
+/* { dg-skip-if "needs codesize optimization" { *-*-* } { "-O0" "-O1" "-O2" "-O3" } { "" } } */
+
+extern void foo (void*);
+
+extern void bar (void*);
+
+void
+test (void* p)
+{
+   if (!p)
+	foo(p);
+   else
+	bar(p);
+}
+
+/* { dg-final { scan-assembler-not "\\\.reloc\t1f,R_MIPS_JALR,foo" } } */
+/* { dg-final { scan-assembler-not "\\\.reloc\t1f,R_MIPS_JALR,bar" } } */
Index: gcc/testsuite/gcc.target/mips/cfgcleanup-jalr2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/mips/cfgcleanup-jalr2.c b/gcc/testsuite/gcc.target/mips/cfgcleanup-jalr2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/mips/cfgcleanup-jalr2.c	(revision 278653)
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-mabicalls -fpic -mno-mips16 -mno-micromips" } */
+/* { dg-additional-options "-fno-inline -fipa-ra -mcompact-branches=never" } */
+/* { dg-skip-if "needs codesize optimization" { *-*-* } { "-O0" "-O1" "-O2" "-O3" } { "" } } */
+
+static int foo (void* p) { __asm__ (""::"r"(p):"$t0"); return 0; }
+
+static int bar (void* p) { return 1; }
+
+int
+test (void* p)
+{
+  int res = !p ? foo(p) : bar(p);
+
+  register int tmp __asm__("$t0") = -1;
+  __asm__ (""::"r"(tmp));
+
+  return res;
+}
+
+/* { dg-final { scan-assembler "\\\.reloc\t1f,R_MIPS_JALR,foo" } } */
+/* { dg-final { scan-assembler "\\\.reloc\t1f,R_MIPS_JALR,bar" } } */
+/* { dg-final { scan-assembler-not "\\.set\tnomacro\n\tjalr\t\\\$25" } } */
Index: gcc/testsuite/gcc.target/mips/dwarfregtable-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/mips/dwarfregtable-1.c b/gcc/testsuite/gcc.target/mips/dwarfregtable-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/mips/dwarfregtable-1.c	(revision 278653)
@@ -0,0 +1,5 @@
+/* Check if content of dwarf reg size table matches the expected.  */
+/* { dg-do run } */
+/* { dg-options "-mabi=32 -mfp32" } */
+
+#include "dwarfregtable.h"
Index: gcc/testsuite/gcc.target/mips/dwarfregtable.h
===================================================================
diff --git a/gcc/testsuite/gcc.target/mips/dwarfregtable.h b/gcc/testsuite/gcc.target/mips/dwarfregtable.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/mips/dwarfregtable.h	(revision 278653)
@@ -0,0 +1,22 @@
+
+typedef unsigned Unwind_Word __attribute__((__mode__(__unwind_word__)));
+
+#define DWARF_FRAME_REGISTERS 188
+
+static unsigned char ref_dwarf_reg_size_table[DWARF_FRAME_REGISTERS + 1] =
+  {
+    [0 ... 66] =  sizeof (Unwind_Word),
+    [80 ... 181] = sizeof (Unwind_Word)
+  };
+
+static unsigned char dwarf_reg_size_table[DWARF_FRAME_REGISTERS + 1] = {};
+
+int
+main (void)
+{
+  __builtin_init_dwarf_reg_size_table (dwarf_reg_size_table);
+  if (__builtin_memcmp (ref_dwarf_reg_size_table,
+                       dwarf_reg_size_table, DWARF_FRAME_REGISTERS + 1) != 0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/mips/cfgcleanup-jalr3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/mips/cfgcleanup-jalr3.c b/gcc/testsuite/gcc.target/mips/cfgcleanup-jalr3.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/mips/cfgcleanup-jalr3.c	(revision 278653)
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-mabicalls -fpic -mno-mips16 -mno-micromips" } */
+/* { dg-additional-options "-fno-inline -fipa-ra -mcompact-branches=never" } */
+/* { dg-skip-if "needs codesize optimization" { *-*-* } { "-O0" "-O1" "-O2" "-O3" } { "" } } */
+
+static int foo (void* p) { return 0; }
+
+static int bar (void* p) { return 1; }
+
+int
+test (void* p)
+{
+  int res = !p ? foo(p) : bar(p);
+
+  register int tmp __asm__("$t0") = -1;
+  __asm__ (""::"r"(tmp));
+
+  return res;
+}
+
+/* { dg-final { scan-assembler-not "\\\.reloc\t1f,R_MIPS_JALR,foo" } } */
+/* { dg-final { scan-assembler-not "\\\.reloc\t1f,R_MIPS_JALR,bar" } } */
+/* { dg-final { scan-assembler "\\.set\tnomacro\n\tjalr\t\\\$25" } } */
Index: gcc/testsuite/gcc.target/mips/dwarfregtable-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/mips/dwarfregtable-2.c b/gcc/testsuite/gcc.target/mips/dwarfregtable-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/mips/dwarfregtable-2.c	(revision 278653)
@@ -0,0 +1,5 @@
+/* Check if content of dwarf reg size table matches the expected.  */
+/* { dg-do run } */
+/* { dg-options "-mabi=32 -mfpxx" } */
+
+#include "dwarfregtable.h"
Index: gcc/testsuite/gcc.target/riscv/promote-type-for-libcall.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/riscv/promote-type-for-libcall.c b/gcc/testsuite/gcc.target/riscv/promote-type-for-libcall.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/riscv/promote-type-for-libcall.c	(revision 278653)
@@ -0,0 +1,37 @@
+/* { dg-do run } */
+/* { dg-options "-O1 -ftree-slp-vectorize -funroll-loops" } */
+
+#include <stdio.h>
+#include <stdlib.h>
+#define N 4
+volatile float f[N];
+int x[N] __attribute__((aligned(8)));
+int main() {
+  int i;
+  x[0] = -1;
+  x[1] = 2;
+  x[2] = -2;
+  x[3] = 2;
+
+  for (i=0;i<N;++i){
+    f[i] = x[i];
+  }
+
+  if (f[0] != -1.0f) {
+    abort();
+  }
+
+  if (f[1] != 2.0f) {
+    abort();
+  }
+
+  if (f[2] != -2.0f) {
+    abort();
+  }
+
+  if (f[3] != 2.0f) {
+    abort();
+  }
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/aarch64/options_set_9.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_9.c b/gcc/testsuite/gcc.target/aarch64/options_set_9.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_9.c	(revision 278653)
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8-a+simd+fp" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\-a} 1 } } */
+
+ /* Check that grouping of bits that don't form a synthetic group don't turn
+    on the parent. e.g. rdma turns on simd+fp, but simd+fp does not turn on
+    rdma since rdma is it's own group.  crypto however turns on aes and sha2
+    and turning on sha2 and eas should turn on crypto!.  */
Index: gcc/testsuite/gcc.target/aarch64/nosplit-di-const-volatile_1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/aarch64/nosplit-di-const-volatile_1.c b/gcc/testsuite/gcc.target/aarch64/nosplit-di-const-volatile_1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/aarch64/nosplit-di-const-volatile_1.c	(revision 278653)
@@ -0,0 +1,15 @@
+/* Check that storing the 64-bit immediate to a volatile location is done
+   with a single store.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+typedef unsigned long long u64;
+
+void bar (u64 *x)
+{
+  *(volatile u64 *)x = 0xabcdef10abcdef10ULL;
+}
+
+/* { dg-final { scan-assembler-times "str\tx..?, .*" 1 } } */
+/* { dg-final { scan-assembler-not "str\tw..?, .*" } } */
Index: gcc/testsuite/gcc.target/aarch64/options_set_1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_1.c b/gcc/testsuite/gcc.target/aarch64/options_set_1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_1.c	(revision 278653)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.2\-a\+crc} 1 } } */
+
+/* Check to see if crc is output by default.  */
Index: gcc/testsuite/gcc.target/aarch64/no-inline-lrint_3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/aarch64/no-inline-lrint_3.c b/gcc/testsuite/gcc.target/aarch64/no-inline-lrint_3.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/aarch64/no-inline-lrint_3.c	(revision 278653)
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target ilp32 } */
+/* { dg-options "-O3 -fno-math-errno -fno-fp-int-builtin-inexact" } */
+
+#define TEST(name, float_type, int_type, fn) void f_##name (float_type x) \
+{									  \
+  volatile int_type   b = __builtin_##fn (x);				  \
+}
+
+TEST (dld, double, long, lrint)
+TEST (flf, float , long, lrintf)
+
+TEST (did, double, int, lrint)
+TEST (fif, float , int, lrintf)
+
+/* { dg-final { scan-assembler-times "fcvtzs\tw\[0-9\]+, \[d,s\]\[0-9\]+" 2 } } */
+/* { dg-final { scan-assembler-times "bl\tlrint" 2 } } */
Index: gcc/testsuite/gcc.target/aarch64/options_set_2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_2.c b/gcc/testsuite/gcc.target/aarch64/options_set_2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_2.c	(revision 278653)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+crypto" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.2\-a\+crypto\+crc} 1 } } */
+
+/* Check to see if crc and crypto are maintained if crypto specified.  */
Index: gcc/testsuite/gcc.target/aarch64/pr90075.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/aarch64/pr90075.c b/gcc/testsuite/gcc.target/aarch64/pr90075.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/aarch64/pr90075.c	(revision 278653)
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-O1" } */
+
+typedef struct {
+  float one, two;
+} twofloats;
+
+float
+bug (twofloats tf)
+{
+  float f1, f2;
+  union {
+    twofloats tfloats;
+    float arr[2];
+  } utfloats;
+
+  utfloats.tfloats = tf;
+  f1 = utfloats.arr[1];
+  f2 = __builtin_copysignf (0, f1);
+  return f2;
+}
Index: gcc/testsuite/gcc.target/aarch64/options_set_3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_3.c b/gcc/testsuite/gcc.target/aarch64/options_set_3.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_3.c	(revision 278653)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+aes+sha2+crypto" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.2\-a\+crypto\+crc} 1 } } */
+
+/* Check if smallest set is maintained when outputting. */
Index: gcc/testsuite/gcc.target/aarch64/options_set_4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_4.c b/gcc/testsuite/gcc.target/aarch64/options_set_4.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_4.c	(revision 278653)
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+aes+sha2" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.2\-a\+crypto\+crc} 1 } } */
+
+/* Check if individual bits that make up a grouping is specified that only the
+   grouping is kept. */
\ No newline at end of file
Index: gcc/testsuite/gcc.target/aarch64/options_set_5.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_5.c b/gcc/testsuite/gcc.target/aarch64/options_set_5.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_5.c	(revision 278653)
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+aes+sha2+nosha2" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.2\-a\+crc\+aes} 1 } } */
+
+/* Check if turning off feature bits works correctly and grouping is no
+   longer valid.   */
Index: gcc/testsuite/gcc.target/aarch64/options_set_10.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_10.c b/gcc/testsuite/gcc.target/aarch64/options_set_10.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_10.c	(revision 278653)
@@ -0,0 +1,11 @@
+/* { dg-do compile { target { { aarch64*-*-linux*} && native } } } */
+/* { dg-additional-options "-mcpu=native" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-not {\.arch .+\+profile.*} } } */
+
+ /* Check that an empty feature string is not detected during mcpu=native.  */
Index: gcc/testsuite/gcc.target/aarch64/options_set_6.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_6.c b/gcc/testsuite/gcc.target/aarch64/options_set_6.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_6.c	(revision 278653)
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.2-a+crypto+nosha2" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.2\-a\+crypto\+crc} 1 } } */
+
+/* Group as a whole was requested to be turned on, crypto itself is a bit and so
+   just turning off one feature can't turn it off.   */
Index: gcc/testsuite/gcc.target/aarch64/options_set_7.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_7.c b/gcc/testsuite/gcc.target/aarch64/options_set_7.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_7.c	(revision 278653)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.4-a+dotprod" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.4\-a} 1 } } */
+
+/* Checking if enabling default features drops the superfluous bits.   */
Index: gcc/testsuite/gcc.target/aarch64/options_set_8.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/aarch64/options_set_8.c b/gcc/testsuite/gcc.target/aarch64/options_set_8.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/aarch64/options_set_8.c	(revision 278653)
@@ -0,0 +1,12 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-march=armv8.4-a+nodotprod" } */
+
+int main ()
+{
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times {\.arch armv8\.4\-a} 1 } } */
+
+/* Checking if trying to turn off default features propagates the commandline
+   option.  */
Index: gcc/testsuite/gcc.target/i386/pr70799-5.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr70799-5.c b/gcc/testsuite/gcc.target/i386/pr70799-5.c
deleted file mode 10644
--- a/gcc/testsuite/gcc.target/i386/pr70799-5.c	(revision 278653)
+++ /dev/null	(nonexistent)
@@ -1,17 +0,0 @@
-/* PR target/pr70799 */
-/* { dg-do compile { target ia32 } } */
-/* { dg-options "-O2 -march=slm -mavx512vl -mno-stackrealign" } */
-/* { dg-final { scan-assembler "psllq" } } */
-/* { dg-final { scan-assembler "psraq" } } */
-
-long long a, b;
-
-void test1 (int c)
-{
-  a = b << c;
-}
-
-void test2 (int c)
-{
-  a = b >> c;
-}
Index: gcc/testsuite/gcc.target/i386/pr70799-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr70799-4.c b/gcc/testsuite/gcc.target/i386/pr70799-4.c
deleted file mode 10644
--- a/gcc/testsuite/gcc.target/i386/pr70799-4.c	(revision 278653)
+++ /dev/null	(nonexistent)
@@ -1,17 +0,0 @@
-/* PR target/pr70799 */
-/* { dg-do compile { target ia32 } } */
-/* { dg-options "-O2 -march=slm -mno-stackrealign" } */
-/* { dg-final { scan-assembler "psllq" } } */
-/* { dg-final { scan-assembler "psrlq" } } */
-
-unsigned long long a, b;
-
-void test1 (int c)
-{
-  a = b << c;
-}
-
-void test2 (int c)
-{
-  a = b >> c;
-}
Index: gcc/testsuite/gcc.target/i386/pr52146.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr52146.c b/gcc/testsuite/gcc.target/i386/pr52146.c
--- a/gcc/testsuite/gcc.target/i386/pr52146.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr52146.c	(revision 278653)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32" } */
 
 void
Index: gcc/testsuite/gcc.target/i386/avx512bw-vpmovswb-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/avx512bw-vpmovswb-1.c b/gcc/testsuite/gcc.target/i386/avx512bw-vpmovswb-1.c
--- a/gcc/testsuite/gcc.target/i386/avx512bw-vpmovswb-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/avx512bw-vpmovswb-1.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512bw -mavx512vl -O2" } */
+/* { dg-additional-options "-fno-common" { target *-*-darwin* } } */
 /* { dg-final { scan-assembler-times "vpmovswb\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\[^\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpmovswb\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\[^\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpmovswb\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\[^\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}{z}(?:\n|\[ \\t\]+#)" 1 } } */
Index: gcc/testsuite/gcc.target/i386/pr89523-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-4.c b/gcc/testsuite/gcc.target/i386/pr89523-4.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr89523-4.c	(revision 278653)
@@ -0,0 +1,36 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -march=haswell" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+typedef double __v2df __attribute__ ((__vector_size__ (16)));
+typedef int __v4si __attribute__ ((__vector_size__ (16)));
+typedef long long __v2di __attribute__ ((__vector_size__ (16)));
+
+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));
+
+extern __inline __m128d
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm_i32gather_pd (double const *__base, __m128i __index, const int __scale)
+{
+  __v2df __zero = { 0.0, 0.0 };
+  __v2df __mask = __builtin_ia32_cmpeqpd (__zero, __zero);
+  __v2df x = x;
+
+  return (__m128d) __builtin_ia32_gathersiv2df (x,
+						__base,
+						(__v4si)__index,
+						__mask,
+						__scale);
+}
+
+__m128d x;
+__m128i idx;
+
+void extern
+avx2_test (void)
+{
+  x = _mm_i32gather_pd ((void *) 0, idx, 1);
+}
Index: gcc/testsuite/gcc.target/i386/pr66819-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr66819-4.c b/gcc/testsuite/gcc.target/i386/pr66819-4.c
--- a/gcc/testsuite/gcc.target/i386/pr66819-4.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr66819-4.c	(revision 278653)
@@ -1,6 +1,6 @@
 /* { dg-do compile { target ia32 } } */
 /* { dg-options "-O2 -mregparm=3" } */
-/* { dg-final { scan-assembler-not "call" } } */
+/* { dg-final { scan-assembler-not {call[ \t]+_?bar} } } */
 
 #include <stdarg.h>
 
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,10 +13,12 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-times {jmp[ \t]*\.?LIND} 2 } } */
+/* { dg-final { scan-assembler-times {call[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
Index: gcc/testsuite/gcc.target/i386/pr32219-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr32219-1.c b/gcc/testsuite/gcc.target/i386/pr32219-1.c
--- a/gcc/testsuite/gcc.target/i386/pr32219-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr32219-1.c	(revision 278653)
@@ -12,7 +12,11 @@
   return xxx;
 }
 
-/* { dg-final { scan-assembler "movl\[ \t\]xxx\\(%rip\\), %eax" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-not "xxx@GOTPCREL" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %eax" { target ia32 } } } */
-/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %eax" { target ia32 } } } */
+/* { dg-final { scan-assembler {movl[ \t]_?xxx\(%rip\),[ \t]%eax} { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler-not "_?xxx@GOTPCREL" { target { ! ia32 } } } } */
+
+/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %eax" { target { ia32 && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler-not "movl\[ \t\]_?xxx@GOT\\(%\[^,\]*\\), %eax" { target { ia32 && { ! *-*-darwin* } } } } } */
+
+/* For Darwin, we default to PIC - but that's needed for Darwin's PIE.  */
+/* { dg-final { scan-assembler {movl[ \t]_xxx-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk" } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,9 +12,11 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/pr52857-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr52857-1.c b/gcc/testsuite/gcc.target/i386/pr52857-1.c
--- a/gcc/testsuite/gcc.target/i386/pr52857-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr52857-1.c	(revision 278653)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-g -O -mx32 -maddress-mode=long" } */
 
 extern void get_BID128 (int *);
Index: gcc/testsuite/gcc.target/i386/pr52698.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr52698.c b/gcc/testsuite/gcc.target/i386/pr52698.c
--- a/gcc/testsuite/gcc.target/i386/pr52698.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr52698.c	(revision 278653)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long" } */
 
 extern void abort (void);
Index: gcc/testsuite/gcc.target/i386/ret-thunk-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-1.c b/gcc/testsuite/gcc.target/i386/ret-thunk-1.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-1.c	(revision 278653)
@@ -6,8 +6,8 @@
 {
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/cet-notrack-icf-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/cet-notrack-icf-3.c b/gcc/testsuite/gcc.target/i386/cet-notrack-icf-3.c
--- a/gcc/testsuite/gcc.target/i386/cet-notrack-icf-3.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/cet-notrack-icf-3.c	(revision 278653)
@@ -3,8 +3,8 @@
 /* { dg-options "-O2 -fcf-protection=none" } */
 /* { dg-final { scan-assembler-not "endbr" } } */
 /* { dg-final { scan-assembler-not "fn2:" } } */
-/* { dg-final { scan-assembler "set\[ \t]+fn2,fn1" } } */
-/* { dg-final { scan-assembler "set\[ \t]+fn3,fn1" } } */
+/* { dg-final { scan-assembler "set\[ \t]+fn2,fn1" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "set\[ \t]+fn3,fn1" { target { ! *-*-darwin* } } } } */
 
 int (*foo)(int);
 
Index: gcc/testsuite/gcc.target/i386/ret-thunk-10.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-10.c b/gcc/testsuite/gcc.target/i386/ret-thunk-10.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-10.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-10.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=thunk-inline -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=thunk-inline -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -10,11 +11,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-times {\tpause} 2 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 2 } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "_?__x86_indirect_thunk_(r|e)ax:" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/wbnoinvd-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/wbnoinvd-1.c b/gcc/testsuite/gcc.target/i386/wbnoinvd-1.c
--- a/gcc/testsuite/gcc.target/i386/wbnoinvd-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/wbnoinvd-1.c	(revision 278653)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -mwbnoinvd" } */
-/* { dg-final { scan-assembler-times "wbnoinvd" 2 } } */
+/* { dg-final { scan-assembler-times {\twbnoinvd} 1 } } */
 
 #include "x86intrin.h"
 
Index: gcc/testsuite/gcc.target/i386/pr55049-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr55049-1.c b/gcc/testsuite/gcc.target/i386/pr55049-1.c
--- a/gcc/testsuite/gcc.target/i386/pr55049-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr55049-1.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile { target { ! ia32 } } } */
 /* { dg-require-effective-target fpic } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -fPIC -mx32" } */
 
 extern void __morestack_fail (const char *msg);
Index: gcc/testsuite/gcc.target/i386/pr54157.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr54157.c b/gcc/testsuite/gcc.target/i386/pr54157.c
--- a/gcc/testsuite/gcc.target/i386/pr54157.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr54157.c	(revision 278653)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long -ftree-vectorize" } */
 
 struct s2{
Index: gcc/testsuite/gcc.target/i386/stack-prot-sym.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/stack-prot-sym.c b/gcc/testsuite/gcc.target/i386/stack-prot-sym.c
--- a/gcc/testsuite/gcc.target/i386/stack-prot-sym.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/stack-prot-sym.c	(revision 278653)
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-effective-target tls_native } */
 /* { dg-options "-O2 -fstack-protector-all -mstack-protector-guard=tls -mstack-protector-guard-reg=gs -mstack-protector-guard-symbol=my_guard" } */
 
 void f(void) { }
Index: gcc/testsuite/gcc.target/i386/pconfig-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pconfig-1.c b/gcc/testsuite/gcc.target/i386/pconfig-1.c
--- a/gcc/testsuite/gcc.target/i386/pconfig-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pconfig-1.c	(revision 278653)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -mpconfig" } */
-/* { dg-final { scan-assembler-times "pconfig" 5 } } */
+/* { dg-final { scan-assembler-times {\tpconfig} 2 } } */
 
 #include <x86intrin.h>
 
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,9 +13,11 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/pr59874-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr59874-3.c b/gcc/testsuite/gcc.target/i386/pr59874-3.c
--- a/gcc/testsuite/gcc.target/i386/pr59874-3.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr59874-3.c	(revision 278653)
@@ -1,7 +1,8 @@
 /* PR target/59874 */
 /* { dg-do compile } */
 /* { dg-options "-O2 -mpopcnt -masm=att" } */
-/* { dg-final { scan-assembler "popcntw" } } */
+/* { dg-final { scan-assembler "\tpopcntw" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "\tpopcnt" { target *-*-darwin* } } } */
 
 unsigned int
 foo (unsigned short x)
Index: gcc/testsuite/gcc.target/i386/ret-thunk-25.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-25.c b/gcc/testsuite/gcc.target/i386/ret-thunk-25.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-25.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-25.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* PR target/r84530 */
 /* { dg-do compile { target ia32 } } */
+/* { dg-skip-if "ABI differs for return complex value" { *-*-darwin* } } */
 /* { dg-options "-O2 -mfunction-return=thunk -fcheck-pointer-bounds -mmpx -fno-pic" } */
 
 struct s { _Complex unsigned short x; };
Index: gcc/testsuite/gcc.target/i386/pr91704.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr91704.c b/gcc/testsuite/gcc.target/i386/pr91704.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr91704.c	(revision 278653)
@@ -0,0 +1,14 @@
+/* PR target/91704 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -funsigned-char -mavx2 -mavx512f -masm=att" } */
+/* { dg-final { scan-assembler-times "\tvpcmpgtb\t%ymm" 1 } } */
+/* { dg-final { scan-assembler-not "\tvpsubusb\t" } } */
+/* { dg-final { scan-assembler-not "\tvpcmpeqb\t" } } */
+
+#include <x86intrin.h>
+
+__m256i
+foo (__m256i x, __m256i y)
+{
+  return _mm256_cmpgt_epi8 (x, y);
+}
Index: gcc/testsuite/gcc.target/i386/avx512bw-vpmovuswb-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/avx512bw-vpmovuswb-1.c b/gcc/testsuite/gcc.target/i386/avx512bw-vpmovuswb-1.c
--- a/gcc/testsuite/gcc.target/i386/avx512bw-vpmovuswb-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/avx512bw-vpmovuswb-1.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512bw -mavx512vl -O2" } */
+/* { dg-additional-options "-fno-common" { target *-*-darwin* } } */
 /* { dg-final { scan-assembler-times "vpmovuswb\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\[^\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpmovuswb\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\[^\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpmovuswb\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\[^\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}{z}(?:\n|\[ \\t\]+#)" 1 } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-9.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-9.c b/gcc/testsuite/gcc.target/i386/ret-thunk-9.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-9.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-9.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=thunk -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=thunk -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -10,12 +11,14 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "__x86_return_thunk:" } } */
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
+/* { dg-final { scan-assembler {jmp[ \t]+\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]+\.?LIND} } } */
+/* { dg-final { scan-assembler "_?__x86_return_thunk:" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_bar} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_bar\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler-times {\tpause} 2 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 2 } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/pr63538.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr63538.c b/gcc/testsuite/gcc.target/i386/pr63538.c
--- a/gcc/testsuite/gcc.target/i386/pr63538.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr63538.c	(revision 278653)
@@ -9,5 +9,5 @@
 {
   return str;
 }
-
-/* { dg-final { scan-assembler "movabs" } } */
+/* See PR90698 re. Darwin xfail.  */
+/* { dg-final { scan-assembler "movabs" { xfail { *-*-darwin* } } } } */
Index: gcc/testsuite/gcc.target/i386/pr49866.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr49866.c b/gcc/testsuite/gcc.target/i386/pr49866.c
--- a/gcc/testsuite/gcc.target/i386/pr49866.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr49866.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* PR target/49866 */
 /* { dg-do assemble { target lp64 } } */
+/* { dg-xfail-if "PR90698" { *-*-darwin* } } */
 /* { dg-options "-O2 -mcmodel=large"  } */
 
 void fn (void *, int, int);
Index: gcc/testsuite/gcc.target/i386/pr67985-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr67985-2.c b/gcc/testsuite/gcc.target/i386/pr67985-2.c
--- a/gcc/testsuite/gcc.target/i386/pr67985-2.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr67985-2.c	(revision 278653)
@@ -10,4 +10,4 @@
 
 /* { dg-final { scan-assembler-not "mulss" } } */
 /* { dg-final { scan-assembler-not "movl\[ \t\].*, %eax" } } */
-/* { dg-final { scan-assembler "call\[ \t\]__mulsf3" } } */
+/* { dg-final { scan-assembler "call\[ \t\]_?__mulsf3" } } */
Index: gcc/testsuite/gcc.target/i386/pr89523-5.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-5.c b/gcc/testsuite/gcc.target/i386/pr89523-5.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr89523-5.c	(revision 278653)
@@ -0,0 +1,39 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512pf" } */
+/* { dg-final { scan-assembler "\tvgather" } } */
+/* { dg-final { scan-assembler-not "addr32 vgather" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_prefetch_i32gather_pd (__m256i __index, void const *__addr,
+			      int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd ((__mmask8) 0xFF, (__v8si) __index, __addr,
+			      __scale, __hint);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_prefetch_i32gather_pd (__m256i __index, __mmask8 __mask,
+				   void const *__addr, int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd (__mask, (__v8si) __index, __addr, __scale,
+			      __hint);
+}
+
+volatile __m256i idx;
+volatile __mmask8 m8;
+void *base;
+
+void extern
+avx512pf_test (void)
+{
+  _mm512_prefetch_i32gather_pd (idx, base, 8, 3);
+  _mm512_mask_prefetch_i32gather_pd (idx, m8, base, 8, 3);
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,10 +13,12 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-times {jmp[ \t]*\.?LIND} 2 } } */
+/* { dg-final { scan-assembler-times {call[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
Index: gcc/testsuite/gcc.target/i386/pr32219-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr32219-2.c b/gcc/testsuite/gcc.target/i386/pr32219-2.c
--- a/gcc/testsuite/gcc.target/i386/pr32219-2.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr32219-2.c	(revision 278653)
@@ -12,6 +12,13 @@
 }
 
 /* { dg-final { scan-assembler-not "movl\[ \t\]xxx\\(%rip\\), %" { target { ! ia32 } } } } */
+/* For Darwin m64 we are always PIC, but common symbols are indirected, which happens to
+   match the general "ELF" case.  */
 /* { dg-final { scan-assembler "xxx@GOTPCREL" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %" { target ia32 } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %" { target ia32 } } } */
+
+/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %" { target { ia32 && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %" { target { ia32 && { ! *-*-darwin* } } } } } */
+
+/* Darwin m32 defaults to PIC but common symbols need to be indirected.  */
+/* { dg-final { scan-assembler {movl[ \t][Ll]_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
+
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,9 +12,11 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/pr52857-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr52857-2.c b/gcc/testsuite/gcc.target/i386/pr52857-2.c
--- a/gcc/testsuite/gcc.target/i386/pr52857-2.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr52857-2.c	(revision 278653)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-g -O -mx32 -maddress-mode=long" } */
 
 void uw_init_context_1 (void *);
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-register-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-register-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-register-1.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-register-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-register-1.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mindirect-branch=thunk -mindirect-branch-register -fno-pic" } */
+/* { dg-options "-O2 -mindirect-branch=thunk -mindirect-branch-register " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,12 +12,12 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler "mov\[ \t\](%eax|%rax), \\((%esp|%rsp)\\)" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler-not "push(?:l|q)\[ \t\]*_?dispatch"  } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk\n" } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk_bnd\n" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk\n" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk_bnd\n" } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-2.c b/gcc/testsuite/gcc.target/i386/ret-thunk-2.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-2.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-2.c	(revision 278653)
@@ -6,8 +6,8 @@
 {
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
Index: gcc/testsuite/gcc.target/i386/cet-notrack-icf-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/cet-notrack-icf-4.c b/gcc/testsuite/gcc.target/i386/cet-notrack-icf-4.c
--- a/gcc/testsuite/gcc.target/i386/cet-notrack-icf-4.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/cet-notrack-icf-4.c	(revision 278653)
@@ -3,7 +3,7 @@
 /* { dg-options "-O2 -fcf-protection" } */
 /* { dg-final { scan-assembler "endbr" } } */
 /* { dg-final { scan-assembler "fn2:" } } */
-/* { dg-final { scan-assembler "set\[ \t]+fn3,fn1" } } */
+/* { dg-final { scan-assembler "set\[ \t]+fn3,fn1" { target { ! *-*-darwin* } } } } */
 
 int (*foo)(int);
 
Index: gcc/testsuite/gcc.target/i386/ret-thunk-11.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-11.c b/gcc/testsuite/gcc.target/i386/ret-thunk-11.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-11.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-11.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=thunk-extern -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=thunk-extern -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -10,11 +11,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "_?__x86_indirect_thunk_(r|e)ax:" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/cet-sjlj-5.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/cet-sjlj-5.c b/gcc/testsuite/gcc.target/i386/cet-sjlj-5.c
--- a/gcc/testsuite/gcc.target/i386/cet-sjlj-5.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/cet-sjlj-5.c	(revision 278653)
@@ -3,7 +3,7 @@
 /* { dg-final { scan-assembler-times "endbr32" 2 { target ia32 } } } */
 /* { dg-final { scan-assembler-times "endbr64" 2 { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler-times "call	_?setjmp" 1 } } */
-/* { dg-final { scan-assembler-times "call	longjmp" 1 } } */
+/* { dg-final { scan-assembler-times "call	_?longjmp" 1 } } */
 
 #include <stdio.h>
 #include <setjmp.h>
Index: gcc/testsuite/gcc.target/i386/pr39013-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr39013-1.c b/gcc/testsuite/gcc.target/i386/pr39013-1.c
--- a/gcc/testsuite/gcc.target/i386/pr39013-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr39013-1.c	(revision 278653)
@@ -12,5 +12,9 @@
   return foo () + bar ();
 }
 
-/* { dg-final { scan-assembler "foo@PLT" } } */
-/* { dg-final { scan-assembler "bar@PLT" } } */
+/* { dg-final { scan-assembler "foo@PLT" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "bar@PLT" { target { ! *-*-darwin* } } } } */
+
+/* Darwin's dynamic linker does PIE without indirection.  */
+/* { dg-final { scan-assembler {call[ \t]_foo} { target *-*-darwin* } } } */
+/* { dg-final { scan-assembler {call[ \t]_bar} { target *-*-darwin* } } } */
Index: gcc/testsuite/gcc.target/i386/pr89848.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr89848.c b/gcc/testsuite/gcc.target/i386/pr89848.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr89848.c	(revision 278653)
@@ -0,0 +1,11 @@
+/* PR target/89848 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -msse2 -mtune=pentium3m" } */
+
+long long
+foo (long long x)
+{
+  x >>= 3;
+  x <<= x;
+  return x;
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -14,9 +15,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-times {jmp[ \t]*\.?LIND} 2 } } */
+/* { dg-final { scan-assembler-times {call[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
Index: gcc/testsuite/gcc.target/i386/pr90547.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr90547.c b/gcc/testsuite/gcc.target/i386/pr90547.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr90547.c	(revision 278653)
@@ -0,0 +1,21 @@
+/* PR target/90547 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+foo ()
+{
+  void *g[] = {&&a, &&b};
+
+  for (unsigned c = 0x1F;; c >>= 1)
+    {
+      unsigned d = (long)("a"+1);
+      long e = 8;
+
+      while (e)
+        {
+          a: goto *g[c&d];
+          b: e--;
+        }
+    }
+}
Index: gcc/testsuite/gcc.target/i386/pr91131.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr91131.c b/gcc/testsuite/gcc.target/i386/pr91131.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr91131.c	(revision 278653)
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+struct Reg_T {
+    unsigned int a : 3;
+    unsigned int b : 1;
+    unsigned int c : 4;
+};
+
+volatile struct Reg_T Reg_A;
+
+int
+main ()
+{
+  Reg_A = (struct Reg_T){ .a = 0, .b = 0, .c = 0 };
+  return 0;
+}
+
+/* { dg-final { scan-assembler-times "mov\[^\r\n\]*Reg_A" 1 } } */
Index: gcc/testsuite/gcc.target/i386/pr89523-6.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-6.c b/gcc/testsuite/gcc.target/i386/pr89523-6.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr89523-6.c	(revision 278653)
@@ -0,0 +1,38 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512pf" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_prefetch_i32gather_pd (__m256i __index, void const *__addr,
+			      int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd ((__mmask8) 0xFF, (__v8si) __index, __addr,
+			      __scale, __hint);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_prefetch_i32gather_pd (__m256i __index, __mmask8 __mask,
+				   void const *__addr, int __scale, int __hint)
+{
+  __builtin_ia32_gatherpfdpd (__mask, (__v8si) __index, __addr, __scale,
+			      __hint);
+}
+
+volatile __m256i idx;
+volatile __mmask8 m8;
+
+void extern
+avx512pf_test (void)
+{
+  _mm512_prefetch_i32gather_pd (idx, (void *) 0, 8, 3);
+  _mm512_mask_prefetch_i32gather_pd (idx, m8, (void *) 0, 8, 3);
+}
Index: gcc/testsuite/gcc.target/i386/pr32219-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr32219-3.c b/gcc/testsuite/gcc.target/i386/pr32219-3.c
--- a/gcc/testsuite/gcc.target/i386/pr32219-3.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr32219-3.c	(revision 278653)
@@ -12,7 +12,16 @@
   return xxx;
 }
 
-/* { dg-final { scan-assembler "movl\[ \t\]xxx\\(%rip\\), %eax" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-not "xxx@GOTPCREL" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %eax" { target ia32 } } } */
-/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %eax" { target ia32 } } } */
+/* { dg-final { scan-assembler {movl[ \t]xxx\(%rip\),[ \t]%eax} { target { { ! ia32 } && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler-not "xxx@GOTPCREL" { target { { ! ia32 } && { ! *-*-darwin* } } } } } */
+
+/* For Darwin m64, code is always PIC and we need to indirect through the GOT to allow
+   weak symbols to be interposed.  The dynamic loader knows how to apply PIE to this.  */
+/* { dg-final { scan-assembler {movq[ \t]_xxx@GOTPCREL\(%rip\),[ \t]%rax} { target { { ! ia32 } && *-*-darwin* } } } } */
+
+/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %eax" { target { ia32 && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %eax" { target { ia32 && { ! *-*-darwin* } } } } } */
+
+/* For Darwin, we need PIC to allow PIE, but also we must indirect weak symbols so that
+   they can be indirected.  Again, dyld knows how to deal with this. */
+/* { dg-final { scan-assembler {movl[ \t][Ll]_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,9 +13,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/pr53698.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr53698.c b/gcc/testsuite/gcc.target/i386/pr53698.c
--- a/gcc/testsuite/gcc.target/i386/pr53698.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr53698.c	(revision 278653)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O -mx32 -maddress-mode=long -fno-tree-dominator-opts" } */
 
 extern char foo[];
Index: gcc/testsuite/gcc.target/i386/pr89827.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr89827.c b/gcc/testsuite/gcc.target/i386/pr89827.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr89827.c	(revision 278653)
@@ -0,0 +1,11 @@
+/* PR target/89827 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -msse2 -mstv -mno-stackrealign" } */
+
+unsigned long long a;
+
+void
+foo (void)
+{
+  a >>= (unsigned short) a;
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-register-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-register-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-register-2.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-register-2.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-register-2.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mindirect-branch=thunk-inline -mindirect-branch-register -fno-pic" } */
+/* { dg-options "-O2 -mindirect-branch=thunk-inline -mindirect-branch-register " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,10 +12,10 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler "mov\[ \t\](%eax|%rax), \\((%esp|%rsp)\\)" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler-not "push(?:l|q)\[ \t\]*_?dispatch"  } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-3.c b/gcc/testsuite/gcc.target/i386/ret-thunk-3.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-3.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-3.c	(revision 278653)
@@ -6,7 +6,7 @@
 {
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-12.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-12.c b/gcc/testsuite/gcc.target/i386/ret-thunk-12.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-12.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-12.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -10,11 +11,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "_?__x86_indirect_thunk_(r|e)ax:" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/pr90867.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr90867.c b/gcc/testsuite/gcc.target/i386/pr90867.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr90867.c	(revision 278653)
@@ -0,0 +1,30 @@
+/* PR target/90867 */
+/* { dg-do run { target lp64 } } */
+/* { dg-options "-O2 -msse2" } */
+
+unsigned long long freq = 3600000000UL;   /* 3.6 GHz = 3600.0 MHz */
+
+__attribute__((noipa)) void
+bar (double x)
+{
+  static double d = 3600000000.0;
+  if (x != d)
+    __builtin_abort ();
+  d /= 1000.0;
+}
+
+__attribute__ ((target ("arch=x86-64"))) int
+foo ()
+{
+  bar ((double) freq);
+  bar (1e-3 * freq);
+  bar (1e-6 * freq);
+  bar (1e-9 * freq);
+  return 0;
+}
+
+int
+main ()
+{
+  return foo ();
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fjump-tables" } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void func0 (void);
 void func1 (void);
@@ -36,7 +37,7 @@
 }
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk(_nt|)_(r|e)ax" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk(_nt|)_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*\.?LIND" } } */
Index: gcc/testsuite/gcc.target/i386/pr39013-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr39013-2.c b/gcc/testsuite/gcc.target/i386/pr39013-2.c
--- a/gcc/testsuite/gcc.target/i386/pr39013-2.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr39013-2.c	(revision 278653)
@@ -12,5 +12,9 @@
   return foo () + bar ();
 }
 
-/* { dg-final { scan-assembler "foo@PLT" } } */
-/* { dg-final { scan-assembler "bar@PLT" } } */
+/* { dg-final { scan-assembler "foo@PLT" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "bar@PLT" { target { ! *-*-darwin* } } } } */
+
+/* Darwin's dynamic linker does PIE without indirection.  */
+/* { dg-final { scan-assembler {call[ \t]_foo} { target *-*-darwin* } } } */
+/* { dg-final { scan-assembler {call[ \t]_bar} { target *-*-darwin* } } } */
Index: gcc/testsuite/gcc.target/i386/pr89965.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr89965.c b/gcc/testsuite/gcc.target/i386/pr89965.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr89965.c	(revision 278653)
@@ -0,0 +1,39 @@
+/* PR rtl-optimization/89965 */
+/* { dg-do run } */
+/* { dg-options "-O -mtune=nano-x2 -fcaller-saves -fexpensive-optimizations -fno-tree-dce -fno-tree-ter" } */
+/* { dg-additional-options "-march=i386" { target ia32 } } */
+
+int a;
+
+__attribute__ ((noipa)) unsigned long long
+foo (unsigned char c, unsigned d, unsigned e, unsigned long long f,
+     unsigned char g, unsigned h, unsigned long long i)
+{
+  (void) d;
+  unsigned short j = __builtin_mul_overflow_p (~0, h, c);
+  e <<= e;
+  i >>= 7;
+  c *= i;
+  i /= 12;
+  a = __builtin_popcount (c);
+  __builtin_add_overflow (e, a, &f);
+  return c + f + g + j + h;
+}
+
+__attribute__ ((noipa)) void
+bar (void)
+{
+  char buf[64];
+  __builtin_memset (buf, 0x55, sizeof buf);
+  asm volatile ("" : : "r" (&buf[0]) : "memory");
+}
+
+int
+main (void)
+{
+  bar ();
+  unsigned long long x = foo (2, 0, 0, 0, 0, 0, 0);
+  if (x != 0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -13,9 +14,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-times {jmp[ \t]*\.?LIND} 2 } } */
+/* { dg-final { scan-assembler-times {call[ \t]*\.?LIND} 2 } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
Index: gcc/testsuite/gcc.target/i386/fuse-caller-save-rec.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/fuse-caller-save-rec.c b/gcc/testsuite/gcc.target/i386/fuse-caller-save-rec.c
--- a/gcc/testsuite/gcc.target/i386/fuse-caller-save-rec.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/fuse-caller-save-rec.c	(revision 278653)
@@ -18,14 +18,12 @@
   return y + bar (y);
 }
 
-/* For !nonpic && ia32 xfails, see PR64895.  */
-
 /* Check that no registers are saved/restored. */
-/* { dg-final { scan-assembler-not "push" { xfail { { ! nonpic } && ia32 } } } } */
-/* { dg-final { scan-assembler-not "pop" { xfail { { ! nonpic } && ia32 } } } } */
+/* { dg-final { scan-assembler-not "push" } } */
+/* { dg-final { scan-assembler-not "pop" } } */
 
 /* Check that addition uses dx. */
-/* { dg-final { scan-assembler-times "addl\t%\[re\]?dx, %\[re\]?ax" 1 { xfail { { ! nonpic } && ia32 } } } } */
+/* { dg-final { scan-assembler-times "addl\t%\[re\]?dx, %\[re\]?ax" 1 } } */
 
 /* Verify that bar is self-recursive.  */
 /* { dg-final { scan-assembler-times "call\t_?bar" 2 } } */
Index: gcc/testsuite/gcc.target/i386/fuse-caller-save-xmm.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/fuse-caller-save-xmm.c b/gcc/testsuite/gcc.target/i386/fuse-caller-save-xmm.c
--- a/gcc/testsuite/gcc.target/i386/fuse-caller-save-xmm.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/fuse-caller-save-xmm.c	(revision 278653)
@@ -15,14 +15,20 @@
   return y + bar (y);
 }
 
-/* For !nonpic && ia32 xfails, see PR64895.  */
-
 /* Check presence of all insns on xmm registers.  These checks are expected to
    pass with both -fipa-ra and -fno-ipa-ra.  */
-/* { dg-final { scan-assembler-times "addpd\t\\.?LC0.*, %xmm0" 1 } } */
-/* { dg-final { scan-assembler-times "addpd\t%xmm1, %xmm0" 1 { xfail { { ! nonpic } && ia32 } } } } */
-/* { dg-final { scan-assembler-times "movapd\t%xmm0, %xmm1" 1 { xfail { { ! nonpic } && ia32 } } } } */
 
+/* Darwin local constant symbol is "lC0", ELF targets ".LC0" */
+/* { dg-final { scan-assembler-times {addpd\t\.?[Ll]C0.*, %xmm0} 1 { target { { ! ia32 } || nonpic } } } } */
+/* { dg-final { scan-assembler-times {movapd\t\.?[Ll]C0.*, %xmm1} 1 { target { ia32 && { ! nonpic } } } } } */
+
+/* We happen to get this for both cases, but in different positions.  */
+/* { dg-final { scan-assembler-times "addpd\t%xmm1, %xmm0" 1 } } */
+
+/* { dg-final { scan-assembler-times "movapd\t%xmm0, %xmm1" 1 { target { { ! ia32 } || nonpic } } } } */
+/* { dg-final { scan-assembler-times "movapd\t%xmm0, %xmm2" 1 { target { ia32 && { ! nonpic } } } } } */
+/* { dg-final { scan-assembler-times "addpd\t%xmm2, %xmm0" 1 { target { ia32 && { ! nonpic } } } } } */
+
 /* Check absence of save/restore of xmm1 register.  */
 /* { dg-final { scan-assembler-not "movaps\t%xmm1, \\(%\[re\]?sp\\)" } } */
 /* { dg-final { scan-assembler-not "movapd\t\\(%\[re\]?sp\\), %xmm1" } } */
Index: gcc/testsuite/gcc.target/i386/pr77881.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr77881.c b/gcc/testsuite/gcc.target/i386/pr77881.c
--- a/gcc/testsuite/gcc.target/i386/pr77881.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr77881.c	(revision 278653)
@@ -8,5 +8,5 @@
     if (a < 0 || b)
           baz ();
 }
-/* { dg-final { scan-assembler "js\[ \t\]\.L" } } */
-/* { dg-final { scan-assembler "jne\[ \t\]\.L" } } */
+/* { dg-final { scan-assembler "js\[ \t\]\.?L" } } */
+/* { dg-final { scan-assembler "jne\[ \t\]\.?L" } } */
Index: gcc/testsuite/gcc.target/i386/cet-notrack-5a.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/cet-notrack-5a.c b/gcc/testsuite/gcc.target/i386/cet-notrack-5a.c
--- a/gcc/testsuite/gcc.target/i386/cet-notrack-5a.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/cet-notrack-5a.c	(revision 278653)
@@ -2,7 +2,8 @@
 /* { dg-options "-O -fcf-protection" } */
 /* { dg-final { scan-assembler-times "endbr32" 1 { target ia32 } } } */
 /* { dg-final { scan-assembler-times "endbr64" 1 { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-not "\tcall\[ \t]+" } } */
+/* { dg-final { scan-assembler-not "\tcall\[ \t]+" { target { { ! ia32 } || { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler-times "\tcall\[ \t]+" 1 { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler-times "notrack call\[ \t]+" 1 } } */
 
 int (*fptr) (int) __attribute__ ((nocf_check));
Index: gcc/testsuite/gcc.target/i386/pr87853.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr87853.c b/gcc/testsuite/gcc.target/i386/pr87853.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr87853.c	(revision 278653)
@@ -0,0 +1,20 @@
+/* PR target/87853 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -funsigned-char -msse2 -mno-sse3 -masm=att" } */
+/* { dg-final { scan-assembler-times "\tpcmpgtb\t%xmm" 2 } } */
+/* { dg-final { scan-assembler-not "\tpsubusb\t" } } */
+/* { dg-final { scan-assembler-not "\tpcmpeqb\t" } } */
+
+#include <x86intrin.h>
+
+__m128i
+foo (__m128i x, __m128i y)
+{
+  return _mm_cmpgt_epi8 (x, y);
+}
+
+__m128i
+bar (__m128i x, __m128i y)
+{
+  return _mm_cmplt_epi8 (x, y);
+}
Index: gcc/testsuite/gcc.target/i386/pr89523-7.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-7.c b/gcc/testsuite/gcc.target/i386/pr89523-7.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr89523-7.c	(revision 278653)
@@ -0,0 +1,42 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512f" } */
+/* { dg-final { scan-assembler "\tvscatter" } } */
+/* { dg-final { scan-assembler-not "addr32 vscatter" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef double __v8df __attribute__ ((__vector_size__ (64)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef double __m512d __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_i32scatter_pd (void *__addr, __m256i __index, __m512d __v1,
+		      int __scale)
+{
+  __builtin_ia32_scattersiv8df (__addr, (__mmask8) 0xFF,
+				(__v8si) __index, (__v8df) __v1, __scale);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_i32scatter_pd (void *__addr, __mmask8 __mask,
+			   __m256i __index, __m512d __v1, int __scale)
+{
+  __builtin_ia32_scattersiv8df (__addr, __mask, (__v8si) __index,
+				(__v8df) __v1, __scale);
+}
+
+volatile __m512d src;
+volatile __m256i idx;
+volatile __mmask8 m8;
+double *addr;
+
+void extern
+avx512f_test (void)
+{
+  _mm512_i32scatter_pd (addr, idx, src, 8);
+  _mm512_mask_i32scatter_pd (addr, m8, idx, src, 8);
+}
Index: gcc/testsuite/gcc.target/i386/pr32219-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr32219-4.c b/gcc/testsuite/gcc.target/i386/pr32219-4.c
--- a/gcc/testsuite/gcc.target/i386/pr32219-4.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr32219-4.c	(revision 278653)
@@ -13,6 +13,12 @@
 }
 
 /* { dg-final { scan-assembler-not "movl\[ \t\]xxx\\(%rip\\), %" { target { ! ia32 } } } } */
+/* Darwin is always PIC for PIE so no change, weak symbols need to be indirect and this
+   happens to match the ELF case.  */
 /* { dg-final { scan-assembler "xxx@GOTPCREL" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %" { target ia32 } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %" { target ia32 } } } */
+
+/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %" { target { ia32 && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %" { target { ia32 && { ! *-*-darwin* } } } } } */
+
+/* Darwin m32 equivalent (indirect and PIC).  */
+/* { dg-final { scan-assembler {movl[ \t][Ll]_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,9 +13,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-register-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-register-3.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-register-3.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-register-3.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-register-3.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mindirect-branch=thunk-extern -mindirect-branch-register -fno-pic" } */
+/* { dg-options "-O2 -mindirect-branch=thunk-extern -mindirect-branch-register " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,9 +12,9 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not "push(?:l|q)\[ \t\]*_?dispatch"  } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
 /* { dg-final { scan-assembler-not {\t(pause|pause|nop)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-4.c b/gcc/testsuite/gcc.target/i386/ret-thunk-4.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-4.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-4.c	(revision 278653)
@@ -6,7 +6,7 @@
 {
 }
 
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-13.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-13.c b/gcc/testsuite/gcc.target/i386/ret-thunk-13.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-13.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-13.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 extern int foo (void) __attribute__ ((function_return("thunk")));
@@ -11,11 +12,11 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-times {\tpause} 2 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 2 } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 3 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 3 } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler-times {jmp[ \t]*\.?LIND} 3 } } */
+/* { dg-final { scan-assembler-times {call[ \t]*\.?LIND} 3 } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -14,8 +15,10 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr52876.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr52876.c b/gcc/testsuite/gcc.target/i386/pr52876.c
--- a/gcc/testsuite/gcc.target/i386/pr52876.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr52876.c	(revision 278653)
@@ -1,4 +1,5 @@
 /* { dg-do run { target x32 } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long" } */
 
 extern void abort (void);
Index: gcc/testsuite/gcc.target/i386/avx512bw-vpmovwb-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/avx512bw-vpmovwb-1.c b/gcc/testsuite/gcc.target/i386/avx512bw-vpmovwb-1.c
--- a/gcc/testsuite/gcc.target/i386/avx512bw-vpmovwb-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/avx512bw-vpmovwb-1.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512bw -mavx512vl -O2" } */
+/* { dg-additional-options "-fno-common" { target *-*-darwin* } } */
 /* { dg-final { scan-assembler-times "vpmovwb\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\[^\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpmovwb\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\[^\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpmovwb\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+\[^\n\]*%xmm\[0-9\]+\{%k\[1-7\]\}{z}(?:\n|\[ \\t\]+#)" 1 } } */
Index: gcc/testsuite/gcc.target/i386/cet-notrack-5b.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/cet-notrack-5b.c b/gcc/testsuite/gcc.target/i386/cet-notrack-5b.c
--- a/gcc/testsuite/gcc.target/i386/cet-notrack-5b.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/cet-notrack-5b.c	(revision 278653)
@@ -3,7 +3,8 @@
 /* { dg-options "-O -fcf-protection" } */
 /* { dg-final { scan-assembler-times "endbr32" 1 { target ia32 } } } */
 /* { dg-final { scan-assembler-times "endbr64" 1 { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-times "\tcall\[ \t]+" 1 } } */
+/* { dg-final { scan-assembler-times "\tcall\[ \t]+" 1 { target { { ! ia32 } || { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler-times "\tcall\[ \t]+" 2 { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler-times "notrack call\[ \t]+" 1 } } */
 
 int (*fptr) (int) __attribute__ ((nocf_check));
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,8 +12,10 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr89523-8.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-8.c b/gcc/testsuite/gcc.target/i386/pr89523-8.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr89523-8.c	(revision 278653)
@@ -0,0 +1,41 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512f" } */
+/* { dg-final { scan-assembler "\tvscatter" } } */
+/* { dg-final { scan-assembler-not "addr32 vscatter" } } */
+
+typedef long long __v8di __attribute__ ((__vector_size__ (64)));
+typedef double __v8df __attribute__ ((__vector_size__ (64)));
+typedef long long __m512i __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef double __m512d __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_i64scatter_pd (void *__addr, __m512i __index, __m512d __v1,
+		      int __scale)
+{
+  __builtin_ia32_scatterdiv8df (__addr, (__mmask8) 0xFF,
+				(__v8di) __index, (__v8df) __v1, __scale);
+}
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_mask_i64scatter_pd (void *__addr, __mmask8 __mask,
+			   __m512i __index, __m512d __v1, int __scale)
+{
+  __builtin_ia32_scatterdiv8df (__addr, __mask, (__v8di) __index,
+				(__v8df) __v1, __scale);
+}
+
+volatile __m512d src;
+volatile __m512i idx;
+volatile __mmask8 m8;
+double *addr;
+
+void extern
+avx512f_test (void)
+{
+  _mm512_i64scatter_pd (addr, idx, src, 8);
+  _mm512_mask_i64scatter_pd (addr, m8, idx, src, 8);
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fjump-tables" } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void func0 (void);
 void func1 (void);
@@ -37,8 +38,8 @@
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
Index: gcc/testsuite/gcc.target/i386/pr32219-5.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr32219-5.c b/gcc/testsuite/gcc.target/i386/pr32219-5.c
--- a/gcc/testsuite/gcc.target/i386/pr32219-5.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr32219-5.c	(revision 278653)
@@ -11,7 +11,11 @@
   return xxx;
 }
 
-/* { dg-final { scan-assembler "movl\[ \t\]xxx\\(%rip\\), %eax" { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler "movl\[ \t\]_?xxx\\(%rip\\), %eax" { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler-not "xxx@GOTPCREL" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %eax" { target ia32 } } } */
-/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %eax" { target ia32 } } } */
+
+/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %eax" { target { ia32 && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %eax" { target { ia32 && { ! *-*-darwin* } } } } } */
+
+/* For Darwin m32, we need PIC (the default) to allow PIE.  */
+/* { dg-final { scan-assembler {movl[ \t]_xxx-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
Index: gcc/testsuite/gcc.target/i386/pr89523-1a.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-1a.c b/gcc/testsuite/gcc.target/i386/pr89523-1a.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr89523-1a.c	(revision 278653)
@@ -0,0 +1,24 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-maddress-mode=short -mx32 -Ofast -funroll-loops -march=haswell" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+void foo (void);
+
+extern float *ncost;
+
+float
+bar (int type, int num)
+{
+  int i;
+  float cost;
+
+  cost = 0;
+  for (i = 0; i < num; i++)
+    if (type)
+      cost += ncost[i];
+    else
+      foo ();
+  return (cost);
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile { target { ! x32 } } } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fcheck-pointer-bounds -mmpx -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fcheck-pointer-bounds -mmpx" } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void (*dispatch) (char *);
 char buf[10];
@@ -11,8 +12,8 @@
 }
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk_bnd_rax" { target lp64 } } } */
-/* { dg-final { scan-assembler "bnd call\[ \t\]*__x86_indirect_thunk_bnd_eax" { target ia32 } } } */
+/* { dg-final { scan-assembler "bnd jmp\[ \t\]*_?__x86_indirect_thunk_bnd_rax" { target lp64 } } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*_?__x86_indirect_thunk_bnd_eax" { target ia32 } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd ret" } } */
Index: gcc/testsuite/gcc.target/i386/pr89945.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr89945.c b/gcc/testsuite/gcc.target/i386/pr89945.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr89945.c	(revision 278653)
@@ -0,0 +1,21 @@
+/* PR target/89945 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+foo ()
+{
+  void *g[] = {&&a, &&b};
+
+  for (unsigned c = 0x1F;; c >>= 1)
+    {
+      unsigned d = (long)"a";
+      long e = 8;
+
+      while (e)
+        {
+          a: goto *g[c&d];
+          b: e--;
+        }
+    }
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-register-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-register-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-register-4.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-register-4.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-register-4.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mindirect-branch=keep -fno-pic" } */
+/* { dg-options "-O2 -mindirect-branch=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*func_p) (void);
 
Index: gcc/testsuite/gcc.target/i386/ret-thunk-5.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-5.c b/gcc/testsuite/gcc.target/i386/ret-thunk-5.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-5.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-5.c	(revision 278653)
@@ -8,8 +8,8 @@
 {
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/pr55093.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr55093.c b/gcc/testsuite/gcc.target/i386/pr55093.c
--- a/gcc/testsuite/gcc.target/i386/pr55093.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr55093.c	(revision 278653)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long" } */
 /* { dg-skip-if "different ABI" { x86_64-*-mingw* } } */
 
Index: gcc/testsuite/gcc.target/i386/ret-thunk-14.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-14.c b/gcc/testsuite/gcc.target/i386/ret-thunk-14.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-14.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-14.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -13,9 +14,11 @@
 
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?bar" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_bar} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_bar\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/pr90193.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr90193.c b/gcc/testsuite/gcc.target/i386/pr90193.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr90193.c	(revision 278653)
@@ -0,0 +1,21 @@
+/* PR target/90193 *
+/* { dg-do link } */
+/* { dg-options "-O1" } */
+/* { dg-require-effective-target tls } */
+
+__thread int var;
+
+static int
+foo (void)
+{
+  asm goto ("jmp %l[l]\n\t" : : "m" (var) : : l);
+  return 0;
+l:
+  return 1;
+}
+
+int
+main ()
+{
+  return foo ();
+}
Index: gcc/testsuite/gcc.target/i386/wbinvd-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/wbinvd-1.c b/gcc/testsuite/gcc.target/i386/wbinvd-1.c
--- a/gcc/testsuite/gcc.target/i386/wbinvd-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/wbinvd-1.c	(revision 278653)
@@ -1,6 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2" } */
-/* { dg-final { scan-assembler-times "wbinvd" 2 } } */
+/* { dg-final { scan-assembler-times {\twbinvd} 1 } } */
 
 #include "immintrin.h"
 
Index: gcc/testsuite/gcc.target/i386/pr82659-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr82659-3.c b/gcc/testsuite/gcc.target/i386/pr82659-3.c
--- a/gcc/testsuite/gcc.target/i386/pr82659-3.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr82659-3.c	(revision 278653)
@@ -1,4 +1,5 @@
 /* { dg-do compile } */
+/* { dg-require-alias "" } */
 /* { dg-options "-O2 -fcf-protection" } */
 /* { dg-final { scan-assembler-times {\mendbr} 2 } } */
 
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -13,8 +14,10 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr89902.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr89902.c b/gcc/testsuite/gcc.target/i386/pr89902.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr89902.c	(revision 278653)
@@ -0,0 +1,13 @@
+/* PR target/89902 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -fno-tree-coalesce-vars -mavx512bitalg" } */
+
+void bar (void);
+
+int
+foo (long long x)
+{
+  x <<= (char) x;
+  bar ();
+  return x;
+}
Index: gcc/testsuite/gcc.target/i386/pr66470.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr66470.c b/gcc/testsuite/gcc.target/i386/pr66470.c
--- a/gcc/testsuite/gcc.target/i386/pr66470.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr66470.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* PR target/66470 */
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long" } */
 /* { dg-require-effective-target tls } */
 
Index: gcc/testsuite/gcc.target/i386/pr59929.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr59929.c b/gcc/testsuite/gcc.target/i386/pr59929.c
--- a/gcc/testsuite/gcc.target/i386/pr59929.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr59929.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-options "-O0 -mno-accumulate-outgoing-args" } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-additional-options "-mx32 -maddress-mode=short" { target x32 } } */
 
 void
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,8 +12,10 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr89523-9.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-9.c b/gcc/testsuite/gcc.target/i386/pr89523-9.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr89523-9.c	(revision 278653)
@@ -0,0 +1,30 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -mavx512f" } */
+/* { dg-final { scan-assembler-not "\tvscatter" } } */
+/* { dg-final { scan-assembler "addr32 vscatter" } } */
+
+typedef int __v8si __attribute__ ((__vector_size__ (32)));
+typedef double __v8df __attribute__ ((__vector_size__ (64)));
+typedef long long __m256i __attribute__ ((__vector_size__ (32),
+					  __may_alias__));
+typedef double __m512d __attribute__ ((__vector_size__ (64), __may_alias__));
+typedef unsigned char  __mmask8;
+
+extern __inline void
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm512_i32scatter_pd (void *__addr, __m256i __index, __m512d __v1,
+		      int __scale)
+{
+  __builtin_ia32_scattersiv8df (__addr, (__mmask8) 0xFF,
+				(__v8si) __index, (__v8df) __v1, __scale);
+}
+
+volatile __m512d src;
+volatile __m256i idx;
+
+void extern
+avx512f_test (void)
+{
+  _mm512_i32scatter_pd ((void *) 0, idx, src, 8);
+}
Index: gcc/testsuite/gcc.target/i386/pr32219-6.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr32219-6.c b/gcc/testsuite/gcc.target/i386/pr32219-6.c
--- a/gcc/testsuite/gcc.target/i386/pr32219-6.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr32219-6.c	(revision 278653)
@@ -11,7 +11,14 @@
   return xxx;
 }
 
-/* { dg-final { scan-assembler-not "movl\[ \t\]xxx\\(%rip\\), %" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "xxx@GOTPCREL" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %" { target ia32 } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %" { target ia32 } } } */
+/* { dg-final { scan-assembler-not "movl\[ \t\]xxx\\(%rip\\), %" { target { { ! ia32 } && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler "xxx@GOTPCREL" { target { { ! ia32 } && { ! *-*-darwin* } } } } } */
+
+/* Darwin m64 is always PIC, and the dynamic linker doesn't need an indirection.  */
+/* { dg-final { scan-assembler {movl[ \t]_xxx\(%rip\),[ \t]%eax} { target { { ! ia32 } && *-*-darwin* } } } } */
+
+/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %" { target { ia32 && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %" { target { ia32 && { ! *-*-darwin* } } } } } */
+
+/* Darwin m32 defaults to PIC, so no change.  */
+/* { dg-final { scan-assembler {movl[ \t]_xxx-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
Index: gcc/testsuite/gcc.target/i386/pr89523-1b.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-1b.c b/gcc/testsuite/gcc.target/i386/pr89523-1b.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr89523-1b.c	(revision 278653)
@@ -0,0 +1,7 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-maddress-mode=long -mx32 -Ofast -funroll-loops -march=haswell" } */
+/* { dg-final { scan-assembler-not "\tvgather" } } */
+/* { dg-final { scan-assembler "addr32 vgather" } } */
+
+#include "pr89523-1a.c"
Index: gcc/testsuite/gcc.target/i386/pr89684.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr89684.c b/gcc/testsuite/gcc.target/i386/pr89684.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr89684.c	(revision 278653)
@@ -0,0 +1,23 @@
+/* PR ipa/89684 */
+/* { dg-do compile } */
+/* { dg-require-ifunc "" } */
+
+void bar (int, void (*) (void));
+
+__attribute__((target_clones ("default", "avx")))
+void foo (void)
+{
+  bar (0, foo);
+  bar (0, foo);
+}
+
+__attribute__((target_clones ("default", "avx", "avx2")))
+void baz (void)
+{
+  bar (0, foo);
+  bar (0, foo);
+  bar (0, foo);
+  bar (0, foo);
+  bar (0, foo);
+  bar (0, foo);
+}
Index: gcc/testsuite/gcc.target/i386/pr22076.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr22076.c b/gcc/testsuite/gcc.target/i386/pr22076.c
--- a/gcc/testsuite/gcc.target/i386/pr22076.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr22076.c	(revision 278653)
@@ -1,6 +1,8 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -fomit-frame-pointer -flax-vector-conversions -mmmx" } */
 /* { dg-additional-options "-mno-vect8-ret-in-mem" { target *-*-vxworks* } } */
+/* { dg-additional-options "-fno-common" { target *-*-darwin* } } */
+/* { dg-additional-options "-mdynamic-no-pic" { target { ia32 && *-*-darwin* } } } */
 
 #include <mmintrin.h>
 
Index: gcc/testsuite/gcc.target/i386/ret-thunk-22.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-22.c b/gcc/testsuite/gcc.target/i386/ret-thunk-22.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-22.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-22.c	(revision 278653)
@@ -6,10 +6,12 @@
 struct s gs = { 100 + 200i };
 struct s __attribute__((noinline)) foo (void) { return gs; }
 
-/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
-/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk_ecx" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk_ecx" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {call[ \t]*___x86.get_pc_thunk.cx} { target { *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {jmp[ \t]*___x86_return_thunk} { target { *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile { target { ! x32 } } } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fcheck-pointer-bounds -mmpx -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fcheck-pointer-bounds -mmpx" } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void (*dispatch) (char *);
 char buf[10];
@@ -12,8 +13,8 @@
 }
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "bnd call\[ \t\]*__x86_indirect_thunk_bnd_(r|e)ax" } } */
-/* { dg-final { scan-assembler "bnd call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*_?__x86_indirect_thunk_bnd_(r|e)ax" } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*\.?LIND" } } */
 /* { dg-final { scan-assembler "bnd ret" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-6.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-6.c b/gcc/testsuite/gcc.target/i386/ret-thunk-6.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-6.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-6.c	(revision 278653)
@@ -7,8 +7,8 @@
 {
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
Index: gcc/testsuite/gcc.target/i386/pr24414.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr24414.c b/gcc/testsuite/gcc.target/i386/pr24414.c
--- a/gcc/testsuite/gcc.target/i386/pr24414.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr24414.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-options "-O2" } */
+/* { dg-skip-if "asm insert mismatches ABI for Darwin" { *-*-darwin* } } */
 int test;
 
 int
Index: gcc/testsuite/gcc.target/i386/ret-thunk-15.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-15.c b/gcc/testsuite/gcc.target/i386/ret-thunk-15.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-15.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-15.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -11,11 +12,13 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?bar" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_bar} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_bar\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/cet-sjlj-6b.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/cet-sjlj-6b.c b/gcc/testsuite/gcc.target/i386/cet-sjlj-6b.c
--- a/gcc/testsuite/gcc.target/i386/cet-sjlj-6b.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/cet-sjlj-6b.c	(revision 278653)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O -maddress-mode=long -fcf-protection -mx32" } */
 /* { dg-final { scan-assembler-times "endbr64" 2 } } */
 /* { dg-final { scan-assembler-times "movq\t.*buf\\+16" 1 } } */
Index: gcc/testsuite/gcc.target/i386/fuse-caller-save.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/fuse-caller-save.c b/gcc/testsuite/gcc.target/i386/fuse-caller-save.c
--- a/gcc/testsuite/gcc.target/i386/fuse-caller-save.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/fuse-caller-save.c	(revision 278653)
@@ -16,11 +16,9 @@
   return y + bar (y);
 }
 
-/* For !nonpic && ia32 xfails, see PR64895.  */
-
 /* Check that no registers are saved/restored. */
-/* { dg-final { scan-assembler-not "push" { xfail { { ! nonpic } && ia32 } } } } */
-/* { dg-final { scan-assembler-not "pop" { xfail { { ! nonpic } && ia32 } } } } */
+/* { dg-final { scan-assembler-not "push" } } */
+/* { dg-final { scan-assembler-not "pop" } } */
 
 /* PR61605.  If the first argument register and the return register differ, then
    bar leaves the first argument register intact.  That means in foo that the
@@ -31,4 +29,4 @@
 /* { dg-final { scan-assembler-not "movl" { target { ! ia32 } } } } */
 
 /* Check that addition uses di (in case of no copy) or dx (in case of copy). */
-/* { dg-final { scan-assembler-times "addl\t%\[re\]?d\[ix\], %\[re\]?ax" 1 { xfail { { ! nonpic } && ia32 } } } } */
+/* { dg-final { scan-assembler-times "addl\t%\[re\]?d\[ix\], %\[re\]?ax" 1 } } */
Index: gcc/testsuite/gcc.target/i386/pr90899.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr90899.c b/gcc/testsuite/gcc.target/i386/pr90899.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr90899.c	(revision 278653)
@@ -0,0 +1,6 @@
+/* PR middle-end/90899 */
+/* { dg-do compile } */
+/* { dg-require-ifunc "" } */
+
+__attribute__ ((target_clones ("default", "arch=slm"))) static int f () { return 0; }
+__attribute__ ((alias ("f"))) __typeof (f) g;
Index: gcc/testsuite/gcc.target/i386/pr89523-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-2.c b/gcc/testsuite/gcc.target/i386/pr89523-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr89523-2.c	(revision 278653)
@@ -0,0 +1,37 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -march=haswell" } */
+/* { dg-final { scan-assembler "\tvgather" } } */
+/* { dg-final { scan-assembler-not "addr32 vgather" } } */
+
+typedef double __v2df __attribute__ ((__vector_size__ (16)));
+typedef int __v4si __attribute__ ((__vector_size__ (16)));
+typedef long long __v2di __attribute__ ((__vector_size__ (16)));
+
+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));
+
+extern __inline __m128d
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm_i32gather_pd (double const *__base, __m128i __index, const int __scale)
+{
+  __v2df __zero = { 0.0, 0.0 };
+  __v2df __mask = __builtin_ia32_cmpeqpd (__zero, __zero);
+  __v2df x = x;
+
+  return (__m128d) __builtin_ia32_gathersiv2df (x,
+						__base,
+						(__v4si)__index,
+						__mask,
+						__scale);
+}
+
+__m128d x;
+double *base;
+__m128i idx;
+
+void extern
+avx2_test (void)
+{
+  x = _mm_i32gather_pd (base, idx, 1);
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,10 +12,12 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void func0 (void);
 void func1 (void);
@@ -37,7 +38,9 @@
 }
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk(_nt|)_(r|e)ax" } } */
+/* { dg-final { scan-assembler {leaq[ \t]*L[0-9]+\(%rip\)} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {addl[ \t]*L[0-9]+-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk(_nt|)_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr89903.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr89903.c b/gcc/testsuite/gcc.target/i386/pr89903.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr89903.c	(revision 278653)
@@ -0,0 +1,14 @@
+/* PR target/89903 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -march=skylake" } */
+
+int a, b;
+
+void
+foo (void)
+{
+  unsigned long long d = 983040;
+  d += a;
+  d >>= (short) d;
+  b = d;
+}
Index: gcc/testsuite/gcc.target/i386/pr82662.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr82662.c b/gcc/testsuite/gcc.target/i386/pr82662.c
--- a/gcc/testsuite/gcc.target/i386/pr82662.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr82662.c	(revision 278653)
@@ -23,4 +23,4 @@
 int f10 (S x, S y) { return x < y; }
 int f11 (S x, S y) { return x <= y; }
 
-/* { dg-final { scan-assembler-times {\mset} 12 } } */
+/* { dg-final { scan-assembler-times {\tset} 12 } } */
Index: gcc/testsuite/gcc.target/i386/fpprec-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/fpprec-1.c b/gcc/testsuite/gcc.target/i386/fpprec-1.c
--- a/gcc/testsuite/gcc.target/i386/fpprec-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/fpprec-1.c	(revision 278653)
@@ -11,6 +11,9 @@
 	0x1.0000000000001p-1, 0x1.fffffffffffffp-2,
 	0x1.0000000000001p+0, 0x1.fffffffffffffp-1,
 	0x1.8000000000001p+0, 0x1.7ffffffffffffp+0,
+	-0x1.0000000000001p-1, -0x1.fffffffffffffp-2,
+	-0x1.0000000000001p+0, -0x1.fffffffffffffp-1,
+	-0x1.8000000000001p+0, -0x1.7ffffffffffffp+0,
 	-0.0, 0.0, -0.5, 0.5, -1.0, 1.0, -1.5, 1.5, -2.0, 2.0,
 	-2.5, 2.5 };
 #define NUM (sizeof(x)/sizeof(double))
@@ -19,6 +22,7 @@
 	-0x1.fffffffffffffp+1023, 0x1.fffffffffffffp+1023,
 	-0.0, 0.0,
 	1.0, 0.0, 1.0, 1.0, 2.0, 1.0,
+	-1.0, -0.0, -1.0, -1.0, -2.0, -1.0,
 	-0.0, 0.0, -1.0, 1.0, -1.0, 1.0, -2.0, 2.0, -2.0, 2.0,
 	-3.0, 3.0 };
 
@@ -26,6 +30,7 @@
         -0x1.fffffffffffffp+1023, 0x1.fffffffffffffp+1023,
         -0.0, 0.0,
         1.0, 0.0, 1.0, 1.0, 2.0, 1.0,
+        -1.0, -0.0, -1.0, -1.0, -2.0, -1.0,
         -0.0, 0.0, -0.0, 0.0, -1.0, 1.0, -2.0, 2.0, -2.0, 2.0,
         -2.0, 2.0 };
 
@@ -33,6 +38,7 @@
         -0x1.fffffffffffffp+1023, 0x1.fffffffffffffp+1023,
         -1.0, 0.0,
         0.0, 0.0, 1.0, 0.0, 1.0, 1.0,
+        -1.0, -1.0, -2.0, -1.0, -2.0, -2.0,
         -0.0, 0.0, -1.0, 0.0, -1.0, 1.0, -2.0, 1.0, -2.0, 2.0,
         -3.0, 2.0 };
 
@@ -40,6 +46,7 @@
         -0x1.fffffffffffffp+1023, 0x1.fffffffffffffp+1023,
         -0.0, 1.0,
         1.0, 1.0, 2.0, 1.0, 2.0, 2.0,
+        -0.0, -0.0, -1.0, -0.0, -1.0, -1.0,
         -0.0, 0.0, -0.0, 1.0, -1.0, 1.0, -1.0, 2.0, -2.0, 2.0,
         -2.0, 3.0 };
 
@@ -47,6 +54,7 @@
         -0x1.fffffffffffffp+1023, 0x1.fffffffffffffp+1023,
         -0.0, 0.0,
         0.0, 0.0, 1.0, 0.0, 1.0, 1.0,
+        -0.0, -0.0, -1.0, -0.0, -1.0, -1.0,
         -0.0, 0.0, -0.0, 0.0, -1.0, 1.0, -1.0, 1.0, -2.0, 2.0,
         -2.0, 2.0 };
 
Index: gcc/testsuite/gcc.target/i386/avx512bw-pr91150.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/avx512bw-pr91150.c b/gcc/testsuite/gcc.target/i386/avx512bw-pr91150.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/avx512bw-pr91150.c	(revision 278653)
@@ -0,0 +1,37 @@
+/* PR target/91150 */
+/* { dg-do run } */
+/* { dg-options "-O2 -mavx512bw" } */
+/* { dg-require-effective-target avx512bw } */
+
+#include "avx512bw-check.h"
+
+typedef unsigned char V __attribute__((vector_size (64)));
+
+__attribute__((noipa)) void
+foo (V *x, V *y, V *z)
+{
+  *x = __builtin_shuffle (*y, *z, (V) { 0, 1, 2, 3, 4, 5, 6, 7, 8,
+					9, 10, 11, 12, 13, 14, 15,
+					80, 81, 82, 83, 84, 85, 86, 87,
+					88, 89, 90, 91, 92, 93, 94, 95,
+					96, 97, 98, 99, 100, 101, 102, 103,
+					104, 105, 106, 107, 108, 109, 110, 111,
+				        112, 113, 114, 115, 116, 117, 118, 119,
+					120, 121, 122, 123, 124, 125, 126, 127 });
+}
+
+static void
+avx512bw_test (void)
+{
+  union U { unsigned char a[64]; V v; } a, b, c;
+  int i;
+  for (i = 0; i < 64; i++)
+    {
+      b.a[i] = i + 1;
+      c.a[i] = i + 65;
+    }
+  foo (&a.v, &b.v, &c.v);
+  for (i = 0; i < 64; i++)
+    if (a.a[i] != (i < 16 ? i + 1 : i + 65))
+      __builtin_abort ();
+}
Index: gcc/testsuite/gcc.target/i386/cet-notrack-icf-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/cet-notrack-icf-1.c b/gcc/testsuite/gcc.target/i386/cet-notrack-icf-1.c
--- a/gcc/testsuite/gcc.target/i386/cet-notrack-icf-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/cet-notrack-icf-1.c	(revision 278653)
@@ -3,8 +3,8 @@
 /* { dg-options "-O2 -fcf-protection=none" } */
 /* { dg-final { scan-assembler-not "endbr" } } */
 /* { dg-final { scan-assembler-not "fn3:" } } */
-/* { dg-final { scan-assembler "set\[ \t]+fn2,fn1" } } */
-/* { dg-final { scan-assembler "set\[ \t]+fn3,fn1" } } */
+/* { dg-final { scan-assembler "set\[ \t]+fn2,fn1" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "set\[ \t]+fn3,fn1" { target { ! *-*-darwin* } } } } */
 
 static __attribute__((noinline)) int
 fn1 (int x)
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,8 +13,10 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/memset-strategy-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/memset-strategy-1.c b/gcc/testsuite/gcc.target/i386/memset-strategy-1.c
--- a/gcc/testsuite/gcc.target/i386/memset-strategy-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/memset-strategy-1.c	(revision 278653)
@@ -1,6 +1,9 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -march=atom -mmemset-strategy=libcall:-1:align" } */
-/* { dg-final { scan-assembler-times "memset" 2  } } */
+/* On ELF platforms, one hit comes from the .file directive.  */
+/* { dg-final { scan-assembler-times "memset" 2 { target { ! *-*-darwin* } } } } */
+/* But not on Darwin, which doesn't have a .file directive by default.  */
+/* { dg-final { scan-assembler-times "_memset" 1 { target *-*-darwin* } } } */
 
 char a[2048];
 void t (void)
@@ -7,4 +10,3 @@
 {
   __builtin_memset (a, 1, 2048);
 }
-
Index: gcc/testsuite/gcc.target/i386/pr61599-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr61599-1.c b/gcc/testsuite/gcc.target/i386/pr61599-1.c
--- a/gcc/testsuite/gcc.target/i386/pr61599-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr61599-1.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* PR target/61599 */
 /* { dg-do run { target lp64 } } */
+/* { dg-skip-if "PR90698" { *-*-darwin* } } */
 /* { dg-additional-sources pr61599-2.c } */
 /* { dg-options "-mcmodel=medium -fdata-sections" } */
 
Index: gcc/testsuite/gcc.target/i386/pr32219-7.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr32219-7.c b/gcc/testsuite/gcc.target/i386/pr32219-7.c
--- a/gcc/testsuite/gcc.target/i386/pr32219-7.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr32219-7.c	(revision 278653)
@@ -12,7 +12,15 @@
   return xxx;
 }
 
-/* { dg-final { scan-assembler "movl\[ \t\]xxx\\(%rip\\), %eax" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-not "xxx@GOTPCREL" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %eax" { target ia32 } } } */
-/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %eax" { target ia32 } } } */
+/* { dg-final { scan-assembler "movl\[ \t\]xxx\\(%rip\\), %eax" { target { { ! ia32 } && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler-not "xxx@GOTPCREL" { target { { ! ia32 } && { ! *-*-darwin* } } } } } */
+
+/* For Darwin m64, code is always PIC but we need to indirect through the GOT to allow
+   weak symbols to be interposed.  The dynamic loader knows how to apply PIE to this.  */
+/* { dg-final { scan-assembler {movq[ \t]_xxx@GOTPCREL\(%rip\),[ \t]%rax} { target { { ! ia32 } && *-*-darwin* } } } } */
+
+/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %eax" { target { ia32 && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %eax" { target { ia32 && { ! *-*-darwin* } } } } } */
+
+/* Darwin m32 equivalent (indirect and PIC).  */
+/* { dg-final { scan-assembler {movl[ \t][Ll]_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-7.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk -fjump-tables" } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void func0 (void);
 void func1 (void);
@@ -36,8 +37,10 @@
 }
 
 /* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {leaq[ \t]*L[0-9]+\(%rip\)} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {addl[ \t]*L[0-9]+-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-23.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-23.c b/gcc/testsuite/gcc.target/i386/ret-thunk-23.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-23.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-23.c	(revision 278653)
@@ -6,10 +6,12 @@
 struct s gs = { 100 + 200i };
 struct s __attribute__((noinline)) foo (void) { return gs; }
 
-/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
-/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk_ecx" } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk_ecx" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {call[ \t]*___x86.get_pc_thunk.cx} { target { *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {jmp[ \t]*___x86_return_thunk} { target { *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler-not {\tpause} } } */
 /* { dg-final { scan-assembler-not {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/pr85860.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr85860.c b/gcc/testsuite/gcc.target/i386/pr85860.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr85860.c	(revision 278653)
@@ -0,0 +1,23 @@
+/* { dg-do compile { target lp64 } } */
+/* { dg-options "-O2 -fno-guess-branch-probability -flive-range-shrinkage -mbmi2" } */
+
+int a, b, c, d, e;
+
+extern int bar(void);
+
+__int128
+foo (unsigned g, int h, long i, __int128 j, short k, __int128 l)
+{
+  unsigned __int128 m = j;
+  do
+    {
+      j %= 5;
+      c = c >> (m & 31);
+      e = __builtin_sub_overflow (b, 0, &m);
+      d = bar ();
+      l *= __builtin_mul_overflow_p ((unsigned) d, ~(unsigned __int128) 1,
+				     (unsigned __int128) 0);
+    }
+  while (a);
+  return m + j + k + l;
+}
Index: gcc/testsuite/gcc.target/i386/ret-thunk-7.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-7.c b/gcc/testsuite/gcc.target/i386/ret-thunk-7.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-7.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-7.c	(revision 278653)
@@ -7,7 +7,7 @@
 {
 }
 
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-16.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-16.c b/gcc/testsuite/gcc.target/i386/ret-thunk-16.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-16.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-16.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mfunction-return=thunk-inline -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mfunction-return=thunk-inline -mindirect-branch=thunk-extern " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 extern void (*bar) (void);
 
@@ -11,8 +12,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler-not "__x86_return_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr55116-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr55116-1.c b/gcc/testsuite/gcc.target/i386/pr55116-1.c
--- a/gcc/testsuite/gcc.target/i386/pr55116-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr55116-1.c	(revision 278653)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long" } */
 
 int glob_int_arr[100];
Index: gcc/testsuite/gcc.target/i386/memcpy-strategy-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/memcpy-strategy-3.c b/gcc/testsuite/gcc.target/i386/memcpy-strategy-3.c
--- a/gcc/testsuite/gcc.target/i386/memcpy-strategy-3.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/memcpy-strategy-3.c	(revision 278653)
@@ -1,6 +1,9 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -march=atom -mmemcpy-strategy=vector_loop:2000:align,libcall:-1:align" } */
-/* { dg-final { scan-assembler-times "memcpy" 2  } } */
+/* On ELF platforms, one hit comes from the .file directive.  */
+/* { dg-final { scan-assembler-times "memcpy" 2 { target { ! *-*-darwin* } } } } */
+/* But not on Darwin, which doesn't have a .file directive by default.  */
+/* { dg-final { scan-assembler-times "_memcpy" 1  { target *-*-darwin* } } } */
 
 char a[2048];
 char b[2048];
Index: gcc/testsuite/gcc.target/i386/pr89523-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr89523-3.c b/gcc/testsuite/gcc.target/i386/pr89523-3.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr89523-3.c	(revision 278653)
@@ -0,0 +1,36 @@
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
+/* { dg-options "-mx32 -O2 -march=haswell" } */
+/* { dg-final { scan-assembler "\tvgather" } } */
+/* { dg-final { scan-assembler-not "addr32 vgather" } } */
+
+typedef double __v2df __attribute__ ((__vector_size__ (16)));
+typedef int __v4si __attribute__ ((__vector_size__ (16)));
+typedef long long __v2di __attribute__ ((__vector_size__ (16)));
+
+typedef long long __m128i __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));
+
+extern __inline __m128d
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm_i64gather_pd (double const *__base, __m128i __index, const int __scale)
+{
+  __v2df __zero = { 0.0, 0.0 };
+  __v2df __mask = __builtin_ia32_cmpeqpd (__zero, __zero);
+
+  return (__m128d) __builtin_ia32_gatherdiv2df (__zero,
+						__base,
+						(__v2di)__index,
+						__mask,
+						__scale);
+}
+
+__m128d x;
+double *base;
+__m128i idx;
+
+void extern
+avx2_test (void)
+{
+  x = _mm_i64gather_pd (base, idx, 1);
+}
Index: gcc/testsuite/gcc.target/i386/pr66819-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr66819-3.c b/gcc/testsuite/gcc.target/i386/pr66819-3.c
--- a/gcc/testsuite/gcc.target/i386/pr66819-3.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr66819-3.c	(revision 278653)
@@ -1,6 +1,6 @@
 /* { dg-do compile { target ia32 } } */
 /* { dg-options "-O2 -mregparm=3" } */
-/* { dg-final { scan-assembler-not "call" } } */
+/* { dg-final { scan-assembler-not {call[ \t]+_?bar} } } */
 
 void (*bar)(int, int);
 
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-inline " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -11,10 +12,12 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
 /* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-8.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-8.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-8.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-8.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-8.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mfunction-return=keep -mindirect-branch=thunk -fno-pic" } */
+/* { dg-options "-O2 -mfunction-return=keep -mindirect-branch=thunk " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 void func0 (void);
 void func1 (void);
@@ -36,7 +37,7 @@
     }
 }
 
-/* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler-not "_?__x86_indirect_thunk" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/cet-notrack-6b.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/cet-notrack-6b.c b/gcc/testsuite/gcc.target/i386/cet-notrack-6b.c
--- a/gcc/testsuite/gcc.target/i386/cet-notrack-6b.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/cet-notrack-6b.c	(revision 278653)
@@ -2,7 +2,8 @@
 /* { dg-options "-O0 -fcf-protection" } */
 /* { dg-final { scan-assembler-times "endbr32" 1 { target ia32 } } } */
 /* { dg-final { scan-assembler-times "endbr64" 1 { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-not "\tcall\[ \t]+" } } */
+/* { dg-final { scan-assembler-not "\tcall\[ \t]+" { target { { ! ia32 } || { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler-times "\tcall\[ \t]+" 1 { target { ia32 && *-*-darwin* } } } } */
 /* { dg-final { scan-assembler-times "notrack call\[ \t]+" 1 } } */
 
 int foo (int arg);
Index: gcc/testsuite/gcc.target/i386/pr70738-7.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr70738-7.c b/gcc/testsuite/gcc.target/i386/pr70738-7.c
--- a/gcc/testsuite/gcc.target/i386/pr70738-7.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr70738-7.c	(revision 278653)
@@ -1,4 +1,4 @@
-/* { dg-do compile { target ia32 } } */
+/* { dg-do compile { target { ia32 && { ! *-*-darwin* } } } } */
 /* { dg-options "-msse2 -mgeneral-regs-only" } */
 
 extern float a, b, c;
Index: gcc/testsuite/gcc.target/i386/cet-notrack-icf-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/cet-notrack-icf-2.c b/gcc/testsuite/gcc.target/i386/cet-notrack-icf-2.c
--- a/gcc/testsuite/gcc.target/i386/cet-notrack-icf-2.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/cet-notrack-icf-2.c	(revision 278653)
@@ -3,7 +3,7 @@
 /* { dg-options "-O2 -fcf-protection" } */
 /* { dg-final { scan-assembler "endbr" } } */
 /* { dg-final { scan-assembler "fn3:" } } */
-/* { dg-final { scan-assembler "set\[ \t]+fn2,fn1" } } */
+/* { dg-final { scan-assembler "set\[ \t]+fn2,fn1" { target { ! *-*-darwin* } } } } */
 
 static __attribute__((noinline)) int
 fn1 (int x)
Index: gcc/testsuite/gcc.target/i386/cet-sjlj-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/cet-sjlj-3.c b/gcc/testsuite/gcc.target/i386/cet-sjlj-3.c
--- a/gcc/testsuite/gcc.target/i386/cet-sjlj-3.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/cet-sjlj-3.c	(revision 278653)
@@ -3,7 +3,7 @@
 /* { dg-final { scan-assembler-times "endbr32" 4 { target ia32 } } } */
 /* { dg-final { scan-assembler-times "endbr64" 4 { target { ! ia32 } } } } */
 /* { dg-final { scan-assembler-times "call	_?setjmp" 1 } } */
-/* { dg-final { scan-assembler-times "call	longjmp" 1 } } */
+/* { dg-final { scan-assembler-times "call	_?longjmp" 1 } } */
 
 #include <stdio.h>
 #include <setjmp.h>
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -mindirect-branch=thunk-extern " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -12,7 +13,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
Index: gcc/testsuite/gcc.target/i386/pr55597.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr55597.c b/gcc/testsuite/gcc.target/i386/pr55597.c
--- a/gcc/testsuite/gcc.target/i386/pr55597.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr55597.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile { target { ! ia32 } } } */
 /* { dg-require-effective-target fpic } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -fPIC -mx32 -maddress-mode=long" } */
 
 struct initial_sp
Index: gcc/testsuite/gcc.target/i386/pr64317.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr64317.c b/gcc/testsuite/gcc.target/i386/pr64317.c
--- a/gcc/testsuite/gcc.target/i386/pr64317.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr64317.c	(revision 278653)
@@ -2,9 +2,14 @@
 /* { dg-require-effective-target ia32 } */
 /* { dg-require-effective-target pie } */
 /* { dg-options "-O2 -fpie" } */
-/* { dg-final { scan-assembler "addl\[ \\t\]+\[$\]_GLOBAL_OFFSET_TABLE_, %ebx" } } */
-/* { dg-final { scan-assembler "movl\[ \\t\]+c@GOTOFF\[(\]%ebx\[)\]" } } */
-/* { dg-final { scan-assembler-not "movl\[ \\t\]+\[0-9]+\[(\]%esp\[)\], %ebx" } } */
+/* { dg-final { scan-assembler "addl\[ \\t\]+\[$\]_GLOBAL_OFFSET_TABLE_, %ebx" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "movl\[ \\t\]+c@GOTOFF\[(\]%ebx\[)\]" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-not "movl\[ \\t\]+\[0-9]+\[(\]%esp\[)\], %ebx" { target { ! *-*-darwin* } } } } */
+
+/* Check PIC access to c and t1 on Darwin (PIC is default, needed for PIE).  */
+/* { dg-final { scan-assembler {_c-L1\$pb\(%} { target *-*-darwin* } } } */
+/* { dg-final { scan-assembler {_t1.[0-9]+-L1\$pb\(%} { target *-*-darwin* } } } */
+
 long c = 1;
 
 int bar();
Index: gcc/testsuite/gcc.target/i386/pr32219-8.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr32219-8.c b/gcc/testsuite/gcc.target/i386/pr32219-8.c
--- a/gcc/testsuite/gcc.target/i386/pr32219-8.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr32219-8.c	(revision 278653)
@@ -13,6 +13,12 @@
 }
 
 /* { dg-final { scan-assembler-not "movl\[ \t\]xxx\\(%rip\\), %" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler "xxx@GOTPCREL" { target { ! ia32 } } } } */
-/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %" { target ia32 } } } */
-/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %" { target ia32 } } } */
+/* Darwin is always PIC so no change, weak symbols needs to be indirect and this
+   happens to match the ELF case.  */
+/* { dg-final { scan-assembler "_?xxx@GOTPCREL" { target { ! ia32 } } } } */
+
+/* { dg-final { scan-assembler-not "movl\[ \t\]xxx@GOTOFF\\(%\[^,\]*\\), %" { target { ia32 && { ! *-*-darwin* } } } } } */
+/* { dg-final { scan-assembler "movl\[ \t\]xxx@GOT\\(%\[^,\]*\\), %" { target { ia32 && { ! *-*-darwin* } } } } } */
+
+/* Darwin m32 default to PIC but needs indirection for the weak symbol.  */
+/* { dg-final { scan-assembler {movl[ \t][Ll]_xxx\$non_lazy_ptr-L1\$pb\(%eax\),[ \t]%eax} { target { ia32 && *-*-darwin* } } } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
-/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep -fno-pic" } */
+/* { dg-options "-O2 -mno-indirect-branch-register -mfunction-return=keep " } */
+/* { dg-additional-options "-fno-pic" { target { ! *-*-darwin* } } } */
 
 typedef void (*dispatch_t)(long offset);
 
@@ -14,9 +15,11 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler {movq[ \t]*_dispatch} { target { lp64 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {movl[ \t]*[Ll]_dispatch\$non_lazy_ptr-L[0-9]+\$pb} { target { ia32 && *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*_?__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-24.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-24.c b/gcc/testsuite/gcc.target/i386/ret-thunk-24.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-24.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-24.c	(revision 278653)
@@ -6,10 +6,12 @@
 struct s gs = { 100 + 200i };
 struct s __attribute__((noinline)) foo (void) { return gs; }
 
-/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
-/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk_ecx" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk_ecx" { target { ! *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {call[ \t]*___x86.get_pc_thunk.cx} { target { *-*-darwin* } } } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*___x86_return_thunk} { target { *-*-darwin* } } } } */
+/* { dg-final { scan-assembler {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler {call[ \t]*\.?LIND} } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-8.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-8.c b/gcc/testsuite/gcc.target/i386/ret-thunk-8.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-8.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-8.c	(revision 278653)
@@ -8,7 +8,7 @@
 {
 }
 
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*_?__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
-/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {jmp[ \t]*\.?LIND} } } */
+/* { dg-final { scan-assembler-not {call[ \t]*\.?LIND} } } */
Index: gcc/testsuite/gcc.target/i386/pr91623.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr91623.c b/gcc/testsuite/gcc.target/i386/pr91623.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr91623.c	(revision 278653)
@@ -0,0 +1,32 @@
+/* PR middle-end/91623 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -msse4.1 -mno-sse4.2" } */
+
+typedef long long V __attribute__((__vector_size__(16)));
+V e, h;
+int d;
+const int i;
+
+void foo (void);
+
+void
+bar (int k, int l)
+{
+  if (d && 0 <= k - 1 && l)
+    foo ();
+}
+
+void
+baz (void)
+{
+  V n = (V) { 1 };
+  V g = (V) {};
+  V o = g;
+  for (int f = 0; f < i; ++f)
+    {
+      V a = o == n;
+      h = a;
+      bar (f, i);
+      o = e;
+    }
+}
Index: gcc/testsuite/gcc.target/i386/pr55116-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr55116-2.c b/gcc/testsuite/gcc.target/i386/pr55116-2.c
--- a/gcc/testsuite/gcc.target/i386/pr55116-2.c	(revision 278653)
+++ b/gcc/testsuite/gcc.target/i386/pr55116-2.c	(revision 278653)
@@ -1,4 +1,5 @@
 /* { dg-do compile { target { ! ia32 } } } */
+/* { dg-require-effective-target maybe_x32 } */
 /* { dg-options "-O2 -mx32 -maddress-mode=long" } */
 
 typedef struct rtx_def *rtx;
Index: gcc/testsuite/gcc.target/x86_64/abi/avx512f/abi-avx512f.exp
===================================================================
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/avx512f/abi-avx512f.exp b/gcc/testsuite/gcc.target/x86_64/abi/avx512f/abi-avx512f.exp
--- a/gcc/testsuite/gcc.target/x86_64/abi/avx512f/abi-avx512f.exp	(revision 278653)
+++ b/gcc/testsuite/gcc.target/x86_64/abi/avx512f/abi-avx512f.exp	(revision 278653)
@@ -37,7 +37,6 @@
 foreach src [lsort [glob -nocomplain $srcdir/$subdir/test_*.c]] {
     if {[runtest_file_p $runtests $src]} {
 	if { ([istarget *-*-darwin*]) } then {
-	    # FIXME: Darwin isn't tested.
 	    c-torture-execute [list $src \
 				    $srcdir/$subdir/asm-support-darwin.s] \
 				    $additional_flags
Index: gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support-darwin.s
===================================================================
diff --git a/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support-darwin.s b/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support-darwin.s
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/x86_64/abi/avx512f/asm-support-darwin.s	(revision 278653)
@@ -0,0 +1,93 @@
+	.text
+	.p2align 4,,15
+	.globl _snapshot
+_snapshot:
+LFB3:
+	movq	%rax, _rax(%rip)
+	movq	%rbx, _rbx(%rip)
+	movq	%rcx, _rcx(%rip)
+	movq	%rdx, _rdx(%rip)
+	movq	%rdi, _rdi(%rip)
+	movq	%rsi, _rsi(%rip)
+	movq	%rbp, _rbp(%rip)
+	movq	%rsp, _rsp(%rip)
+	movq	%r8, _r8(%rip)
+	movq	%r9, _r9(%rip)
+	movq	%r10, _r10(%rip)
+	movq	%r11, _r11(%rip)
+	movq	%r12, _r12(%rip)
+	movq	%r13, _r13(%rip)
+	movq	%r14, _r14(%rip)
+	movq	%r15, _r15(%rip)
+	vmovdqu32 %zmm0, _zmm_regs+0(%rip)
+	vmovdqu32 %zmm1, _zmm_regs+64(%rip)
+	vmovdqu32 %zmm2, _zmm_regs+128(%rip)
+	vmovdqu32 %zmm3, _zmm_regs+192(%rip)
+	vmovdqu32 %zmm4, _zmm_regs+256(%rip)
+	vmovdqu32 %zmm5, _zmm_regs+320(%rip)
+	vmovdqu32 %zmm6, _zmm_regs+384(%rip)
+	vmovdqu32 %zmm7, _zmm_regs+448(%rip)
+	vmovdqu32 %zmm8, _zmm_regs+512(%rip)
+	vmovdqu32 %zmm9, _zmm_regs+576(%rip)
+	vmovdqu32 %zmm10, _zmm_regs+640(%rip)
+	vmovdqu32 %zmm11, _zmm_regs+704(%rip)
+	vmovdqu32 %zmm12, _zmm_regs+768(%rip)
+	vmovdqu32 %zmm13, _zmm_regs+832(%rip)
+	vmovdqu32 %zmm14, _zmm_regs+896(%rip)
+	vmovdqu32 %zmm15, _zmm_regs+960(%rip)
+	vmovdqu32 %zmm16, _zmm_regs+1024(%rip)
+	vmovdqu32 %zmm17, _zmm_regs+1088(%rip)
+	vmovdqu32 %zmm18, _zmm_regs+1152(%rip)
+	vmovdqu32 %zmm19, _zmm_regs+1216(%rip)
+	vmovdqu32 %zmm20, _zmm_regs+1280(%rip)
+	vmovdqu32 %zmm21, _zmm_regs+1344(%rip)
+	vmovdqu32 %zmm22, _zmm_regs+1408(%rip)
+	vmovdqu32 %zmm23, _zmm_regs+1472(%rip)
+	vmovdqu32 %zmm24, _zmm_regs+1536(%rip)
+	vmovdqu32 %zmm25, _zmm_regs+1600(%rip)
+	vmovdqu32 %zmm26, _zmm_regs+1664(%rip)
+	vmovdqu32 %zmm27, _zmm_regs+1728(%rip)
+	vmovdqu32 %zmm28, _zmm_regs+1792(%rip)
+	vmovdqu32 %zmm29, _zmm_regs+1856(%rip)
+	vmovdqu32 %zmm30, _zmm_regs+1920(%rip)
+	vmovdqu32 %zmm31, _zmm_regs+1984(%rip)
+	jmp	*_callthis(%rip)
+LFE3:
+
+	.p2align 4,,15
+	.globl _snapshot_ret
+_snapshot_ret:
+	movq	%rdi, _rdi(%rip)
+	subq	$8, %rsp
+	call	*_callthis(%rip)
+	addq	$8, %rsp
+	movq	%rax, _rax(%rip)
+	movq	%rdx, _rdx(%rip)
+	vmovdqu32	%zmm0, _zmm_regs+0(%rip)
+	vmovdqu32	%zmm1, _zmm_regs+64(%rip)
+	fstpt	_x87_regs(%rip)
+	fstpt	_x87_regs+16(%rip)
+	fldt	_x87_regs+16(%rip)
+	fldt	_x87_regs(%rip)
+	ret
+
+	.comm	_callthis,8,8
+	.comm	_rax,8,8
+	.comm	_rbx,8,8
+	.comm	_rcx,8,8
+	.comm	_rdx,8,8
+	.comm	_rsi,8,8
+	.comm	_rdi,8,8
+	.comm	_rsp,8,8
+	.comm	_rbp,8,8
+	.comm	_r8,8,8
+	.comm	_r9,8,8
+	.comm	_r10,8,8
+	.comm	_r11,8,8
+	.comm	_r12,8,8
+	.comm	_r13,8,8
+	.comm	_r14,8,8
+	.comm	_r15,8,8
+	.comm	_zmm_regs,2048,64
+	.comm	_x87_regs,128,32
+	.comm   _volatile_var,8,8
Index: gcc/testsuite/g++.target/arm/arm.exp
===================================================================
diff --git a/gcc/testsuite/g++.target/arm/arm.exp b/gcc/testsuite/g++.target/arm/arm.exp
Index: gcc/testsuite/lib/scanasm.exp
===================================================================
diff --git a/gcc/testsuite/lib/scanasm.exp b/gcc/testsuite/lib/scanasm.exp
--- a/gcc/testsuite/lib/scanasm.exp	(revision 278653)
+++ b/gcc/testsuite/lib/scanasm.exp	(revision 278653)
@@ -504,7 +504,10 @@
 	}
     }
 
-    if { [istarget hppa*-*-*] } {
+    if { [istarget hppa*-*-linux*] } {
+	set pattern [format {%s:\n\t.PROC\n\t.CALLINFO.*\n\t.ENTRY\n.L.*:\n(\t.file[^\t]*)*\t[^:]+:%d(:[0-9]+)?\n} \
+                     $symbol $line]
+    } elseif { [istarget hppa*-*-*] } {
 	set pattern [format {\t;[^:]+:%d(:[0-9]+)?\n(\t[^\t]+\n)+%s:\n\t.PROC} \
                      $line $symbol]
     } elseif { [istarget mips*-*-*] } {
Index: gcc/testsuite/lib/target-supports.exp
===================================================================
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
--- a/gcc/testsuite/lib/target-supports.exp	(revision 278653)
+++ b/gcc/testsuite/lib/target-supports.exp	(revision 278653)
@@ -5018,13 +5018,13 @@
 	     || [istarget powerpc*-*-aix5.2*] } {
 	    return 0
 	}
+	# Darwin doesn't run on power8, so far.
+	if { [istarget *-*-darwin*] } {
+	    return 0
+	}
 	return [check_no_compiler_messages powerpc_p8vector_ok object {
 	    int main (void) {
-#ifdef __MACH__
-		asm volatile ("xxlorc vs0,vs0,vs0");
-#else
 		asm volatile ("xxlorc 0,0,0");
-#endif
 		return 0;
 	    }
 	} "-mpower8-vector"]
@@ -5045,6 +5045,10 @@
 	     || [istarget powerpc*-*-aix5.2*] } {
 	    return 0
 	}
+	# Darwin doesn't run on power9, so far.
+	if { [istarget *-*-darwin*] } {
+	    return 0
+	}
 	return [check_no_compiler_messages powerpc_p9vector_ok object {
 	    int main (void) {
 		long e = -1;
@@ -5095,6 +5099,10 @@
 	     || [istarget powerpc*-*-aix5.2*] } {
 	    return 0
 	}
+	# Darwin doesn't have VSX, so no soft support for float128.
+	if { [istarget *-*-darwin*] } {
+	    return 0
+	}
 	return [check_no_compiler_messages powerpc_float128_sw_ok object {
 		volatile __float128 x = 1.0q;
 		volatile __float128 y = 2.0q;
@@ -5121,6 +5129,10 @@
 	     || [istarget powerpc*-*-aix5.2*] } {
 	    return 0
 	}
+	# Darwin doesn't run on any machine with float128 h/w so far.
+	if { [istarget *-*-darwin*] } {
+	    return 0
+	}
 	return [check_no_compiler_messages powerpc_float128_hw_ok object {
 		volatile __float128 x = 1.0q;
 		volatile __float128 y = 2.0q;
@@ -5147,13 +5159,14 @@
 	     || [istarget powerpc*-*-aix6*] } {
 	    return 0
 	}
+	# Darwin doesn't have VSX, even if it's used with an assembler
+	# which recognises the insns.
+	if { [istarget *-*-darwin*] } {
+	    return 0
+	}
 	return [check_no_compiler_messages powerpc_vsx_ok object {
 	    int main (void) {
-#ifdef __MACH__
-		asm volatile ("xxlor vs0,vs0,vs0");
-#else
 		asm volatile ("xxlor 0,0,0");
-#endif
 		return 0;
 	    }
 	} "-mvsx"]
Index: gcc/testsuite/gfortran.dg/transfer_simplify_12.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/transfer_simplify_12.f90 b/gcc/testsuite/gfortran.dg/transfer_simplify_12.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/transfer_simplify_12.f90	(revision 278653)
@@ -0,0 +1,27 @@
+! { dg-do run }
+! { dg-options "-O -std=legacy" }
+!
+! Test fixes for some findings while resolving PR fortran/89077
+
+program test
+  implicit none
+  integer :: i
+  character(*)  ,parameter :: s =  'abcdef'   ! Length will be 6
+  character(*)  ,parameter :: h = 6Habcdef    ! Length will be 8 (Hollerith!)
+  character(10) ,parameter :: k = 6Habcdef
+  character(10) ,parameter :: t = transfer (s, s)
+  character(10) ,save      :: u = transfer (s, s)
+  character(10) ,parameter :: v = transfer (h, h)
+  character(10) ,save      :: w = transfer (h, h)
+  character(10) ,parameter :: x = transfer ([(s(i:i),i=len(s),1,-1)], s)
+  character(10) ,save      :: y = transfer ([(s(i:i),i=len(s),1,-1)], s)
+  if (len (h) /= 8) stop 1
+  if (h /= s) stop 2
+  if (k /= s) stop 3
+  if (t /= s) stop 4
+  if (u /= s) stop 5
+  if (v /= s) stop 6
+  if (w /= s) stop 7
+  if (x /= "fedcba") stop 8
+  if (y /= x) stop 9
+end program test
Index: gcc/testsuite/gfortran.dg/associate_49.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/associate_49.f90 b/gcc/testsuite/gfortran.dg/associate_49.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/associate_49.f90	(revision 278653)
@@ -0,0 +1,34 @@
+! { dg-do run }
+!
+! Test the fix for PR91588, in which the declaration of 'a' caused
+! an ICE.
+!
+! Contributed by Gerhardt Steinmetz  <gscfq@t-online.de>
+!
+program p
+   character(4), parameter :: parm = '7890'
+   associate (z => '1234')
+      block
+         integer(len(z)) :: a
+         if (kind(a) .ne. 4) stop 1
+      end block
+   end associate
+   associate (z => '123')
+      block
+         integer(len(z)+1) :: a
+         if (kind(a) .ne. 4) stop 2
+      end block
+   end associate
+   associate (z => 1_8)
+      block
+         integer(kind(z)) :: a
+         if (kind(a) .ne. 8) stop 3
+      end block
+   end associate
+   associate (z => parm)
+      block
+         integer(len(z)) :: a
+         if (kind(a) .ne. 4) stop 4
+      end block
+   end associate
+end
Index: gcc/testsuite/gfortran.dg/gomp/pr89651.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/gomp/pr89651.f90 b/gcc/testsuite/gfortran.dg/gomp/pr89651.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/gomp/pr89651.f90	(revision 278653)
@@ -0,0 +1,21 @@
+! PR fortran/89651
+! { dg-do compile }
+! { dg-additional-options "-Wuninitialized" }
+
+program pr89651
+  integer :: n
+  real, allocatable :: t(:)
+  n = 10
+  allocate (t(n), source = 0.0)
+!$omp parallel firstprivate(t)
+  print *, sum (t) ! { dg-bogus "lbound' may be used uninitialized in this function" }
+                   ! { dg-bogus "ubound' may be used uninitialized in this function" "" { target *-*-* } .-1 }
+                   ! { dg-bogus "offset' may be used uninitialized in this function" "" { target *-*-* } .-2 }
+!$omp end parallel
+!$omp parallel private(t)
+  t = 0.0
+  print *, sum (t) ! { dg-bogus "lbound' may be used uninitialized in this function" }
+                   ! { dg-bogus "ubound' may be used uninitialized in this function" "" { target *-*-* } .-1 }
+                   ! { dg-bogus "offset' may be used uninitialized in this function" "" { target *-*-* } .-2 }
+!$omp end parallel
+end program pr89651
Index: gcc/testsuite/gfortran.dg/gomp/pr89621.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/gomp/pr89621.f90 b/gcc/testsuite/gfortran.dg/gomp/pr89621.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/gomp/pr89621.f90	(revision 278653)
@@ -0,0 +1,18 @@
+! PR middle-end/89621
+! { dg-do compile }
+
+subroutine sub(str)
+  character(*), intent(in) :: str
+end subroutine sub
+
+program pr89621
+  implicit none
+  integer i
+  character(len=:), allocatable :: str
+  str = "test"
+  !$omp parallel do
+  do i = 1, 10
+    call sub(str)
+  enddo
+  !$omp end parallel do
+end program pr89621
Index: gcc/testsuite/gfortran.dg/substr_8.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/substr_8.f90 b/gcc/testsuite/gfortran.dg/substr_8.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/substr_8.f90	(revision 278653)
@@ -0,0 +1,15 @@
+! { dg-do run }
+! PR fortran/71203 - used to ICE on zero-length arrays or substrings
+! Derived from original test cases by Gerhard Steinmetz
+
+program p
+  implicit none
+  character(3), parameter :: a(4) = ' '
+  character(*), parameter :: b(4) = 'abc'
+  character(*), parameter :: x(*) = a(2:2)(3:1)
+  character(*), parameter :: y(*) = a(2:1)(3:1)
+  character(*), parameter :: z(*) = b(2:1)(2:3)
+  if (size (x) /= 1 .or. len(x) /= 0) stop 1
+  if (size (y) /= 0 .or. len(y) /= 0) stop 2
+  if (size (z) /= 0 .or. len(z) /= 2) stop 3
+end
Index: gcc/testsuite/gfortran.dg/allocate_with_mold_3.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/allocate_with_mold_3.f90 b/gcc/testsuite/gfortran.dg/allocate_with_mold_3.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/allocate_with_mold_3.f90	(revision 278653)
@@ -0,0 +1,21 @@
+! { dg-do  run }
+! PR fortran/89174 - this used to segfault on execution.
+! Test case by Neil Carlson.
+module mod
+  type :: array_data
+    class(*), allocatable :: mold
+  contains
+    procedure :: push
+  end type
+contains
+  subroutine push(this, value)
+    class(array_data), intent(inout) :: this
+    class(*), intent(in) :: value
+    allocate(this%mold, mold=value) ! <== SEGFAULTS HERE
+  end subroutine
+end module
+
+use mod
+type(array_data) :: foo
+call foo%push(42)
+end
Index: gcc/testsuite/gfortran.dg/char_result_mod_19.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/char_result_mod_19.f90 b/gcc/testsuite/gfortran.dg/char_result_mod_19.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/char_result_mod_19.f90	(revision 278653)
@@ -0,0 +1,18 @@
+! { dg-do  run }
+! { dg-additional-sources char_result_19.f90 }
+!
+! Module for char_result_19.f90
+! Tests fix for PR86248
+!
+module test_module
+  implicit none
+  public :: func_1
+  private
+  character(len=*),dimension(0:2),parameter :: darray = (/"el0 ","el11","el2 "/)
+contains
+  function func_1 (func_1_input) result(f)
+    integer, intent(in) :: func_1_input
+    character(len = len_trim (darray(func_1_input))) :: f
+    f = darray(func_1_input)
+  end function func_1
+end module test_module
Index: gcc/testsuite/gfortran.dg/pointer_array_11.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pointer_array_11.f90 b/gcc/testsuite/gfortran.dg/pointer_array_11.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pointer_array_11.f90	(revision 278653)
@@ -0,0 +1,90 @@
+! { dg-do run }
+!
+! Test the fix for PR91077 - both the original test and that in comment #4 of the PR.
+!
+! Contribute by Ygal Klein  <ygalklein@gmail.com>
+!
+program test
+  implicit none
+  call original
+  call comment_4
+contains
+  subroutine original
+    integer, parameter :: length = 9
+    real(8), dimension(2) :: a, b
+    integer :: i
+    type point
+       real(8) :: x
+    end type point
+
+    type stored
+       type(point), dimension(:), allocatable :: np
+    end type stored
+    type(stored), dimension(:), pointer :: std =>null()
+    allocate(std(1))
+    allocate(std(1)%np(length))
+    std(1)%np(1)%x = 0.3d0
+    std(1)%np(2)%x = 0.3555d0
+    std(1)%np(3)%x = 0.26782d0
+    std(1)%np(4)%x = 0d0
+    std(1)%np(5)%x = 1.555d0
+    std(1)%np(6)%x = 7.3d0
+    std(1)%np(7)%x = 7.8d0
+    std(1)%np(8)%x = 6.3d0
+    std(1)%np(9)%x = 5.5d0
+!    do i = 1, 2
+!       write(*, "('std(1)%np(',i1,')%x = ',1e22.14)") i, std(1)%np(i)%x
+!    end do
+!    do i = 1, 2
+!       write(*, "('std(1)%np(1:',i1,') = ',9e22.14)") i, std(1)%np(1:i)%x
+!    end do
+    a = std(1)%np(1:2)%x
+    b = [std(1)%np(1)%x, std(1)%np(2)%x]
+!    print *,a
+!    print *,b
+    if (allocated (std(1)%np)) deallocate (std(1)%np)
+    if (associated (std)) deallocate (std)
+    if (norm2(a - b) .gt. 1d-3) stop 1
+  end subroutine
+
+  subroutine comment_4
+    integer, parameter :: length = 2
+    real(8), dimension(length) :: a, b
+    integer :: i
+
+    type point
+       real(8) :: x
+    end type point
+
+    type points
+       type(point), dimension(:), pointer :: np=>null()
+    end type points
+
+    type stored
+       integer :: l
+       type(points), pointer :: nfpoint=>null()
+    end type stored
+
+    type(stored), dimension(:), pointer :: std=>null()
+
+
+    allocate(std(1))
+    allocate(std(1)%nfpoint)
+    allocate(std(1)%nfpoint%np(length))
+    std(1)%nfpoint%np(1)%x = 0.3d0
+    std(1)%nfpoint%np(2)%x = 0.3555d0
+
+!    do i = 1, length
+!       write(*, "('std(1)%nfpoint%np(',i1,')%x = ',1e22.14)") i, std(1)%nfpoint%np(i)%x
+!    end do
+!    do i = 1, length
+!       write(*, "('std(1)%nfpoint%np(1:',i1,')%x = ',2e22.14)") i, std(1)%nfpoint%np(1:i)%x
+!    end do
+    a = std(1)%nfpoint%np(1:2)%x
+    b = [std(1)%nfpoint%np(1)%x, std(1)%nfpoint%np(2)%x]
+    if (associated (std(1)%nfpoint%np)) deallocate (std(1)%nfpoint%np)
+    if (associated (std(1)%nfpoint)) deallocate (std(1)%nfpoint)
+    if (associated (std)) deallocate (std)
+    if (norm2(a - b) .gt. 1d-3) stop 2
+    end subroutine
+end program test
Index: gcc/testsuite/gfortran.dg/typebound_call_22.f03
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/typebound_call_22.f03 b/gcc/testsuite/gfortran.dg/typebound_call_22.f03
--- a/gcc/testsuite/gfortran.dg/typebound_call_22.f03	(revision 278653)
+++ b/gcc/testsuite/gfortran.dg/typebound_call_22.f03	(revision 278653)
@@ -26,4 +26,4 @@
   call x%bar ()
 end program
 
-! { dg-final { scan-tree-dump-times "base \\(\\);" 1 "optimized" } }
+! { dg-final { scan-tree-dump-times "base \\(\\);" 1 "optimized" { xfail *-*-* } } }
Index: gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90 b/gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/c_ptr_tests_19.f90	(revision 278653)
@@ -0,0 +1,36 @@
+! { dg-do run }
+
+! PR 71544 - this failed with some optimization options due to a
+! pointer not being marked as escaping.
+
+module store_cptr
+    use, intrinsic :: iso_c_binding
+    implicit none
+    public
+    type(c_ptr), save :: cptr
+end module store_cptr
+
+subroutine init()
+    use, intrinsic :: iso_c_binding
+    implicit none
+    integer(c_int), pointer :: a
+    allocate(a)
+    call save_cptr(c_loc(a))
+    a = 100
+end subroutine init
+
+subroutine save_cptr(cptr_in)
+    use store_cptr
+    implicit none
+    type(c_ptr), intent(in) :: cptr_in
+    cptr = cptr_in
+end subroutine save_cptr
+
+program init_fails
+    use store_cptr
+    implicit none
+    integer(c_int), pointer :: val
+    call init()
+    call c_f_pointer(cptr,val)
+    if (val /= 100) stop 1
+end program init_fails
Index: gcc/testsuite/gfortran.dg/public_private_module_10.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/public_private_module_10.f90 b/gcc/testsuite/gfortran.dg/public_private_module_10.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/public_private_module_10.f90	(revision 278653)
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! PR 87734 - this used to issue spurious errors.
+
+module m_vstring
+  implicit none
+
+  public :: vstring_length
+
+contains
+
+  subroutine vstring_cast()
+    character ( len = vstring_length() ) :: char_string
+  end subroutine
+
+  pure integer function vstring_length ()
+  end function
+
+end module
Index: gcc/testsuite/gfortran.dg/entry_22.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/entry_22.f90 b/gcc/testsuite/gfortran.dg/entry_22.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/entry_22.f90	(revision 278653)
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! { dg-additional-options "-pedantic" }
+! PR fortran/89981 - this used to give a wrong warning (error with
+! -pedantic)
+program main
+  call bar(i)
+  call baz(i) ! { dg-error "Type mismatch in argument" }
+end program main
+subroutine foo(r)
+  entry bar(i)
+  entry baz(r)
+end subroutine foo
Index: gcc/testsuite/gfortran.dg/proc_ptr_51.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/proc_ptr_51.f90 b/gcc/testsuite/gfortran.dg/proc_ptr_51.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/proc_ptr_51.f90	(revision 278653)
@@ -0,0 +1,38 @@
+! { dg-do run }
+!
+! Test the fix for PR90786.
+!
+! Contributed by Andrew benson  <abensonca@gmail.com>
+!
+module f
+procedure(c), pointer :: c_
+
+ type :: s
+   integer :: i = 42
+ end type s
+ class(s), pointer :: res, tgt
+
+contains
+
+ function c()
+   implicit none
+   class(s), pointer ::  c
+   c => tgt
+   return
+ end function c
+
+ subroutine fs()
+   implicit none
+   c_ => c  ! This used to ICE
+   return
+ end subroutine fs
+
+end module f
+
+  use f
+  allocate (tgt, source = s(99))
+  call fs()
+  res => c_()
+  if (res%i .ne. 99) stop 1
+  deallocate (tgt)
+end
Index: gcc/testsuite/gfortran.dg/dependency_53.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/dependency_53.f90 b/gcc/testsuite/gfortran.dg/dependency_53.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/dependency_53.f90	(revision 278653)
@@ -0,0 +1,25 @@
+! { dg-do run }
+! PR fortran/66089 - used to ICE and, after that ICE was fixed,
+! gave wrong results.
+  type :: t
+    integer :: c
+  end type t
+
+  class(t), dimension(:), allocatable :: b,c
+
+  allocate (b(5), source=t(7))
+  allocate(c(5), source=t(13))
+  c = plus(c(1), b)
+  if (any(c%c /= 20)) stop 1
+  c = t(13)
+  c = plus(b, c(1))
+  if (any(c%c /= 20)) stop 2
+contains
+
+  elemental function plus(lhs, rhs)
+    class(t), intent(in) :: lhs, rhs
+    type(t)             :: plus
+    plus%c = lhs%c + rhs%c
+  end function plus
+
+end
Index: gcc/testsuite/gfortran.dg/binding_label_tests_30.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/binding_label_tests_30.f90 b/gcc/testsuite/gfortran.dg/binding_label_tests_30.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/binding_label_tests_30.f90	(revision 278653)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! Make sure this error is flagged.
+subroutine foo() ! { dg-error "is already being used as a SUBROUTINE" }
+end subroutine foo
+
+subroutine bar() bind(C,name="foo") ! { dg-error "is already being used as a SUBROUTINE" }
+end subroutine bar
Index: gcc/testsuite/gfortran.dg/class_70.f03
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/class_70.f03 b/gcc/testsuite/gfortran.dg/class_70.f03
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/class_70.f03	(revision 278653)
@@ -0,0 +1,38 @@
+! { dg-do run }
+!
+! Test the fix for PR57284 - [OOP] ICE with find_array_spec for polymorphic
+! arrays. Once thw ICE was fixed, work was needed to fix a segfault while
+! determining the size of 'z'.
+!
+! Contributed by Lorenz Huedepohl  <bugs@stellardeath.org>
+!
+module testmod
+  type type_t
+    integer :: idx
+  end type type_t
+  type type_u
+     type(type_t), allocatable :: cmp(:)
+  end type
+contains
+  function foo(a, b) result(add)
+    class(type_t), intent(in) :: a(:), b(size(a))
+    type(type_t) :: add(size(a))
+    add%idx = a%idx + b%idx
+  end function
+end module testmod
+program p
+  use testmod
+  class(type_t), allocatable, dimension(:) :: x, y, z
+  class(type_u), allocatable :: w
+  allocate (x, y, source = [type_t (1), type_t(2)])
+  z = foo (x, y)
+  if (any (z%idx .ne. [2, 4])) stop 1
+
+! Try something a bit more complicated than the original.
+
+  allocate (w)
+  allocate (w%cmp, source = [type_t (2), type_t(3)])
+  z = foo (w%cmp, y)
+  if (any (z%idx .ne. [3, 5])) stop 2
+  deallocate (w, x, y, z)
+end program
Index: gcc/testsuite/gfortran.dg/warn_unused_dummy_argument_5.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/warn_unused_dummy_argument_5.f90 b/gcc/testsuite/gfortran.dg/warn_unused_dummy_argument_5.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/warn_unused_dummy_argument_5.f90	(revision 278653)
@@ -0,0 +1,16 @@
+! { dg-do compile }
+! { dg-additional-options "-Wunused-dummy-argument" }
+! PR 91557 - this used to generate a bogus warning
+! Test case by Gerhard Steinmetz
+program p
+   integer :: a, b
+   a = 1
+   call g
+contains
+   subroutine g
+      integer :: x, y
+      call h (x, y)
+      if ( a > 0 )   y = y - 1
+      b = y - x + 1
+   end
+end
Index: gcc/testsuite/gfortran.dg/transpose_optimization_2.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/transpose_optimization_2.f90 b/gcc/testsuite/gfortran.dg/transpose_optimization_2.f90
--- a/gcc/testsuite/gfortran.dg/transpose_optimization_2.f90	(revision 278653)
+++ b/gcc/testsuite/gfortran.dg/transpose_optimization_2.f90	(revision 278653)
@@ -61,4 +61,4 @@
 ! The check below for temporaries gave 14 and 33 for "parm" and "atmp".
 !
 ! { dg-final { scan-tree-dump-times "parm" 72 "original" } }
-! { dg-final { scan-tree-dump-times "atmp" 12 "original" } }
+! { dg-final { scan-tree-dump-times "atmp" 13 "original" } }
Index: gcc/testsuite/gfortran.dg/external_procedures_4.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/external_procedures_4.f90 b/gcc/testsuite/gfortran.dg/external_procedures_4.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/external_procedures_4.f90	(revision 278653)
@@ -0,0 +1,28 @@
+! { dg-do run }
+!
+! Test the fix for PR87127 in which the references to exfunc cause
+! the error "‘exfunc’ at (1) is not a function".
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+function exfunc(i)
+  implicit none
+  integer :: exfunc,i
+  exfunc = 2*i
+end function
+
+! contents of test.f90
+program test
+  implicit none
+  integer :: exfunc,i
+  integer,parameter :: array(2)=[6,7]
+  associate(i=>array(2))            ! Original bug
+    if (exfunc(i) .ne. 2*i) stop 1
+  end associate
+  i = 99
+  call foo
+contains
+  subroutine foo()                  ! Comment #3
+    if (exfunc(i) .ne. 2*i) stop 2
+  end subroutine foo
+end program
Index: gcc/testsuite/gfortran.dg/whole_file_3.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/whole_file_3.f90 b/gcc/testsuite/gfortran.dg/whole_file_3.f90
--- a/gcc/testsuite/gfortran.dg/whole_file_3.f90	(revision 278653)
+++ b/gcc/testsuite/gfortran.dg/whole_file_3.f90	(revision 278653)
@@ -14,8 +14,8 @@
 
       program test
       EXTERNAL R
-      call PHLOAD (R, 1) ! { dg-warning "Missing alternate return spec" }
-      CALL PHLOAD (R, 2) ! { dg-warning "Missing alternate return spec" }
+      call PHLOAD (R, 1) ! { dg-error "Missing alternate return specifier" }
+      CALL PHLOAD (R, 2) ! { dg-error "Missing alternate return specifier" }
       CALL PHLOAD (R, *999) ! This one is OK
  999  continue
       END program test
Index: gcc/testsuite/gfortran.dg/pr85797.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr85797.f90 b/gcc/testsuite/gfortran.dg/pr85797.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr85797.f90	(revision 278653)
@@ -0,0 +1,31 @@
+! { dg-do compile }
+! PR fortran/83515 - ICE: Invalid expression in gfc_element_size 
+! PR fortran/85797 - ICE in gfc_element_size, at fortran/target-memory.c:126
+! PR fortran/89904 - ICE in gfortran starting with r270045
+
+recursive subroutine a
+  c = transfer (a, b)           ! { dg-error "'SOURCE' argument of 'TRANSFER'" }
+end
+
+recursive subroutine d
+  c = transfer (b, d)           ! { dg-error "'MOLD' argument of 'TRANSFER'" }
+end
+
+subroutine f
+  use, intrinsic :: iso_c_binding
+  integer(c_intptr_t) :: b, c
+  procedure(), pointer :: a
+  c = transfer (a, b)
+  c = transfer (transfer (b, a), b)
+end
+
+module m
+contains
+  function f () result (z)
+    class(*), pointer :: z
+  end function f
+  recursive subroutine s (q)
+    procedure(f) :: q
+    call s (q)
+  end subroutine s
+end
Index: gcc/testsuite/gfortran.dg/dtio_34.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/dtio_34.f90 b/gcc/testsuite/gfortran.dg/dtio_34.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/dtio_34.f90	(revision 278653)
@@ -0,0 +1,32 @@
+! { dg-do run }
+! PR84387 Defined output does not work for a derived type that
+! has no components 
+module m
+   type :: t
+      private
+      !integer :: m_i = 0  !<-- ***
+   contains
+      private
+      procedure, pass(this) :: write_t
+      generic, public :: write(formatted) => write_t
+   end type
+contains
+   subroutine write_t(this, lun, iotype, vlist, istat, imsg)
+      ! argument definitions
+      class(t), intent(in)            :: this
+      integer, intent(in)             :: lun
+      character(len=*), intent(in)    :: iotype
+      integer, intent(in)             :: vlist(:)
+      integer, intent(out)            :: istat
+      character(len=*), intent(inout) :: imsg
+      write(lun, fmt=*, iostat=istat, iomsg=imsg) "Hello World!"
+      return
+   end subroutine write_t
+
+end module
+
+program p
+   use m, only : t
+   type(t) :: foo
+   print "(dt)", foo ! { dg-output " Hello World!" }
+end program
Index: gcc/testsuite/gfortran.dg/associate_48.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/associate_48.f90 b/gcc/testsuite/gfortran.dg/associate_48.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/associate_48.f90	(revision 278653)
@@ -0,0 +1,41 @@
+! { dg=do run }
+!
+! Test the fix for PR90498.
+!
+! Contributed by Vladimir Fuka  <vladimir.fuka@gmail.com>
+!
+  type field_names_a
+    class(*), pointer :: var(:) =>null()
+  end type
+
+  type(field_names_a),pointer :: a(:)
+  allocate (a(2))
+
+  allocate (a(1)%var(2), source = ["hello"," vlad"])
+  allocate (a(2)%var(2), source = ["HELLO"," VLAD"])
+  call s(a)
+  deallocate (a(1)%var)
+  deallocate (a(2)%var)
+  deallocate (a)
+contains
+  subroutine s(a)
+
+    type(field_names_a) :: a(:)
+
+    select type (var => a(1)%var)
+      type is (character(*))
+        if (any (var .ne. ["hello"," vlad"])) stop 1
+      class default
+        stop
+    end select
+
+    associate (var => a(2)%var)
+      select type (var)
+        type is (character(*))
+          if (any (var .ne. ["HELLO"," VLAD"])) stop 2
+        class default
+          stop
+      end select
+    end associate
+  end
+end
Index: gcc/testsuite/gfortran.dg/coarray_data_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/coarray_data_1.f90 b/gcc/testsuite/gfortran.dg/coarray_data_1.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/coarray_data_1.f90	(revision 278653)
@@ -0,0 +1,11 @@
+! { dg-do  run }
+! { dg-options "-fcoarray=lib -lcaf_single " }
+! PR 71066 - this used to ICE
+program p
+   real :: a(2,2)[*]
+   integer :: b(2,2)[*]
+   data a /4*0.0/
+   data b /1234, 2345, 3456, 4567/
+   if (any (a /= 0.0)) stop 1
+   if (any (b /= reshape([1234, 2345, 3456, 4567],[2,2]))) stop 2
+end
Index: gcc/testsuite/gfortran.dg/deferred_character_33.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_33.f90 b/gcc/testsuite/gfortran.dg/deferred_character_33.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/deferred_character_33.f90	(revision 278653)
@@ -0,0 +1,35 @@
+! { dg-do run }
+! { dg-additional-sources deferred_character_33a.f90 }
+! PR fortran/90744 - this used to pass a wrong length
+! to an external function without a prototype.
+! Original test case by Tomáš Trnka.
+module StringModule
+   implicit none
+
+contains
+   function getstr()
+      character(:), allocatable :: getstr
+
+      getstr = 'OK'
+   end function
+end module
+module TestModule
+   use StringModule
+   implicit none
+
+contains
+   subroutine DoTest()
+      if (.false.) then
+         call convrs('A',getstr())
+      else
+         call convrs('B',getstr())
+      end if
+   end subroutine
+end module
+program external_char_length
+   use TestModule
+
+   implicit none
+
+   call DoTest()
+end program
Index: gcc/testsuite/gfortran.dg/transfer_check_5.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/transfer_check_5.f90 b/gcc/testsuite/gfortran.dg/transfer_check_5.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/transfer_check_5.f90	(revision 278653)
@@ -0,0 +1,14 @@
+! { dg-do compile }
+! { dg-options "-Wsurprising" }
+!
+! PR fortran/89516 - ICE in gfc_calculate_transfer_sizes at gcc/fortran/check.c:5506
+! Found by Martin Liška
+
+program test
+  character(*), parameter :: n = ''
+  character(*), parameter :: o = transfer ([''], n)
+  print *, transfer(1,'',size=0) ! No warning
+  print *, transfer(1,'',size=1) ! No warning
+  print *, transfer('',1,size=0) ! No warning
+  print *, transfer('',1,size=1) ! { dg-warning "has partly undefined result" }
+end program test
Index: gcc/testsuite/gfortran.dg/do_subscript_6.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/do_subscript_6.f90 b/gcc/testsuite/gfortran.dg/do_subscript_6.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/do_subscript_6.f90	(revision 278653)
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! { dg-options "-std=legacy" }
+! PR 91550 - this used to cause an ICE
+! Test case by Gerhard Steinmetz
+program p
+   real :: a(3)
+   integer :: i
+   do i = 1, 3, .1 ! { dg-error "cannot be zero" }
+      a(i) = i
+   end do
+end
Index: gcc/testsuite/gfortran.dg/pr89492.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr89492.f90 b/gcc/testsuite/gfortran.dg/pr89492.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr89492.f90	(revision 278653)
@@ -0,0 +1,27 @@
+! { dg-do compile }
+!
+! PR fortran/89492 - Endless compilation of an invalid TRANSFER after r269177
+! Test error recovery for invalid uses of TRANSFER
+! Test proper simplification for MOLD with size 0
+!
+! Derived from original testcase by Dominique d'Humieres
+
+program bug4a
+  implicit none
+  type bug4
+! Intentionally left empty
+  end type bug4
+  integer, parameter :: k = size(transfer('',['']))  ! k = 0
+  integer, parameter :: i = len (transfer('',['']))  ! i = 0
+  integer, parameter :: l = len (transfer('', '' ))  ! l = 0
+  integer, parameter :: m(k) = k
+  integer, parameter :: j(i) = i
+  integer, parameter :: n(l) = l
+  print *, k,i,l,m,j,n
+  print *,      transfer(1,[''])                ! { dg-error "shall not have storage size 0" }
+  print *,      transfer(1, '' )                ! No error
+  print *, size(transfer(1,['']))               ! { dg-error "shall not have storage size 0" }
+  print *, len (transfer(1, '' ))               ! No error
+  print *, size(transfer([1],[bug4()]))         ! { dg-error "shall not have storage size 0" }
+  print *, transfer(transfer([1],[bug4()]),[1]) ! { dg-error "shall not have storage size 0" }
+end program bug4a
Index: gcc/testsuite/gfortran.dg/external_procedure_4.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/external_procedure_4.f90 b/gcc/testsuite/gfortran.dg/external_procedure_4.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/external_procedure_4.f90	(revision 278653)
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! PR fortran/90937 - this used to cause an ICE.
+! Original test case by Toon Moene.
+subroutine lfidiff
+
+   implicit none
+
+   contains 
+
+      subroutine grlfi(cdnom)
+
+         character(len=*) cdnom(:)
+         character(len=len(cdnom)) clnoma
+
+         call lficas(clnoma)
+
+      end subroutine grlfi
+
+end subroutine lfidiff
Index: gcc/testsuite/gfortran.dg/assign_10.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/assign_10.f90 b/gcc/testsuite/gfortran.dg/assign_10.f90
--- a/gcc/testsuite/gfortran.dg/assign_10.f90	(revision 278653)
+++ b/gcc/testsuite/gfortran.dg/assign_10.f90	(revision 278653)
@@ -24,4 +24,4 @@
 ! Note that it is the kind conversion that generates the temp.
 !
 ! { dg-final { scan-tree-dump-times "parm" 20 "original" } }
-! { dg-final { scan-tree-dump-times "atmp" 18 "original" } }
+! { dg-final { scan-tree-dump-times "atmp" 20 "original" } }
Index: gcc/testsuite/gfortran.dg/deferred_character_33a.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_33a.f90 b/gcc/testsuite/gfortran.dg/deferred_character_33a.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/deferred_character_33a.f90	(revision 278653)
@@ -0,0 +1,9 @@
+! { dg-do compile }
+subroutine convrs(quanty,fromto)
+   implicit none
+
+   character(*), intent(in) :: quanty,fromto
+
+   if (len(fromto) /= 2) stop 1
+   if (fromto /= 'OK') stop 2
+end subroutine
Index: gcc/testsuite/gfortran.dg/coarray_allocate_11.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/coarray_allocate_11.f90 b/gcc/testsuite/gfortran.dg/coarray_allocate_11.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/coarray_allocate_11.f90	(revision 278653)
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! { dg-additional-options -fcoarray=single }
+program p
+   integer, allocatable :: z[:,:]
+   integer :: i
+   allocate (z[1:,*]) ! { dg-error "Bad array specification in ALLOCATE statement" }
+   allocate (z[:2,*]) ! { dg-error "Bad array specification in ALLOCATE statement" }
+   allocate (z[2:1,*]) ! { dg-error "Upper cobound is less than lower cobound" }
+   allocate (z[:0,*]) ! { dg-error "Bad array specification in ALLOCATE statement" }
+   allocate (z[0,*]) ! { dg-error "Upper cobound is less than lower cobound" }
+   allocate (z[1,*]) ! This is OK
+   allocate (z[1:1,*]) ! This is OK
+   allocate (z[i:i,*]) ! This is OK
+   allocate (z[i:i-1,*]) ! { dg-error "Upper cobound is less than lower cobound" }
+end
Index: gcc/testsuite/gfortran.dg/pointer_intent_8.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pointer_intent_8.f90 b/gcc/testsuite/gfortran.dg/pointer_intent_8.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pointer_intent_8.f90	(revision 278653)
@@ -0,0 +1,22 @@
+! { dg-do run }
+! PR 85797 - this used to get wrong results.
+
+
+PROGRAM testfortran2
+  IMPLICIT NONE
+
+  INTEGER, DIMENSION(10), TARGET :: i4array
+
+  i4array = (/ 1,2,3,4,5,6,7,8,9,10 /)
+
+  call InRef(i4array)
+
+CONTAINS
+
+  subroutine InRef(v)
+    INTEGER, DIMENSION(:), POINTER, INTENT(in) :: v
+    INTEGER :: i
+    if (any (v /= [(i,i=1,10)])) stop 1
+  END subroutine
+
+END
Index: gcc/testsuite/gfortran.dg/ieee/ieee.exp
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/ieee/ieee.exp b/gcc/testsuite/gfortran.dg/ieee/ieee.exp
--- a/gcc/testsuite/gfortran.dg/ieee/ieee.exp	(revision 278653)
+++ b/gcc/testsuite/gfortran.dg/ieee/ieee.exp	(revision 278653)
@@ -22,15 +22,15 @@
 load_lib gfortran-dg.exp
 load_lib target-supports.exp
 
-# Initialize `dg'.
-dg-init
-
-# Flags specified in each test
+# If a testcase doesn't have special options, use these.
 global DEFAULT_FFLAGS
 if ![info exists DEFAULT_FFLAGS] then {
-    set DEFAULT_FFLAGS ""
+    set DEFAULT_FFLAGS " -pedantic-errors"
 }
 
+# Initialize `dg'.
+dg-init
+
 # Flags for finding the IEEE modules
 if [info exists TOOL_OPTIONS] {
    set specpath [get_multilibs ${TOOL_OPTIONS}]
Index: gcc/testsuite/gfortran.dg/binding_label_tests_33.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/binding_label_tests_33.f90 b/gcc/testsuite/gfortran.dg/binding_label_tests_33.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/binding_label_tests_33.f90	(revision 278653)
@@ -0,0 +1,39 @@
+! { dg-do run }
+! PR 79485 - used to crash because the wrong routine was called.
+module fmod1
+
+  contains
+
+  subroutine foo(i)
+    implicit none
+
+    integer, intent(inout) :: i
+
+    i=i+1
+
+  end subroutine foo
+
+end module fmod1
+
+module fmod2
+  use iso_c_binding
+  use fmod1, only : foo_first => foo
+
+  contains
+
+  subroutine foo(i) bind(c)
+    implicit none
+
+    integer, intent(inout) :: i
+
+    i=i+2
+    call foo_first(i)
+
+  end subroutine foo
+
+end module fmod2
+
+  use fmod2
+  
+  call foo(i)
+end
Index: gcc/testsuite/gfortran.dg/charlen_17.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/charlen_17.f90 b/gcc/testsuite/gfortran.dg/charlen_17.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/charlen_17.f90	(revision 278653)
@@ -0,0 +1,14 @@
+! { dg-do compile }
+! PR 87673 - used to cause errors about non-pure functions.
+
+module x
+  implicit none
+contains
+  pure function foo() result(res)
+    character(len=:), allocatable :: res
+    allocate (character(bar()) :: res)
+  end function foo
+  pure integer function bar()
+    bar = 1
+  end function bar
+end module x
Index: gcc/testsuite/gfortran.dg/char_result_19.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/char_result_19.f90 b/gcc/testsuite/gfortran.dg/char_result_19.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/char_result_19.f90	(revision 278653)
@@ -0,0 +1,24 @@
+! { dg-do preprocess }
+! { dg-additional-options "-cpp" }
+!
+! Test the fix for PR86248
+!
+! Contributed by Bill Long  <longb@cray.com>
+!
+program test
+  use test_module
+  implicit none
+  integer :: i
+  character(:), allocatable :: chr
+  do i = 0, 2
+    chr = func_1 (i)
+    select case (i)
+      case (0)
+        if (chr .ne. 'el0') stop i
+      case (1)
+        if (chr .ne. 'el11') stop i
+      case (2)
+        if (chr .ne. 'el2') stop i
+    end select
+  end do
+end program test
Index: gcc/testsuite/gfortran.dg/deferred_character_32.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/deferred_character_32.f90 b/gcc/testsuite/gfortran.dg/deferred_character_32.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/deferred_character_32.f90	(revision 278653)
@@ -0,0 +1,13 @@
+! { dg-do run }
+!
+! Test the fix for PR88117.
+!
+! Contributed by Gerhard Steinmetz  <gscfq@t-online.de>
+!
+program p
+   character(:), pointer :: z(:)
+   allocate (z, source  = ['abcd', 'bcde'])
+   z = (z) ! gimplifier choked here.
+   if (any (z .ne. ['abcd', 'bcde'])) stop 1
+   deallocate (z)
+end
Index: gcc/testsuite/gfortran.dg/do_subscript_5.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/do_subscript_5.f90 b/gcc/testsuite/gfortran.dg/do_subscript_5.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/do_subscript_5.f90	(revision 278653)
@@ -0,0 +1,20 @@
+! { dg-do compile }
+! { dg-additional-options "-Wdo-subscript" }
+! PR 90563 - this used to be rejected, wrongly
+! Original test case by Tobias Neumann
+program test
+      implicit none
+      integer, parameter :: swap(4) = [2,1,3,4]
+      real :: p(20)
+      integer :: j
+
+      p = 0.0
+
+      ! The following warnings are actually bogus, but we are not yet
+      ! clever enough to suppress them.
+      do j=1,6 ! { dg-warning "out of bounds" }
+          if (j<5) then
+              p(j) = p(swap(j)) ! { dg-warning "out of bounds" }
+          endif
+      enddo
+end program
Index: gcc/testsuite/gfortran.dg/dg.exp
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/dg.exp b/gcc/testsuite/gfortran.dg/dg.exp
--- a/gcc/testsuite/gfortran.dg/dg.exp	(revision 278653)
+++ b/gcc/testsuite/gfortran.dg/dg.exp	(revision 278653)
@@ -36,7 +36,7 @@
     global gfortran_test_path
     global gfortran_aux_module_flags
     if { [llength $args] != 2 } {
-	error "dg-set-target-env-var: needs one argument"
+	error "dg-compile-aux-modules: needs one argument"
 	return
     }
 
Index: gcc/testsuite/gfortran.dg/pr91660_2.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr91660_2.f90 b/gcc/testsuite/gfortran.dg/pr91660_2.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr91660_2.f90	(revision 278653)
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/91660
+program foo
+   type(doubleprecision :: x   ! { dg-error "Malformed type-spec" }
+   type(double precision :: y  ! { dg-error "Malformed type-spec" }
+   type(character(len=3) :: a  ! { dg-error "Malformed type-spec" }
+   type(doublecomplex :: b     ! { dg-error "Malformed type-spec" }
+   type(double complex :: c    ! { dg-error "Malformed type-spec" }
+end program foo
Index: gcc/testsuite/gfortran.dg/pr69455_2.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr69455_2.f90 b/gcc/testsuite/gfortran.dg/pr69455_2.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr69455_2.f90	(revision 278653)
@@ -0,0 +1,13 @@
+! { dg-do run }
+program foo
+   block
+      use, intrinsic :: ISO_FORTRAN_ENV, only: wp => REAL32, ik => INT32
+      if (ik /= 4) stop 1
+      if (wp /= 4) stop 2
+   end block
+   block
+      use, intrinsic :: ISO_FORTRAN_ENV, only: wp => REAL64, ik => INT64
+      if (ik /= 8) stop 3
+      if (wp /= 8) stop 4
+   end block
+end program foo
Index: gcc/testsuite/gfortran.dg/finalize_28.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/finalize_28.f90 b/gcc/testsuite/gfortran.dg/finalize_28.f90
--- a/gcc/testsuite/gfortran.dg/finalize_28.f90	(revision 278653)
+++ b/gcc/testsuite/gfortran.dg/finalize_28.f90	(revision 278653)
@@ -21,4 +21,4 @@
     integer, intent(out) :: edges(:,:)
   end subroutine coo_dump_edges
 end module coo_graphs
-! { dg-final { scan-tree-dump-times "__builtin_free" 6 "original" } }
+! { dg-final { scan-tree-dump-times "__builtin_free" 5 "original" } }
Index: gcc/testsuite/gfortran.dg/substr_simplify.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/substr_simplify.f90 b/gcc/testsuite/gfortran.dg/substr_simplify.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/substr_simplify.f90	(revision 278653)
@@ -0,0 +1,20 @@
+! { dg-do run }
+!
+! Test fixes for substring simplications derived from
+! PR fortran/89077 - ICE using * as len specifier for character parameter
+
+program test
+  implicit none
+  integer :: i
+  character(*), parameter :: s = 'abcdef', y = 'efcdab'
+  character(6), save      :: t = transfer ([(s(i:i),  i=1,len(s)  )], s)
+  character(*), parameter :: u = transfer ([(s(i:i+2),i=1,len(s),3)], s)
+  character(6), save      :: v = transfer ([(s(i:i+2),i=1,len(s),3)], s)
+  character(*), parameter :: w = transfer ([(y(i:i+1),i=len(s)-1,1,-2)], s)
+  character(6), save      :: x = transfer ([(y(i:i+1),i=len(s)-1,1,-2)], s)
+  if (len (t) /= len (s) .or. t /= s) stop 1
+  if (len (u) /= len (s) .or. u /= s) stop 2
+  if (len (v) /= len (s) .or. v /= s) stop 3
+  if (len (w) /= len (s) .or. w /= s) stop 4
+  if (len (x) /= len (s) .or. x /= s) stop 5
+end
Index: gcc/testsuite/gfortran.dg/altreturn_10.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/altreturn_10.f90 b/gcc/testsuite/gfortran.dg/altreturn_10.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/altreturn_10.f90	(revision 278653)
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! { dg-options -Os }
+! PR 78865 - this used to ICE.
+program p
+   call sub (3)
+end
+subroutine sub (x)
+   integer :: x, i, n
+   do i = 1, x
+      if ( n /= 0 ) stop
+      call sub2
+   end do
+   print *, x, n
+end
+subroutine sub2
+   call sub (*99) ! { dg-error "Unexpected alternate return specifier" }
+   call sub (99.) ! { dg-warning "Type mismatch in argument" }
+99 stop
+end
Index: gcc/testsuite/gfortran.dg/altreturn_9_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/altreturn_9_1.f90 b/gcc/testsuite/gfortran.dg/altreturn_9_1.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/altreturn_9_1.f90	(revision 278653)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! { dg-options "-std=gnu" }
+! See altreturn_9_0.f90
+subroutine sub(i, *, j)
+  if (i == 10 .and. j == 20) return 1
+  return
+end subroutine sub
Index: gcc/testsuite/gfortran.dg/binding_label_tests_32.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/binding_label_tests_32.f90 b/gcc/testsuite/gfortran.dg/binding_label_tests_32.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/binding_label_tests_32.f90	(revision 278653)
@@ -0,0 +1,35 @@
+! { dg-do run }
+! PR 77746 - this used to crash during execution.
+! Original test case by Vladimir Fuka.
+module first
+  private
+  public execute
+  
+  interface execute
+    module procedure random_name
+  end interface
+  
+contains
+
+  subroutine random_name()
+  end subroutine
+end module
+
+module test
+  use first
+
+  implicit none
+
+contains
+
+  subroutine p_execute(i)  bind(C, name="random_name")
+    integer :: i
+
+    call execute()
+  end subroutine
+  
+end module
+
+  use test
+  call p_execute(1)
+end
Index: gcc/testsuite/gfortran.dg/interface_abstract_5.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/interface_abstract_5.f90 b/gcc/testsuite/gfortran.dg/interface_abstract_5.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/interface_abstract_5.f90	(revision 278653)
@@ -0,0 +1,32 @@
+! { dg-do compile }
+!
+! PR 71861: [7/8/9 Regression] [F03] ICE in write_symbol(): bad module symbol
+!
+! Contributed by Gerhard Steinmetz <gerhard.steinmetz.fortran@t-online.de>
+
+module m1
+   intrinsic abs
+   abstract interface
+      function abs(x)    ! { dg-error "ABSTRACT attribute conflicts with INTRINSIC attribute" }
+         real :: abs, x
+      end
+   end interface
+end
+
+module m2
+   abstract interface
+      function abs(x)
+         real :: abs, x
+      end
+   end interface
+   intrinsic abs    ! { dg-error "ABSTRACT attribute conflicts with INTRINSIC attribute" }
+end
+
+module m3
+   abstract interface
+      function f(x)
+         real :: f, x
+      end
+   end interface
+   intrinsic f    ! { dg-error "ABSTRACT attribute conflicts with INTRINSIC attribute" }
+end
Index: gcc/testsuite/gfortran.dg/pr89266.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr89266.f90 b/gcc/testsuite/gfortran.dg/pr89266.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr89266.f90	(revision 278653)
@@ -0,0 +1,25 @@
+! { dg-do run }
+!
+! PR fortran/89266 - ICE with TRANSFER of len=0 character array constructor
+
+program test
+  implicit none
+  character(*), parameter :: n = ''
+  character(*), parameter :: o = transfer ([''], n)
+  character(*), parameter :: p = transfer ( n , n)
+  character(*), parameter :: q = transfer ([n], n)
+  character(6), save      :: r = transfer ([''], n)
+  character(6), save      :: s = transfer ( n , n)
+  character(6), save      :: t = transfer ([n], n)
+  integer,      parameter :: a(0) = 0
+  integer,      parameter :: b(0) = transfer (a, a)
+  integer,      save      :: c(0) = transfer (a, a)
+  if (len (o) /= 0) stop 1
+  if (len (p) /= 0) stop 2
+  if (len (q) /= 0) stop 3
+  if (r /= "") stop 4
+  if (s /= "") stop 5
+  if (t /= "") stop 6
+  if (size (b) /= 0 .or. any (b /= 0)) stop 7
+  if (size (c) /= 0 .or. any (c /= 0)) stop 8
+end program test
Index: gcc/testsuite/gfortran.dg/pr91660_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr91660_1.f90 b/gcc/testsuite/gfortran.dg/pr91660_1.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr91660_1.f90	(revision 278653)
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/91660
+! Code contributed by Gerhard Steinmetz
+program p
+   type t
+   end type
+   type (t x    ! { dg-error "Malformed type-spec" }
+   x = t()      ! { dg-error "Can't convert" }
+end
Index: gcc/testsuite/gfortran.dg/coarray/caf.exp
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/coarray/caf.exp b/gcc/testsuite/gfortran.dg/coarray/caf.exp
--- a/gcc/testsuite/gfortran.dg/coarray/caf.exp	(revision 278653)
+++ b/gcc/testsuite/gfortran.dg/coarray/caf.exp	(revision 278653)
@@ -51,11 +51,21 @@
     global gfortran_test_path
     global gfortran_aux_module_flags
     if { [llength $args] != 2 } {
-	error "dg-set-target-env-var: needs one argument"
+	error "dg-compile-aux-modules: needs one argument"
 	return
     }
+
+    set level [info level]
+    if { [info procs dg-save-unknown] != [list] } {
+	rename dg-save-unknown dg-save-unknown-level-$level
+    }
+
     dg-test $gfortran_test_path/[lindex $args 1] "" $gfortran_aux_module_flags
-    # cleanup-modules isn't intentionally invoked here.
+    # cleanup-modules is intentionally not invoked here.
+
+    if { [info procs dg-save-unknown-level-$level] != [list] } {
+	rename dg-save-unknown-level-$level dg-save-unknown
+    }
 }
 
 # Add -latomic only where supported.  Assume built-in support elsewhere.
Index: gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90 b/gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90
--- a/gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90	(revision 278653)
+++ b/gcc/testsuite/gfortran.dg/lto/20091028-1_0.f90	(revision 278653)
@@ -1,5 +1,5 @@
 ! { dg-lto-do link }
-! { dg-extra-ld-options "-r -nostdlib -finline-functions" }
+! { dg-extra-ld-options "-r -nostdlib -finline-functions -Wno-lto-type-mismatch" }
 
 SUBROUTINE int_gen_ti_header_char( hdrbuf, hdrbufsize, itypesize, &
                               DataHandle, Element, VarName, Data, code )
Index: gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90 b/gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90
--- a/gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90	(revision 278653)
+++ b/gcc/testsuite/gfortran.dg/lto/20091028-2_0.f90	(revision 278653)
@@ -1,5 +1,5 @@
 ! { dg-lto-do link }
-! { dg-extra-ld-options "-r -nostdlib -finline-functions" }
+! { dg-extra-ld-options "-r -nostdlib -finline-functions -Wno-lto-type-mismatch" }
 
 SUBROUTINE int_gen_ti_header_char( hdrbuf, hdrbufsize, itypesize, &
                               DataHandle, Element, VarName, Data, code )
Index: gcc/testsuite/gfortran.dg/lto/pr87689_0.f
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/lto/pr87689_0.f b/gcc/testsuite/gfortran.dg/lto/pr87689_0.f
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/lto/pr87689_0.f	(revision 278653)
@@ -0,0 +1,13 @@
+! { dg-lto-run }
+! PR 87689 - this used to fail for POWER, plus it used to
+! give warnings about mismatches with LTO.
+! Original test case by Judicaël Grasset.
+      program main
+        implicit none
+        character :: c
+        character(len=20) :: res, doesntwork_p8
+        external doesntwork_p8
+        c = 'o'
+        res = doesntwork_p8(c,1,2,3,4,5,6)
+        if (res /= 'foo') stop 3
+      end program main
Index: gcc/testsuite/gfortran.dg/lto/pr87689_1.f
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/lto/pr87689_1.f b/gcc/testsuite/gfortran.dg/lto/pr87689_1.f
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/lto/pr87689_1.f	(revision 278653)
@@ -0,0 +1,11 @@
+      function doesntwork_p8(c,a1,a2,a3,a4,a5,a6)
+        implicit none
+        character(len=20) :: doesntwork_p8
+        character :: c
+        integer :: a1,a2,a3,a4,a5,a6
+        if (a1 /= 1 .or. a2 /= 2 .or. a3 /= 3 .or. a4 /= 4 .or. a5 /= 5
+     &       .or. a6 /= 6) stop 1
+       if (c /= 'o ') stop 2
+       doesntwork_p8 = 'foo'
+       return
+       end
Index: gcc/testsuite/gfortran.dg/finalize_34.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/finalize_34.f90 b/gcc/testsuite/gfortran.dg/finalize_34.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/finalize_34.f90	(revision 278653)
@@ -0,0 +1,25 @@
+! { dg-do compile }
+! { dg-additional-options "-fdump-tree-original" }
+! PR 87352 - this used to cause an excessive number of deallocations.
+module testmodule
+  implicit none
+  public
+
+  type :: evtlist_type
+     real,  allocatable, dimension(:) :: p1
+     real,  allocatable, dimension(:) :: p2
+     real,  allocatable, dimension(:) :: p3
+     real,  allocatable, dimension(:) :: p4
+  end type evtlist_type
+
+  type :: evtlistlist_type
+     type(evtlist_type)  :: evtlist(1:1)
+  end type evtlistlist_type
+
+end module testmodule 
+
+program main
+  use testmodule
+  type(evtlist_type), dimension(10) :: a
+end program main
+! { dg-final  { scan-tree-dump-times "__builtin_free" 8 "original" } }
Index: gcc/testsuite/gfortran.dg/pr89664.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr89664.f90 b/gcc/testsuite/gfortran.dg/pr89664.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr89664.f90	(revision 278653)
@@ -0,0 +1,24 @@
+! { dg-do compile }
+! { dg-options "-Ofast" }
+
+subroutine s (x)
+   real :: x
+   call sub (x)
+end
+subroutine sub (x)
+   real :: x, y
+   logical :: a, b
+   real :: f1, f2, f3, f4
+   y = f1()
+   a = .false.
+   if ( f2() > f3() ) a = .true.
+   b = .false.
+   if ( f2() > f4() ) b = .true.
+   if ( a ) then
+      x = 1.0
+   else if ( b ) then
+      x = 1.0/y**2
+   else
+      x = 1.0/y - y**2
+   end if
+end
Index: gcc/testsuite/gfortran.dg/no_arg_check_2.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/no_arg_check_2.f90 b/gcc/testsuite/gfortran.dg/no_arg_check_2.f90
--- a/gcc/testsuite/gfortran.dg/no_arg_check_2.f90	(revision 278653)
+++ b/gcc/testsuite/gfortran.dg/no_arg_check_2.f90	(revision 278653)
@@ -139,7 +139,7 @@
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) array_class_t1_alloc._data.data" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) \\(array_class_t1_ptr._data.dat" 1 "original" } }
 
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 3 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 4 "original" } }
 ! { dg-final { scan-tree-dump-times " = _gfortran_internal_pack \\(&parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(&array_int\\)" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(real\\(kind=4\\).0:. . restrict\\) array_real_alloc.data" 1 "original" } }
@@ -148,5 +148,5 @@
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t2.0:. . restrict\\) array_t2_alloc.data\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. . restrict\\) array_class_t1_alloc._data.data\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 0 "original" } }
 
Index: gcc/testsuite/gfortran.dg/pr69455_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr69455_1.f90 b/gcc/testsuite/gfortran.dg/pr69455_1.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr69455_1.f90	(revision 278653)
@@ -0,0 +1,14 @@
+! { dg-do run }
+program foo
+   block
+      use, intrinsic :: iso_c_binding, only: wp => c_float, ik => c_int
+      if (ik /= 4) stop 1
+      if (wp /= 4) stop 2
+   end block
+   block
+      use, intrinsic :: iso_c_binding, only: wp => c_double, ik => c_int64_t
+      if (ik /= 8) stop 3
+      if (wp /= 8) stop 4
+   end block
+end program foo
+
Index: gcc/testsuite/gfortran.dg/pr77583.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr77583.f90 b/gcc/testsuite/gfortran.dg/pr77583.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr77583.f90	(revision 278653)
@@ -0,0 +1,10 @@
+! { dg-do compile }
+!
+! PR fortran/77583 - ICE in pp_quoted_string, at pretty-print.c:966
+! Contributed by Gerhard Steinmetz <gerhard.steinmetz.fortran@t-online.de>
+
+pure subroutine sub(s)
+contains
+   pure subroutine s  ! { dg-error "conflicts with DUMMY argument" }
+   end
+end
Index: gcc/testsuite/gfortran.dg/blockdata_11.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/blockdata_11.f90 b/gcc/testsuite/gfortran.dg/blockdata_11.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/blockdata_11.f90	(revision 278653)
@@ -0,0 +1,33 @@
+! { dg-do run }
+! PR 84394 - this used to complain about private procedures in
+! BLOCK data.
+module mod1
+   implicit none
+   type :: type1
+      integer :: i1
+   end type type1
+end module
+
+module mod2
+   implicit none
+   contains
+      subroutine sub1
+         integer vals
+         common /block1/ vals(5)
+         if (any(vals /= [1, 2, 3, 4, 5])) stop 1
+      end subroutine
+end module
+
+block data blkdat
+  use mod1
+  integer vals
+  common /block1/ vals(5)
+  data vals/1, 2, 3, 4, 5/
+end block data blkdat
+
+program main
+  use mod2, only: sub1
+  implicit none
+  call sub1
+end program
+
Index: gcc/testsuite/gfortran.dg/altreturn_9_0.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/altreturn_9_0.f90 b/gcc/testsuite/gfortran.dg/altreturn_9_0.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/altreturn_9_0.f90	(revision 278653)
@@ -0,0 +1,10 @@
+! { dg-do  run }
+! { dg-options -std=gnu }
+! { dg-additional-sources altreturn_9_1.f90 }
+! PR 89496 - wrong type for alternate return was generated
+
+program main
+  call sub(10, *10, 20)
+  stop 1
+10 continue
+end program main
Index: gcc/testsuite/gfortran.dg/binding_label_tests_31.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/binding_label_tests_31.f90 b/gcc/testsuite/gfortran.dg/binding_label_tests_31.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/binding_label_tests_31.f90	(revision 278653)
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! PR fortran/66695 - this used to ICE.
+! Original test case by Vladimir Fuka.
+module mod
+  implicit none
+contains
+    integer function F()
+    end function
+end module
+    
+module mod_C
+  use mod
+  implicit none
+contains
+  subroutine s()  bind(C, name="f")
+    integer :: x
+      x = F()
+  end subroutine
+end module
Index: gcc/testsuite/gfortran.dg/pr88326.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr88326.f90 b/gcc/testsuite/gfortran.dg/pr88326.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr88326.f90	(revision 278653)
@@ -0,0 +1,11 @@
+! { dg-do compile }
+!
+! PR fortran/88326 - ICE in gfc_conv_array_initializer
+
+program p
+  character, parameter :: x(3) = ['a','b','c']
+  character    :: y(1) = transfer('', x) ! { dg-error "Different shape for array assignment" }
+  character(0) :: z(1) = transfer('', x) ! { dg-error "Different shape for array assignment" }
+  character    :: u(0) = transfer('', x)
+  print *, y, z, u
+end
Index: gcc/testsuite/gfortran.dg/warn_conversion_11.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/warn_conversion_11.f90 b/gcc/testsuite/gfortran.dg/warn_conversion_11.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/warn_conversion_11.f90	(revision 278653)
@@ -0,0 +1,18 @@
+! { dg-do compile }
+! { dg-options "-Wconversion" }
+! PR 86119 - this used to warn.
+program proglen
+
+implicit none
+
+   class(*), allocatable :: s
+   integer :: l2
+
+   allocate(s, source = '123  ')
+
+   select type(s)
+   type is (character(len=*))
+      l2 = len(s)
+   end select
+
+end program proglen
Index: gcc/testsuite/gfortran.dg/pdt_4.f03
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pdt_4.f03 b/gcc/testsuite/gfortran.dg/pdt_4.f03
--- a/gcc/testsuite/gfortran.dg/pdt_4.f03	(revision 278653)
+++ b/gcc/testsuite/gfortran.dg/pdt_4.f03	(revision 278653)
@@ -97,9 +97,9 @@
     type (mytype(4, *)) :: arg      ! OK
   end subroutine
   subroutine bar(arg)               ! { dg-error "is neither allocatable nor a pointer" }
-    type (thytype(8, :, 4) :: arg
+    type (thytype(8, :, 4)) :: arg
   end subroutine
   subroutine foobar(arg)            ! OK
-    type (thytype(8, *, 4) :: arg
+    type (thytype(8, *, 4)) :: arg
   end subroutine
 end
Index: gcc/testsuite/gfortran.dg/assumed_type_2.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/assumed_type_2.f90 b/gcc/testsuite/gfortran.dg/assumed_type_2.f90
--- a/gcc/testsuite/gfortran.dg/assumed_type_2.f90	(revision 278653)
+++ b/gcc/testsuite/gfortran.dg/assumed_type_2.f90	(revision 278653)
@@ -157,7 +157,7 @@
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) array_class_t1_alloc._data.data" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_scalar .\\(struct t1 .\\) \\(array_class_t1_ptr._data.dat" 1 "original" } }
 
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 3 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(D" 4 "original" } }
 ! { dg-final { scan-tree-dump-times " = _gfortran_internal_pack \\(&parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(&array_int\\)" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(real\\(kind=4\\).0:. . restrict\\) array_real_alloc.data" 1 "original" } }
@@ -166,7 +166,7 @@
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) parm" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t2.0:. . restrict\\) array_t2_alloc.data\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. . restrict\\) array_class_t1_alloc._data.data\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "sub_array_assumed \\(\\(struct t1.0:. .\\) array_class_t1_ptr._data.data\\);" 0 "original" } }
 
 ! { dg-final { scan-tree-dump-times "sub_array_shape \\(&array_real_alloc," 1 "original" } }
 ! { dg-final { scan-tree-dump-times "sub_array_shape \\(&array_char_ptr," 1 "original" } }
Index: gcc/testsuite/gcc.c-torture/execute/20190228-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/execute/20190228-1.c b/gcc/testsuite/gcc.c-torture/execute/20190228-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/execute/20190228-1.c	(revision 278653)
@@ -0,0 +1,16 @@
+/* PR tree-optimization/89536 */
+/* Testcase by Zhendong Su <su@cs.ucdavis.edu> */
+
+int a = 1;
+
+int main (void)
+{
+  a = ~(a && 1); 
+  if (a < -1)
+    a = ~a;
+  
+  if (!a)
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/20190820-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/execute/20190820-1.c b/gcc/testsuite/gcc.c-torture/execute/20190820-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/execute/20190820-1.c	(revision 278653)
@@ -0,0 +1,111 @@
+/* PR rtl-optimization/91347 */
+/* Reported by John David Anglin <danglin@gcc.gnu.org> */
+
+typedef unsigned short __u16;
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+typedef __signed__ long long __s64;
+typedef unsigned long long __u64;
+typedef __u16 u16;
+typedef __s32 s32;
+typedef __u32 u32;
+typedef __u64 u64;
+typedef _Bool bool;
+typedef s32 int32_t;
+typedef u32 uint32_t;
+typedef u64 uint64_t;
+
+char hex_asc_upper[16];
+u16 decpair[100];
+
+static __attribute__ ((noipa)) void
+put_dec_full4 (char *buf, unsigned r)
+{
+ unsigned q;
+ q = (r * 0x147b) >> 19;
+ *((u16 *)buf) = decpair[r - 100*q];
+ buf += 2;
+ *((u16 *)buf) = decpair[q];
+}
+
+static __attribute__ ((noipa)) unsigned
+put_dec_helper4 (char *buf, unsigned x)
+{
+  uint32_t q = (x * (uint64_t)0x346DC5D7) >> 43;
+  put_dec_full4(buf, x - q * 10000);
+  return q;
+}
+
+static __attribute__ ((noipa)) char *
+put_dec (char *buf, unsigned long long n)
+{
+ uint32_t d3, d2, d1, q, h;
+ d1 = ((uint32_t)n >> 16);
+ h = (n >> 32);
+ d2 = (h ) & 0xffff;
+ d3 = (h >> 16);
+ q = 656 * d3 + 7296 * d2 + 5536 * d1 + ((uint32_t)n & 0xffff);
+ q = put_dec_helper4(buf, q);
+ q += 7671 * d3 + 9496 * d2 + 6 * d1;
+ q = put_dec_helper4(buf+4, q);
+ q += 4749 * d3 + 42 * d2;
+ q = put_dec_helper4(buf+8, q);
+ return buf;
+}
+
+struct printf_spec {
+ unsigned int type:8;
+ signed int field_width:24;
+ unsigned int flags:8;
+ unsigned int base:8;
+ signed int precision:16;
+} __attribute__((__packed__));
+
+static __attribute__ ((noipa)) char *
+number (char *buf, char *end, unsigned long long num, struct printf_spec spec)
+{
+
+ char tmp[3 * sizeof(num)] __attribute__((__aligned__(2)));
+ char sign;
+ char locase;
+ int need_pfx = ((spec.flags & 64) && spec.base != 10);
+ int i;
+ bool is_zero = num == 0LL;
+ int field_width = spec.field_width;
+ int precision = spec.precision;
+
+ i = 0;
+ if (num < spec.base)
+  tmp[i++] = hex_asc_upper[num] | locase;
+ else if (spec.base != 10) {
+  int mask = spec.base - 1;
+  int shift = 3;
+  if (spec.base == 16)
+   shift = 4;
+  else
+    __builtin_abort ();
+  do {
+   tmp[i++] = (hex_asc_upper[((unsigned char)num) & mask] | locase);
+   num >>= shift;
+  } while (num);
+ } else {
+  i = put_dec(tmp, num) - tmp;
+ }
+ return buf;
+}
+
+static __attribute__ ((noipa)) char *
+pointer_string (char *buf, char *end, const void *ptr, struct printf_spec spec)
+{
+ spec.base = 16;
+ spec.flags = 0;
+ return number(buf, end, 100, spec);
+}
+
+int
+main (void)
+{
+  struct printf_spec spec;
+  char *s = pointer_string (0, 0, 0, spec);
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/20191023-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/execute/20191023-1.c b/gcc/testsuite/gcc.c-torture/execute/20191023-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/execute/20191023-1.c	(revision 278653)
@@ -0,0 +1,73 @@
+/* PR tree-optimization/92131 */
+/* Testcase by Armin Rigo <arigo@tunes.org> */
+
+long b, c, d, e, f, i;
+char g, h, j, k;
+int *aa;
+
+static void error (void) __attribute__((noipa));
+static void error (void) { __builtin_abort(); }
+
+static void see_me_here (void) __attribute__((noipa));
+static void see_me_here (void) {}
+
+static void aaa (void) __attribute__((noipa));
+static void aaa (void) {}
+
+static void a (void) __attribute__((noipa));
+static void a (void) {
+  long am, ao;
+  if (aa == 0) {
+    aaa();
+    if (j)
+      goto ay;
+  }
+  return;
+ay:
+  aaa();
+  if (k) {
+    aaa();
+    goto az;
+  }
+  return;
+az:
+  if (i)
+    if (g)
+      if (h)
+        if (e)
+          goto bd;
+  return;
+bd:
+  am = 0;
+  while (am < e) {
+    switch (c) {
+    case 8:
+      goto bh;
+    case 4:
+      return;
+    }
+  bh:
+    if (am >= 0)
+      b = -am;
+    ao = am + b;
+    f = ao & 7;
+    if (f == 0)
+      see_me_here();
+    if (ao >= 0)
+      am++;
+    else
+      error();
+  }
+}
+
+int main (void)
+{
+    j++;
+    k++;
+    i++;
+    g++;
+    h++;
+    e = 1;
+    a();
+    return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr91450-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr91450-1.c b/gcc/testsuite/gcc.c-torture/execute/pr91450-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/execute/pr91450-1.c	(revision 278653)
@@ -0,0 +1,88 @@
+/* PR middle-end/91450 */
+
+__attribute__((noipa)) unsigned long long
+foo (int a, int b)
+{
+  unsigned long long r;
+  if (!__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  return r;
+}
+
+__attribute__((noipa)) unsigned long long
+bar (int a, int b)
+{
+  unsigned long long r;
+  if (a >= 0)
+    return 0;
+  if (!__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  return r;
+}
+
+__attribute__((noipa)) unsigned long long
+baz (int a, int b)
+{
+  unsigned long long r;
+  if (b >= 0)
+    return 0;
+  if (!__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  return r;
+}
+
+__attribute__((noipa)) unsigned long long
+qux (int a, int b)
+{
+  unsigned long long r;
+  if (a >= 0)
+    return 0;
+  if (b < 0)
+    return 0;
+  if (!__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  return r;
+}
+
+__attribute__((noipa)) unsigned long long
+quux (int a, int b)
+{
+  unsigned long long r;
+  if (a < 0)
+    return 0;
+  if (b >= 0)
+    return 0;
+  if (!__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  return r;
+}
+
+int
+main ()
+{
+  if (foo (-4, 2) != -8ULL)
+    __builtin_abort ();
+  if (foo (2, -4) != -8ULL)
+    __builtin_abort ();
+  if (bar (-4, 2) != -8ULL)
+    __builtin_abort ();
+  if (baz (2, -4) != -8ULL)
+    __builtin_abort ();
+  if (qux (-4, 2) != -8ULL)
+    __builtin_abort ();
+  if (quux (2, -4) != -8ULL)
+    __builtin_abort ();
+  if (foo (-2, 1) != -2ULL)
+    __builtin_abort ();
+  if (foo (1, -2) != -2ULL)
+    __builtin_abort ();
+  if (bar (-2, 1) != -2ULL)
+    __builtin_abort ();
+  if (baz (1, -2) != -2ULL)
+    __builtin_abort ();
+  if (qux (-2, 1) != -2ULL)
+    __builtin_abort ();
+  if (quux (1, -2) != -2ULL)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr91137.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr91137.c b/gcc/testsuite/gcc.c-torture/execute/pr91137.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/execute/pr91137.c	(revision 278653)
@@ -0,0 +1,34 @@
+long long a;
+unsigned b;
+int c[70];
+int d[70][70];
+int e;
+
+__attribute__ ((noinline)) void f(long long *g, int p2) {
+  *g = p2;
+}
+
+__attribute__ ((noinline)) void fn2() {
+  for (int j = 0; j < 70; j++) {
+    for (int i = 0; i < 70; i++) {
+      if (b)
+        c[i] = 0;
+      for (int l = 0; l < 70; l++)
+        d[i][1] = d[l][i];
+    }
+    for (int k = 0; k < 70; k++)
+      e = c[0];
+  }
+}
+
+int main() {
+  b = 5;
+  for (int j = 0; j < 70; ++j)
+    c[j] = 2075593088;
+  fn2();
+  f(&a, e);
+  if (a)
+    __builtin_abort();
+  return 0;
+}
+
Index: gcc/testsuite/gcc.c-torture/execute/pr90949.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr90949.c b/gcc/testsuite/gcc.c-torture/execute/pr90949.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/execute/pr90949.c	(revision 278653)
@@ -0,0 +1,42 @@
+void __attribute__ ((noipa, noinline)) my_puts (const char *str) { }
+
+void __attribute__ ((noipa, noinline)) my_free (void *p) { }
+
+
+struct Node
+{
+  struct Node *child;
+};
+
+struct Node space[2] = { };
+
+struct Node * __attribute__ ((noipa, noinline)) my_malloc (int bytes)
+{
+  return &space[0];
+}
+
+void
+walk (struct Node *module, int cleanup)
+{
+  if (module == 0)
+    {
+      return;
+    }
+  if (!cleanup)
+    {
+      my_puts ("No cleanup");
+    }
+  walk (module->child, cleanup);
+  if (cleanup)
+    {
+      my_free (module);
+    }
+}
+
+int
+main ()
+{
+  struct Node *node = my_malloc (sizeof (struct Node));
+  node->child = 0;
+  walk (node, 1);
+}
Index: gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp b/gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp
--- a/gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp	(revision 278653)
+++ b/gcc/testsuite/gcc.c-torture/execute/builtins/builtins.exp	(revision 278653)
@@ -37,7 +37,7 @@
 torture-init
 set-torture-options $C_TORTURE_OPTIONS {{}} $LTO_TORTURE_OPTIONS
 
-set additional_flags "-fno-tree-loop-distribute-patterns -fno-tracer"
+set additional_flags "-fno-tree-loop-distribute-patterns -fno-tracer -fno-ipa-ra"
 if [istarget "powerpc-*-darwin*"] {
    lappend additional_flags "-Wl,-multiply_defined,suppress"
 }
Index: gcc/testsuite/gcc.c-torture/execute/20190901-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/execute/20190901-1.c b/gcc/testsuite/gcc.c-torture/execute/20190901-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/execute/20190901-1.c	(revision 278653)
@@ -0,0 +1,36 @@
+/* PR target/91472 */
+/* Reported by John Paul Adrian Glaubitz <glaubitz@physik.fu-berlin.de> */
+
+typedef unsigned int gmp_uint_least32_t;
+
+union ieee_double_extract
+{
+  struct
+    {
+      gmp_uint_least32_t sig:1;
+      gmp_uint_least32_t exp:11;
+      gmp_uint_least32_t manh:20;
+      gmp_uint_least32_t manl:32;
+    } s;
+  double d;
+};
+
+double __attribute__((noipa))
+tests_infinity_d (void)
+{
+  union ieee_double_extract x;
+  x.s.exp = 2047;
+  x.s.manl = 0;
+  x.s.manh = 0;
+  x.s.sig = 0;
+  return x.d;
+}
+
+int
+main (void)
+{
+  double x = tests_infinity_d ();
+  if (x == 0.0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr91450-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr91450-2.c b/gcc/testsuite/gcc.c-torture/execute/pr91450-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/execute/pr91450-2.c	(revision 278653)
@@ -0,0 +1,76 @@
+/* PR middle-end/91450 */
+
+__attribute__((noipa)) void
+foo (int a, int b)
+{
+  unsigned long long r;
+  if (__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  if (r != 0)
+    __builtin_abort ();
+}
+
+__attribute__((noipa)) void
+bar (int a, int b)
+{
+  unsigned long long r;
+  if (a >= 0)
+    return;
+  if (__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  if (r != 0)
+    __builtin_abort ();
+}
+
+__attribute__((noipa)) void
+baz (int a, int b)
+{
+  unsigned long long r;
+  if (b >= 0)
+    return;
+  if (__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  if (r != 0)
+    __builtin_abort ();
+}
+
+__attribute__((noipa)) void
+qux (int a, int b)
+{
+  unsigned long long r;
+  if (a >= 0)
+    return;
+  if (b < 0)
+    return;
+  if (__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  if (r != 0)
+    __builtin_abort ();
+}
+
+__attribute__((noipa)) void
+quux (int a, int b)
+{
+  unsigned long long r;
+  if (a < 0)
+    return;
+  if (b >= 0)
+    return;
+  if (__builtin_mul_overflow (a, b, &r))
+    __builtin_abort ();
+  if (r != 0)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  foo (-4, 0);
+  foo (0, -4);
+  foo (0, 0);
+  bar (-4, 0);
+  baz (0, -4);
+  qux (-4, 0);
+  quux (0, -4);
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89703-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr89703-2.c b/gcc/testsuite/gcc.c-torture/compile/pr89703-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/compile/pr89703-2.c	(revision 278653)
@@ -0,0 +1,13 @@
+/* PR tree-optimization/89703 */
+
+typedef __SIZE_TYPE__ size_t;
+extern void *memcpy (void *, const void *, size_t);
+extern char *strlen (const char *);
+extern char c[2];
+
+void
+foo (char **q)
+{
+  memcpy (c, "a", 2);
+  q[0] = strlen (c);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89998-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr89998-2.c b/gcc/testsuite/gcc.c-torture/compile/pr89998-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/compile/pr89998-2.c	(revision 278653)
@@ -0,0 +1,4 @@
+/* PR tree-optimization/89998 */
+/* { dg-additional-options "-fno-printf-return-value" } */
+
+#include "pr89998-1.c"
Index: gcc/testsuite/gcc.c-torture/compile/pr90139.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr90139.c b/gcc/testsuite/gcc.c-torture/compile/pr90139.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/compile/pr90139.c	(revision 278653)
@@ -0,0 +1,20 @@
+/* PR middle-end/90139 */
+
+typedef float __attribute__((vector_size (sizeof (float)))) V;
+void bar (int, V *);
+int l;
+
+void
+foo (void)
+{
+  V n, b, o;
+  while (1)
+    switch (l)
+      {
+      case 0:
+	o = n;
+	n = b;
+	b = o;
+	bar (1, &o);
+      }
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr72802.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr72802.c b/gcc/testsuite/gcc.c-torture/compile/pr72802.c
--- a/gcc/testsuite/gcc.c-torture/compile/pr72802.c	(revision 278653)
+++ b/gcc/testsuite/gcc.c-torture/compile/pr72802.c	(revision 278653)
@@ -1,3 +1,4 @@
+/* { dg-skip-if "see PR trail" { *-*-darwin* } } */
 static a[];
 static b, h, m, n, o, p, q, t, u, v, t5, t6, t16, t17, t18, t25;
 c;
Index: gcc/testsuite/gcc.c-torture/compile/pr91001.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr91001.c b/gcc/testsuite/gcc.c-torture/compile/pr91001.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/compile/pr91001.c	(revision 278653)
@@ -0,0 +1,31 @@
+/* PR middle-end/91001 */
+/* PR middle-end/91105 */
+/* PR middle-end/91106 */
+
+struct __attribute__((packed)) S { short b; char c; };
+struct T { short b, c, d; };
+struct __attribute__((packed)) R { int b; char c; };
+union __attribute__((aligned(128), transparent_union)) U { struct S c; } u;
+union __attribute__((aligned(32), transparent_union)) V { struct T c; } v;
+union __attribute__((aligned(32), transparent_union)) W { struct R c; } w;
+void foo (union U);
+void bar (union V);
+void baz (union W);
+
+void
+qux (void)
+{
+  foo (u);
+}
+
+void
+quux (void)
+{
+  bar (v);
+}
+
+void
+corge (void)
+{
+  baz (w);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89663-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr89663-1.c b/gcc/testsuite/gcc.c-torture/compile/pr89663-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/compile/pr89663-1.c	(revision 278653)
@@ -0,0 +1,81 @@
+/* PR middle-end/89663 */
+
+int irint ();
+long lrint ();
+long long llrint ();
+int iround ();
+long lround ();
+long long llround ();
+int iceil ();
+long lceil ();
+long long llceil ();
+int ifloor ();
+long lfloor ();
+long long llfloor ();
+int irintf ();
+long lrintf ();
+long long llrintf ();
+int iroundf ();
+long lroundf ();
+long long llroundf ();
+int iceilf ();
+long lceilf ();
+long long llceilf ();
+int ifloorf ();
+long lfloorf ();
+long long llfloorf ();
+int irintl ();
+long lrintl ();
+long long llrintl ();
+int iroundl ();
+long lroundl ();
+long long llroundl ();
+int iceill ();
+long lceill ();
+long long llceill ();
+int ifloorl ();
+long lfloorl ();
+long long llfloorl ();
+
+void
+foo (long long *p)
+{
+  int n = 0;
+#define T(f) p[n++] = f (1);
+  T (irint)
+  T (lrint)
+  T (llrint)
+  T (iround)
+  T (lround)
+  T (llround)
+  T (iceil)
+  T (lceil)
+  T (llceil)
+  T (ifloor)
+  T (lfloor)
+  T (llfloor)
+  T (irintf)
+  T (lrintf)
+  T (llrintf)
+  T (iroundf)
+  T (lroundf)
+  T (llroundf)
+  T (iceilf)
+  T (lceilf)
+  T (llceilf)
+  T (ifloorf)
+  T (lfloorf)
+  T (llfloorf)
+  T (irintl)
+  T (lrintl)
+  T (llrintl)
+  T (iroundl)
+  T (lroundl)
+  T (llroundl)
+  T (iceill)
+  T (lceill)
+  T (llceill)
+  T (ifloorl)
+  T (lfloorl)
+  T (llfloorl)
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr90840.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr90840.c b/gcc/testsuite/gcc.c-torture/compile/pr90840.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/compile/pr90840.c	(revision 278653)
@@ -0,0 +1,19 @@
+/* PR middle-end/90840 */
+struct S { long long a; int b; };
+struct S foo (void);
+struct __attribute__((packed)) T { long long a; char b; };
+struct T baz (void);
+
+void
+bar (void)
+{
+  _Complex long double c;
+  *(struct S *) &c = foo ();
+}
+
+void
+qux (void)
+{
+  _Complex long double c;
+  *(struct T *) &c = baz ();
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89703-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr89703-1.c b/gcc/testsuite/gcc.c-torture/compile/pr89703-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/compile/pr89703-1.c	(revision 278653)
@@ -0,0 +1,13 @@
+/* PR tree-optimization/89703 */
+
+typedef __SIZE_TYPE__ size_t;
+extern char *strlen (const char *);
+extern char *strnlen (const char *, size_t);
+extern char c[2];
+
+void
+foo (char **q)
+{
+  q[0] = strlen (c);
+  q[1] = strnlen (c, 2);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89655.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr89655.c b/gcc/testsuite/gcc.c-torture/compile/pr89655.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/compile/pr89655.c	(revision 278653)
@@ -0,0 +1,15 @@
+/* PR middle-end/89655 */
+
+int a, b, d;
+char *c;
+
+void
+foo (void)
+{
+  int f = a;
+  for (;;)
+    {
+      for (f = 0; f < (a > 3 ? : a); f++)
+	b = c[f] ? c[(f + 2 > a - 1 ? a - 1 : 2) * d] : 0;
+    }
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89998-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr89998-1.c b/gcc/testsuite/gcc.c-torture/compile/pr89998-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/compile/pr89998-1.c	(revision 278653)
@@ -0,0 +1,42 @@
+/* PR tree-optimization/89998 */
+
+unsigned int sprintf (char *str, const char *fmt, ...);
+unsigned int snprintf (char *str, __SIZE_TYPE__ len, const char *fmt, ...);
+
+int
+f1 (char *s)
+{
+  return sprintf (s, "foo");
+}
+
+int
+f2 (char *s)
+{
+  return sprintf (s, "%d", 123);
+}
+
+int
+f3 (int *p, char *s)
+{
+  const char *t = "bar";
+  return sprintf (s, "%s", t);
+}
+
+int
+f4 (char *s)
+{
+  return snprintf (s, 8, "foo");
+}
+
+int
+f5 (char *s)
+{
+  return snprintf (s, 8, "%d", 123);
+}
+
+int
+f6 (int *p, char *s)
+{
+  const char *t = "bar";
+  return snprintf (s, 8, "%s", t);
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89412.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr89412.c b/gcc/testsuite/gcc.c-torture/compile/pr89412.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/compile/pr89412.c	(revision 278653)
@@ -0,0 +1,16 @@
+/* PR middle-end/89412 */
+
+struct S { double a, b; } d;
+int e;
+double f;
+
+void
+foo ()
+{
+  _Complex double h;
+  while (e)
+    {
+      f = h;
+      *(struct S *) &h = d;
+    }
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr92056.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr92056.c b/gcc/testsuite/gcc.c-torture/compile/pr92056.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/compile/pr92056.c	(revision 278653)
@@ -0,0 +1,18 @@
+/* PR tree-optimization/92056 */
+
+const char *d;
+
+void
+foo (int c, char *e, const char *a, const char *b)
+{
+  switch (c)
+    {
+    case 33:
+      for (;; d++)
+        if (__builtin_strcmp (b ? : "", d))
+          return;
+      break;
+    case 4:
+      __builtin_sprintf (e, a);
+    }
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr89663-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr89663-2.c b/gcc/testsuite/gcc.c-torture/compile/pr89663-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/compile/pr89663-2.c	(revision 278653)
@@ -0,0 +1,82 @@
+/* PR middle-end/89663 */
+
+int irint (double);
+long lrint (double);
+long long llrint (double);
+int iround (double);
+long lround (double);
+long long llround (double);
+int iceil (double);
+long lceil (double);
+long long llceil (double);
+int ifloor (double);
+long lfloor (double);
+long long llfloor (double);
+int irintf (float);
+long lrintf (float);
+long long llrintf (float);
+int iroundf (float);
+long lroundf (float);
+long long llroundf (float);
+int iceilf (float);
+long lceilf (float);
+long long llceilf (float);
+int ifloorf (float);
+long lfloorf (float);
+long long llfloorf (float);
+int irintl (long double);
+long lrintl (long double);
+long long llrintl (long double);
+int iroundl (long double);
+long lroundl (long double);
+long long llroundl (long double);
+int iceill (long double);
+long lceill (long double);
+long long llceill (long double);
+int ifloorl (long double);
+long lfloorl (long double);
+long long llfloorl (long double);
+
+void
+foo (long long *p)
+{
+  int (*fn) (int);
+  int n = 0;
+#define T(f) fn = (int (*) (int)) f; p[n++] = fn (1);
+  T (irint)
+  T (lrint)
+  T (llrint)
+  T (iround)
+  T (lround)
+  T (llround)
+  T (iceil)
+  T (lceil)
+  T (llceil)
+  T (ifloor)
+  T (lfloor)
+  T (llfloor)
+  T (irintf)
+  T (lrintf)
+  T (llrintf)
+  T (iroundf)
+  T (lroundf)
+  T (llroundf)
+  T (iceilf)
+  T (lceilf)
+  T (llceilf)
+  T (ifloorf)
+  T (lfloorf)
+  T (llfloorf)
+  T (irintl)
+  T (lrintl)
+  T (llrintl)
+  T (iroundl)
+  T (lroundl)
+  T (llroundl)
+  T (iceill)
+  T (lceill)
+  T (llceill)
+  T (ifloorl)
+  T (lfloorl)
+  T (llfloorl)
+}
Index: gcc/testsuite/gcc.c-torture/compile/20191108-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/compile/20191108-1.c b/gcc/testsuite/gcc.c-torture/compile/20191108-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/compile/20191108-1.c	(revision 278653)
@@ -0,0 +1,14 @@
+/* PR target/92095 */
+/* Testcase by Sergei Trofimovich <slyfox@inbox.ru> */
+
+typedef union {
+  double a;
+  int b[2];
+} c;
+
+double d(int e)
+{
+  c f;
+  (&f)->b[0] = 15728640;
+  return e ? -(&f)->a : (&f)->a;
+}
Index: gcc/testsuite/gnat.dg/unchecked_convert13.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/unchecked_convert13.adb b/gcc/testsuite/gnat.dg/unchecked_convert13.adb
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/unchecked_convert13.adb	(revision 278653)
@@ -0,0 +1,30 @@
+-- { dg-do compile }
+
+with Ada.Unchecked_Conversion;
+
+procedure Unchecked_Convert13 is
+
+  type B16_T is mod 2 ** 16;
+  for B16_T'Size use 16;
+  for B16_T'Alignment use 1;
+
+  type Rec_T is record
+    A : Short_Integer;
+  end record;
+  for Rec_T use record
+    A at 0 range 0 .. 15;
+  end record;
+  for Rec_T'Size use 16;
+
+  Rec : constant Rec_T := (A => 0);
+
+  function Rec_To_B16 is new Ada.Unchecked_Conversion (Rec_T, B16_T);
+
+  procedure Nested (B16 : B16_T) is
+  begin
+    null;
+  end;
+
+begin
+  Nested (Rec_To_B16 (Rec));
+end;
Index: gcc/testsuite/gnat.dg/opt77.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/opt77.adb b/gcc/testsuite/gnat.dg/opt77.adb
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/opt77.adb	(revision 278653)
@@ -0,0 +1,14 @@
+-- { dg-do run }
+-- { dg-options "-O -fno-inline" }
+
+with Opt77_Pkg; use Opt77_Pkg;
+
+procedure Opt77 is
+  N : Natural := 0;
+  To_Add : Boolean;
+begin
+  Proc ("One", N, To_Add);
+  if To_Add then
+    raise Program_Error;
+  end if;
+end;
Index: gcc/testsuite/gnat.dg/opt78.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/opt78.adb b/gcc/testsuite/gnat.dg/opt78.adb
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/opt78.adb	(revision 278653)
@@ -0,0 +1,16 @@
+-- { dg-do compile }
+-- { dg-options "-O" }
+
+package body Opt78 is
+
+   procedure Proc (P : UC; Msg : String) is
+      Default : UC := (1, "!");
+   begin
+      if P = Default then
+         raise Program_Error;
+      else
+         raise Constraint_Error;
+      end if;
+   end;
+
+end Opt78;
Index: gcc/testsuite/gnat.dg/opt78.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/opt78.ads b/gcc/testsuite/gnat.dg/opt78.ads
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/opt78.ads	(revision 278653)
@@ -0,0 +1,13 @@
+package Opt78 is
+
+   subtype Reasonable is Integer range 1..10;
+
+   type UC (D: Reasonable := 2) is record
+      S: String (1 .. D) := "Hi";
+   end record;
+
+   type AUC is access all UC;
+
+   procedure Proc (P : UC; Msg : String);
+
+end Opt78;
Index: gcc/testsuite/gnat.dg/opt79.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/opt79.adb b/gcc/testsuite/gnat.dg/opt79.adb
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/opt79.adb	(revision 278653)
@@ -0,0 +1,28 @@
+-- { dg-do compile }
+-- { dg-options "-O" }
+
+package body Opt79 is
+
+  function F (I : Integer) return Arr is
+    A : Arr;
+
+    procedure Nested is
+
+      procedure Inner is
+      begin
+        A (1) := 0;
+      end;
+
+    begin
+       Inner;
+    end;
+
+  begin
+    Nested;
+    for J in A'Range loop
+      A (J) := I;
+    end loop;
+    return A;
+  end;
+
+end Opt79;
Index: gcc/testsuite/gnat.dg/opt79.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/opt79.ads b/gcc/testsuite/gnat.dg/opt79.ads
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/opt79.ads	(revision 278653)
@@ -0,0 +1,7 @@
+package Opt79 is
+
+  type Arr is array (1 .. 8) of Integer;
+
+  function F (I : Integer) return Arr;
+
+end Opt79;
Index: gcc/testsuite/gnat.dg/opt77_pkg.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/opt77_pkg.adb b/gcc/testsuite/gnat.dg/opt77_pkg.adb
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/opt77_pkg.adb	(revision 278653)
@@ -0,0 +1,28 @@
+package body Opt77_Pkg is
+
+  function Compare (S : String) return Boolean is
+  begin
+    return S = "Two";
+  end;
+
+  procedure Proc (S : String; N : in out Natural; To_Add : out Boolean) is
+    To_Take : Boolean := False;
+    To_Read : Boolean := False;
+  begin
+    To_Add := False;
+
+    if S = "One" then
+      To_Read := True;
+      To_Take := Compare (S);
+    end if;
+
+    if To_Read and not To_Take then
+      N := N + 1;
+    end if;
+
+    if To_Take then
+      To_Add := True;
+    end if;
+  end;
+
+end Opt77_Pkg;
Index: gcc/testsuite/gnat.dg/opt77_pkg.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/opt77_pkg.ads b/gcc/testsuite/gnat.dg/opt77_pkg.ads
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/opt77_pkg.ads	(revision 278653)
@@ -0,0 +1,5 @@
+package Opt77_Pkg is
+
+  procedure Proc (S : String; N : in out Natural; To_Add : out Boolean);
+
+end Opt77_Pkg;
Index: gcc/testsuite/gnat.dg/specs/array5_pkg2-g.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/specs/array5_pkg2-g.ads b/gcc/testsuite/gnat.dg/specs/array5_pkg2-g.ads
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/specs/array5_pkg2-g.ads	(revision 278653)
@@ -0,0 +1,13 @@
+with System.Address_To_Access_Conversions;
+
+generic
+
+  type T is new Root with private;
+
+package Array5_Pkg2.G is
+
+  package Ptr is new System.Address_To_Access_Conversions (T);
+
+  Data : Ptr.Object_Pointer;
+
+end Array5_Pkg2.G;
Index: gcc/testsuite/gnat.dg/specs/array5_pkg2.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/specs/array5_pkg2.ads b/gcc/testsuite/gnat.dg/specs/array5_pkg2.ads
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/specs/array5_pkg2.ads	(revision 278653)
@@ -0,0 +1,5 @@
+package Array5_Pkg2 is
+
+  type Root is tagged null record;
+
+end Array5_Pkg2;
Index: gcc/testsuite/gnat.dg/specs/array5.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/specs/array5.ads b/gcc/testsuite/gnat.dg/specs/array5.ads
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/specs/array5.ads	(revision 278653)
@@ -0,0 +1,9 @@
+-- { dg-do compile }
+
+with Array5_Pkg1; use Array5_Pkg1;
+
+package Array5 is
+
+  C : constant Integer := Arr'Last;
+
+end Array5;
Index: gcc/testsuite/gnat.dg/specs/array5_pkg1.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/specs/array5_pkg1.ads b/gcc/testsuite/gnat.dg/specs/array5_pkg1.ads
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/specs/array5_pkg1.ads	(revision 278653)
@@ -0,0 +1,14 @@
+with Array5_Pkg2; use Array5_Pkg2;
+with Array5_Pkg2.G;
+
+package Array5_Pkg1 is
+
+  type Derived is new Root with record
+    N : Integer;
+  end record;
+
+  package My_G is new Array5_Pkg2.G (Derived);
+
+  type Arr is array (1 .. My_G.Data.N) of Integer;
+
+end Array5_Pkg1;
Index: gcc/testsuite/gnat.dg/specs/array4.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/specs/array4.ads b/gcc/testsuite/gnat.dg/specs/array4.ads
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/specs/array4.ads	(revision 278653)
@@ -0,0 +1,17 @@
+-- { dg-do compile }
+-- { dg-skip-if "missing -gsplit-dwarf support" { *-*-darwin* } }
+-- { dg-options "-gsplit-dwarf" }
+
+package Array4 is
+
+  type Arr1 is array (Positive range <>) of Boolean;
+
+  Size : Positive := 20;
+
+  type Rec is record
+    A : Arr1 (1 .. Size);
+  end record;
+
+  type Arr2 is array (Positive range <>) of Rec;
+
+end Array4;
Index: gcc/testsuite/gcc.dg/darwin-minversion-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/darwin-minversion-2.c b/gcc/testsuite/gcc.dg/darwin-minversion-2.c
--- a/gcc/testsuite/gcc.dg/darwin-minversion-2.c	(revision 278653)
+++ b/gcc/testsuite/gcc.dg/darwin-minversion-2.c	(revision 278653)
@@ -1,6 +1,6 @@
 /* Basic test for -mmacosx-version-min switch on Darwin.  */
 /* { dg-options "-mmacosx-version-min=10.1 -mmacosx-version-min=10.5" } */
-/* { dg-do run { target *-*-darwin* } } */
+/* { dg-do compile { target *-*-darwin* } } */
 
 int
 main ()
Index: gcc/testsuite/gcc.dg/pr90756.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr90756.c b/gcc/testsuite/gcc.dg/pr90756.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr90756.c	(revision 278653)
@@ -0,0 +1,26 @@
+/* PR rtl-optimization/90756 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wno-psabi" } */
+/* { dg-additional-options "-mno-sse" { target ia32 } } */
+
+typedef float B __attribute__((vector_size(4 * sizeof (float))));
+typedef unsigned long long C __attribute__((vector_size(4 * sizeof (long long))));
+typedef short D __attribute__((vector_size(4 * sizeof (short))));
+B z;
+void foo (C);
+C bar (D);
+B baz ();
+D qux (B);
+
+void
+quux (int x)
+{
+  B n = z, b = z;
+  while (1)
+    switch (x)
+      {
+      case 0: n = baz (); /* FALLTHRU */
+      case 1: { B o = n; n = b; b = o; } /* FALLTHRU */
+      case 2: { D u = qux (b); C v = bar (u); foo (v); }
+      }
+}
Index: gcc/testsuite/gcc.dg/darwin-weakimport-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/darwin-weakimport-3.c b/gcc/testsuite/gcc.dg/darwin-weakimport-3.c
--- a/gcc/testsuite/gcc.dg/darwin-weakimport-3.c	(revision 278653)
+++ b/gcc/testsuite/gcc.dg/darwin-weakimport-3.c	(revision 278653)
@@ -1,5 +1,20 @@
 /* { dg-do compile { target *-*-darwin* } } */
-/* { dg-options "-fno-asynchronous-unwind-tables" } */
+
+/* Here we want to test if "foo" gets placed into a coalesced
+   section (it should not).
+
+   However, for i386, and PIC code we have a "get_pc thunk" that
+   is (correctly) placed in a coalesced section when using an older
+   linker - also unwind tables are emitted into coalesced.
+
+   With modern linkers this is moot, since even weak symbols
+   are emitted into the regular sections.
+
+   To avoid the unwind tables -fno-asynchronous-unwind-tables.
+   To ensure that we emit code for an older linker -mtarget-linker
+   To avoid the get_pc thunk optimise at least O1.  */
+
+/* { dg-options "-fno-asynchronous-unwind-tables -O1 -mtarget-linker 85.2" } */
 /* { dg-require-weak "" } */
 
 /* { dg-final { scan-assembler-not "coalesced" } } */
Index: gcc/testsuite/gcc.dg/gomp/pr89796.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/gomp/pr89796.c b/gcc/testsuite/gcc.dg/gomp/pr89796.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/gomp/pr89796.c	(revision 278653)
@@ -0,0 +1,23 @@
+/* PR c++/89796 */
+/* { dg-do compile } */
+/* { dg-additional-options "-Wunused-value" } */
+
+int
+f1 (int *p)
+{
+  int r;
+  #pragma omp atomic capture		/* { dg-bogus "value computed is not used" } */
+  { r = *p; (*p)++; }
+  return r;
+}
+
+int
+f2 (int *p)
+{
+  int s
+    = ({ int r;
+	 #pragma omp atomic capture	/* { dg-bogus "value computed is not used" } */
+	 { r = *p; (*p)++; }
+	 r; });
+  return s;
+}
Index: gcc/testsuite/gcc.dg/gomp/pr90900.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/gomp/pr90900.c b/gcc/testsuite/gcc.dg/gomp/pr90900.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/gomp/pr90900.c	(revision 278653)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fopenmp -g" } */
+
+void f (int a)
+{
+  void *x = &&lab;
+#pragma omp parallel
+  if (a)
+    { lab: __builtin_unreachable(); }
+  x;
+}
Index: gcc/testsuite/gcc.dg/gomp/pr78884.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/gomp/pr78884.c b/gcc/testsuite/gcc.dg/gomp/pr78884.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/gomp/pr78884.c	(revision 278653)
@@ -0,0 +1,16 @@
+/* PR middle-end/78884 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fopenmp" } */
+
+void bar (int *);
+
+void
+foo (int n)
+{
+#pragma omp simd
+  for (int i = 0; i < 1024; i++)
+    {
+      int vla[n];
+      bar (vla);
+    }
+}
Index: gcc/testsuite/gcc.dg/pr89521-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr89521-1.c b/gcc/testsuite/gcc.dg/pr89521-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr89521-1.c	(revision 278653)
@@ -0,0 +1,13 @@
+/* PR c/89521 */
+/* { dg-do compile } */
+/* { dg-options "-Ofast -w" } */
+
+#define A(name) __typeof (__builtin_##name (0)) name (); long name##1 () { return name (1); }
+#define B(name) A(name) A(name##f) A(name##l)
+B (ceil)
+B (floor)
+B (round)
+B (trunc)
+B (nearbyint)
+B (rint)
+B (logb)
Index: gcc/testsuite/gcc.dg/debug/pr89704.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/debug/pr89704.c b/gcc/testsuite/gcc.dg/debug/pr89704.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/debug/pr89704.c	(revision 278653)
@@ -0,0 +1,14 @@
+/* PR debug/89704 */
+/* { dg-do compile } */
+
+typedef __INTPTR_TYPE__ intptr_t;
+
+int
+foo (void)
+{
+  lab1:;
+  lab2:;
+  static int i = (intptr_t) &&lab1 - (intptr_t) &&lab2;
+  static int j = (intptr_t) &&lab1 - (intptr_t) &&lab2;
+  return i;
+}
Index: gcc/testsuite/gcc.dg/pr89521-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr89521-2.c b/gcc/testsuite/gcc.dg/pr89521-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr89521-2.c	(revision 278653)
@@ -0,0 +1,42 @@
+/* PR c/89521 */
+/* { dg-do compile } */
+/* { dg-options "-Ofast -w" } */
+
+#define A(name) __typeof (__builtin_##name (0)) name (); \
+  float name##1 () { return name (1); } \
+  double name##2 () { return name (1); }
+#define B(name) A(name) A(name##l)
+B (cosh)
+B (exp)
+B (exp10)
+B (exp2)
+B (expm1)
+B (gamma)
+B (j0)
+B (j1)
+B (lgamma)
+B (pow10)
+B (sinh)
+B (tgamma)
+B (y0)
+B (y1)
+B (acos)
+B (acosh)
+B (asin)
+B (asinh)
+B (atan)
+B (atanh)
+B (cbrt)
+B (cos)
+B (erf)
+B (erfc)
+B (log)
+B (log10)
+B (log2)
+B (log1p)
+B (sin)
+B (tan)
+B (tanh)
+B (sqrt)
+B (fabs)
+B (logb)
Index: gcc/testsuite/gcc.dg/Wrestrict-19.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Wrestrict-19.c b/gcc/testsuite/gcc.dg/Wrestrict-19.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/Wrestrict-19.c	(revision 278653)
@@ -0,0 +1,33 @@
+/* PR middle-end/89934 - ICE on a call with fewer arguments to strncpy
+   declared without prototype
+   { dg-do compile }
+   { dg-options "-O2 -Wall" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+char *strncpy ();
+
+char* f0 (char *s)
+{
+  return strncpy ();
+}
+
+char* f1 (char *s)
+{
+  return strncpy (s);
+}
+
+char* f2 (char *s)
+{
+  return strncpy (s, s + 1);   /* ICE here.  */
+}
+
+void f3 (char *s, size_t n, const char *t)
+{
+  strncpy (s, n, t);
+  strncpy (n, s, t);
+}
+
+/* { dg-prune-output "\\\[-Wbuiltin-declaration-mismatch]" }
+   { dg-prune-output "\\\[-Wint-conversion]" } */
+
Index: gcc/testsuite/gcc.dg/pr90082.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr90082.c b/gcc/testsuite/gcc.dg/pr90082.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr90082.c	(revision 278653)
@@ -0,0 +1,13 @@
+/* PR rtl-optimization/90082 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -fnon-call-exceptions -ftrapv" } */
+
+void *buf[5];
+
+void
+foo (int a)
+{
+  if (__builtin_setjmp (buf) == 0)
+    __asm__ ("" : : "n" (a * 2));	/* { dg-error "impossible constraint in 'asm'" } */
+					/* { dg-warning "asm operand 0 probably doesn't match constraints" "" { target *-*-* } .-1 } */
+}
Index: gcc/testsuite/gcc.dg/pr89520-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr89520-1.c b/gcc/testsuite/gcc.dg/pr89520-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr89520-1.c	(revision 278653)
@@ -0,0 +1,13 @@
+/* PR c/89520 */
+/* { dg-do compile } */
+/* { dg-options "-Ofast -w" } */
+
+#define A(name) __typeof (__builtin_##name (0)) name (); long name##1 () { return name (); }
+#define B(name) A(name) A(name##f) A(name##l)
+B (ceil)
+B (floor)
+B (round)
+B (trunc)
+B (nearbyint)
+B (rint)
+B (logb)
Index: gcc/testsuite/gcc.dg/pr90010.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr90010.c b/gcc/testsuite/gcc.dg/pr90010.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr90010.c	(revision 278653)
@@ -0,0 +1,27 @@
+/* PR c++/90010 */
+/* { dg-do compile } */
+/* { dg-options "-Wall" } */
+
+char b[4096] = "abc";
+void bar (char *);
+
+void
+foo ()
+{
+  char d[4096];
+  __builtin_snprintf (d, sizeof d, "%sfoobarbazquxquuxquuzthudfred", b);	/* { dg-warning "'foobarbazquxquuxquuzthudfred' directive output may be truncated writing 28 bytes into a region of size between 1 and 4096" } */
+  /* { dg-message "'__builtin_snprintf' output between 29 and 4124 bytes into a destination of size 4096" "" { target *-*-* } .-1 } */
+  bar (d);
+  __builtin_snprintf (d, sizeof d, "%sfoobarbazquxquuxquuzcorgefred", b);	/* { dg-warning "'foobarbazquxquuxquuzcorgefred' directive output may be truncated writing 29 bytes into a region of size between 1 and 4096" } */
+  /* { dg-message "'__builtin_snprintf' output between 30 and 4125 bytes into a destination of size 4096" "" { target *-*-* } .-1 } */
+  bar (d);
+  __builtin_snprintf (d, sizeof d, "%sfoobarbazquxquuxquuzcorgewaldo", b);	/* { dg-warning "'foobarbazquxquuxquuzcorgewaldo' directive output may be truncated writing 30 bytes into a region of size between 1 and 4096" } */
+  /* { dg-message "'__builtin_snprintf' output between 31 and 4126 bytes into a destination of size 4096" "" { target *-*-* } .-1 } */
+  bar (d);
+  __builtin_snprintf (d, sizeof d, "%sfoobarbazquxquuxquuzcorgegarply", b);	/* { dg-warning "'foobarbazquxquuxquuzcorgegarply' directive output may be truncated writing 31 bytes into a region of size between 1 and 4096" } */
+  /* { dg-message "'__builtin_snprintf' output between 32 and 4127 bytes into a destination of size 4096" "" { target *-*-* } .-1 } */
+  bar (d);
+  __builtin_snprintf (d, sizeof d, "%sfoobarfredquxquuxquuzcorgegarply", b);	/* { dg-warning "'foobarfredquxquuxquuzcorgega\.\.\.' directive output may be truncated writing 32 bytes into a region of size between 1 and 4096" } */
+  /* { dg-message "'__builtin_snprintf' output between 33 and 4128 bytes into a destination of size 4096" "" { target *-*-* } .-1 } */
+  bar (d);
+}
Index: gcc/testsuite/gcc.dg/torture/neon-immediate-timode.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/neon-immediate-timode.c b/gcc/testsuite/gcc.dg/torture/neon-immediate-timode.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/neon-immediate-timode.c	(revision 278653)
@@ -0,0 +1,10 @@
+union a {
+  char b;
+  long long c;
+};
+union a d;
+int g(int, union a, union a);
+void e() {
+  union a f[2] = {-1L};
+  g(0, d, f[0]);
+}
Index: gcc/testsuite/gcc.dg/torture/pr91812.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr91812.c b/gcc/testsuite/gcc.dg/torture/pr91812.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr91812.c	(revision 278653)
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } { "" } } */
+/* { dg-options "-fdump-tree-optimized-blocks" } */
+
+unsigned register1;
+unsigned register2;
+
+void busy_wait_for_register (int x)
+{
+  volatile unsigned* ptr;
+  switch(x) {
+    case 0x1111:
+    ptr = &register1;
+    break;
+
+    case 0x2222:
+    ptr = &register2;
+    break;
+
+    default:
+    return;
+  }
+  while (*ptr) {}
+}
+
+/* { dg-final { scan-tree-dump "loop depth 1" "optimized" } } */
Index: gcc/testsuite/gcc.dg/torture/pr91200.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr91200.c b/gcc/testsuite/gcc.dg/torture/pr91200.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr91200.c	(revision 278653)
@@ -0,0 +1,32 @@
+/* { dg-do compile } */
+
+int printf (const char *, ...);
+
+char a;
+int b, c, **d;
+
+int main ()
+{
+  int f = -128, *g, *h[2] = {0, 0}, i;
+  printf("0");
+  if (a)
+    {
+      while (f > a) {
+        int *j = &i;
+        *j |= 0;
+      }
+      h[i] = &c;
+    }
+  if (h[1])
+    {
+      int **k = &g;
+      *k = &f;
+      while (i)
+        {
+          int **l[] = {&g};
+        }
+      int **m = &g;
+      *d = *m = &b;
+    }
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr90278.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr90278.c b/gcc/testsuite/gcc.dg/torture/pr90278.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr90278.c	(revision 278653)
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-fexceptions -fnon-call-exceptions" } */
+
+double
+hc (void)
+{
+  double dp = 0.0;
+  double ek[1];
+
+  ek[0] = 1.0 / dp < 0.0;
+
+  return ek[0];
+}
Index: gcc/testsuite/gcc.dg/torture/pr89572.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr89572.c b/gcc/testsuite/gcc.dg/torture/pr89572.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr89572.c	(revision 278653)
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-finline-functions" } */
+
+int vh, it, k1;
+
+void
+vn (void)
+{
+  ++vh;
+  if (vh == 0 && it == 0)
+    k1 = -k1;
+}
+
+__attribute__ ((returns_twice)) void
+ef (int *uw)
+{
+  while (uw != (void *) 0)
+    {
+      vn ();
+      *uw = 0;
+    }
+}
+
+void
+gu (int *uw)
+{
+  ef (uw);
+}
Index: gcc/testsuite/gcc.dg/torture/pr90071.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr90071.c b/gcc/testsuite/gcc.dg/torture/pr90071.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr90071.c	(revision 278653)
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+
+int a;
+static int b;
+
+void
+foo ()
+{
+  int d;
+  int e = (int) (__INTPTR_TYPE__) &&f;
+  void *g = &&h;
+h: ++e;
+   if (a)
+     i: goto *g;
+   for (;;)
+     {
+       e = 0;
+       if (b)
+	 goto i;
+     }
+f:
+   goto *({ d || e < 0 || e >= 2; });
+   &e;
+}
Index: gcc/testsuite/gcc.dg/torture/pr91126.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr91126.c b/gcc/testsuite/gcc.dg/torture/pr91126.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr91126.c	(revision 278653)
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+
+struct S
+{
+  __INT32_TYPE__ a : 24;
+  __INT32_TYPE__ b : 8;
+} s;
+
+int
+main()
+{
+  s.a = 0xfefefe;
+  s.b = 0xfe;
+  unsigned char c;
+  c = ((unsigned char *)&s)[0];
+  if (c != 0xfe)
+    __builtin_abort ();
+  c = ((unsigned char *)&s)[1];
+  if (c != 0xfe)
+    __builtin_abort ();
+  c = ((unsigned char *)&s)[2];
+  if (c != 0xfe)
+    __builtin_abort ();
+  c = ((unsigned char *)&s)[3];
+  if (c != 0xfe)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr90328.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr90328.c b/gcc/testsuite/gcc.dg/torture/pr90328.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr90328.c	(revision 278653)
@@ -0,0 +1,24 @@
+/* { dg-do run } */
+
+void g(int*__restrict x, int*y)
+{
+  *x = *y;
+}
+
+void __attribute__((noipa)) f(int* a,int* b)
+{
+  for(int i=0;i<1024;++i)
+    g(a+i,b+i);
+}
+
+int main()
+{
+  int x[1025];
+  for (int i = 0; i < 1025; ++i)
+    x[i] = i+1;
+  f(x+1, x);
+  for (int i = 0; i < 1025; ++i)
+    if (x[i] != 1)
+      __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr89091.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr89091.c b/gcc/testsuite/gcc.dg/torture/pr89091.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr89091.c	(revision 278653)
@@ -0,0 +1,10 @@
+/* PR middle-end/89091 */
+/* { dg-do compile { target int128 } } */
+
+struct S { unsigned __int128 s : 65; };
+
+int
+foo (struct S *x, int y)
+{
+  return y && x->s;
+}
Index: gcc/testsuite/gcc.dg/torture/restrict-7.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/restrict-7.c b/gcc/testsuite/gcc.dg/torture/restrict-7.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/restrict-7.c	(revision 278653)
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+
+extern void abort (void);
+
+static inline __attribute__((always_inline)) void
+copy(int *restrict a, int *restrict b)
+{
+  *b = *a;
+  *a = 7;
+}
+
+void __attribute__((noinline))
+floppy(int mat[static 2], unsigned idxs[static 3])
+{
+  for (int i = 0; i < 3; i++)
+    copy(&mat[i%2], &mat[idxs[i]]);
+}
+
+int main()
+{
+  int mat[2] = {10, 20};
+  unsigned idxs[3] = {1, 0, 1};
+  floppy(mat, idxs);
+  if (mat[0] != 7 || mat[1] != 10)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr89595.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr89595.c b/gcc/testsuite/gcc.dg/torture/pr89595.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr89595.c	(revision 278653)
@@ -0,0 +1,39 @@
+/* { dg-do run } */
+/* { dg-additional-options "-fgimple" } */
+
+int __attribute__((noipa))
+__GIMPLE(startwith("dom")) bar(int cond, int val)
+{
+  int i;
+
+  if (0 != 0)
+    goto bb_6;
+  else
+    goto bb_2;
+
+bb_2:
+  if (cond_5(D) != 0)
+    goto bb_4;
+  else
+    goto bb_5;
+
+bb_4:
+  i_6 = val_2(D);
+  i_1 = val_2(D) > 0 ? i_6 : 0;
+
+bb_5:
+  i_3 = __PHI (bb_4: i_1, bb_2: 0);
+  return i_3;
+
+bb_6:
+  i_4 = 1;
+  i_9 = 2;
+  goto bb_2;
+}
+
+int main()
+{
+  if (bar (1, 1) != 1)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr89677.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr89677.c b/gcc/testsuite/gcc.dg/torture/pr89677.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr89677.c	(revision 278653)
@@ -0,0 +1,15 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target int32plus } */
+
+int a, b, d;
+unsigned c;
+float e, f, g;
+void h() {
+    float *i = &g;
+    for (; c < 10; c += 3)
+      for (; d; d += 3) {
+	  a = *i;
+	  g = f + 0;
+	  f = b + *i + (b - e + 305219) + -b + 3;
+      }
+}
Index: gcc/testsuite/gcc.dg/torture/pr89505.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr89505.c b/gcc/testsuite/gcc.dg/torture/pr89505.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr89505.c	(revision 278653)
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+
+struct S { int i; void *p; int j; };
+int a;
+int __attribute__((noinline))
+foo (struct S * __restrict p, int q)
+{
+  int *x = &p->j;
+  if (q)
+    x = &a;
+  p->j = 1;
+  *x = 2;
+  return p->j;
+}
+
+int main()
+{
+  struct S s;
+  if (foo (&s, 0) != 2)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr90020.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr90020.c b/gcc/testsuite/gcc.dg/torture/pr90020.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr90020.c	(revision 278653)
@@ -0,0 +1,29 @@
+/* { dg-do run } */
+/* { dg-require-weak "" } */
+/* { dg-additional-options "-Wl,-undefined,dynamic_lookup" { target *-*-darwin* } } */
+/* { dg-additional-options "-Wl,-flat_namespace" { target *-*-darwin[89]* } } */
+
+void __attribute__((noinline,noclone))
+check (int i)
+{
+  if (i == 0)
+    __builtin_exit (0);
+}
+
+int i;
+extern int x __attribute__((weak));
+
+int main(int argc, char **argv)
+{
+  if (argc)
+    {
+      check (i);
+      return x;
+    }
+  else
+    {
+      check (i);
+      return x-1;
+    }
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr89710.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr89710.c b/gcc/testsuite/gcc.dg/torture/pr89710.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr89710.c	(revision 278653)
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+
+void
+gm (int *);
+
+__attribute__ ((returns_twice)) void
+jg (void)
+{
+}
+
+void
+eb (void)
+{
+  int r6 = 0;
+
+  if (r6 != 0)
+    gm (&r6);
+}
+
+void
+gm (int *r6)
+{
+  jg ();
+
+  for (;;)
+    {
+      eb ();
+      *r6 = 0;
+    }
+}
Index: gcc/testsuite/gcc.dg/uninit-pr89296.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/uninit-pr89296.c b/gcc/testsuite/gcc.dg/uninit-pr89296.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/uninit-pr89296.c	(revision 278653)
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wuninitialized" } */
+
+int get_a_value ();
+void printk(const char *);
+void test_func()
+{
+    int loop;
+    while (!loop) {             /* { dg-warning "is used uninitialized" } */
+	loop = get_a_value();
+	printk("...");
+    }
+}
Index: gcc/testsuite/gcc.dg/ipa/ipcp-5.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/ipa/ipcp-5.c b/gcc/testsuite/gcc.dg/ipa/ipcp-5.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/ipa/ipcp-5.c	(revision 278653)
@@ -0,0 +1,45 @@
+/* Test that estimated local cloning time benefit of extern inline functions is
+   zero.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O3 -fdump-ipa-cp -fno-early-inlining"  } */
+/* { dg-add-options bind_pic_locally } */
+
+extern int get_int (void);
+extern void use_stuff (int);
+
+int arr[10];
+
+inline void
+f (int a)
+{
+  arr[0] += a + 5;
+  arr[1] += a + 50;
+  arr[2] += a - 3;
+  arr[3] += a;
+  arr[4] += a + 21;
+  arr[5] += a + 900;
+  arr[6] += a + 2;
+  arr[7] += a + 3456;
+  arr[8] += a + 3;
+  arr[9] += a + 32;
+  use_stuff (a);
+}
+
+
+int
+entry (void)
+{
+  int i;
+  for (i = 0; i < 100; i++)
+    f (7);
+  for (i = 0; i < 100; i++)
+    f (get_int ());
+  return 0;
+}
+
+
+/* { dg-final { scan-ipa-dump "loc_time: 0" "cp" } } */
+/* { dg-final { scan-ipa-dump-not "replacing param.*with const" "cp"  } } */
+
+
Index: gcc/testsuite/gcc.dg/pr88074.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr88074.c b/gcc/testsuite/gcc.dg/pr88074.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr88074.c	(revision 278653)
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+
+#include <complex.h>
+
+int main()
+{
+  _Complex double x;
+  __real x = 3.091e+8;
+  __imag x = -4.045e+8;
+  /* This used to spend huge amounts of compile-time inside mpc.  */
+  volatile _Complex double y = ctan (x);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr89520-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr89520-2.c b/gcc/testsuite/gcc.dg/pr89520-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr89520-2.c	(revision 278653)
@@ -0,0 +1,42 @@
+/* PR c/89520 */
+/* { dg-do compile } */
+/* { dg-options "-Ofast -w" } */
+
+#define A(name) __typeof (__builtin_##name (0)) name (); \
+  float name##1 () { return name (); } \
+  double name##2 () { return name (); }
+#define B(name) A(name) A(name##l)
+B (cosh)
+B (exp)
+B (exp10)
+B (exp2)
+B (expm1)
+B (gamma)
+B (j0)
+B (j1)
+B (lgamma)
+B (pow10)
+B (sinh)
+B (tgamma)
+B (y0)
+B (y1)
+B (acos)
+B (acosh)
+B (asin)
+B (asinh)
+B (atan)
+B (atanh)
+B (cbrt)
+B (cos)
+B (erf)
+B (erfc)
+B (log)
+B (log10)
+B (log2)
+B (log1p)
+B (sin)
+B (tan)
+B (tanh)
+B (sqrt)
+B (fabs)
+B (logb)
Index: gcc/testsuite/gcc.dg/vect/pr91293-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/vect/pr91293-2.c b/gcc/testsuite/gcc.dg/vect/pr91293-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/vect/pr91293-2.c	(revision 278653)
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+/* { dg-additional-options "-msse4.1" { target { sse4_runtime } } } */
+
+long long a;
+unsigned b, c;
+int d = 62;
+void e(long long *f, int p2) { *f = p2; }
+int main()
+{
+  for (int g = 2; g <= d; g++)
+    {
+      c += 5 - g;
+      b += g + 4;
+    }
+  e(&a, b);
+  if (a != 2196)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/vect/pr91665.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/vect/pr91665.c b/gcc/testsuite/gcc.dg/vect/pr91665.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/vect/pr91665.c	(revision 278653)
@@ -0,0 +1,15 @@
+/* PR tree-optimization/91665 */
+/* { dg-do compile } */
+/* { dg-additional-options "-Ofast" } */
+
+short int v;
+
+void
+foo (short int x, short int y)
+{
+  short int *p = &v;
+
+  x = 1;
+  while (x != 0)
+    x += ++y || (*p = x);
+}
Index: gcc/testsuite/gcc.dg/vect/pr81740-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/vect/pr81740-2.c b/gcc/testsuite/gcc.dg/vect/pr81740-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/vect/pr81740-2.c	(revision 278653)
@@ -0,0 +1,25 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vect_int } */
+/* { dg-require-effective-target vect_hw_misalign } */
+
+#include "tree-vect.h"
+
+int a[8][10] = { [2][5] = 4 }, c;
+
+int
+main ()
+{
+  short b;
+  int i, d;
+  check_vect ();
+  for (b = 4; b >= 0; b--)
+    for (c = 6; c >= 0; c--)
+      a[c + 1][b + 2] = a[c][b + 1];
+  for (i = 0; i < 8; i++)
+    for (d = 0; d < 10; d++)
+      if (a[i][d] != (i == 3 && d == 6) * 4)
+	__builtin_abort ();
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump "OUTER LOOP VECTORIZED" "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/pr91293-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/vect/pr91293-1.c b/gcc/testsuite/gcc.dg/vect/pr91293-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/vect/pr91293-1.c	(revision 278653)
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+/* { dg-additional-options "-msse4.1" { target { sse4_runtime } } } */
+
+long long a;
+unsigned b, c;
+int d = 62;
+void e(long long *f, int p2) { *f = p2; }
+int main()
+{
+  for (int g = 2; g <= d; g++)
+    {
+      b += g + 4;
+      c += 5 - g;
+    }
+  e(&a, b);
+  if (a != 2196)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/vect/pr91293-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/vect/pr91293-3.c b/gcc/testsuite/gcc.dg/vect/pr91293-3.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/vect/pr91293-3.c	(revision 278653)
@@ -0,0 +1,20 @@
+/* { dg-do run } */
+/* { dg-additional-options "-msse4.1" { target { sse4_runtime } } } */
+
+long long a;
+unsigned b, c;
+int d = 62;
+void e(long long *f, int p2) { *f = p2; }
+int xx = 5, yy = 4;
+int main()
+{
+  for (int g = 2; g <= d; g++)
+    {
+      c += xx - g;
+      b += yy + g;
+    }
+  e(&a, b);
+  if (a != 2196)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/vect/pr90018.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/vect/pr90018.c b/gcc/testsuite/gcc.dg/vect/pr90018.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/vect/pr90018.c	(revision 278653)
@@ -0,0 +1,47 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vect_double } */
+
+#include "tree-vect.h"
+
+void __attribute__((noinline,noclone))
+foo (double *a4, int n)
+{
+  for (int i = 0; i < n; ++i)
+    {
+      /* We may not apply interleaving to the group (a), (b) because of (c).  */
+      double tem1 = a4[i*4] + a4[i*4+n*4] /* (a) */;
+      double tem2 = a4[i*4+2*n*4+1];
+      a4[i*4+n*4+1] = tem1; /* (c) */
+      a4[i*4+1] = tem2;
+      double tem3 = a4[i*4] - tem2;
+      double tem4 = tem3 + a4[i*4+n*4];
+      a4[i*4+n*4+1] = tem4 + a4[i*4+n*4+1] /* (b) */;
+    }
+}
+int main(int argc, char **argv)
+{
+  int n = 11;
+  double a4[4 * n * 3];
+  double a42[4 * n * 3];
+  check_vect ();
+  for (int i = 0; i < 4 * n * 3; ++i)
+    a4[i] = a42[i] = i;
+  foo (a4, n);
+  for (int i = 0; i < n; ++i)
+    {
+      double tem1 = a42[i*4] + a42[i*4+n*4];
+      double tem2 = a42[i*4+2*n*4+1];
+      a42[i*4+n*4+1] = tem1;
+      a42[i*4+1] = tem2;
+      double tem3 = a42[i*4] - tem2;
+      double tem4 = tem3 + a42[i*4+n*4];
+      a42[i*4+n*4+1] = tem4 + a42[i*4+n*4+1];
+      __asm__ volatile ("": : : "memory");
+    }
+  for (int i = 0; i < 4 * n * 3; ++i)
+    if (a4[i] != a42[i])
+      __builtin_abort ();
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump "READ_WRITE dependence in interleaving" "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/slp-reduc-sad.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/vect/slp-reduc-sad.c b/gcc/testsuite/gcc.dg/vect/slp-reduc-sad.c
--- a/gcc/testsuite/gcc.dg/vect/slp-reduc-sad.c	(revision 278653)
+++ b/gcc/testsuite/gcc.dg/vect/slp-reduc-sad.c	(revision 278653)
@@ -12,7 +12,7 @@
 int __attribute__((noinline,noclone))
 foo (uint8_t *pix1, uint8_t *pix2, int i_stride_pix2)
 {
-  int i_sum = 0;
+  int i_sum = 5;
   for( int y = 0; y < 16; y++ )
     {
       i_sum += abs ( pix1[0] - pix2[0] );
@@ -52,7 +52,7 @@
       __asm__ volatile ("");
     }
 
-  if (foo (X, Y, 16) != 32512)
+  if (foo (X, Y, 16) != 32512 + 5)
     abort ();
 
   return 0;
Index: gcc/testsuite/gcc.dg/vect/pr81740-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/vect/pr81740-1.c b/gcc/testsuite/gcc.dg/vect/pr81740-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/vect/pr81740-1.c	(revision 278653)
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vect_int } */
+
+#include "tree-vect.h"
+
+int a[8][10] = { [2][5] = 4 }, c;
+
+int
+main ()
+{
+  short b;
+  int i, d;
+  check_vect ();
+  for (b = 4; b >= 0; b--)
+    for (c = 0; c <= 6; c++)
+      a[c + 1][b + 2] = a[c][b + 1];
+  for (i = 0; i < 8; i++)
+    for (d = 0; d < 10; d++)
+      if (a[i][d] != (i == 3 && d == 6) * 4)
+	__builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/vect/bb-slp-pr90006.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/vect/bb-slp-pr90006.c b/gcc/testsuite/gcc.dg/vect/bb-slp-pr90006.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/vect/bb-slp-pr90006.c	(revision 278653)
@@ -0,0 +1,31 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-fno-math-errno" } */
+/* { dg-additional-options "-march=x86-64" { target x86_64-*-* i?86-*-* } } */
+
+long int lrint(double x);
+
+int a, b;
+union c {
+    int d;
+};
+
+int e()
+{
+  int f, g, h;
+  long i, j, k;
+  double l, m = b = lrint(0.3127);
+  a = b >> 16 >> 8 & 255;
+  ((union c *)e)->d = a;
+  k = m;
+  h = k >> 16 >> 8 & 255;
+  ((union c *)(e + 4))->d = h;
+  j = lrint(l);
+  g = j >> 16 >> 8 & 255;
+  ((union c *)(e + 8))->d = g;
+  i = lrint(0.292);
+  f = i >> 16 >> 8 & 255;
+  ((union c *)(e + 12))->d = f;
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump "basic block vectorized" "slp2" { target { { x86_64-*-* i?86-*-* } && ilp32 } } } } */
Index: gcc/testsuite/gcc.dg/pr89734.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr89734.c b/gcc/testsuite/gcc.dg/pr89734.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr89734.c	(revision 278653)
@@ -0,0 +1,12 @@
+/* PR c/89734 */
+/* { dg-do compile } */
+/* { dg-options "" } */
+
+typedef const int CI;
+typedef _Atomic int AI;
+
+CI foo (void);
+const int foo (void);
+
+AI baz (void);
+_Atomic int baz (void);
Index: gcc/testsuite/gcc.dg/pr84032.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr84032.c b/gcc/testsuite/gcc.dg/pr84032.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr84032.c	(revision 278653)
@@ -0,0 +1,23 @@
+/* PR rtl-optimization/84032 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -fmodulo-sched" } */
+/* { dg-additional-options "-mcpu=power6" { target { powerpc-*-* } } } */
+
+void
+yr (int cm)
+{
+  int ka = cm;
+
+  for (;;)
+    {
+      short int m0;
+
+      for (m0 = 0; m0 < 6; ++m0)
+        {
+          ka &= 1;
+          cm *= 2;
+        }
+
+      ka = (ka == 0) ? cm : 0;
+    }
+}
Index: gcc/testsuite/gcc.dg/tsan/pr90208-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/tsan/pr90208-2.c b/gcc/testsuite/gcc.dg/tsan/pr90208-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/tsan/pr90208-2.c	(revision 278653)
@@ -0,0 +1,20 @@
+/* PR tree-optimization/90208 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fexceptions -fsanitize=thread" } */
+
+void *b[5];
+void foo (void);
+
+void
+bar (int d)
+{
+  while (d)
+    foo ();
+}
+
+void
+baz (void)
+{
+  bar (2);
+  __builtin_setjmp (b);
+}
Index: gcc/testsuite/gcc.dg/pr89037.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr89037.c b/gcc/testsuite/gcc.dg/pr89037.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr89037.c	(revision 278653)
@@ -0,0 +1,24 @@
+/* { dg-do run { target int128 } } */
+/* { dg-options "" } */
+
+struct s
+{
+  __int128 y : 66;
+};
+typedef struct s T;
+T a[] = { 1, 10000, 0x12345, 0xff000001, 1ULL << 63, (__int128) 1 << 64,
+	  ((__int128) 1 << 64) | 1 };
+
+int
+main (void)
+{
+  if (a[0].y != 1
+      || a[1].y != 10000
+      || a[2].y != 0x12345
+      || a[3].y != 0xff000001
+      || a[4].y != (1ULL << 63)
+      || a[5].y != ((__int128) 1 << 64)
+      || a[6].y != (((__int128) 1 << 64) | 1))
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/guality/pr54970.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/guality/pr54970.c b/gcc/testsuite/gcc.dg/guality/pr54970.c
--- a/gcc/testsuite/gcc.dg/guality/pr54970.c	(revision 278653)
+++ b/gcc/testsuite/gcc.dg/guality/pr54970.c	(revision 278653)
@@ -8,17 +8,17 @@
 int
 main ()
 {
-  int a[] = { 1, 2, 3 };	/* { dg-final { gdb-test 15 "a\[0\]" "1" } } */
+  int a[] = { 1, 2, 3 };	/* { dg-final { gdb-test 15 "a\[0\]" "1" { xfail { *-*-* } } } } */
   int *p = a + 2;		/* { dg-final { gdb-test 15 "a\[1\]" "2" } } */
   int *q = a + 1;		/* { dg-final { gdb-test 15 "a\[2\]" "3" } } */
 				/* { dg-final { gdb-test 15 "*p" "3" } } */
   asm volatile (NOP);		/* { dg-final { gdb-test 15 "*q" "2" } } */
-  *p += 10;			/* { dg-final { gdb-test 20 "a\[0\]" "1" } } */
+  *p += 10;			/* { dg-final { gdb-test 20 "a\[0\]" "1" { xfail { *-*-* } } } } */
 				/* { dg-final { gdb-test 20 "a\[1\]" "2" } } */
 				/* { dg-final { gdb-test 20 "a\[2\]" "13" } } */
 				/* { dg-final { gdb-test 20 "*p" "13" } } */
   asm volatile (NOP);		/* { dg-final { gdb-test 20 "*q" "2" } } */
-  *q += 10;			/* { dg-final { gdb-test 25 "a\[0\]" "1" } } */
+  *q += 10;			/* { dg-final { gdb-test 25 "a\[0\]" "1" { xfail { *-*-* } } } } */
 				/* { dg-final { gdb-test 25 "a\[1\]" "12" } } */
 				/* { dg-final { gdb-test 25 "a\[2\]" "13" } } */
 				/* { dg-final { gdb-test 25 "*p" "13" } } */
Index: gcc/testsuite/gcc.dg/uninit-pred-8_b.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/uninit-pred-8_b.c b/gcc/testsuite/gcc.dg/uninit-pred-8_b.c
--- a/gcc/testsuite/gcc.dg/uninit-pred-8_b.c	(revision 278653)
+++ b/gcc/testsuite/gcc.dg/uninit-pred-8_b.c	(revision 278653)
@@ -1,6 +1,7 @@
-
 /* { dg-do compile } */
-/* { dg-options "-Wuninitialized -O2" } */
+/* ???  Jump threading makes a mess of the logical-op-non-short-circuit=0 case
+   so force it our way.  */
+/* { dg-options "-Wuninitialized -O2 --param logical-op-non-short-circuit=1" } */
 
 int g;
 void bar();
Index: gcc/testsuite/gcc.dg/cpp/usr/include/stdio.h
===================================================================
diff --git a/gcc/testsuite/gcc.dg/cpp/usr/include/stdio.h b/gcc/testsuite/gcc.dg/cpp/usr/include/stdio.h
deleted file mode 10644
--- a/gcc/testsuite/gcc.dg/cpp/usr/include/stdio.h	(revision 278653)
+++ /dev/null	(nonexistent)
@@ -1,4 +0,0 @@
-/* Used by gcc.dg/cpp/isysroot-1.c to test isysroot.  */
-void foo()
-{
-}
Index: gcc/testsuite/gcc.dg/cpp/usr/include/example.h
===================================================================
diff --git a/gcc/testsuite/gcc.dg/cpp/usr/include/example.h b/gcc/testsuite/gcc.dg/cpp/usr/include/example.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/cpp/usr/include/example.h	(revision 278653)
@@ -0,0 +1,4 @@
+/* Used by gcc.dg/cpp/isysroot-1.c to test isysroot.  */
+void foo()
+{
+}
Index: gcc/testsuite/gcc.dg/cpp/isysroot-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/cpp/isysroot-1.c b/gcc/testsuite/gcc.dg/cpp/isysroot-1.c
--- a/gcc/testsuite/gcc.dg/cpp/isysroot-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.dg/cpp/isysroot-1.c	(revision 278653)
@@ -1,10 +1,17 @@
 /* { dg-options "-isysroot ${srcdir}/gcc.dg/cpp" } */
 /* { dg-do compile  { target *-*-darwin* } } */
 
-#include <stdio.h>
+/* For the test to succeed there needs to be some header that is to be found
+   in the 'expected' place i.e. <sysroot>/usr/include/.  It's important that
+   it is not the name of a header for which fixincludes have been applied,
+   since such headers will be found in the gcc include-fixed dir and, in
+   general, reference additional headers.  The dummy sysroot will prevent the
+   additional headers from being found, resulting in a failed test.  So use
+   a header name we don't expect to see. */
+#include <example.h>
 int main()
 {
-  /* Special stdio.h supplies function foo.  */
+  /* Special example.h supplies function foo.  */
   void (*x)(void) = foo;
   return 0;
 }
Index: gcc/testsuite/gcc.dg/pr90898.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr90898.c b/gcc/testsuite/gcc.dg/pr90898.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr90898.c	(revision 278653)
@@ -0,0 +1,16 @@
+/* PR c/90898 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void *p;
+int bar (void);
+void baz (int *);
+
+void
+foo (void)
+{
+  p = __builtin_stack_save ();
+  int a[(bar (), 2)];
+  baz (a);
+  __builtin_stack_restore (p);
+}
Index: gcc/testsuite/gcc.dg/pr90760.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr90760.c b/gcc/testsuite/gcc.dg/pr90760.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr90760.c	(revision 278653)
@@ -0,0 +1,9 @@
+/* PR c/90760 */
+/* { dg-do compile } */
+/* { dg-require-alias "" } */
+/* { dg-require-named-sections "" } */
+
+void bar (void) {}
+void foo (void) __attribute__ ((alias ("bar")));	/* { dg-error "section of alias 'foo' must match section of its target" } */
+void foo (void) __attribute__ ((section ("baz")));
+void qux (void) __attribute__ ((alias ("bar"), section ("baz")));	/* { dg-error "section of alias 'qux' must match section of its target" } */
Index: gcc/testsuite/gcc.dg/darwin-minversion-link.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/darwin-minversion-link.c b/gcc/testsuite/gcc.dg/darwin-minversion-link.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/darwin-minversion-link.c	(revision 278653)
@@ -0,0 +1,26 @@
+/* Test that we can handle leading-zeros on mmacosx-version-min for invocations
+   including linking (so that spec processing works).  To make sure that any
+   necessary target libs are present we make this specific to the target version
+   being built.  */
+/* { dg-do link { target *-*-darwin* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.04.11 -DCHECK=1049" { target *-*-darwin8* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.05.08 -DCHECK=1058" { target *-*-darwin9* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.06.08 -DCHECK=1068" { target *-*-darwin10* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.07.05 -DCHECK=1075" { target *-*-darwin11* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.08.05 -DCHECK=1085" { target *-*-darwin12* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.09.05 -DCHECK=1095" { target *-*-darwin13* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.010.03 -DCHECK=101003" { target *-*-darwin14* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.011.06 -DCHECK=101106" { target *-*-darwin15* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.012.06 -DCHECK=101206" { target *-*-darwin16* } } */
+/* { dg-additional-options "-mmacosx-version-min=010.013.06 -DCHECK=101306" { target *-*-darwin17* } } */
+/* This next test covers 10.18 and (currently unreleased) 10.19 for now. */  
+/* { dg-additional-options "-mmacosx-version-min=010.014.05 -DCHECK=101405" { target *-*-darwin1[89]* } } */
+
+int
+main ()
+{
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ != CHECK
+  fail me;
+#endif
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/Wrestrict-5.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Wrestrict-5.c b/gcc/testsuite/gcc.dg/Wrestrict-5.c
--- a/gcc/testsuite/gcc.dg/Wrestrict-5.c	(revision 278653)
+++ b/gcc/testsuite/gcc.dg/Wrestrict-5.c	(revision 278653)
@@ -1,19 +1,11 @@
-/* Test to verify that valid calls to common restrict-qualified built-in
+/* PR tree-optimization/83655 - ICE on an invalid call to memcpy declared
+   with no prototype
+   Test to verify that valid calls to common restrict-qualified built-in
    functions declared with no prototype are checked for overlap, and that
    invalid calls are ignored.
   { dg-do compile }
   { dg-options "-O2 -Wrestrict" }  */
 
-typedef __SIZE_TYPE__ size_t;
-
-#if __cplusplus
-extern "C" {
-
-#define NO_PROTO ...
-#else
-#define NO_PROTO /* empty */
-#endif
-
 void* memcpy ();
 char* strncpy ();
 
@@ -41,3 +33,6 @@
 {
   strncpy (d + 1, d + 3, "");
 }
+
+/* { dg-prune-output "\\\[-Wbuiltin-declaration-mismatch]" }
+   { dg-prune-output "\\\[-Wint-conversion]" } */
Index: gcc/testsuite/gcc.dg/pr88074-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr88074-2.c b/gcc/testsuite/gcc.dg/pr88074-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr88074-2.c	(revision 278653)
@@ -0,0 +1,17 @@
+/* PR middle-end/88074 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+/* { dg-add-options float128 } */
+/* { dg-require-effective-target float128 } */
+/* { dg-final { scan-tree-dump-not "link_error " "optimized" } } */
+
+extern void link_error (void);
+int
+main ()
+{
+  if (((__FLT128_MAX__ * 0.5 + __FLT128_MAX__ * 0.5i)
+       / (__FLT128_MAX__ * 0.25 + __FLT128_MAX__ * 0.25i))
+      != (_Complex _Float128) 2)
+    link_error ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr87979.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr87979.c b/gcc/testsuite/gcc.dg/pr87979.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr87979.c	(revision 278653)
@@ -0,0 +1,11 @@
+/* PR rtl-optimization/87979 */
+/* { dg-do compile } */
+/* { dg-options "-Os -fmodulo-sched -fno-tree-loop-im" } */
+/* { dg-additional-options "-march=z196" { target { s390*-*-* } } } */
+
+void foo(void)
+{
+  static int m;
+  for (int i = 0; i < 10; ++i)
+    m++;
+}
Index: gcc/testsuite/gcc.dg/autopar/pr91162.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/autopar/pr91162.c b/gcc/testsuite/gcc.dg/autopar/pr91162.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/autopar/pr91162.c	(revision 278653)
@@ -0,0 +1,25 @@
+/* { dg-do compile { target int128 } } */
+/* { dg-options "-O -ftree-parallelize-loops=2 -fno-tree-dominator-opts --param parloops-min-per-thread=30" } */
+
+void
+zf (__int128 ct)
+{
+  __int128 *rk = &ct;
+
+  if (0)
+    {
+      int jj;
+
+t9:
+      for (jj = 0; jj < 60; ++jj)
+	{
+	}
+
+      __builtin_unreachable ();
+    }
+
+  while (*rk < 1)
+    ++*rk;
+
+  goto t9;
+}
Index: gcc/testsuite/gcc.dg/pr89590.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr89590.c b/gcc/testsuite/gcc.dg/pr89590.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr89590.c	(revision 278653)
@@ -0,0 +1,11 @@
+/* PR middle-end/89590 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -Wall -w" } */
+
+void free (void *);
+
+void
+foo (void)
+{
+  ((void (*)()) free) ();
+}
Index: gcc/testsuite/gcc.dg/pr91854.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr91854.c b/gcc/testsuite/gcc.dg/pr91854.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr91854.c	(revision 278653)
@@ -0,0 +1,55 @@
+/* PR target/91854 */
+/* Testcase by Sergei Trofimovich <slyfox@inbox.ru> */
+/* { dg-do assemble } */
+/* { dg-options "-O2 -Wno-int-conversion" }  */
+/* { dg-additional-options "-fPIE -mcpu=niagara4" { target sparc*-*-* } } */
+
+typedef struct {
+  long a;
+} __attribute__((packed)) c;
+void *e, *f;
+int i, j, ab, k, l, m, o;
+inline int g(int p) {
+  if (__builtin_expect(p, 1)) {
+    const int aa = ((c *)e)->a ^ ((c *)f)->a;
+    if (aa)
+      f = sizeof(long);
+    return f;
+  }
+}
+void d();
+int am ();
+inline int n(char p, int u) {
+  int q, r, ac = i;
+  short b = m;
+  while (r && u) {
+    if (l) {
+      if (k) {
+        void *h = i;
+        if (__builtin_expect(p, 1)) {
+          const int aa = ((c *)e)->a ^ ((c *)h)->a;
+          if (aa)
+            h = sizeof(long);
+          q = h;
+        }
+      }
+      ab = q;
+      char s;
+      if (s) {
+        char t = l = g(t);
+      }
+    }
+    if (j && b)
+      if (ac)
+        d();
+  }
+}
+void v() {
+  const int al = am();
+  if (al)
+    n(am, v);
+an:
+  n(am, v);
+  if (o)
+    goto an;
+}
Index: gcc/testsuite/gcc.dg/tree-ssa/pr89725.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr89725.c b/gcc/testsuite/gcc.dg/tree-ssa/pr89725.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr89725.c	(revision 278653)
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -floop-interchange -fno-tree-dce" } */
+int abs (int);
+int find_sad_16x16(int *intra_mode)
+{
+  int current_intra_sad_2,best_intra_sad2;
+  int M1[16][16],M0[4][4][4][4],M3[4],M4[4][4];
+  int i,j,k;
+  int ii,jj;
+  int up_avail, left_avail, left_up_avail;
+  for (i=0;i<17;i++)
+    if (left_up_avail)
+      {
+	for (jj=0;jj<4;jj++)
+	  for (ii=0;ii<4;ii++)
+	    for (j=0;j<4;j++)
+	      for (i=0;i<4;i++)
+		{
+		  M0[i][ii][2][jj]=M3[0]-M3[1];
+		  M0[i][ii][1][jj]=M3[2]+M3[3];
+		  current_intra_sad_2 += abs(M0[i][ii][j][jj]);
+		}
+
+        if(current_intra_sad_2 < best_intra_sad2)
+          best_intra_sad2=current_intra_sad_2;
+      }
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/tree-ssa/reassoc-43.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-43.c b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-43.c
--- a/gcc/testsuite/gcc.dg/tree-ssa/reassoc-43.c	(revision 278653)
+++ b/gcc/testsuite/gcc.dg/tree-ssa/reassoc-43.c	(revision 278653)
@@ -50,4 +50,4 @@
 	}
     }
 }
-/* { dg-final { scan-tree-dump-not "0 != 0" "reassoc2"} } */
+/* { dg-final { scan-tree-dump-not "\[ (\]0 != 0" "reassoc2"} } */
Index: gcc/testsuite/gcc.dg/tree-ssa/pr91091-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr91091-1.c b/gcc/testsuite/gcc.dg/tree-ssa/pr91091-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr91091-1.c	(revision 278653)
@@ -0,0 +1,23 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -fno-strict-aliasing" } */
+
+struct s { int x; } __attribute__((packed));
+struct t { int x; };
+
+void __attribute__((noinline,noipa))
+swap(struct s* p, struct t* q)
+{
+  p->x = q->x;
+  q->x = p->x;
+}
+
+int main()
+{    
+  struct t a[2];
+  a[0].x = 0x12345678;
+  a[1].x = 0x98765432;
+  swap ((struct s *)((char *)a + 1), a);
+  if (a[0].x != 0x12345678)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/tree-ssa/pr89872.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr89872.c b/gcc/testsuite/gcc.dg/tree-ssa/pr89872.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr89872.c	(revision 278653)
@@ -0,0 +1,27 @@
+/* PR c/89872 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+/* { dg-final { scan-tree-dump-times " ={v} 1;" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times " ={v} 2;" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times " ={v} 3;" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times " ={v} 4;" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times " ={v} 0;" 1 "optimized" } } */
+/* { dg-final { scan-tree-dump-times " ={v} " 10 "optimized" } } */
+
+void
+foo (void)
+{
+  (volatile int){1} + (volatile int){2};
+}
+
+void
+bar (void)
+{
+  (volatile int){3};
+}
+
+void
+baz (void)
+{
+  (volatile int){4} / (volatile int){0};
+}
Index: gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-78.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-78.c b/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-78.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-78.c	(revision 278653)
@@ -0,0 +1,27 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -fstrict-aliasing" } */
+
+union U {
+  struct A { int : 2; int x : 8; } a;
+  struct B { int : 6; int x : 8; } b;
+};
+
+int __attribute__((noipa))
+foo (union U *p, union U *q)
+{
+  p->a.x = 1;
+  q->b.x = 1;
+  return p->a.x;
+}
+
+int
+main()
+{
+  union U x;
+  if (foo (&x, &x) != x.a.x)
+    __builtin_abort ();
+  return 0;
+}
+
+/* We support arbitrary punning through unions when it happens through
+   the union type and thus p == q is valid here.  */
Index: gcc/testsuite/gcc.dg/tree-ssa/pr89546.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr89546.c b/gcc/testsuite/gcc.dg/tree-ssa/pr89546.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr89546.c	(revision 278653)
@@ -0,0 +1,100 @@
+/* { dg-do run } */
+/* { dg-options "-O" } */
+
+struct I
+{
+  int i;
+};
+
+struct A
+{
+  struct I i1;
+  struct I i2;
+  struct I i3;
+};
+
+struct B
+{
+  struct I i0;
+  struct A a;
+};
+
+struct C
+{
+  struct I i00;
+  struct B b;
+};
+
+volatile int v;
+
+void __attribute__((noipa))
+consume_i (struct I i)
+{
+  v = i.i;
+}
+
+void __attribute__((noipa))
+consume_a (struct A a)
+{
+  v = a.i1.i;
+}
+
+void __attribute__((noipa))
+consume_b (struct B b)
+{
+  v = b.a.i1.i;
+}
+
+void __attribute__((noipa))
+consume_c (struct C c)
+{
+  v = c.b.a.i1.i;
+}
+
+
+
+
+int __attribute__((noipa))
+foo (struct I input)
+{
+  struct I i1, i2, i3;
+  struct A a1, a2, a3;
+  struct B b1;
+  struct C c;
+
+  i1 = input;
+  a1.i1 = i1;
+  b1.a = a1;
+
+  i2.i = 1;
+  b1.i0 = i2;
+
+  c.b = b1;
+
+  a2 = c.b.a;
+  a3 = a2;
+  i3 = a3.i1;
+
+  int t = c.b.i0.i;
+  a2.i3.i = 4;
+  consume_i (i1);
+  consume_i (i2);
+  consume_b (b1);
+  consume_a (a1);
+  consume_a (a2);
+  consume_a (a3);
+  consume_c (c);
+
+  return i3.i + t;
+}
+
+int
+main (int argc, char *argv[])
+{
+  struct I s;
+  s.i = 1234;
+  int i = foo (s);
+  if (i != 1235)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/Wnonnull.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Wnonnull.c b/gcc/testsuite/gcc.dg/Wnonnull.c
--- a/gcc/testsuite/gcc.dg/Wnonnull.c	(revision 278653)
+++ b/gcc/testsuite/gcc.dg/Wnonnull.c	(revision 278653)
@@ -2,7 +2,10 @@
    { dg-do compile }
    { dg-options "-O2 -Wall" } */
 
-#include <string.h>
+extern __SIZE_TYPE__ strlen (const char *__s)
+			     __attribute ((pure)) __attribute ((nonnull (1)));
+extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
+		     __SIZE_TYPE__ __n) __attribute ((nonnull (1, 2)));
 
 char buf[100];
 
@@ -14,9 +17,9 @@
 
 __attribute ((nonnull (1, 2)))
 inline char*
-my_strcpy (char *restrict dst, const char *restrict src, size_t size)
+my_strcpy (char *restrict dst, const char *restrict src, __SIZE_TYPE__ size)
 {
-  size_t len = strlen (src);        /* { dg-warning "argument 1 null where non-null expected" } */
+  __SIZE_TYPE__ len = strlen (src); /* { dg-warning "argument 1 null where non-null expected" } */
   if (len < size)
     memcpy (dst, src, len + 1);     /* { dg-warning "argument 2 null where non-null expected" } */
   else
Index: gcc/testsuite/gcc.dg/pr90733.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr90733.c b/gcc/testsuite/gcc.dg/pr90733.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr90733.c	(revision 278653)
@@ -0,0 +1,22 @@
+/* PR debug/90733 */
+/* { dg-do compile } */
+/* { dg-options "-g -O2 -w" } */
+
+struct S { unsigned a : 1; };
+union U { struct S b; _Complex unsigned c; };
+
+union U
+foo (union U d)
+{
+  union U e = d;
+  return e;
+}
+
+int
+bar (void)
+{
+  union U x, y;
+  x.c = x.b.a;
+  y = foo (x);
+  return x.c != y.c;
+}
Index: gcc/testsuite/gcc.dg/darwin-minversion-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/darwin-minversion-1.c b/gcc/testsuite/gcc.dg/darwin-minversion-1.c
--- a/gcc/testsuite/gcc.dg/darwin-minversion-1.c	(revision 278653)
+++ b/gcc/testsuite/gcc.dg/darwin-minversion-1.c	(revision 278653)
@@ -1,6 +1,6 @@
 /* Basic test for -mmacosx-version-min switch on Darwin.  */
 /* { dg-options "-mmacosx-version-min=10.5" } */
-/* { dg-do run { target *-*-darwin* } } */
+/* { dg-do compile { target *-*-darwin* } } */
 
 int
 main ()
Index: gcc/testsuite/gcc.dg/Warray-bounds-38.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Warray-bounds-38.c b/gcc/testsuite/gcc.dg/Warray-bounds-38.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/Warray-bounds-38.c	(revision 278653)
@@ -0,0 +1,30 @@
+/* PR middle-end/88273 - bogus warning: 'memcpy' offset [-527, -529]
+   is out of the bounds [0, 16]
+   { dg-do compile }
+   { dg-options "-O2 -Wall" }  */
+
+typedef __SIZE_TYPE__ size_t;
+
+void *q;
+
+size_t x, y;
+
+inline void f (char *p, int i, size_t j)
+{
+  size_t n = y ? y : j;
+
+  p += x - i;
+
+  __builtin_memcpy (q, p, n);   /* { dg-bogus "bounds" } */
+
+  x = n;
+}
+
+void g (void)
+{
+  struct { char a[16]; } s;
+
+  f (q, 0, sizeof s);
+
+  f (s.a, 33 * sizeof s, 1);
+}
Index: gcc/testsuite/gcc.dg/uninit-19.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/uninit-19.c b/gcc/testsuite/gcc.dg/uninit-19.c
--- a/gcc/testsuite/gcc.dg/uninit-19.c	(revision 278653)
+++ b/gcc/testsuite/gcc.dg/uninit-19.c	(revision 278653)
@@ -12,7 +12,7 @@
 {
   if (p1 & 8)
     b[3] = p10[a];
-  /* { dg-warning "may be used uninitialized" "" { target { { nonpic } || { hppa*64*-*-* } } } .-1 } */
+  /* { dg-warning "may be used uninitialized" "" { target { { nonpic } || { hppa*64*-*-* *-*-darwin* } } } .-1 } */
 }
 
 void
@@ -22,5 +22,5 @@
   if (l & 6)
     n = &c + m;
   fn1 (l, &d, &e, &g, &i, &h, &k, n);
-  /* { dg-warning "may be used uninitialized" "" { target { ! { { nonpic } || { hppa*64*-*-* } } } } .-1 } */
+  /* { dg-warning "may be used uninitialized" "" { target { ! { { nonpic } || { hppa*64*-*-* *-*-darwin* } } } } .-1 } */
 }
Index: gcc/testsuite/gcc.dg/pr89679.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr89679.c b/gcc/testsuite/gcc.dg/pr89679.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr89679.c	(revision 278653)
@@ -0,0 +1,26 @@
+/* PR rtl-optimization/89679 */
+/* { dg-do run } */
+/* { dg-options "-Og -frerun-cse-after-loop -fno-tree-fre" } */
+
+unsigned short g;
+
+void
+foo (unsigned long long x)
+{
+  if (x != 0xffff)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+#if __SIZEOF_SHORT__ == 2 && __SIZEOF_INT__ == 4 && __CHAR_BIT__ == 8
+  unsigned short d = 0;
+  unsigned long long x, c = ~0;
+  c = c >> d;
+  __builtin_memset (&d, c, 2);
+  x = d + g;
+  foo (x);
+#endif
+  return 0;
+}
Index: gcc/testsuite/ChangeLog
===================================================================
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
--- a/gcc/testsuite/ChangeLog	(revision 278653)
+++ b/gcc/testsuite/ChangeLog	(revision 278653)
@@ -1,3 +1,2131 @@
+2019-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91355
+	* g++.dg/torture/pr91355.C: New test.
+
+	Backported from mainline
+	2019-11-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/90840
+	* gcc.c-torture/compile/pr90840.c: New test.
+
+	PR target/90867
+	* gcc.target/i386/pr90867.c: New test.
+
+	PR c/90898
+	* gcc.dg/pr90898.c: New test.
+
+	2019-11-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/91450
+	* gcc.c-torture/execute/pr91450-1.c: New test.
+	* gcc.c-torture/execute/pr91450-2.c: New test.
+
+	2019-11-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92384
+	* g++.dg/torture/pr92384.C: New test.
+
+	2019-10-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/92296
+	* c-c++-common/cpp/pr92296-1.c: New test.
+	* c-c++-common/cpp/pr92296-2.c: New test.
+
+	2019-10-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92201
+	* g++.dg/other/pr92201.C: New test.
+
+	2019-10-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/92056
+	* gcc.c-torture/compile/pr92056.c: New test.
+
+	2019-10-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/91974
+	* g++.dg/cpp1z/eval-order5.C: New test.
+
+	2019-09-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/91665
+	* gcc.dg/vect/pr91665.c: New test.
+
+	2019-09-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/91001
+	PR middle-end/91105
+	PR middle-end/91106
+	* gcc.c-torture/compile/pr91001.c: New test.
+
+	2019-09-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/91623
+	* gcc.target/i386/pr91623.c: New test.
+
+	2019-08-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/91401
+	* c-c++-common/gomp/pr91401-1.c: New test.
+	* c-c++-common/gomp/pr91401-2.c: New test.
+
+2019-11-20  Peter Bergner <bergner@linux.ibm.com>
+
+	Backport from mainline
+	2019-11-13  David Edelsohn  <dje.gcc@gmail.com>
+
+	* gcc.target/powerpc/pr92090.c: Limit -mbig to powerpc64le-*-*.
+	* gcc.target/powerpc/pr92090-2.c: Likewise.
+
+	2019-11-07  Peter Bergner <bergner@linux.ibm.com>
+
+	PR other/92090
+	* gcc.target/powerpc/pr92090-2.c: New test.
+
+	2019-11-07  Peter Bergner <bergner@linux.ibm.com>
+
+	PR other/92090
+	* gcc.target/powerpc/pr92090.c: New test.
+
+2019-11-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/compile/20191108-1.c: New test.
+	* gcc.target/sparc/overflow-1.c: Add -fno-pie to the options.
+	* gcc.target/sparc/overflow-2.c: Likewise.
+	* gcc.target/sparc/overflow-3.c: Likewise.
+	* gcc.target/sparc/overflow-4.c: Likewise.
+	* gcc.target/sparc/overflow-5.c: Likewise.
+
+2019-11-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-20  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* obj-c++.dg/stubify-1.mm: Adjust options and scan-asm checks.
+	* obj-c++.dg/stubify-2.mm: Likewise.
+	* objc.dg/stubify-1.m: Likewise.
+	* objc.dg/stubify-2.m: Likewise.
+
+2019-11-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR c++/79274
+	* g++.dg/tls/pr77285-2.C: XFAIL test for Darwin.
+
+2019-11-02  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline
+	2019-06-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/pr90760.c: Require alias support.
+
+2019-11-01  Delia Burduv  <Delia.Burduv@arm.com>
+
+	Backport from trunk
+	2019-02-20  Andre Vieira <andre.simoesdiasvieira@arm.com>
+
+	PR target/86487
+	* gcc.target/arm/pr86487.c: New.
+
+2019-10-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-10-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/Wnonnull.c: Provide prototypes for strlen and memcpy.
+	Use __SIZE_TYPE__ instead of size_t.
+
+	Backport from mainline.
+	2019-10-19  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/Wnonnull.c: Add attributed function declarations for
+	memcpy and strlen for Darwin.
+
+2019-10-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-10-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/i386/indirect-thunk-1.c: Allow 'l' or 'L' in
+	indirection label prefix, for Darwin.
+	* gcc.target/i386/indirect-thunk-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-5.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-6.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-4.c: Likewise.
+	* gcc.target/i386/pr32219-2.c: Likewise.
+	* gcc.target/i386/pr32219-3.c: Likewise.
+	* gcc.target/i386/pr32219-4.c: Likewise.
+	* gcc.target/i386/pr32219-7.c: Likewise.
+	* gcc.target/i386/pr32219-8.c: Likewise.
+	* gcc.target/i386/ret-thunk-14.c: Likewise.
+	* gcc.target/i386/ret-thunk-15.c: Likewise.
+	* gcc.target/i386/ret-thunk-9.c: Likewise.
+
+2019-10-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-08-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* obj-c++.dg/stubify-1.mm: Rename symbol stub option.
+	* obj-c++.dg/stubify-2.mm: Likewise.
+	* objc.dg/stubify-1.m: Likewise.
+	* objc.dg/stubify-2.m: Likewise.
+
+2019-10-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-15  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* lib/target-supports.exp 
+	(check_effective_target_powerpc_p8vector_ok): No support for Darwin.
+	(check_effective_target_powerpc_p9vector_ok): Likewise.
+	(check_effective_target_powerpc_float128_sw_ok): Likewise.
+	(check_effective_target_powerpc_float128_hw_ok): Likewise.
+	(check_effective_target_powerpc_vsx_ok): Likewise.
+	* gcc.target/powerpc/bfp/bfp.exp: Don't try to run this for Darwin.
+	* gcc.target/powerpc/dfp/dfp.exp: Likewise.
+
+2019-10-30  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	Backport from mainline
+	2019-07-09  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	* gcc.target/mips/cfgcleanup-jalr1.c: New test.
+	* gcc.target/mips/cfgcleanup-jalr2.c: New test.
+	* gcc.target/mips/cfgcleanup-jalr3.c: New test.
+
+2019-10-28  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.c-torture/compile/pr72802.c: Skip for Darwin.
+
+2019-10-28  Jiufu Guo  <guojiufu@linux.ibm.com>
+
+	Backport from mainline
+	PR target/70010
+	* gcc.target/powerpc/pr70010.c: Add -Wno-psabi and -mvsx.
+
+2019-10-28  Peter Bergner <bergner@linux.ibm.com>
+	    Jiufu Guo  <guojiufu@linux.ibm.com>
+
+	PR target/70010
+	* gcc.target/powerpc/pr70010.c: New test.
+	* gcc.target/powerpc/pr70010-1.c: New test.
+	* gcc.target/powerpc/pr70010-3.c: New test.
+	* gcc.target/powerpc/pr70010-4.c: New test.
+
+2019-10-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/86248
+	* gfortran.dg/char_result_19.f90 : New test.
+	* gfortran.dg/char_result_mod_19.f90 : Module for the new test.
+
+2019-10-25  Richard Earnshaw  <rearnsha@arm.com>
+
+	Backport from mainline
+	2019-05-08  Mihail Ionescu  <mihail.ionescu@arm.com>
+	   Richard Earnshaw  <rearnsha@arm.com>
+	PR target/88167
+	* gcc.target/arm/pr88167-1.c: New test.
+	* gcc.target/arm/pr88167-2.c: New test.
+
+2019-10-23  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-10-17  Richard Biener  <rguenther@suse.de>
+
+	PR debug/91887
+	* g++.dg/debug/dwarf2/pr91887.C: New testcase.
+
+	2019-09-19  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91812
+	* gcc.dg/torture/pr91812.c: New testcase.
+
+2019-10-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20191023-1.c: New test.
+
+2019-10-18  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/69455
+	* gfortran.dg/pr69455_1.f90: New test.
+	* gfortran.dg/pr69455_2.f90: Ditto.
+
+2019-10-17  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2019-10-15  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR target/92093
+	* gcc.target/powerpc/pr91275.c: Fix type and endian issues.
+
+2019-10-14  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	Backport from trunk.
+	2019-09-26  Will Schmidt <will_schmidt@vnet.ibm.com>
+
+	* gcc.target/powerpc/pure-builtin-redundant-load.c:  New.
+
+2019-10-10  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/92022
+	* g++.dg/pr92022.C: New test.
+
+2019-10-07  Thomas Koenig <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84487
+	* gfortran.dg/typebound_call_22.f03: xfail.
+
+2019-10-07  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	Backport from mainline
+	2019-10-01  Bill Schmidt  <wschmdit@linux.ibm.com>
+
+	PR target/91275
+	* gcc.target/powerpc/pr91275.c: New.
+
+2019-10-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-09-24  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* gcc.target/aarch64/nosplit-di-const-volatile_1.c: New test.
+
+2019-10-01  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/pr91854.c: New test.
+
+2019-09-28  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/91588
+	* gfortran.dg/associate_49.f90 : New test.
+
+2019-09-25  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2019-08-22  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* gcc.target/arm/acle/crc_hf_1.c: New test.
+
+2019-09-20  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-11  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR testsuite/81058
+	* gcc.target/i386/avx512bw-vpmovswb-1.c: Use regular data section
+	for variables on Darwin, rather than common.
+	* gcc.target/i386/avx512bw-vpmovuswb-1.c: Likewise.
+	* gcc.target/i386/avx512bw-vpmovwb-1.c: Likewise.
+
+2019-09-18  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91550
+	* gfortran.dg/do_subscript_6.f90: New test.
+
+2019-09-15  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91557
+	* gfortran.dg/warn_unused_dummy_argument_5.f90: New test.
+
+2019-09-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.target/sparc/20161111-1.c: XFAIL redundant zero-extension test.
+
+2019-09-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/87853
+	* gcc.target/i386/pr87853.c: New test.
+
+	PR target/91704
+	* gcc.target/i386/pr91704.c: New test.
+
+2019-09-05  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/91660
+	* gfortran.dg/pdt_4.f03: Fix invalid code.
+	* gfortran.dg/pr91660_1.f90: New test.
+	* gfortran.dg/pr91660_2.f90: Ditto.
+
+2019-09-04  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backport from mainline
+	2019-08-13  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	PR target/81800
+	* gcc.target/aarch64/no-inline-lrint_3.c: New test.
+
+2019-09-02  Richard Biener  <rguenther@suse.de>
+
+	PR testsuite/91619
+	* gcc.dg/vect/pr81740-2.c: Restrict to vect_hw_misalign.
+
+2019-09-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-15  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR objc/90709
+	* obj-c++.dg/proto-lossage-7.mm: Use proxy headers.
+	* obj-c++.dg/strings/const-cfstring-2.mm: Likewise.
+	* obj-c++.dg/strings/const-cfstring-5.mm: Likewise
+	* obj-c++.dg/strings/const-str-12.mm: Likewise.
+	* obj-c++.dg/syntax-error-1.mm: Likewise.
+	* obj-c++.dg/torture/strings/const-cfstring-1.mm: Likewise.
+	* obj-c++.dg/torture/strings/const-str-10.mm: Likewise.
+	* obj-c++.dg/torture/strings/const-str-11.mm: Likewise.
+	* obj-c++.dg/torture/strings/const-str-9.mm: Likewise.
+	* obj-c++.dg/cxx-ivars-3.mm: Skip on later Darwin, where the 10.4 API
+	in no longer supported, also on m64 where there's no meaning to it.
+	* obj-c++.dg/isa-field-1.mm: Suppress unwanted warning, add comment why.
+	* obj-c++.dg/objc-gc-3.mm: Skip for Darwin > 16, the API use is an error
+	there.
+	* obj-c++.dg/qual-types-1.mm: Prune a spurious l64 warning.
+	* obj-c++.dg/stubify-1.mm: Tidy up after better compiler warnings.
+	* obj-c++.dg/stubify-2.mm: Likewise.
+	* obj-c++.dg/try-catch-1.mm: Likewise.
+	* obj-c++.dg/try-catch-3.mm: Likewise.
+
+	Backport from mainline.
+	2019-06-15  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR objc/90709
+	* objc.dg/encode-7-next-64bit.m: Use proxy headers.
+	* objc.dg/image-info.m: Likewise.
+	* objc.dg/method-6.m: Likewise.
+	* objc.dg/no-extra-load.m: Likewise.
+	* objc.dg/objc-foreach-4.m: Likewise.
+	* objc.dg/objc-foreach-5.m: Likewise.
+	* objc.dg/proto-lossage-7.m: Likewise.
+	* objc.dg/strings/const-cfstring-2.m: Likewise.
+	* objc.dg/strings/const-cfstring-5.m: Likewise.
+	* objc.dg/strings/const-str-12b.m: Likewise.
+	* objc.dg/symtab-1.m: Likewise.
+	* objc.dg/torture/strings/const-cfstring-1.m: Likewise.
+	* objc.dg/torture/strings/const-str-10.m: Likewise.
+	* objc.dg/torture/strings/const-str-11.m: Likewise.
+	* objc.dg/torture/strings/const-str-9.m: Likewise.
+	* objc.dg/zero-link-1.m: Likewise.
+	* objc.dg/zero-link-2.m: Likewise.
+	* objc.dg/zero-link-3.m: Likewise.
+	* objc.dg/isa-field-1.m: Suppress unwanted warning, add comment why.
+	* objc.dg/headers.m: XFAIL for Darwin14-19.
+	* objc.dg/objc-gc-4.m: Skip for Darwin > 16, the API use is an error
+	there.
+
+	Backport from mainline.
+	2019-06-15  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR objc/90709
+	* objc-obj-c++-shared/CF-CFString.h: New.
+	* objc-obj-c++-shared/F-NSArray.h: New.
+	* objc-obj-c++-shared/F-NSAutoreleasePool.h: New.
+	* objc-obj-c++-shared/F-NSObject.h: New.
+	* objc-obj-c++-shared/F-NSString.h: New.
+	* objc-obj-c++-shared/F-NSValue.h: New.
+	* objc-obj-c++-shared/GNUStep/CoreFoundation/CFArray.h: New.
+	* objc-obj-c++-shared/GNUStep/CoreFoundation/CFAvailability.h: New.
+	* objc-obj-c++-shared/GNUStep/CoreFoundation/CFBase.h: New.
+	* objc-obj-c++-shared/GNUStep/CoreFoundation/CFCharacterSet.h: New.
+	* objc-obj-c++-shared/GNUStep/CoreFoundation/CFData.h: New.
+	* objc-obj-c++-shared/GNUStep/CoreFoundation/CFDictionary.h: New.
+	* objc-obj-c++-shared/GNUStep/CoreFoundation/CFLocale.h: New.
+	* objc-obj-c++-shared/GNUStep/CoreFoundation/CFString.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSArray.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSAutoreleasePool.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSDate.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSEnumerator.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSGeometry.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSObjCRuntime.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSObject.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSRange.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSString.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSValue.h: New.
+	* objc-obj-c++-shared/GNUStep/Foundation/NSZone.h: New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/GNUstep.h: New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/GSBlocks.h: New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/GSConfig.h: New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/GSObjCRuntime.h: New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/GSVersionMacros.h: New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/NSArray+GNUstepBase.h: New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/NSMutableString+GNUstepBase.h:
+	New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/NSNumber+GNUstepBase.h: New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/NSObject+GNUstepBase.h: New.
+	* objc-obj-c++-shared/GNUStep/GNUstepBase/NSString+GNUstepBase.h: New.
+
+2019-09-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-07-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/powerpc/bmi2-bzhi64-1a.c: Add options to enable altivec
+	and vsx.
+
+2019-09-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-07-25  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR gcov-profile/91087
+	* g++.dg/gcov/pr16855.C: Xfail the count lines for the DTORs and the
+	"final" line for the failure summaries.  Adjust source layout so that
+	dejagnu xfail expressions work.
+
+2019-09-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-07-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/powerpc/stabs-attrib-vect-darwin.c: Require stabs
+	support.
+
+2019-09-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/powerpc/safe-indirect-jump-1.c: Skip for Darwin.
+	* gcc.target/powerpc/safe-indirect-jump-7.c: Likewise.
+
+2019-09-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-04-15  Dominique d'Humieres  <dominiq@gcc.gnu.org>
+
+	PR tree-optimization/90020
+	* gcc.dg/torture/pr90020.c: Add linker options for darwin.
+
+2019-09-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-10  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/x86_64/abi/avx512f/abi-avx512f.exp: Darwin is
+	now tested.
+	* gcc.target/x86_64/abi/avx512f/asm-support-darwin.s: New.
+
+2019-09-01  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20190901-1.c: New test.
+
+2019-08-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/powerpc/spec-barr-1.c: Adjust scan assembler regex
+	to recognise Darwin's register names.
+
+2019-08-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/cpp/isysroot-1.c: Use <example.h> as the test header.
+	* gcc.dg/cpp/usr/include/stdio.h: Rename...
+	* gcc.dg/cpp/usr/include/example.h: ... to this.
+
+2019-08-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/powerpc/builtins-2.c: Require VSX hardware support.
+
+2019-08-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/powerpc/pr80125.c (foo): Use an unsigned char
+	vector explicitly for the vec_perm.
+
+2019-08-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/powerpc/pr71785.c: For Darwin, make test non-PIC,
+	expect the out-of-line GPR restore, and test specifically for
+	absence of branches to local labels.
+
+2019-08-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/powerpc/pr64205.c: Require effective target dfp.
+	* gcc.target/powerpc/pr79909.c: Likewise.
+
+2019-08-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/powerpc/darwin-bool-1.c: Suppress the pedantic
+	warning about _Bool.
+
+2019-08-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* g++.dg/pr71694.C: Use non-PIC codegen for Darwin m32.
+
+2019-08-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/darwin-minversion-1.c: Use compile rather than link/run.
+	* gcc.dg/darwin-minversion-2.c: Likewise.
+
+2019-08-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-11  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR testsuite/65364
+	* gcc.dg/uninit-19.c (fn1): Adjust target condition for Darwin.
+	(fn2): Likewise.
+
+2019-08-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-06  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* g++.dg/cpp0x/alignas4.C: Amend test to check for zerofill syntax
+	on Darwin.
+
+2019-08-31  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/91481
+	* gcc.target/powerpc/darn-3.c: Fix testcase.
+
+2019-08-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/90698
+	* gcc.target/i386/pr49866.c: XFAIL for Darwin.
+	* gcc.target/i386/pr63538.c: Likewise.
+	* gcc.target/i386/pr61599-1.c: Skip for Darwin.
+
+2019-08-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-31  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* g++.dg/cpp0x/pr84497.C: Require alias support.
+
+2019-08-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/i386/stack-prot-sym.c: Require native TLS support.
+
+2019-08-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-27  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/i386/pr22076.c: Adjust options to
+	match codegen expected by the scan-asms.
+
+2019-08-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-26  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/i386/pr39013-1.c: Adjust scan-asms for PIE to
+	account for PIC code on Darwin.
+	* gcc.target/i386/pr39013-2.c: Likewise.
+	* gcc.target/i386/pr64317.c: Likewise.
+
+2019-08-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-25  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/i386/pr59874-3.c: Use the spelling of popcnt
+	expected for Darwin.
+
+2019-08-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-25  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/i386/pr82659-3.c: Require alias support.
+
+2019-08-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/i386/pconfig-1.c: Scan for the string in the generated
+	code, not in comments or miscellaneous directives.
+	* gcc.target/i386/wbinvd-1.c: Likewise.
+	* gcc.target/i386/wbnoinvd-1.c: Likewise.
+	* gcc.target/i386/pr66819-3.c: Specifically, check that there is no
+	call to "bar".
+	* gcc.target/i386/pr66819-4.c: Likewise.
+	* gcc.target/i386/pr82662.c
+
+2019-08-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/i386/pr67985-2.c: Adjust label checks for
+	Darwin.
+	* gcc.target/i386/pr77881.c: Likewise.
+
+2019-08-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.target/i386/pr70738-7.c: Likewise.
+	* gcc.target/i386/pr24414.c: Likewise.
+
+2019-08-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR rtl-optimisation/64895
+	* gcc.target/i386/fuse-caller-save-rec.c: Remove XFAILs.
+	* gcc.target/i386/fuse-caller-save.c: Likewise.
+	* gcc.target/i386/fuse-caller-save-xmm.c: Adjust tests for
+	PIC cases, remove XFAILs.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-07-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91108
+	* gcc.dg/tree-ssa/pr91091-1.c: New testcase.
+	* gcc.dg/tree-ssa/ssa-fre-78.c: Likewise.
+
+2019-08-30  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2019-08-23  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/91481
+	* gcc.target/powerpc/darn-3.c: New testcase.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-12-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/88315
+	* gcc.dg/vect/slp-reduc-sad.c: Adjust to provide non-trivial
+	initial value.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-06-18  Richard Biener  <rguenther@suse.de>
+
+	PR debug/90900
+	* gcc.dg/gomp/pr90900.c: New testcase.
+
+	2019-04-29  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90278
+	* gcc.dg/torture/pr90278.c: New testcase.
+
+	2019-04-25  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/90194
+	* g++.dg/torture/pr90194.C: New testcase.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-07-31  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91293
+	* gcc.dg/vect/pr91293-1.c: New testcase.
+	* gcc.dg/vect/pr91293-2.c: Likewise.
+	* gcc.dg/vect/pr91293-3.c: Likewise.
+
+	2019-07-31  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91280
+	* g++.dg/torture/pr91280.C: New testcase.
+
+	2019-07-19  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91200
+	* gcc.dg/torture/pr91200.c: New testcase.
+
+	2019-07-15  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/91162
+	* gcc.dg/autopar/pr91162.c: New testcase.
+
+	2019-07-11  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/91131
+	* gcc.target/i386/pr91131.c: New testcase.
+
+	2019-07-10  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/91126
+	* gcc.dg/torture/pr91126.c: New testcase.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-05-06  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90328
+	* gcc.dg/torture/pr90328.c: New testcase.
+
+	2019-02-22  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/87609
+	* gcc.dg/torture/restrict-7.c: New testcase.
+
+2019-08-30  Bin Cheng  <bin.linux@linux.alibaba.com>
+
+	Backport from mainline
+	2019-07-18  Bin Cheng  <bin.linux@linux.alibaba.com>
+
+	PR tree-optimization/91137
+	* gcc.c-torture/execute/pr91137.c: New test.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-04-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90006
+	* gcc.dg/vect/bb-slp-pr90006.c: New testcase.
+
+	2019-04-01  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	PR tree-optimization/89725
+	* gcc.dg/tree-ssa/pr89725.c: New test.
+
+	2019-03-26  Bin Cheng  <bin.cheng@linux.alibaba.com>
+
+	PR tree-optimization/81740
+	* gcc.dg/vect/pr81740-1.c: New testcase.
+	* gcc.dg/vect/pr81740-2.c: Likewise.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-04-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90020
+	* gcc.dg/torture/pr90020.c: New testcase.
+
+2019-08-29  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-22  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR testsuite/27221
+	* g++.dg/ext/alignof2.C: XFAIL for 32bit Darwin.
+
+2019-08-29  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR testsuite/67958
+	* gcc.target/i386/pr32219-1.c: Adjust scan-asms for Darwin, comment
+	the differences.
+	* gcc.target/i386/pr32219-2.c: Likewise.
+	* gcc.target/i386/pr32219-3.c: Likewise.
+	* gcc.target/i386/pr32219-4.c: Likewise.
+	* gcc.target/i386/pr32219-5.c: Likewise.
+	* gcc.target/i386/pr32219-6.c: Likewise.
+	* gcc.target/i386/pr32219-7.c: Likewise.
+	* gcc.target/i386/pr32219-8.c: Likewise.
+
+2019-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-07-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/91150
+	* gcc.target/i386/avx512bw-pr91150.c: New test.
+
+	2019-07-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/78884
+	* gcc.dg/gomp/pr78884.c: New test.
+
+	PR rtl-optimization/90756
+	* gcc.dg/pr90756.c: New test.
+
+	2019-06-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/90954
+	* c-c++-common/gomp/pr90954.c: New test.
+
+	2019-06-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90950
+	* g++.dg/gomp/lastprivate-1.C: New test.
+
+	2019-06-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/90760
+	* gcc.dg/pr90760.c: New test.
+
+	2019-06-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/90733
+	* gcc.dg/pr90733.c: New test.
+
+	2019-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR pch/90326
+	* g++.dg/pch/pr90326.C: New test.
+	* g++.dg/pch/pr90326.Hs: New file.
+
+	2019-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/90139
+	* gcc.c-torture/compile/pr90139.c: New test.
+
+2019-08-28  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/63891
+	* gcc.dg/darwin-weakimport-3.c: Adjust options and explain
+	the reasons.
+
+2019-08-28  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-20  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR testsuite/58321
+	* gcc.target/i386/memcpy-strategy-3.c: Adjust count for Darwin and
+	add a comment as to the reason for the difference.
+	* gcc.target/i386/memset-strategy-1.c: Likewise.
+
+2019-08-28  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-18  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* objc.dg/instancetype-0.m: New.
+
+2019-08-25  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-13  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gcc.dg/darwin-minversion-link.c: New test.
+
+2019-08-23  Mihailo Stojanovic  <mistojanovic@wavecomp.com>
+
+	* gcc.target/mips/get-fcsr-3.c: New test.
+
+2019-08-20  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20190820-1.c: New test.
+
+2019-08-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline.
+	2019-08-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/91436
+	* g++.dg/lookup/missing-std-include-5.C: Limit test to C++14 and up.
+	* g++.dg/lookup/missing-std-include-6.C: Don't check make_unique in
+	test that runs for C++11.
+	* g++.dg/lookup/missing-std-include-8.C: Check make_unique here.
+
+2019-08-14  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-02  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* g++.dg/ext/instantiate2.C: Remove special-casing for Darwin.
+
+2013-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90563
+	* gfortran.dg/do_subscript_5.f90: New test.
+
+2019-08-05  Kito Cheng  <kito.cheng@sifive.com>
+
+	Backport from mainline
+	2019-08-05  Kito Cheng  <kito.cheng@sifive.com>
+
+	* gcc.target/riscv/promote-type-for-libcall.c: New.
+
+2019-08-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Paul Thomas <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90786
+	PR fortran/90813
+	* gfortran.dg/proc_ptr_51.f90: New test.
+
+2019-07-22  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-07-22  Martin Liska  <mliska@suse.cz>
+
+	PR driver/91172
+	* gcc.dg/pr91172.c: New test.
+
+2019-07-21  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline
+	2019-07-18  Richard Sandiford  <richard.sandiford@arm.com>
+
+	* c-c++-common/pr53633-2.c: New test.
+
+2019-07-16  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backport from mainline
+	PR target/89222
+	* gcc.target/arm/pr89222.c: Add new test.
+
+2019-07-16  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	Backport from mainline
+	2019-02-04  Wilco Dijkstra  <wdijkstr@arm.com>
+	PR target/89190
+	* gcc.target/arm/pr89190.c: New test.
+
+2019-07-15  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-07-01  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/vector/vec-shift-2.c: New test.
+
+2019-07-12  Wilco Dijkstra  <wdijkstr@arm.com>
+
+	PR testsuite/78529
+	* gcc.c-torture/execute/builtins/builtins.exp: Add -fno-ipa-ra.
+
+2019-07-07  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91077
+	* gfortran.dg/pointer_array_11.f90 : New test.
+
+2019-07-04  Chenghua Xu  <paul.hua.gm@gmail.com>
+
+	Backported from mainline.
+	* gcc.target/mips/mips-fmadd.c: Rename to ...
+	* gcc.target/mips/mips-fmadd-o32.c: ... Here; add abi=32.
+	* gcc.target/mips/mips-fmadd-n64.c: New.
+
+2019-07-04  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-07-03  Martin Liska  <mliska@suse.cz>
+
+	PR middle-end/90899
+	* gcc.target/i386/pr90899.c: New test.
+
+2019-06-29  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/specs/array5.ads: New test.
+	* gnat.dg/specs/array5_pkg1.ads: New helper.
+	* gnat.dg/specs/array5_pkg2.ads: Likewise.
+	* gnat.dg/specs/array5_pkg2-g.ads: Likewise.
+
+2019-06-21  Jeff Law  <law@redhat.com>
+
+	Backport fom mainline
+	2019-06-21  Jeff Law  <law@redhat.com>
+
+        PR tree-optimization/90949
+	* gcc.c-torture/execute/pr90949.c: New test.
+
+2019-06-21  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90937
+	* gfortran.dg/external_procedure_4.f90: New test.
+
+2019-06-16  Jeff Law  <law@redhat.com>
+
+	Backported from mainline
+	2019-05-31  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+	* gcc.target/mips/msa-fmadd.c: New.
+
+2019-06-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Tomáš Trnka  <trnka@scm.com>
+
+	Backport from trunk
+	PR fortran/90744
+	* gfortran.dg/deferred_character_33.f90: New test.
+	* gfortran.dg/deferred_character_33a.f90: New test.
+
+2019-06-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90810
+	* g++.dg/ext/vector37.C: New test.
+
+2019-06-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90498
+	* gfortran.dg/associate_48.f90 : New test.
+
+2019-06-09  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/57284
+	* gfortran.dg/assign_10.f90: Bump up counts of "atmp".
+	* gfortran.dg/transpose_optimization_2.f90: Ditto
+
+2019-06-09  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/57284
+	* gfortran.dg/class_70.f03
+
+2019-06-07  John David Anglin  <danglin@gcc.gnu.org>
+
+	* lib/scanasm.exp (dg-function-on-line): Add pattern for hppa*-*-linux*.
+
+2019-06-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/82920
+	* gcc.target/i386/indirect-thunk-bnd-1.c: Adjust scan-asms for Darwin,
+	do not use -fno-pic on Darwin.
+	* gcc.target/i386/indirect-thunk-bnd-2.c: Likewise.
+	* gcc.target/i386/ret-thunk-25.c: Skip for Darwin, which has a
+	different ABI for returning this category of complex value.
+
+2019-06-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-15  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/82920
+	* g++.dg/cet-notrack-1.C: Adjust scan assembler for Darwin.
+	* gcc.target/i386/cet-notrack-5a.c: Likewise.
+	* gcc.target/i386/cet-notrack-5b.c: Likewise.
+	* gcc.target/i386/cet-notrack-6b.c: Likewise.
+	* gcc.target/i386/cet-notrack-icf-1.c: Likewise.
+	* gcc.target/i386/cet-notrack-icf-2.c: Likewise.
+	* gcc.target/i386/cet-notrack-icf-3.c: Likewise.
+	* gcc.target/i386/cet-notrack-icf-4.c: Likewise.
+	* gcc.target/i386/cet-sjlj-3.c: Likewise.
+	* gcc.target/i386/cet-sjlj-5.c: Likewise.
+
+2019-06-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-14  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/82920
+	* gcc.target/i386/cet-sjlj-6b.c: Require effective target x32.
+	* gcc.target/i386/pr52146.c: Likewise.
+	* gcc.target/i386/pr52698.c: Likewise.
+	* gcc.target/i386/pr52857-1.c: Likewise.
+	* gcc.target/i386/pr52857-2.c: Likewise.
+	* gcc.target/i386/pr52876.c: Likewise.
+	* gcc.target/i386/pr53698.c: Likewise.
+	* gcc.target/i386/pr54157.c: Likewise.
+	* gcc.target/i386/pr55049-1.c: Likewise.
+	* gcc.target/i386/pr55093.c: Likewise.
+	* gcc.target/i386/pr55116-1.c: Likewise.
+	* gcc.target/i386/pr55116-2.c: Likewise.
+	* gcc.target/i386/pr55597.c: Likewise.
+	* gcc.target/i386/pr59929.c: Likewise.
+	* gcc.target/i386/pr66470.c: Likewise.
+
+2019-06-07  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-12  Iain Sandoe  <iain@sandoe.co.uk>
+	    Dominique d'Humieres  <dominiq@gcc.gnu.org>
+
+	PR target/82920
+	* gcc.target/i386/indirect-thunk-1.c: Adjust scan-asms for Darwin,
+	do not use -fno-pic on Darwin.
+	* gcc.target/i386/indirect-thunk-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-5.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-6.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-8.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-register-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-register-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-register-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-register-4.c: Likewise.
+	* gcc.target/i386/ret-thunk-1.c: Likewise.
+	* gcc.target/i386/ret-thunk-10.c: Likewise.
+	* gcc.target/i386/ret-thunk-11.c: Likewise.
+	* gcc.target/i386/ret-thunk-12.c: Likewise.
+	* gcc.target/i386/ret-thunk-13.c: Likewise.
+	* gcc.target/i386/ret-thunk-14.c: Likewise.
+	* gcc.target/i386/ret-thunk-15.c: Likewise.
+	* gcc.target/i386/ret-thunk-16.c: Likewise.
+	* gcc.target/i386/ret-thunk-2.c: Likewise.
+	* gcc.target/i386/ret-thunk-22.c: Likewise.
+	* gcc.target/i386/ret-thunk-23.c: Likewise.
+	* gcc.target/i386/ret-thunk-24.c: Likewise.
+	* gcc.target/i386/ret-thunk-3.c: Likewise.
+	* gcc.target/i386/ret-thunk-4.c: Likewise.
+	* gcc.target/i386/ret-thunk-5.c: Likewise.
+	* gcc.target/i386/ret-thunk-6.c: Likewise.
+	* gcc.target/i386/ret-thunk-7.c: Likewise.
+	* gcc.target/i386/ret-thunk-8.c: Likewise.
+	* gcc.target/i386/ret-thunk-9.c: Likewise.
+
+2019-05-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt79.ad[sb]: New test.
+
+2019-05-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/specs/array4.ads: New test.
+
+2019-05-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/unchecked_convert13.adb: New test.
+
+2019-05-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-05-23  Martin Liska  <mliska@suse.cz>
+
+	PR sanitizer/90570
+	* g++.dg/asan/pr90570.C: New test.
+
+2019-05-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt78.ad[sb]: New test.
+
+2019-05-23  Uroš Bizjak  <ubizjak@gmail.com>
+
+	Backported from mainline
+	2019-05-21  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/90547
+	* gcc.target/i386/pr90547.c: New test.
+
+2019-05-22  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* g++.dg/tls/pr85400.C: New test.
+
+2019-05-20  Jeff Law  <law@redhat.com>
+
+	Backported from mainline
+	2019-05-17  Dragan Mladjenovic  <dmladjenovic@wavecomp.com>
+
+	* g++.dg/eh/o32-fp.C: New.
+	* gcc.target/mips/dwarfregtable-1.c: New.
+	* gcc.target/mips/dwarfregtable-2.c: New.
+	* gcc.target/mips/dwarfregtable-3.c: New.
+	* gcc.target/mips/dwarfregtable-4.c: New.
+	* gcc.target/mips/dwarfregtable.h: New.
+
+2019-05-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from mainline
+	2019-05-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/90532 Ensure __is_constructible(T[]) is false
+	* g++.dg/ext/90532.C: New test.
+
+2019-05-16  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-05-07  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89765
+	* gcc.target/powerpc/pr89765-mc.c: New test.
+	* gcc.target/powerpc/vsx-builtin-10c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-10d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-11c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-11d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-12c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-12d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-14c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-14d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-15c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-15d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-16c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-16d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-17c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-17d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-18c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-18d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-19c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-19d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-20c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-20d.c: New test.
+	* gcc.target/powerpc/vsx-builtin-9c.c: New test.
+	* gcc.target/powerpc/vsx-builtin-9d.c: New test.
+
+2019-05-08  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline.
+	2019-05-06  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89424
+	* gcc.target/powerpc/pr89424-0.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13a.c: Define macro PR89424 to
+	enable testing of newly patched capability.
+	* gcc.target/powerpc/vsx-builtin-13b.c: Likewise.
+	* gcc.target/powerpc/vsx-builtin-20a.c: Likewise.
+	* gcc.target/powerpc/vsx-builtin-20b.c: Likewise.
+
+2019-05-06  Richard Biener  <rguenther@suse.de>
+
+	PR bootstrap/90359
+	Backport from mainline
+	2019-03-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89655
+	PR bootstrap/89656
+	* gcc.c-torture/compile/pr89655.c: New test.
+
+2019-05-03  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89698
+	* g++.dg/torture/pr89698.C: New testcase.
+
+	2019-03-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89595
+	* gcc.dg/torture/pr89595.c: New testcase.
+
+	2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89710
+	* gcc.dg/torture/pr89710.c: New testcase.
+
+	2019-04-15  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90071
+	* gcc.dg/torture/pr90071.c: New testcase.
+
+	2018-08-20  Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR target/86984
+	* gcc.target/alpha/pr86984.c: New test.
+
+2019-04-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-04-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/90193
+	* gcc.target/i386/pr90193.c: New test.
+
+	PR target/90187
+	* g++.dg/opt/pr90187.C: New test.
+
+	PR tree-optimization/90208
+	* gcc.dg/tsan/pr90208-2.c: New test.
+
+	2019-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90108
+	* c-c++-common/pr90108.c: New test.
+
+	2019-04-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/90082
+	* gcc.dg/pr90082.c: New test.
+
+	PR tree-optimization/90090
+	* g++.dg/opt/pr90090.C: New test.
+
+	2019-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89933
+	* c-c++-common/pr89933.c: New test.
+
+	PR rtl-optimization/89965
+	* gcc.target/i386/pr89965.c: New test.
+
+	PR c/89946
+	* c-c++-common/pr89946.c: New test.
+
+	PR rtl-optimization/90026
+	* g++.dg/opt/pr90026.C: New test.
+
+	2019-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90010
+	* gcc.dg/pr90010.c: New test.
+
+	2019-04-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/89998
+	* gcc.c-torture/compile/pr89998-1.c: New test.
+	* gcc.c-torture/compile/pr89998-2.c: New test.
+
+	2019-03-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/89869
+	* g++.dg/ubsan/vptr-14.C: New test.
+
+	PR c/89872
+	* gcc.dg/tree-ssa/pr89872.c: New test.
+
+	2019-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89621
+	* gfortran.dg/gomp/pr89621.f90: New test.
+
+	2019-03-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89796
+	* g++.dg/gomp/pr89796.C: New test.
+	* gcc.dg/gomp/pr89796.c: New test.
+
+	2019-03-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/60702
+	* g++.dg/tls/thread_local11.C: Remove scan-tree-dump-times directives
+	for _ZTH* calls.
+	* g++.dg/tls/thread_local11a.C: New test.
+
+	2019-03-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/60702
+	* g++.dg/tls/thread_local11.C: New test.
+	* g++.dg/tls/thread_local11.h: New test.
+	* g++.dg/tls/thread_local12a.C: New test.
+	* g++.dg/tls/thread_local12b.C: New test.
+	* g++.dg/tls/thread_local12c.C: New test.
+	* g++.dg/tls/thread_local12d.C: New test.
+	* g++.dg/tls/thread_local12e.C: New test.
+	* g++.dg/tls/thread_local12f.C: New test.
+	* g++.dg/tls/thread_local12g.C: New test.
+	* g++.dg/tls/thread_local12h.C: New test.
+	* g++.dg/tls/thread_local12i.C: New test.
+	* g++.dg/tls/thread_local12j.C: New test.
+	* g++.dg/tls/thread_local12k.C: New test.
+	* g++.dg/tls/thread_local12l.C: New test.
+
+	2019-03-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89767
+	* g++.dg/cpp1y/lambda-init18.C: New test.
+	* g++.dg/cpp1y/lambda-init19.C: New test.
+	* g++.dg/cpp1y/pr89767.C: New test.
+
+	2019-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/89752
+	* g++.dg/ext/asm15.C: Check for particular diagnostic wording.
+	* g++.dg/ext/asm16.C: Likewise.
+	* g++.dg/ext/asm17.C: New test.
+
+	PR target/89726
+	* gcc.target/i386/fpprec-1.c (x): Add 6 new constants.
+	(expect_round, expect_rint, expect_floor, expect_ceil, expect_trunc):
+	Add expected results for them.
+
+	PR c/89734
+	* gcc.dg/pr89734.c: New test.
+
+	2019-03-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/89704
+	* gcc.dg/debug/pr89704.c: New test.
+
+	2019-03-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/89684
+	* gcc.target/i386/pr89684.c: New test.
+
+	PR rtl-optimization/89679
+	* gcc.dg/pr89679.c: New test.
+
+	PR tree-optimization/89703
+	* gcc.c-torture/compile/pr89703-1.c: New test.
+	* gcc.c-torture/compile/pr89703-2.c: New test.
+
+	PR c++/89512
+	* g++.dg/cpp1y/var-templ61.C: New test.
+
+	2019-03-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/88588
+	* c-c++-common/gomp/pr88588.c: New test.
+
+	2019-03-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89663
+	* gcc.c-torture/compile/pr89663-1.c: New test.
+	* gcc.c-torture/compile/pr89663-2.c: New test.
+
+	2019-03-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/89651
+	* gfortran.dg/gomp/pr89651.f90: New test.
+
+	2019-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/88568
+	* g++.dg/other/pr88568.C: New test.
+
+	2019-03-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/82075
+	* g++.dg/cpp1z/decomp49.C: New test.
+
+	2019-03-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/87148
+	* g++.dg/ext/flexary34.C: New test.
+
+	2019-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/89590
+	* gcc.dg/pr89590.c: New test.
+
+	2019-02-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89521
+	* gcc.dg/pr89521-1.c: New test.
+	* gcc.dg/pr89521-2.c: New test.
+
+	PR c/89520
+	* gcc.dg/pr89520-1.c: New test.
+	* gcc.dg/pr89520-2.c: New test.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89403
+	* g++.dg/cpp0x/pr89403.C: New test.
+
+	PR c++/89405
+	* g++.dg/cpp1z/inline-var5.C: New test.
+
+	PR middle-end/89412
+	* gcc.c-torture/compile/pr89412.c: New test.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+		    David Malcolm  <dmalcolm@redhat.com>
+
+	PR middle-end/89091
+	* gcc.dg/torture/pr89091.c: New test.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/88074
+	PR middle-end/89415
+	* gcc.dg/pr88074-2.c: New test.
+
+	2019-02-19  Richard Biener  <rguenther@suse.de>
+
+        PR middle-end/88074
+	* gcc.dg/pr88074.c: New testcase.
+
+2019-04-30  Srinath Parvathaneni  <srinath.parvathaneni@arm.com>
+
+	PR target/90075
+	* gcc.target/aarch64/pr90075.c: New test.
+
+2019-04-29  Richard Sandiford  <richard.sandiford@arm.com>
+
+	Backport from mainline:
+	2019-01-25  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR middle-end/89037
+	* gcc.dg/pr89037.c: New test.
+
+2019-04-26  Roman Zhuykov  <zhroma@ispras.ru>
+
+	Backport from mainline
+	2019-04-23  Roman Zhuykov  <zhroma@ispras.ru>
+
+	PR rtl-optimization/87979
+	* gcc.dg/pr87979.c: New test.
+
+	PR rtl-optimization/84032
+	* gcc.dg/pr84032.c: New test.
+
+2019-04-24  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/87127
+	* gfortran.dg/external_procedures_4.f90: New test.
+
+2019-04-17  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-10  Martin Jambor  <mjambor@suse.cz>
+
+        * g++.dg/tree-ssa/pr87008.C: New test.
+        * gcc.dg/guality/pr54970.c: Xfail tests querying a[0] everywhere.
+
+2019-04-17  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-03-15  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/87532
+	* gcc.target/powerpc/pr87532.c: New test.
+	* gcc.target/powerpc/vec-extract-v16qiu-v2.h: New test.
+	* gcc.target/powerpc/vec-extract-v16qiu-v2a.c: New test.
+	* gcc.target/powerpc/vec-extract-v16qiu-v2b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-10a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-10b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-11a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-11b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-12a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-12b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-13b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-14a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-14b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-15a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-15b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-16a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-16b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-17a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-17b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-18a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-18b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-19a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-19b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-20a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-20b.c: New test.
+	* gcc.target/powerpc/vsx-builtin-9a.c: New test.
+	* gcc.target/powerpc/vsx-builtin-9b.c: New test.
+
+	2019-03-19  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR target/89736
+	* gcc.target/powerpc/pr87532-mc.c: Modify dejagnu directives to
+	restrict this test to vsx targets.
+
+2019-04-15  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-04-15  Martin Jambor  <mjambor@suse.cz>
+
+	* g++.dg/ipa/pr89693.C: New test.
+
+2019-04-15  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-01-18  Martin Liska  <mliska@suse.cz>
+
+	PR middle-end/88587
+	* g++.target/i386/pr88587.C: New test.
+	* gcc.target/i386/mvc13.c: New test.
+
+2019-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/87352
+	* gfortran.dg/finalize_28.f90: Adjust count of __builtin_free.
+	* gfortran.dg/finalize_34.f90: New test.
+
+2019-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/89981
+	* gfortran.dg/entry_22.f90: New test.
+
+2019-04-11  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/90018
+	* gcc.dg/vect/pr90018.c: New testcase.
+
+2019-04-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89904
+	* gfortran.dg/pr85797.f90: Adjust testcase.
+
+2019-04-10  Matthew Malcomson  <matthew.malcomson@arm.com>
+
+	PR target/90024
+	* gcc.dg/torture/neon-immediate-timode.c: New test.
+
+019-04-07  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/89945
+	* gcc.target/i386/pr89945.c: New test.
+
+2019-04-04  Martin Sebor  <msebor@redhat.com>
+
+	PR middle-end/89934
+	* gcc.dg/Wrestrict-19.c: New test.
+	* gcc.dg/Wrestrict-5.c: Add comment.  Remove unused code.
+
+2019-04-02  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/89902
+	PR target/89903
+	* gcc.target/i386/pr70799-4.c: Remove.
+	* gcc.target/i386/pr70799-5.c: Remove.
+	* gcc.target/i386/pr89902.c: New test.
+	* gcc.target/i386/pr89903.c: Ditto.
+
+2019-03-31  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/83515
+	PR fortran/85797
+	* gfortran.dg/pr85797.f90: New test.
+
+2019-03-30  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/89866
+	Backport from trunk
+	* gfortran.dg/pointer_intent_8.f90: New test.
+
+2019-03-30  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/78865
+	Backport from trunk
+	* gfortran.dg/altreturn_10.f90: New test.
+	* gfortran.dg/whole_file_3.f90: Change dg-warning to dg-error.
+
+2019-03-28  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/89848
+	* gcc.target/i386/pr89848.c: New test.
+
+2019-03-26  Uroš Bizjak  <ubizjak@gmail.com>
+
+	PR target/89827
+	* gcc.target/i386/pr89827.c: New test.
+
+2019-03-25  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-03-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/89775
+	* gcc.target/s390/pr89775-1.c: New test.
+	* gcc.target/s390/pr89775-2.c: New test.
+
+2019-03-24  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/71861
+	Backport from trunk
+	* gfortran.dg/interface_abstract_5.f90: New test case.
+
+2019-03-22  Backport from mainline
+
+	2019-03-22  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	* gcc.target/powerpc/mmx-psubd-2.c: Test _m_psubd.
+
+2019-03-21  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR fortran/56408
+	* gcc.target/powerpc/ppc-fortran/ppc-fortran.exp
+	(dg-compile-aux-modules): Fix diagnostic.
+	* gfortran.dg/coarray/caf.exp (dg-compile-aux-modules): Likewise.
+	* gfortran.dg/dg.exp (dg-compile-aux-modules): Likewise.
+
+	PR fortran/56408
+	* gfortran.dg/coarray/caf.exp (dg-compile-aux-modules): Workaround
+	missing nexted dg-test call support in dejaGNU 1.4.4.
+
+	PR fortran/29383
+	* gfortran.dg/ieee/ieee.exp (DEFAULT_FFLAGS): Set the same as in
+	other '*.exp' files.
+
+2019-03-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* c-c++-common/unroll-7.c: New test.
+
+2019-03-18  Martin Sebor  <msebor@redhat.com>
+
+	PR middle-end/88273
+	* gcc.dg/Warray-bounds-38.c: New test.
+
+2019-03-18  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-18  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/89546
+	* gcc.dg/tree-ssa/pr89546.c: New test.
+
+2019-03-17  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/84394
+	Backport from trunk
+	* gfortran.dg/blockdata_11.f90: New test.
+
+2019-03-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2019-03-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/89523
+	* gcc.target/i386/pr89523-1a.c: New test.
+	* gcc.target/i386/pr89523-1b.c: Likewise.
+	* gcc.target/i386/pr89523-2.c: Likewise.
+	* gcc.target/i386/pr89523-3.c: Likewise.
+	* gcc.target/i386/pr89523-4.c: Likewise.
+	* gcc.target/i386/pr89523-5.c: Likewise.
+	* gcc.target/i386/pr89523-6.c: Likewise.
+	* gcc.target/i386/pr89523-7.c: Likewise.
+	* gcc.target/i386/pr89523-8.c: Likewise.
+	* gcc.target/i386/pr89523-9.c: Likewise.
+
+2019-03-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66089
+	Backport from trunk
+	* gfortran.dg/dependency_53.f90: New test.
+	* gfortran.dg/assumed_type_2.f90: Adapted tree dumps.
+	* gfortran.dg/no_arg_check_2.f90: Likewise.
+
+2019-03-16 Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66695
+	PR fortran/77746
+	PR fortran/79485
+	Backport from trunk
+	* gfortran.dg/binding_label_tests_30.f90: New test.
+	* gfortran.dg/binding_label_tests_31.f90: New test.
+	* gfortran.dg/binding_label_tests_32.f90: New test.
+	* gfortran.dg/binding_label_tests_33.f90: New test.
+
+2019-03-15  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-03-06  Richard Biener  <rguenther@suse.de>
+
+	PR testsuite/89551
+	* gcc.dg/uninit-pred-8_b.c: Force logical-op-non-short-circuit
+	the way that makes the testcase PASS.
+
+2019-03-14  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-07  Martin Jambor  <mjambor@suse.cz>
+
+	PR lto/87525
+	* gcc.dg/ipa/ipcp-5.c: New test.
+
+2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89572
+	* gcc.dg/torture/pr89572.c: New testcase.
+
+2019-03-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87673
+	Backport from trunk
+	* gfortran.dg/charlen_17.f90: New test.
+
+2019-03-13  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR target/85860
+	* gcc.target/i386/pr85860.c: New.
+
+2019-03-14  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-03-13  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89677
+	* gcc.dg/torture/pr89677.c: New testcase.
+
+	2019-03-01  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89497
+	* gcc.dg/tree-ssa/reassoc-43.c: Avoid false match in regex.
+	* g++.dg/tree-prof/devirt.C: Scan tracer dump for foldings
+	that happen now earlier.
+
+	2019-02-18  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89296
+	* gcc.dg/uninit-pr89296.c: New testcase.
+
+2019-03-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-03-11  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/zvector/vec-addc-u128.c: New test.
+
+2019-03-13  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2019-02-07  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/zvector/xl-xst-align-1.c: New test.
+	* gcc.target/s390/zvector/xl-xst-align-2.c: New test.
+
+2019-03-12  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89664
+	* gfortran.dg/pr89664.f90: New testcase.
+
+2019-03-12  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2019-03-08  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* gcc.target/arm/f16_f64_conv_no_dp.c: New test.
+
+	Backport from mainline
+	2019-03-11  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	* gcc.target/arm/f16_f64_conv_no_dp.c: Add arm_fp16_ok effective
+	target.
+
+2019-03-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* c-c++-common/unroll-6.c: New test.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-03-10  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gcc.target/i386/indirect-thunk-extern-7.c: Add -fjump-tables to
+	dg-options.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-03-08  Martin Liska  <mliska@suse.cz>
+
+	PR target/86952
+	* gcc.target/i386/indirect-thunk-7.c: Use jump tables to match
+	scanned pattern.
+	* gcc.target/i386/indirect-thunk-inline-7.c: Likewise.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71544
+	Backport from trunk
+	* gfortran.dg/c_ptr_tests_19.f90: New test.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87734
+	Backport from trunk
+	* gfortran.dg/public_private_module_10.f90: New test.
+
+2019-03-08  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2019-03-07  Martin Jambor  <mjambor@suse.cz>
+
+	* g++.dg/ipa/pr88235.C: New test.
+
+2019-03-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89585
+	* g++.dg/asm-qual-3.C: Adjust expected diagnostics.
+
+2019-03-06  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/71203
+	* gfortran.dg/substr_8.f90: New test.
+
+2019-03-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/72714
+	Backport from trunk
+	* gfortran.dg/coarray_allocate_11.f90: New test.
+
+2019-03-06  Tamar Christina  <tamar.christina@arm.com>
+
+	Backport from trunk.
+	2019-02-25  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/88530
+	* common/config/aarch64/aarch64-common.c
+	(struct aarch64_option_extension): Add is_synthetic.
+	(all_extensions): Use it.
+	(TARGET_OPTION_INIT_STRUCT): Define hook.
+	(struct gcc_targetm_common): Moved to end.
+	(all_extensions_by_on): New.
+	(opt_ext_cmp, typedef opt_ext): New.
+	(aarch64_option_init_struct): New.
+	(aarch64_contains_opt): New.
+	(aarch64_get_extension_string_for_isa_flags): Output smallest set.
+	* config/aarch64/aarch64-option-extensions.def
+	(AARCH64_OPT_EXTENSION): Explicitly include AES and SHA2 in crypto.
+	(fp, simd, crc, lse, fp16, rcpc, rdma, dotprod, aes, sha2, sha3,
+	sm4, fp16fml, sve):
+	Set is_synthetic to false.
+	(crypto): Set is_synthetic to true.
+	* config/aarch64/driver-aarch64.c (AARCH64_OPT_EXTENSION): Add
+	SYNTHETIC.
+
+2019-03-06  Tamar Christina  <tamar.christina@arm.com>
+
+	Backport from trunk.
+	2019-02-28  Tamar Christina  <tamar.christina@arm.com>
+
+	PR target/88530
+	* gcc.target/aarch64/options_set_10.c: New test.
+
+2019-03-06  Xiong Hu Luo  <luoxhu@linux.ibm.com>
+
+	Backport of r268834 from mainline to gcc-8-branch.
+	2019-01-23  Xiong Hu Luo  <luoxhu@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/crypto-builtin-1.c
+	(crypto1_be, crypto2_be, crypto3_be, crypto4_be, crypto5_be):
+	New testcases.
+
+2019-03-05  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-02-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/89505
+	* gcc.dg/torture/pr89505.c: New testcase.
+
+2019-03-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89077
+	* gfortran.dg/transfer_simplify_12.f90: New test.
+	* gfortran.dg/substr_simplify.f90: New test.
+
+2019-03-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/77583
+	* gfortran.dg/pr77583.f90: New test.
+
+2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/89174
+	Backport from trunk
+	* gfortran.dg/allocate_with_mold_3.f90: New test.
+
+2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87689
+	Backport from trunk
+	* gfortran.dg/lto/20091028-1_0.f90: Add -Wno-lto-type-mismatch to
+	options.
+	* gfortran.dg/lto/20091028-2_0.f90: Likewise.
+	* gfortran.dg/lto/pr87689_0.f: New file.
+	* gfortran.dg/lto/pr87689_1.f: New file.
+	* gfortran.dg/altreturn_9_0.f90: New file.
+	* gfortran.dg/altreturn_9_1.f90: New file.
+
+2019-03-02  Jerry DeLisle <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84387
+	* gfortran.dg/dtio_34.f90: New test.
+
+2019-03-02  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89516
+	* gfortran.dg/pr89492.f90: Adjust testcase.
+	* gfortran.dg/transfer_check_5.f90: New test.
+
+	PR fortran/89492
+	* gfortran.dg/pr89492.f90: New test.
+
+	PR fortran/89266
+	PR fortran/88326
+	* gfortran.dg/pr89266.f90: New test.
+	* gfortran.dg/pr88326.f90: New test.
+
+2019-02-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20190228-1.c: New test.
+
+2019-02-28  Li Jia He  <helijia@linux.ibm.com>
+
+	Backport from trunk
+	2019-02-20  Li Jia He  <helijia@linux.ibm.com>
+
+	PR target/88100
+	* gcc/testsuite/gcc.target/powerpc/pr88100.c: New testcase.
+
+2019-02-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt77.adb: New test.
+	* gnat.dg/opt77_pkg.ad[sb]: New helper.
+
+2019-02-23  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/86119
+	Backport from trunk
+	* gfortran.dg/warn_conversion_11.f90: New test.
+
+2019-02-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88117
+	* gfortran.dg/deferred_character_32.f90: New test
+
+2019-02-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71066
+	Backport from trunk
+	* gfortran.dg/coarray_data_1.f90: New test.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: gcc/testsuite/objc-obj-c++-shared/F-NSObject.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/F-NSObject.h b/gcc/testsuite/objc-obj-c++-shared/F-NSObject.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/F-NSObject.h	(revision 278653)
@@ -0,0 +1,33 @@
+/* Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef _OBJC_F_NSOBJECT_H_
+#define _OBJC_F_NSOBJECT_H_
+
+/* This is a workaround to PR90709 for the NeXT runtime.
+   If we're on a system version that has headers with items we can't
+   consume, then use the GNUStep header instead.
+*/
+
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1090
+#  import "GNUStep/Foundation/NSObject.h"
+#else 
+#  import <Foundation/NSObject.h>
+#endif
+
+#endif /* _OBJC_F_NSOBJECT_H_ */
Index: gcc/testsuite/objc-obj-c++-shared/F-NSString.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/F-NSString.h b/gcc/testsuite/objc-obj-c++-shared/F-NSString.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/F-NSString.h	(revision 278653)
@@ -0,0 +1,33 @@
+/* Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef _OBJC_F_NSSTRING_H_
+#define _OBJC_F_NSSTRING_H_
+
+/* This is a workaround to PR90709 for the NeXT runtime.
+   If we're on a system version that has headers with items we can't
+   consume, then use the GNUStep header instead.
+*/
+
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1090
+#  import "GNUStep/Foundation/NSString.h"
+#else 
+#  import <Foundation/NSString.h>
+#endif
+
+#endif /* _OBJC_F_NSSTRING_H_ */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFDictionary.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFDictionary.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFDictionary.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFDictionary.h	(revision 278653)
@@ -0,0 +1,174 @@
+/* CFDictionary.h
+
+   Copyright (C) 2010 Free Software Foundation, Inc.
+
+   Written by: Stefan Bidigaray
+   Date: January, 2010
+
+   This file is part of the GNUstep CoreBase Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; see the file COPYING.LIB.
+   If not, see <http://www.gnu.org/licenses/> or write to the 
+   Free Software Foundation, 51 Franklin Street, Fifth Floor, 
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef __COREFOUNDATION_CFDICTIONARY_H__
+#define __COREFOUNDATION_CFDICTIONARY_H__ 1
+
+#include "CFBase.h"
+
+CF_EXTERN_C_BEGIN
+/** \ingroup CFDictionaryRef */
+typedef const struct __CFDictionary *CFDictionaryRef;
+/** \ingroup CFMutableDictionaryRef */
+typedef struct __CFDictionary *CFMutableDictionaryRef;
+
+/** \defgroup CFDictionaryRef CFDictionary Reference
+    \{
+ */
+typedef void (*CFDictionaryApplierFunction) (const void *key,
+                                             const void *value, void *context);
+
+typedef CFStringRef (*CFDictionaryCopyDescriptionCallBack) (const void *value);
+typedef Boolean (*CFDictionaryEqualCallBack) (const void *value1,
+                                              const void *value2);
+typedef CFHashCode (*CFDictionaryHashCallBack) (const void *value);
+typedef void (*CFDictionaryReleaseCallBack) (CFAllocatorRef allocator,
+                                             const void *value);
+typedef const void *(*CFDictionaryRetainCallBack) (CFAllocatorRef allocator,
+                                                   const void *value);
+
+typedef struct _CFDictionaryKeyCallBacks CFDictionaryKeyCallBacks;
+struct _CFDictionaryKeyCallBacks
+{
+  CFIndex version;
+  CFDictionaryRetainCallBack retain;
+  CFDictionaryReleaseCallBack release;
+  CFDictionaryCopyDescriptionCallBack copyDescription;
+  CFDictionaryEqualCallBack equal;
+  CFDictionaryHashCallBack hash;
+};
+
+typedef struct _CFDictionaryValueCallBacks CFDictionaryValueCallBacks;
+struct _CFDictionaryValueCallBacks
+{
+  CFIndex version;
+  CFDictionaryRetainCallBack retain;
+  CFDictionaryReleaseCallBack release;
+  CFDictionaryCopyDescriptionCallBack copyDescription;
+  CFDictionaryEqualCallBack equal;
+};
+
+CF_EXPORT const CFDictionaryKeyCallBacks kCFCopyStringDictionaryKeyCallBacks;
+CF_EXPORT const CFDictionaryKeyCallBacks kCFTypeDictionaryKeyCallBacks;
+CF_EXPORT const CFDictionaryValueCallBacks kCFTypeDictionaryValueCallBacks;
+
+/** \name Creating a dictionary
+    \{
+ */
+CF_EXPORT CFDictionaryRef
+CFDictionaryCreate (CFAllocatorRef allocator, const void **keys,
+                    const void **values, CFIndex numValues,
+                    const CFDictionaryKeyCallBacks * keyCallBacks,
+                    const CFDictionaryValueCallBacks * valueCallBacks);
+
+CF_EXPORT CFDictionaryRef
+CFDictionaryCreateCopy (CFAllocatorRef allocator, CFDictionaryRef theDict);
+/** \} */
+
+/** \name Examining a dictionary
+    \{
+ */
+CF_EXPORT Boolean
+CFDictionaryContainsKey (CFDictionaryRef theDict, const void *key);
+
+CF_EXPORT Boolean
+CFDictionaryContainsValue (CFDictionaryRef theDict, const void *value);
+
+CF_EXPORT CFIndex CFDictionaryGetCount (CFDictionaryRef theDict);
+
+CF_EXPORT CFIndex
+CFDictionaryGetCountOfKey (CFDictionaryRef theDict, const void *key);
+
+CF_EXPORT CFIndex
+CFDictionaryGetCountOfValue (CFDictionaryRef theDict, const void *value);
+
+CF_EXPORT void
+CFDictionaryGetKeysAndValues (CFDictionaryRef theDict, const void **keys,
+                              const void **values);
+
+CF_EXPORT const void *CFDictionaryGetValue (CFDictionaryRef theDict,
+                                            const void *key);
+
+CF_EXPORT Boolean
+CFDictionaryGetValueIfPresent (CFDictionaryRef theDict, const void *key,
+                               const void **value);
+/** \} */
+
+/** \name Applying a funcation to a dictionary
+    \{
+ */
+CF_EXPORT void
+CFDictionaryApplyFunction (CFDictionaryRef theDict,
+                           CFDictionaryApplierFunction applier, void *context);
+/** \} */
+
+/** \name Getting the CFDictionary type ID
+    \{
+ */
+CF_EXPORT CFTypeID CFDictionaryGetTypeID (void);
+/** \} */
+/** \} */
+
+/** \defgroup CFMutableDictionaryRef CFMutableDictionary Reference
+    \{
+ */
+/** \name Creating a Mutable Dictionary
+    \{
+ */
+CF_EXPORT CFMutableDictionaryRef
+CFDictionaryCreateMutable (CFAllocatorRef allocator, CFIndex capacity,
+                           const CFDictionaryKeyCallBacks * keyCallBacks,
+                           const CFDictionaryValueCallBacks * valueCallBacks);
+
+CF_EXPORT CFMutableDictionaryRef
+CFDictionaryCreateMutableCopy (CFAllocatorRef allocator, CFIndex capacity,
+                               CFDictionaryRef theDict);
+/** \} */
+
+/** \name Modifying a Dictionary
+    \{
+ */
+CF_EXPORT void
+CFDictionaryAddValue (CFMutableDictionaryRef theDict, const void *key,
+                      const void *value);
+
+CF_EXPORT void CFDictionaryRemoveAllValues (CFMutableDictionaryRef theDict);
+
+CF_EXPORT void
+CFDictionaryRemoveValue (CFMutableDictionaryRef theDict, const void *key);
+
+CF_EXPORT void
+CFDictionaryReplaceValue (CFMutableDictionaryRef theDict, const void *key,
+                          const void *value);
+
+CF_EXPORT void
+CFDictionarySetValue (CFMutableDictionaryRef theDict, const void *key,
+                      const void *value);
+/** \} */
+/** \} */
+
+CF_EXTERN_C_END
+#endif /* __COREFOUNDATION_CFDICTIONARY_H__ */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFString.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFString.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFString.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFString.h	(revision 278653)
@@ -0,0 +1,593 @@
+/* CFString.h
+   
+   Copyright (C) 2010 Free Software Foundation, Inc.
+   
+   Written by: Stefan Bidigaray
+   Date: January, 2010
+   
+   This file is part of CoreBase.
+   
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; see the file COPYING.LIB.
+   If not, see <http://www.gnu.org/licenses/> or write to the 
+   Free Software Foundation, 51 Franklin Street, Fifth Floor, 
+   Boston, MA 02110-1301, USA.
+*/ 
+
+#ifndef __COREFOUNDATION_CFSTRING_H__
+#define __COREFOUNDATION_CFSTRING_H__
+
+#include "CFBase.h"
+#include "CFArray.h"
+#include "CFCharacterSet.h"
+#include "CFData.h"
+#include "CFDictionary.h"
+#include "CFLocale.h"
+
+#include <stdarg.h>
+
+CF_EXTERN_C_BEGIN
+
+/** \defgroup CFStringRef CFString Reference
+    \brief The CFString type defines opaque objects representing strings.
+
+    CFString is "toll-free bridged" to NSString.
+
+    \{
+ */
+
+/*
+ * Data Types
+ */
+typedef UInt32 CFStringEncoding;
+
+/*
+ * Constants
+ */
+typedef enum
+{
+  kCFCompareCaseInsensitive = 1,
+  kCFCompareBackwards = 4,
+  kCFCompareAnchored = 8,
+  kCFCompareNonliteral = 16,
+  kCFCompareLocalized = 32,
+  kCFCompareNumerically = 64,
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+  kCFCompareDiacriticInsensitive = 128,
+  kCFCompareWidthInsensitive = 256,
+  kCFCompareForcedOrdering = 512
+#endif
+} CFStringCompareFlags;
+
+enum CFStringBuiltInEncodings
+{
+  kCFStringEncodingMacRoman = 0,
+  kCFStringEncodingWindowsLatin1 = 0x0500,
+  kCFStringEncodingISOLatin1 = 0x0201,
+  kCFStringEncodingNextStepLatin = 0x0B01,
+  kCFStringEncodingASCII = 0x0600,
+  kCFStringEncodingUnicode = 0x0100,
+  kCFStringEncodingUTF8 = 0x08000100,
+  kCFStringEncodingNonLossyASCII = 0x0BFF,
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+  kCFStringEncodingUTF16 = 0x0100,
+  kCFStringEncodingUTF16BE = 0x10000100,
+  kCFStringEncodingUTF16LE = 0x14000100,
+  kCFStringEncodingUTF32 = 0x0c000100,
+  kCFStringEncodingUTF32BE = 0x18000100,
+  kCFStringEncodingUTF32LE = 0x1c000100
+#endif
+};
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2, GS_API_LATEST)
+# define kCFStringEncodingInvalidId (0xffffffffU)
+#endif
+
+/** \def CFSTR(x)
+    \brief Creates a constant string object.
+    
+    \note This macro will create the constant string at runtime.
+ */
+/* The 'pure' attribute tells the compiler that this function will always
+   return the same result with the same input.  If it has any skill, then
+   constant propagation passes will magically make sure that this function is
+   called as few times as possible. */
+CF_EXPORT CFStringRef
+__CFStringMakeConstantString (const char *str) GS_PURE_FUNCTION;
+//#define CFSTR(x) __CFStringMakeConstantString("" x "")
+
+#ifdef __CONSTANT_CFSTRINGS__
+#define CFSTR(x)  ((CFStringRef) __builtin___CFStringMakeConstantString ("" x ""))
+#else
+#define CFSTR(x)  __CFStringMakeConstantString("" x "")
+#endif
+
+/** \name Creating a CFString
+    \{
+ */
+CF_EXPORT CFArrayRef
+CFStringCreateArrayBySeparatingStrings (CFAllocatorRef alloc,
+  CFStringRef theString, CFStringRef separatorString);
+
+CF_EXPORT CFStringRef
+CFStringCreateByCombiningStrings (CFAllocatorRef alloc, CFArrayRef theArray,
+  CFStringRef separatorString);
+
+CF_EXPORT CFStringRef
+CFStringCreateCopy (CFAllocatorRef alloc, CFStringRef theString);
+
+CF_EXPORT CFStringRef
+CFStringCreateFromExternalRepresentation (CFAllocatorRef alloc, CFDataRef data,
+  CFStringEncoding encoding);
+
+CF_EXPORT CFStringRef
+CFStringCreateWithBytes (CFAllocatorRef alloc, const UInt8 *bytes,
+  CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation);
+
+CF_EXPORT CFStringRef
+CFStringCreateWithCharacters (CFAllocatorRef alloc, const UniChar *chars,
+  CFIndex numChars);
+
+CF_EXPORT CFStringRef
+CFStringCreateWithCharactersNoCopy (CFAllocatorRef alloc, const UniChar *chars,
+  CFIndex numChars, CFAllocatorRef contentsDeallocator);
+
+CF_EXPORT CFStringRef
+CFStringCreateWithCString (CFAllocatorRef alloc, const char *cStr,
+  CFStringEncoding encoding);
+
+CF_EXPORT CFStringRef
+CFStringCreateWithCStringNoCopy (CFAllocatorRef alloc, const char *cStr,
+  CFStringEncoding encoding, CFAllocatorRef contentsDeallocator);
+
+CF_EXPORT CFStringRef
+CFStringCreateWithFormat (CFAllocatorRef alloc, CFDictionaryRef formatOptions,
+  CFStringRef format, ...);
+
+CF_EXPORT CFStringRef
+CFStringCreateWithFormatAndArguments (CFAllocatorRef alloc,
+  CFDictionaryRef formatOptions, CFStringRef format, va_list arguments);
+
+CF_EXPORT CFStringRef
+CFStringCreateWithSubstring (CFAllocatorRef alloc, CFStringRef str,
+  CFRange range);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT CFStringRef
+CFStringCreateWithFileSystemRepresentation (CFAllocatorRef alloc,
+  const char *buffer);
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+CF_EXPORT CFStringRef
+CFStringCreateWithBytesNoCopy (CFAllocatorRef alloc, const UInt8 *bytes,
+  CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalReprentation,
+  CFAllocatorRef contentsDeallocator);
+#endif
+/** \} */
+
+/** \name Searching CFStrings
+    \{
+ */
+CF_EXPORT CFArrayRef
+CFStringCreateArrayWithFindResults (CFAllocatorRef alloc, CFStringRef theString,
+  CFStringRef stringToFind, CFRange rangeToSearch,
+  CFStringCompareFlags compareOptions);
+
+CF_EXPORT CFRange
+CFStringFind (CFStringRef theString, CFStringRef stringToFind,
+  CFStringCompareFlags compareOptions);
+
+CF_EXPORT Boolean
+CFStringFindWithOptions (CFStringRef theString, CFStringRef stringToFind,
+  CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result);
+
+CF_EXPORT Boolean
+CFStringFindWithOptionsAndLocale (CFStringRef theString,CFStringRef stringToFind,
+  CFRange rangeToSearch, CFStringCompareFlags searchOptions,
+  CFLocaleRef locale, CFRange *result);
+
+CF_EXPORT void
+CFStringGetLineBounds (CFStringRef theString, CFRange range,
+  CFIndex *lineBeginIndex, CFIndex *lineEndIndex, CFIndex *contentsEndIndex);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2, GS_API_LATEST)
+CF_EXPORT Boolean
+CFStringFindCharacterFromSet (CFStringRef theString, CFCharacterSetRef theSet,
+  CFRange rangeToSearch, CFStringCompareFlags searchOptions, CFRange *result);
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+CF_EXPORT void
+CFStringGetParagraphBounds (CFStringRef string, CFRange range,
+  CFIndex *parBeginIndex, CFIndex *parEndIndex, CFIndex *contentsEndIndex);
+#endif
+/** \} */
+
+/** \name Comparing String
+    \{
+ */
+CF_EXPORT CFComparisonResult
+CFStringCompare (CFStringRef theString1, CFStringRef theString2,
+  CFStringCompareFlags compareOptions);
+
+CF_EXPORT CFComparisonResult
+CFStringCompareWithOptions (CFStringRef theString1, CFStringRef theString2,
+  CFRange rangeToCOmpare, CFStringCompareFlags compareOptions);
+
+CF_EXPORT Boolean
+CFStringHasPrefix (CFStringRef theString, CFStringRef prefix);
+
+CF_EXPORT Boolean
+CFStringHasSuffix (CFStringRef theString, CFStringRef suffix);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+CF_EXPORT CFComparisonResult
+CFStringCompareWithOptionsAndLocale (CFStringRef theString1,
+  CFStringRef theString2, CFRange rangeToCOmpare,
+  CFStringCompareFlags compareOptions, CFLocaleRef locale);
+#endif
+/** \} */
+
+/** \name Accessing Characters
+    \{
+ */
+CF_EXPORT CFDataRef
+CFStringCreateExternalRepresentation (CFAllocatorRef alloc,
+  CFStringRef theString, CFStringEncoding encoding, UInt8 lossByte);
+
+CF_EXPORT CFIndex
+CFStringGetBytes (CFStringRef theString, CFRange range,
+  CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation,
+  UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen);
+
+CF_EXPORT UniChar
+CFStringGetCharacterAtIndex (CFStringRef theString, CFIndex idx);
+
+CF_EXPORT void
+CFStringGetCharacters (CFStringRef theString, CFRange range, UniChar *buffer);
+
+CF_EXPORT const UniChar *
+CFStringGetCharactersPtr (CFStringRef theString);
+
+CF_EXPORT Boolean
+CFStringGetCString (CFStringRef theString, char *buffer, CFIndex bufferSize,
+  CFStringEncoding encoding);
+
+CF_EXPORT const char *
+CFStringGetCStringPtr (CFStringRef theString, CFStringEncoding encoding);
+
+CF_EXPORT CFIndex
+CFStringGetLength (CFStringRef str);
+
+CF_EXPORT CFRange
+CFStringGetRangeOfComposedCharactersAtIndex (CFStringRef theString,
+  CFIndex theIndex);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+CF_EXPORT UTF32Char
+CFStringGetLongCharacterForSurrogatePair (UniChar surrogateHigh,
+  UniChar surrogateLow);
+
+CF_EXPORT Boolean
+CFStringGetSurrogatePairForLongCharacter (UTF32Char character,
+  UniChar *surrogates);
+
+CF_EXPORT Boolean
+CFStringIsSurrogateHighCharacter (UniChar character);
+
+CF_EXPORT Boolean
+CFStringIsSurrogateLowCharacter (UniChar character);
+#endif
+/** \} */
+
+/** \name Working with Encodings
+    \{
+ */
+CF_EXPORT CFStringRef
+CFStringConvertEncodingToIANACharSetName (CFStringEncoding encoding);
+
+CF_EXPORT unsigned long
+CFStringConvertEncodingToNSStringEncoding (CFStringEncoding encoding);
+
+UInt32
+CFStringConvertEncodingToWindowsCodepage (CFStringEncoding encoding);
+
+CF_EXPORT CFStringEncoding
+CFStringConvertIANACharSetNameToEncoding (CFStringRef theString);
+
+CF_EXPORT CFStringEncoding
+CFStringConvertNSStringEncodingToEncoding (unsigned long encoding);
+
+CF_EXPORT CFStringEncoding
+CFStringConvertWindowsCodepageToEncoding (UInt32 codepage);
+
+CF_EXPORT CFStringEncoding
+CFStringGetFastestEncoding (CFStringRef theString);
+
+CF_EXPORT const CFStringEncoding *
+CFStringGetListOfAvailableEncodings (void);
+
+CF_EXPORT CFIndex
+CFStringGetMaximumSizeForEncoding (CFIndex length, CFStringEncoding encoding);
+
+CF_EXPORT CFStringEncoding
+CFStringGetMostCompatibleMacStringEncoding (CFStringEncoding encoding);
+
+CF_EXPORT CFStringRef
+CFStringGetNameOfEncoding (CFStringEncoding encoding);
+
+CF_EXPORT CFStringEncoding
+CFStringGetSmallestEncoding (CFStringRef theString);
+
+CF_EXPORT CFStringEncoding
+CFStringGetSystemEncoding (void);
+
+CF_EXPORT Boolean
+CFStringIsEncodingAvailable (CFStringEncoding encoding);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT Boolean
+CFStringGetFileSystemRepresentation (CFStringRef string, char *buffer,
+  CFIndex maxBufLen);
+
+CF_EXPORT CFIndex
+CFStringGetMaximumSizeOfFileSystemRepresentation (CFStringRef string);
+#endif
+/** \} */
+
+/** \name Getting Numeric Values
+    \{
+ */
+CF_EXPORT double
+CFStringGetDoubleValue (CFStringRef str);
+
+CF_EXPORT SInt32
+CFStringGetIntValue (CFStringRef str);
+/** \} */
+
+/** \name Getting String Properties
+    \{
+ */
+CF_EXPORT void
+CFShow (CFTypeRef obj);
+
+CF_EXPORT void
+CFShowStr (CFStringRef str);
+
+CF_EXPORT CFTypeID
+CFStringGetTypeID (void);
+/** \} */
+
+
+
+/** \name Pascal Strings
+    \{
+ */
+CF_EXPORT CFStringRef
+CFStringCreateWithPascalString (CFAllocatorRef alloc, ConstStr255Param pStr,
+  CFStringEncoding encoding);
+
+CF_EXPORT CFStringRef
+CFStringCreateWithPascalStringNoCopy (CFAllocatorRef alloc,
+  ConstStr255Param pStr, CFStringEncoding encoding,
+  CFAllocatorRef contentsDeallocate);
+
+CF_EXPORT Boolean
+CFStringGetPascalString (CFStringRef theString, StringPtr buffer,
+  CFIndex bufferSize, CFStringEncoding encoding);
+
+CF_EXPORT ConstStringPtr
+CFStringGetPascalStringPtr (CFStringRef theString, CFStringEncoding encoding);
+/** \} */
+/** \} */
+
+
+
+/** \defgroup CFMutableStringRef CFMutableString Reference
+ *  \{
+ */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2, GS_API_LATEST)
+typedef enum
+{
+  kCFStringNormalizationFormD = 0,
+  kCFStringNormalizationFormKD = 1,
+  kCFStringNormalizationFormC = 2,
+  kCFStringNormalizationFormKC = 3
+} CFStringNormalizationForm;
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT const CFStringRef kCFStringTransformStripCombiningMarks;
+CF_EXPORT const CFStringRef kCFStringTransformToLatin;
+CF_EXPORT const CFStringRef kCFStringTransformFullwidthHalfwidth;
+CF_EXPORT const CFStringRef kCFStringTransformLatinKatakana;
+CF_EXPORT const CFStringRef kCFStringTransformLatinHiragana;
+CF_EXPORT const CFStringRef kCFStringTransformHiraganaKatakana;
+CF_EXPORT const CFStringRef kCFStringTransformMandarinLatin;
+CF_EXPORT const CFStringRef kCFStringTransformLatinHangul;
+CF_EXPORT const CFStringRef kCFStringTransformLatinArabic;
+CF_EXPORT const CFStringRef kCFStringTransformLatinHebrew;
+CF_EXPORT const CFStringRef kCFStringTransformLatinThai;
+CF_EXPORT const CFStringRef kCFStringTransformLatinCyrillic;
+CF_EXPORT const CFStringRef kCFStringTransformLatinGreek;
+CF_EXPORT const CFStringRef kCFStringTransformToXMLHex;
+CF_EXPORT const CFStringRef kCFStringTransformToUnicodeName;
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+CF_EXPORT const CFStringRef kCFStringTransformStripDiacritics;
+#endif
+
+CF_EXPORT void
+CFStringAppend (CFMutableStringRef theString, CFStringRef appendedString);
+
+CF_EXPORT void
+CFStringAppendCharacters (CFMutableStringRef theString,
+  const UniChar *chars, CFIndex numChars);
+
+CF_EXPORT void
+CFStringAppendCString (CFMutableStringRef theString, const char *cStr,
+  CFStringEncoding encoding);
+
+CF_EXPORT void
+CFStringAppendFormat (CFMutableStringRef theString,
+  CFDictionaryRef formatOptions, CFStringRef format, ...);
+
+CF_EXPORT void
+CFStringAppendFormatAndArguments (CFMutableStringRef theString,
+  CFDictionaryRef formatOptions, CFStringRef format, va_list arguments);
+
+CF_EXPORT void
+CFStringAppendPascalString (CFMutableStringRef theString,
+  ConstStr255Param pStr, CFStringEncoding encoding);
+
+CF_EXPORT void
+CFStringCapitalize (CFMutableStringRef theString, CFLocaleRef locale);
+
+CF_EXPORT CFMutableStringRef
+CFStringCreateMutable (CFAllocatorRef alloc, CFIndex maxLength);
+
+CF_EXPORT CFMutableStringRef
+CFStringCreateMutableCopy (CFAllocatorRef alloc, CFIndex maxLength,
+  CFStringRef theString);
+
+CF_EXPORT CFMutableStringRef
+CFStringCreateMutableWithExternalCharactersNoCopy (CFAllocatorRef alloc,
+  UniChar *chars, CFIndex numChars, CFIndex capacity,
+  CFAllocatorRef externalCharactersAllocator);
+
+CF_EXPORT void
+CFStringDelete (CFMutableStringRef theString, CFRange range);
+
+CF_EXPORT void
+CFStringInsert (CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr);
+
+CF_EXPORT void
+CFStringLowercase (CFMutableStringRef theString, CFLocaleRef locale);
+
+CF_EXPORT void
+CFStringPad (CFMutableStringRef theString, CFStringRef padString,
+  CFIndex length, CFIndex indexIntoPad);
+
+CF_EXPORT void
+CFStringReplace (CFMutableStringRef theString, CFRange range,
+  CFStringRef replacement);
+
+CF_EXPORT void
+CFStringReplaceAll (CFMutableStringRef theString, CFStringRef replacement);
+
+CF_EXPORT void
+CFStringSetExternalCharactersNoCopy (CFMutableStringRef theString,
+  UniChar *chars, CFIndex length, CFIndex capacity);
+
+CF_EXPORT void
+CFStringTrim (CFMutableStringRef theString, CFStringRef trimString);
+
+CF_EXPORT void
+CFStringTrimWhitespace (CFMutableStringRef theString);
+
+CF_EXPORT void
+CFStringUppercase (CFMutableStringRef theString, CFLocaleRef locale);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2, GS_API_LATEST)
+CF_EXPORT CFIndex
+CFStringFindAndReplace (CFMutableStringRef theString,
+  CFStringRef stringToFind, CFStringRef replacementString,
+  CFRange rangeToSearch, CFOptionFlags compareOptions);
+
+CF_EXPORT void
+CFStringNormalize (CFMutableStringRef theString,
+  CFStringNormalizationForm theForm);
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT Boolean
+CFStringTransform (CFMutableStringRef string, CFRange *range,
+  CFStringRef transform, Boolean reverse);
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+CF_EXPORT void
+CFStringFold (CFMutableStringRef theString, CFOptionFlags theFlags,
+  CFLocaleRef theLocale);
+#endif
+/** \} */
+
+
+
+/** \ingroup CFStringRef
+    \name CFStringInlineBuffer
+    \{
+ */
+#define __kCFStringInlineBufferLength 64
+struct CFStringInlineBuffer
+{
+  UniChar buffer[__kCFStringInlineBufferLength];
+  CFStringRef theString;
+  const UniChar *directBuffer;
+  CFRange rangeToBuffer;
+  CFIndex bufferedRangeStart;
+  CFIndex bufferedRangeEnd;
+};
+typedef struct CFStringInlineBuffer CFStringInlineBuffer;
+
+CF_INLINE void
+CFStringInitInlineBuffer (CFStringRef str, CFStringInlineBuffer *buf,
+  CFRange range)
+{
+  buf->theString = str;
+  buf->rangeToBuffer = range;
+  buf->directBuffer = CFStringGetCharactersPtr (str);
+  buf->bufferedRangeStart = 0;
+  buf->bufferedRangeEnd = 0;
+}
+
+CF_INLINE UniChar
+CFStringGetCharacterFromInlineBuffer (CFStringInlineBuffer *buf, CFIndex idx)
+{
+  if (buf->directBuffer)
+    {
+      if (idx < 0 || idx >= buf->rangeToBuffer.length)
+        return 0;
+      return buf->directBuffer[idx + buf->rangeToBuffer.location];
+    }
+  else if (idx >= buf->bufferedRangeEnd || idx < buf->bufferedRangeStart)
+    {
+      CFRange range;
+      
+      if (idx < 0 || idx >= buf->rangeToBuffer.length)
+        return 0;
+      
+      /* Use 16 here so it's efficient to go backwards, too */
+      buf->bufferedRangeStart = idx - 16;
+      if (buf->bufferedRangeStart < 0)
+        buf->bufferedRangeStart = 0;
+      buf->bufferedRangeEnd =
+        buf->bufferedRangeStart + __kCFStringInlineBufferLength;
+      if (buf->bufferedRangeEnd > buf->rangeToBuffer.length)
+        buf->bufferedRangeEnd = buf->rangeToBuffer.length;
+      
+      range = CFRangeMake (buf->rangeToBuffer.location + buf->bufferedRangeStart,
+        buf->bufferedRangeEnd - buf->bufferedRangeStart);
+      
+      CFStringGetCharacters (buf->theString, range, buf->buffer);
+    }
+  
+  return buf->buffer[(idx - buf->bufferedRangeStart)];
+}
+/** \} */
+
+CF_EXTERN_C_END
+
+#endif /* __COREFOUNDATION_CFSTRING_H__ */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFCharacterSet.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFCharacterSet.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFCharacterSet.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFCharacterSet.h	(revision 278653)
@@ -0,0 +1,173 @@
+/* CFCharacterSet.h
+   
+   Copyright (C) 2012 Free Software Foundation, Inc.
+   
+   Written by: Stefan Bidigaray
+   Date: January, 2012
+   
+   This file is part of the GNUstep CoreBase Library.
+   
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; see the file COPYING.LIB.
+   If not, see <http://www.gnu.org/licenses/> or write to the 
+   Free Software Foundation, 51 Franklin Street, Fifth Floor, 
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef __COREFOUNDATION_CFCHARACTERSET_H__
+#define __COREFOUNDATION_CFCHARACTERSET_H__
+
+#include "CFBase.h"
+#include "CFData.h"
+
+CF_EXTERN_C_BEGIN
+
+/** \ingroup CFCharacterSetRef */
+typedef const struct __CFCharacterSet * CFCharacterSetRef;
+/** \ingroup CFMutableCharacterSetRef */
+typedef struct __CFCharacterSet * CFMutableCharacterSetRef;
+
+/** \defgroup CFCharacterSetRef CFCharacterSet Reference
+    \{
+ */
+typedef enum
+{
+  kCFCharacterSetControl = 1,
+  kCFCharacterSetWhitespace,
+  kCFCharacterSetWhitespaceAndNewline,
+  kCFCharacterSetDecimalDigit,
+  kCFCharacterSetLetter,
+  kCFCharacterSetLowercaseLetter,
+  kCFCharacterSetUppercaseLetter,
+  kCFCharacterSetNonBase,
+  kCFCharacterSetDecomposable,
+  kCFCharacterSetAlphaNumeric,
+  kCFCharacterSetPunctuation,
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2, GS_API_LATEST)
+  kCFCharacterSetCapitalizedLetter = 13,
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_3, GS_API_LATEST)
+  kCFCharacterSetSymbol = 14,
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+  kCFCharacterSetNewline = 15,
+#endif
+  kCFCharacterSetIllegal = 12
+} CFCharacterSetPredefinedSet;
+
+
+
+/** \name Creating Character Sets
+    \{
+ */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_3, GS_API_LATEST)
+CF_EXPORT CFCharacterSetRef
+CFCharacterSetCreateCopy (CFAllocatorRef alloc, CFCharacterSetRef set);
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2, GS_API_LATEST)
+CF_EXPORT CFCharacterSetRef
+CFCharacterSetCreateInvertedSet (CFAllocatorRef alloc, CFCharacterSetRef set);
+#endif
+
+CF_EXPORT CFCharacterSetRef
+CFCharacterSetCreateWithCharactersInRange (CFAllocatorRef alloc,
+  CFRange range);
+
+CF_EXPORT CFCharacterSetRef
+CFCharacterSetCreateWithCharactersInString (CFAllocatorRef alloc,
+  CFStringRef string);
+
+CF_EXPORT CFCharacterSetRef
+CFCharacterSetCreateWithBitmapRepresentation (CFAllocatorRef alloc,
+  CFDataRef data);
+/** \} */
+
+/** \name Getting Predefined Character Sets
+    \{
+ */
+CF_EXPORT CFCharacterSetRef
+CFCharacterSetGetPredefined (CFCharacterSetPredefinedSet setIdentifier);
+/** \} */
+
+/** \name Querying Character Sets
+    \{
+ */
+CF_EXPORT CFDataRef
+CFCharacterSetCreateBitmapRepresentation (CFAllocatorRef alloc,
+  CFCharacterSetRef set);
+
+CF_EXPORT Boolean
+CFCharacterSetIsCharacterMember (CFCharacterSetRef set, UniChar c);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2, GS_API_LATEST)
+CF_EXPORT Boolean
+CFCharacterSetHasMemberInPlane (CFCharacterSetRef set, CFIndex plane);
+
+CF_EXPORT Boolean
+CFCharacterSetIsLongCharacterMember (CFCharacterSetRef set, UTF32Char c);
+
+CF_EXPORT Boolean
+CFCharacterSetIsSupersetOfSet (CFCharacterSetRef set,
+  CFCharacterSetRef otherSet);
+#endif
+/** \} */
+
+/** \name Getting the Character Set Type Identifier
+    \{
+ */
+CF_EXPORT CFTypeID
+CFCharacterSetGetTypeID (void);
+/** \} */
+/** \} */
+
+/** \defgroup CFMutableCharacterSetRef CFMutableCharacterSet Reference
+    \{
+ */
+CF_EXPORT CFMutableCharacterSetRef
+CFCharacterSetCreateMutable (CFAllocatorRef alloc);
+
+CF_EXPORT CFMutableCharacterSetRef
+CFCharacterSetCreateMutableCopy (CFAllocatorRef alloc, CFCharacterSetRef set);
+
+CF_EXPORT void
+CFCharacterSetAddCharactersInRange (CFMutableCharacterSetRef set,
+  CFRange range);
+
+CF_EXPORT void
+CFCharacterSetAddCharactersInString (CFMutableCharacterSetRef set,
+  CFStringRef string);
+
+CF_EXPORT void
+CFCharacterSetRemoveCharactersInRange (CFMutableCharacterSetRef set,
+  CFRange range);
+
+CF_EXPORT void
+CFCharacterSetRemoveCharactersInString (CFMutableCharacterSetRef set,
+  CFStringRef string);
+
+CF_EXPORT void
+CFCharacterSetIntersect (CFMutableCharacterSetRef set,
+  CFCharacterSetRef otherSet);
+
+CF_EXPORT void
+CFCharacterSetInvert (CFMutableCharacterSetRef set);
+
+CF_EXPORT void
+CFCharacterSetUnion (CFMutableCharacterSetRef set, CFCharacterSetRef otherSet);
+/** \} */
+
+CF_EXTERN_C_END
+
+#endif /* __COREFOUNDATION_CFCHARACTERSET_H__ */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFData.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFData.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFData.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFData.h	(revision 278653)
@@ -0,0 +1,114 @@
+/* CFData.h
+
+   Copyright (C) 2010 Free Software Foundation, Inc.
+
+   Written by: Stefan Bidigaray
+   Date: January, 2010
+
+   This file is part of CoreBase.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; see the file COPYING.LIB.
+   If not, see <http://www.gnu.org/licenses/> or write to the 
+   Free Software Foundation, 51 Franklin Street, Fifth Floor, 
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef __COREFOUNDATION_CFDATA_H__
+#define __COREFOUNDATION_CFDATA_H__
+
+#include "CFBase.h"
+
+CF_EXTERN_C_BEGIN
+/** \ingroup CFDataRef */
+typedef const struct __CFData *CFDataRef;
+/** \ingroup CFMutableDataRef */
+typedef struct __CFData *CFMutableDataRef;
+
+/** \defgroup CFDataRef CFData Reference
+    \{
+ */
+/** \name Creating a CFData Object
+    \{
+ */
+CF_EXPORT CFDataRef
+CFDataCreate (CFAllocatorRef allocator, const UInt8 * bytes, CFIndex length);
+
+CF_EXPORT CFDataRef
+CFDataCreateCopy (CFAllocatorRef allocator, CFDataRef theData);
+
+CF_EXPORT CFDataRef
+CFDataCreateWithBytesNoCopy (CFAllocatorRef allocator, const UInt8 * bytes,
+                             CFIndex length, CFAllocatorRef bytesDeallocator);
+/** \} */
+
+/** \name Examining a CFData Object
+    \{
+ */
+CF_EXPORT const UInt8 *CFDataGetBytePtr (CFDataRef theData);
+
+CF_EXPORT void
+CFDataGetBytes (CFDataRef theData, CFRange range, UInt8 * buffer);
+
+CF_EXPORT CFIndex CFDataGetLength (CFDataRef theData);
+/** \} */
+
+/** \name Getting the CFData Type ID
+    \{
+ */
+CF_EXPORT CFTypeID CFDataGetTypeID (void);
+/** \} */
+/** \} */
+
+/** \defgroup CFMutableDataRef CFMutableData Reference
+    \{
+ */
+/** \name Creating a Mutable Data Object
+    \{
+ */
+CF_EXPORT CFMutableDataRef
+CFDataCreateMutable (CFAllocatorRef allocator, CFIndex capacity);
+
+CF_EXPORT CFMutableDataRef
+CFDataCreateMutableCopy (CFAllocatorRef allocator, CFIndex capacity,
+                         CFDataRef theData);
+/** \} */
+
+/** \name Accessing Mutable Data
+    \{
+ */
+CF_EXPORT UInt8 *CFDataGetMutableBytePtr (CFMutableDataRef theData);
+/** \} */
+
+/** \name Modifying a Mutable Data Object
+    \{
+ */
+CF_EXPORT void
+CFDataAppendBytes (CFMutableDataRef theData, const UInt8 * bytes,
+                   CFIndex length);
+
+CF_EXPORT void CFDataDeleteBytes (CFMutableDataRef theData, CFRange range);
+
+CF_EXPORT void
+CFDataReplaceBytes (CFMutableDataRef theData, CFRange range,
+                    const UInt8 * newBytes, CFIndex newLength);
+
+CF_EXPORT void
+CFDataIncreaseLength (CFMutableDataRef theData, CFIndex extraLength);
+
+CF_EXPORT void CFDataSetLength (CFMutableDataRef theData, CFIndex length);
+/** \} */
+/** \} */
+
+CF_EXTERN_C_END
+#endif /* __COREFOUNDATION_CFDATA_H__ */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFAvailability.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFAvailability.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFAvailability.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFAvailability.h	(revision 278653)
@@ -0,0 +1,52 @@
+/* CFAvailability.h
+   
+   Copyright (C) 2017 Free Software Foundation, Inc.
+   
+   Written by: Stefan Bidigaray
+   Date: August, 2017
+   
+   This file is part of the GNUstep CoreBase Library.
+   
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; see the file COPYING.LIB.
+   If not, see <http://www.gnu.org/licenses/> or write to the 
+   Free Software Foundation, 51 Franklin Street, Fifth Floor, 
+   Boston, MA 02110-1301, USA.
+*/
+
+
+#ifndef __COREFOUNDATION_CFAVAILABILITY_H__
+#define __COREFOUNDATION_CFAVAILABILITY_H__
+
+/* Compiler features */
+#ifndef __has_feature
+#define __has_feature(x) 0
+#endif
+#ifndef __has_attribute
+#define __has_attribute(x) 0
+#endif
+#ifndef __has_extension
+#define __has_extension(x) __has_feature
+#endif
+
+/* CFEnum macro for type definitions */
+#if (__cplusplus && __cplusplus >= 201103L)
+#define CF_ENUM(_type, _name) _type _name; enum : _type
+#define CF_OPTIONS(_type, _name) _type _name; enum : _type
+#else
+#define CF_ENUM(_type, _name) _type _name; enum
+#define CF_OPTIONS(_type, _name) _type _name; enum
+#endif
+
+#endif /* __COREFOUNDATION_CFAVAILABILITY_H__ */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFBase.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFBase.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFBase.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFBase.h	(revision 278653)
@@ -0,0 +1,464 @@
+/* CFBase.h
+   
+   Copyright (C) 2010 Free Software Foundation, Inc.
+   
+   Written by: Stefan Bidigaray
+   Date: January, 2010
+   
+   This file is part of the GNUstep CoreBase Library.
+   
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.         See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; see the file COPYING.LIB.
+   If not, see <http://www.gnu.org/licenses/> or write to the 
+   Free Software Foundation, 51 Franklin Street, Fifth Floor, 
+   Boston, MA 02110-1301, USA.
+*/
+
+
+#ifndef __COREFOUNDATION_CFBASE_H__
+#define __COREFOUNDATION_CFBASE_H__
+
+/* CoreFoundation defines __LITTLE_ENDIAN__ or __BIG_ENDIAN__ so we'll
+ * do the same here for compatibility.
+ */
+#if !defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)
+#define __LITTLE_ENDIAN__ 1
+#endif
+
+#include "CFAvailability.h"
+#include "../GNUstepBase/GSVersionMacros.h"
+
+/*
+ * CoreFoundation types
+ */
+typedef unsigned char Boolean;
+typedef unsigned char UInt8;
+typedef signed char SInt8;
+typedef unsigned short UInt16;
+typedef signed short SInt16;
+typedef unsigned int UInt32;
+typedef signed int SInt32;
+typedef unsigned long long UInt64;
+typedef signed long long SInt64;
+typedef SInt32 OSStatus;
+
+typedef float Float32;
+typedef double Float64;
+typedef UInt16 UniChar;
+typedef UInt8 *StringPtr;
+typedef const StringPtr *ConstStringPtr;
+typedef UInt8 Str255[256];
+typedef const Str255 *ConstStr255Param;
+typedef SInt16 OSErr;
+typedef SInt16 RegionCode;
+typedef SInt16 LangCode;
+typedef SInt16 ScriptCode;
+typedef UInt32 FourCharCode;
+#ifndef OSTYPE_DECLARED
+typedef FourCharCode OSType;
+#define OSTYPE_DECLARED
+#endif
+typedef UInt8 Byte;
+typedef SInt8 SignedByte;
+
+#ifndef UTF32Char               /* UTF32Char is also defined in GSConfig.h */
+typedef UInt32 UTF32Char;
+#endif
+typedef UInt16 UTF16Char;
+typedef UInt8 UTF8Char;
+
+#if !defined(CF_EXTERN_C_BEGIN)
+#if defined(__cplusplus)
+#define CF_EXTERN_C_BEGIN extern "C" {
+#define CF_EXTERN_C_END }
+#else
+#define CF_EXTERN_C_BEGIN
+#define CF_EXTERN_C_END
+#endif
+#endif
+
+#if defined(_WIN32)
+#if defined(BUILDING_SELF)
+#if defined(__cplusplus)
+#define CF_EXPORT extern "C" __declspec(dllexport)
+#else
+#define CF_EXPORT extern __declspec(dllexport)
+#endif
+#else
+#if defined(__cplusplus)
+#define CF_EXPORT extern "C" __declspec(dllimport)
+#else
+#define CF_EXPORT extern __declspec(dllimport)
+#endif
+#endif
+#else
+#if defined(__cplusplus)
+#define CF_EXPORT extern "C"
+#else
+#define CF_EXPORT extern
+#endif
+#endif
+
+#if !defined(__bool_true_false_are_defined)
+#define true 1
+#define false 0
+#endif
+
+#ifndef TRUE
+#define TRUE  1
+#endif
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#if !defined(CF_INLINE)
+#if defined(__GNUC__) && (__GNUC__ >= 4)
+#define CF_INLINE static __inline__ __attribute__((always_inline))
+#elif defined(__GNUC__)
+#define CF_INLINE static __inline__
+#elif defined(__MWERKS__) || defined(__cplusplus)
+#define CF_INLINE static inline
+#elif defined(_MSC_VER)
+#define CF_INLINE static __inline
+#elif _WIN32
+#define CF_INLINE static __inline__
+#else
+#define CF_INLINE static inline
+#endif
+#endif
+
+#if defined(__GNUC__) || defined(__llvm__)
+#define GS_PURE_FUNCTION __attribute__((pure))
+#else
+#define GS_PURE_FUNCTION
+#endif
+
+CF_EXTERN_C_BEGIN
+/** \defgroup CFTypeRef CFType Reference
+    \{
+ */
+typedef unsigned long CFTypeID;
+typedef const void *CFTypeRef;
+/** @}
+ */
+
+/** \defgroup BaseUtils Base Utilities
+    \{
+ */
+/** An integer value to store a hash code. */
+typedef unsigned long CFHashCode;
+/** A bitfield for passing information to functions.  Can hold as many bits
+    as a word.
+ */
+typedef unsigned long CFOptionFlags;
+/** A signed integer representing an index, size, length or count. */
+typedef signed long CFIndex;
+
+/** A structure that represents a range of items in a container, such as
+    an array.
+ */
+typedef struct CFRange CFRange;
+struct CFRange
+{
+  CFIndex location;
+    /**< An integer representing the start location of the range, inclusive. */
+  CFIndex length;
+    /**< An integer representing the total number of items in the range */
+};
+
+/** Creates a CFRange structure.
+    \param location The starting location.
+    \param length The length.
+    \return An initialized CFRange structure.
+ */
+CF_INLINE CFRange
+CFRangeMake (CFIndex location, CFIndex length)
+{
+  CFRange range;
+
+  range.location = location;
+  range.length = length;
+  return range;
+}
+
+/* Returned by comparison functions */
+typedef enum
+{
+  kCFCompareLessThan = -1,
+  kCFCompareEqualTo = 0,
+  kCFCompareGreaterThan = 1
+} CFComparisonResult;
+
+/* Return when a value is not found */
+enum
+{
+  kCFNotFound = -1
+};
+
+/* Definition for standard comparison function callback. */
+typedef CFComparisonResult (*CFComparatorFunction) (const void *val1,
+                                                    const void *val2,
+                                                    void *context);
+
+/* CoreFoundation version numbers */
+/** \name Library Version Numbers
+    \{
+ */
+CF_EXPORT const double kCFCoreFoundationVersionNumber;
+#define kCFCoreFoundationVersionNumber10_0    196.40
+#define kCFCoreFoundationVersionNumber10_0_3  196.50
+#define kCFCoreFoundationVersionNumber10_1    226.00
+#define kCFCoreFoundationVersionNumber10_1_1  226.00
+#define kCFCoreFoundationVersionNumber10_1_2  227.20
+#define kCFCoreFoundationVersionNumber10_1_3  227.20
+#define kCFCoreFoundationVersionNumber10_1_4  227.30
+#define kCFCoreFoundationVersionNumber10_2    263.00
+#define kCFCoreFoundationVersionNumber10_2_1  263.10
+#define kCFCoreFoundationVersionNumber10_2_2  263.10
+#define kCFCoreFoundationVersionNumber10_2_3  263.30
+#define kCFCoreFoundationVersionNumber10_2_4  263.30
+#define kCFCoreFoundationVersionNumber10_2_5  263.50
+#define kCFCoreFoundationVersionNumber10_2_6  263.50
+#define kCFCoreFoundationVersionNumber10_2_7  263.50
+#define kCFCoreFoundationVersionNumber10_2_8  263.50
+#define kCFCoreFoundationVersionNumber10_3    299.00
+#define kCFCoreFoundationVersionNumber10_3_1  299.00
+#define kCFCoreFoundationVersionNumber10_3_2  299.00
+#define kCFCoreFoundationVersionNumber10_3_3  299.30
+#define kCFCoreFoundationVersionNumber10_3_4  299.31
+#define kCFCoreFoundationVersionNumber10_3_5  299.31
+#define kCFCoreFoundationVersionNumber10_3_6  299.32
+#define kCFCoreFoundationVersionNumber10_3_7  299.33
+#define kCFCoreFoundationVersionNumber10_3_8  299.33
+#define kCFCoreFoundationVersionNumber10_3_9  299.35
+#define kCFCoreFoundationVersionNumber10_4    368.00
+#define kCFCoreFoundationVersionNumber10_4_1  368.10
+#define kCFCoreFoundationVersionNumber10_4_2  368.11
+#define kCFCoreFoundationVersionNumber10_4_3  368.18
+#define kCFCoreFoundationVersionNumber10_4_4_Intel   368.26
+#define kCFCoreFoundationVersionNumber10_4_4_PowerPC 368.25
+#define kCFCoreFoundationVersionNumber10_4_5_Intel   368.26
+#define kCFCoreFoundationVersionNumber10_4_5_PowerPC 368.25
+#define kCFCoreFoundationVersionNumber10_4_6_Intel   368.26
+#define kCFCoreFoundationVersionNumber10_4_6_PowerPC 368.25
+#define kCFCoreFoundationVersionNumber10_4_7  368.27
+#define kCFCoreFoundationVersionNumber10_4_8  368.27
+#define kCFCoreFoundationVersionNumber10_4_9  368.28
+#define kCFCoreFoundationVersionNumber10_4_10 368.28
+#define kCFCoreFoundationVersionNumber10_4_11 368.31
+#define kCFCoreFoundationVersionNumber10_5    476.00
+#define kCFCoreFoundationVersionNumber10_5_1  476.00
+#define kCFCoreFoundationVersionNumber10_5_2  476.10
+#define kCFCoreFoundationVersionNumber10_5_3  476.13
+#define kCFCoreFoundationVersionNumber10_5_4  476.14
+#define kCFCoreFoundationVersionNumber10_5_5  476.15
+#define kCFCoreFoundationVersionNumber10_5_6  476.17
+/** \} */
+/** \} */
+
+#if __has_feature(attribute_cf_returns_retained)
+#define CF_RETURNS_RETAINED __attribute__((cf_returns_retained))
+#else
+#define CF_RETURNS_RETAINED
+#endif
+
+#if __has_feature(attribute_cf_returns_not_retained)
+#define CF_RETURNS_NOT_RETAINED __attribute__((cf_returns_not_retained))
+#else
+#define CF_RETURNS_NOT_RETAINED
+#endif
+
+/** \ingroup CFPropertyListRef
+ */
+typedef CFTypeRef CFPropertyListRef;
+
+/** \ingroup CFStringRef
+ */
+typedef const struct __CFString *CFStringRef;
+/** \ingroup CFMutableStringRef
+ */
+typedef struct __CFString *CFMutableStringRef;
+
+
+
+/** \defgroup CFAllocatorRef CFAllocator Reference
+    \brief CFAllocator is an opaque type used to allocate and deallocate
+    memory.
+    \{
+ */
+/** \brief A reference to a CFAllocator object.
+ */
+typedef const struct __CFAllocator *CFAllocatorRef;
+
+typedef void *(*CFAllocatorAllocateCallBack) (CFIndex allocSize,
+                                              CFOptionFlags hint, void *info);
+typedef void (*CFAllocatorDeallocateCallBack) (void *ptr, void *info);
+typedef void *(*CFAllocatorReallocateCallBack) (void *ptr,
+                                                CFIndex newsize,
+                                                CFOptionFlags hint, void *info);
+typedef CFIndex (*CFAllocatorPreferredSizeCallBack) (CFIndex size,
+                                                     CFOptionFlags hint,
+                                                     void *info);
+typedef const void *(*CFAllocatorRetainCallBack) (const void *info);
+typedef void (*CFAllocatorReleaseCallBack) (const void *info);
+typedef CFStringRef (*CFAllocatorCopyDescriptionCallBack) (const void *info);
+
+struct _CFAllocatorContext
+{
+  CFIndex version;
+  void *info;
+  CFAllocatorRetainCallBack retain;
+  CFAllocatorReleaseCallBack release;
+  CFAllocatorCopyDescriptionCallBack copyDescription;
+  CFAllocatorAllocateCallBack allocate;
+  CFAllocatorReallocateCallBack reallocate;
+  CFAllocatorDeallocateCallBack deallocate;
+  CFAllocatorPreferredSizeCallBack preferredSize;
+};
+typedef struct _CFAllocatorContext CFAllocatorContext;
+
+/** The default allocator and is equivalent to NULL.
+    \see CFAllocatorGetDefault()
+    \see CFAllocatorSetDefault()
+ */
+CF_EXPORT CFAllocatorRef kCFAllocatorDefault;
+/** The default system allocator is used internally by GNUstep and is the
+    default allocator if none is been defined.
+    \see CFAllocatorSetDefault()
+ */
+CF_EXPORT CFAllocatorRef kCFAllocatorSystemDefault;
+/** An allocator that uses the system's malloc, realloc and free functions.
+ */
+CF_EXPORT CFAllocatorRef kCFAllocatorMalloc;
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+/** Equivalent to kCFAllocatorSystemDefault
+ */
+CF_EXPORT CFAllocatorRef kCFAllocatorMallocZone;
+#endif
+/** The NULL allocator does perform any operations.  Can be passed as
+    a deallocator if you do not want GNUstep to deallocate the data.
+ */
+CF_EXPORT CFAllocatorRef kCFAllocatorNull;
+/** This is a special case allocator directing CFAllocatorCreate() to use
+    the given CFAllocatorContext structure to allocate the new allocator.
+ */
+CF_EXPORT CFAllocatorRef kCFAllocatorUseContext;
+
+/** Create a new CFAllocator.
+    \param allocator The allocator used to create this allocator or
+      kCFAllocatorUseContext to use the functions in \b context.
+    \param context The new allocator's context functions.
+    \return A new CFAllocator or NULL in case of failure.
+    \see CFAllocatorContext
+ */
+CF_EXPORT CFAllocatorRef
+CFAllocatorCreate (CFAllocatorRef allocator, CFAllocatorContext * context);
+
+/** Allocate new memory.
+    \param allocator The CFAllocator to use.
+    \param size The number of bytes to allocate.
+    \param hint Option flags.  Currently unused and should be 0.
+    \return Newly allocated memory of NULL in case of failure.
+    \see CFAllocatorDeallocate()
+ */
+CF_EXPORT void *CFAllocatorAllocate (CFAllocatorRef allocator, CFIndex size,
+                                     CFOptionFlags hint);
+
+/** Deallocate the memory pointed to by \b ptr.
+    \param allocator The CFAllocator to use.
+    \param ptr A pointer previously allocated by CFAllocatorAllocate().
+    \see CFAllocatorAllocate()
+ */
+CF_EXPORT void CFAllocatorDeallocate (CFAllocatorRef allocator, void *ptr);
+
+CF_EXPORT CFIndex
+CFAllocatorGetPreferredSizeForSize (CFAllocatorRef allocator, CFIndex size,
+                                    CFOptionFlags hint);
+
+CF_EXPORT void *CFAllocatorReallocate (CFAllocatorRef allocator, void *ptr,
+                                       CFIndex newsize, CFOptionFlags hint);
+
+CF_EXPORT CFAllocatorRef CFAllocatorGetDefault (void);
+
+CF_EXPORT void CFAllocatorSetDefault (CFAllocatorRef allocator);
+
+CF_EXPORT void
+CFAllocatorGetContext (CFAllocatorRef allocator, CFAllocatorContext * context);
+
+CF_EXPORT CFTypeID CFAllocatorGetTypeID (void);
+/** \} */
+
+
+
+/** \ingroup CFTypeRef
+    \{
+ */
+/* These function will be implemented in CFRuntime.c since they 
+   require runtime support. */
+CF_EXPORT CFStringRef CFCopyDescription (CFTypeRef cf);
+
+CF_EXPORT CFStringRef CFCopyTypeIDDescription (CFTypeID typeID);
+
+CF_EXPORT Boolean CFEqual (CFTypeRef cf1, CFTypeRef cf2);
+
+CF_EXPORT CFAllocatorRef CFGetAllocator (CFTypeRef cf);
+
+CF_EXPORT CFIndex CFGetRetainCount (CFTypeRef cf);
+
+CF_EXPORT CFTypeID CFGetTypeID (CFTypeRef cf);
+
+CF_EXPORT CFHashCode CFHash (CFTypeRef cf);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT CFTypeRef CFMakeCollectable (CFTypeRef cf);
+#endif
+
+CF_EXPORT void CFRelease (CFTypeRef cf);
+
+CF_EXPORT CFTypeRef CFRetain (CFTypeRef cf);
+
+CF_EXPORT CFTypeRef CFAutorelease(CFTypeRef arg);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_7, GS_API_LATEST)
+CF_EXPORT void *_CFBridgingRelease (CFTypeRef cf);
+CF_EXPORT CFTypeRef _CFBridgingRetain (void *obj);
+
+#if __has_feature(objc_arc)
+#define CFBridgingRetain(x) (__bridge_retained CFTypeRef)(x)
+#define CFBridgingRelease(x) (__bridge_transfer id)(x)
+#elif __OBJC__
+#define CFBridgingRetain(x) _CFBridgingRetain((void *)(x))
+#define CFBridgingRelease(x) (id)_CFBridgingRelease((x))
+#else
+#define CFBridgingRetain(x) _CFBridgingRetain((void *)(x))
+#define CFBridgingRelease(x) _CFBridgingRelease((x))
+#endif
+#endif
+/** \} */
+
+
+
+/** \defgroup CFNullRef CFNull Reference
+    \{
+ */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2, GS_API_LATEST)
+typedef struct __CFNull *CFNullRef;
+
+CF_EXPORT CFNullRef kCFNull;
+
+CFTypeID CFNullGetTypeID (void);
+#endif
+/** \} */
+
+CF_EXTERN_C_END
+#endif /* __COREFOUNDATION_CFBASE_H__ */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFArray.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFArray.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFArray.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFArray.h	(revision 278653)
@@ -0,0 +1,191 @@
+/* CFArray.h
+   
+   Copyright (C) 2010 Free Software Foundation, Inc.
+   
+   Written by: Stefan Bidigaray
+   Date: January, 2010
+   
+   This file is part of CoreBase.
+   
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; see the file COPYING.LIB.
+   If not, see <http://www.gnu.org/licenses/> or write to the 
+   Free Software Foundation, 51 Franklin Street, Fifth Floor, 
+   Boston, MA 02110-1301, USA.
+*/
+
+
+#ifndef __COREFOUNDATION_CFARRAY_H__
+#define __COREFOUNDATION_CFARRAY_H__
+
+#include "CFBase.h"
+
+CF_EXTERN_C_BEGIN
+/** \ingroup CFArrayRef
+    \brief Reference to an immutable array object.
+ */
+typedef const struct __CFArray *CFArrayRef;
+/**
+    \ingroup CFMutableArrayRef
+    \brief Reference to a mutable array object.
+ */
+typedef struct __CFArray *CFMutableArrayRef;
+
+/** \defgroup CFArrayRef CFArray Reference
+    \brief A CFArray and its mutable type, \ref CFMutableArrayRef
+      "CFMutableArray", are simple, low overhead, ordered containers for
+      objects.
+    \details
+      <code>\#include <CoreFoundation/CFArray.h></code>
+    \{
+ */
+
+/** \name Callbacks
+    \{
+ */
+typedef void (*CFArrayApplierFunction) (const void *value, void *context);
+typedef CFStringRef (*CFArrayCopyDescriptionCallBack) (const void *value);
+typedef void (*CFArrayReleaseCallBack) (CFAllocatorRef allocator,
+                                        const void *value);
+typedef const void *(*CFArrayRetainCallBack) (CFAllocatorRef allocator,
+                                              const void *value);
+typedef Boolean (*CFArrayEqualCallBack) (const void *value1,
+                                         const void *value2);
+/** \} */
+
+/** \brief Structure with CFArray callbacks.
+ */
+typedef struct _CFArrayCallBacks CFArrayCallBacks;
+struct _CFArrayCallBacks
+{
+  CFIndex version; /**< Structure's version number.  Current version is 0. */
+  CFArrayRetainCallBack retain;
+    /**< The callback used to retain values added to the array.  If NULL,
+	 values are not retained. */
+  CFArrayReleaseCallBack release;
+  CFArrayCopyDescriptionCallBack copyDescription;
+  CFArrayEqualCallBack equal;
+};
+
+/** \name Predefined Callback Structures
+    \{
+ */
+CF_EXPORT const CFArrayCallBacks kCFTypeArrayCallBacks;
+/** \} */
+
+
+
+/** \name Creating an Array
+    \{
+ */
+CF_EXPORT CFArrayRef
+CFArrayCreate (CFAllocatorRef allocator, const void **values,
+               CFIndex numValues, const CFArrayCallBacks * callBacks);
+
+CF_EXPORT CFArrayRef
+CFArrayCreateCopy (CFAllocatorRef allocator, CFArrayRef theArray);
+/** \} */
+
+/** \name Examining an Array
+    \{
+ */
+CF_EXPORT CFIndex
+CFArrayBSearchValues (CFArrayRef theArray, CFRange range, const void *value,
+                      CFComparatorFunction comparator, void *context);
+
+CF_EXPORT Boolean
+CFArrayContainsValue (CFArrayRef theArray, CFRange range, const void *value);
+
+CF_EXPORT CFIndex CFArrayGetCount (CFArrayRef theArray);
+
+CF_EXPORT CFIndex
+CFArrayGetCountOfValue (CFArrayRef theArray, CFRange range, const void *value);
+
+CF_EXPORT CFIndex
+CFArrayGetFirstIndexOfValue (CFArrayRef theArray, CFRange range,
+                             const void *value);
+
+CF_EXPORT CFIndex
+CFArrayGetLastIndexOfValue (CFArrayRef theArray, CFRange range,
+                            const void *value);
+
+CF_EXPORT void
+CFArrayGetValues (CFArrayRef theArray, CFRange range, const void **values);
+
+CF_EXPORT const void *CFArrayGetValueAtIndex (CFArrayRef theArray, CFIndex idx);
+/** \} */
+
+/** \name Applying a Function to Elements
+    \{
+ */
+CF_EXPORT void
+CFArrayApplyFunction (CFArrayRef theArray, CFRange range,
+                      CFArrayApplierFunction applier, void *context);
+/** \} */
+
+/** \name Getting the CFArray Type ID
+    \{
+ */
+CF_EXPORT CFTypeID CFArrayGetTypeID (void);
+/** \} */
+
+/** \} */
+
+/** \defgroup CFMutableArrayRef CFMutableArray Reference
+    \details <code>\#include <CoreFoundation/CFArray.h></code>
+    \{
+ */
+CF_EXPORT void
+CFArrayAppendArray (CFMutableArrayRef theArray, CFArrayRef otherArray,
+                    CFRange otherRange);
+
+CF_EXPORT void
+CFArrayAppendValue (CFMutableArrayRef theArray, const void *value);
+
+CF_EXPORT CFMutableArrayRef
+CFArrayCreateMutable (CFAllocatorRef allocator, CFIndex capacity,
+                      const CFArrayCallBacks * callBacks);
+
+CF_EXPORT CFMutableArrayRef
+CFArrayCreateMutableCopy (CFAllocatorRef allocator, CFIndex capacity,
+                          CFArrayRef theArray);
+
+CF_EXPORT void
+CFArrayExchangeValuesAtIndices (CFMutableArrayRef theArray, CFIndex idx1,
+                                CFIndex idx2);
+
+CF_EXPORT void
+CFArrayInsertValueAtIndex (CFMutableArrayRef theArray, CFIndex idx,
+                           const void *value);
+
+CF_EXPORT void CFArrayRemoveAllValues (CFMutableArrayRef theArray);
+
+CF_EXPORT void
+CFArrayRemoveValueAtIndex (CFMutableArrayRef theArray, CFIndex idx);
+
+CF_EXPORT void
+CFArrayReplaceValues (CFMutableArrayRef theArray, CFRange range,
+                      const void **newValues, CFIndex newCount);
+
+CF_EXPORT void
+CFArraySetValueAtIndex (CFMutableArrayRef theArray, CFIndex idx,
+                        const void *value);
+
+CF_EXPORT void
+CFArraySortValues (CFMutableArrayRef theArray, CFRange range,
+                   CFComparatorFunction comparator, void *context);
+
+/** \} */
+
+CF_EXTERN_C_END
+#endif /* __COREFOUNDATION_CFARRAY_H__ */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFLocale.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFLocale.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFLocale.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/CoreFoundation/CFLocale.h	(revision 278653)
@@ -0,0 +1,249 @@
+/* CFLocale.h
+   
+   Copyright (C) 2010 Free Software Foundation, Inc.
+   
+   Written by: Stefan Bidigaray
+   Date: March, 2011
+   
+   This file is part of the GNUstep CoreBase Library.
+   
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; see the file COPYING.LIB.
+   If not, see <http://www.gnu.org/licenses/> or write to the 
+   Free Software Foundation, 51 Franklin Street, Fifth Floor, 
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef __COREFOUNDATION_CFLOCALE__
+#define __COREFOUNDATION_CFLOCALE__ 1
+
+#include "CFBase.h"
+
+#include "CFArray.h"
+#include "CFDictionary.h"
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_3, GS_API_LATEST)
+
+CF_EXTERN_C_BEGIN
+
+/** \defgroup CFLocaleRef CFLocale Reference
+    \brief CFLocale provides basic functionality for language and/or region
+    specific operations.
+    
+    Locale-sensitive operations, such as collation, calendars and
+    capitalization, may use CFLocale objects to provide language and/or region
+    specific functionality.
+  
+    CFLocale is "toll-free bridged" to NSLocale.
+    
+    \{
+ */
+typedef const struct __CFLocale *CFLocaleRef;
+
+/** 
+ */
+enum
+{
+  kCFLocaleLanguageDirectionUnknown     = 0,
+  kCFLocaleLanguageDirectionLeftToRight = 1,
+  kCFLocaleLanguageDirectionRightToLeft = 2,
+  kCFLocaleLanguageDirectionTopToBottom = 3,
+  kCFLocaleLanguageDirectionBottomToTop = 4
+};
+typedef CFIndex CFLocaleLanguageDirection;
+
+/** \name CFLocale Property Keys
+    \{
+ */
+CF_EXPORT const CFStringRef kCFLocaleMeasurementSystem; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleDecimalSeparator; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleGroupingSeparator; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleCurrencySymbol; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleCurrencyCode; /* CFString */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT const CFStringRef kCFLocaleIdentifier; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleLanguageCode; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleCountryCode; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleScriptCode; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleVariantCode; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleExemplarCharacterSet; /* CFCharacterSet */
+CF_EXPORT const CFStringRef kCFLocaleCalendarIdentifier; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleCalendar; /* CFCalendar */
+CF_EXPORT const CFStringRef kCFLocaleCollationIdentifier; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleUsesMetricSystem; /* CFBoolean */
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+CF_EXPORT const CFStringRef kCFLocaleCollatorIdentifier; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleQuotationBeginDelimiterKey; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleQuotationEndDelimiterKey; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleAlternateQuotationBeginDelimiterKey; /* CFString */
+CF_EXPORT const CFStringRef kCFLocaleAlternateQuotationEndDelimiterKey; /* CFString */
+#endif
+/** \} */
+
+/** \name CFCalendar Identifiers
+    \{
+ */
+CF_EXPORT const CFStringRef kCFGregorianCalendar;
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT const CFStringRef kCFBuddhistCalendar;
+CF_EXPORT const CFStringRef kCFChineseCalendar;
+CF_EXPORT const CFStringRef kCFHebrewCalendar;
+CF_EXPORT const CFStringRef kCFIslamicCalendar;
+CF_EXPORT const CFStringRef kCFIslamicCivilCalendar;
+CF_EXPORT const CFStringRef kCFJapaneseCalendar;
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+CF_EXPORT const CFStringRef kCFRepublicOfChinaCalendar;
+CF_EXPORT const CFStringRef kCFPersianCalendar;
+CF_EXPORT const CFStringRef kCFIndianCalendar;
+CF_EXPORT const CFStringRef kCFISO8601Calendar;
+#endif
+/** \} */
+
+/** CFLocale Change Notification
+ */
+CF_EXPORT const CFStringRef kCFLocaleCurrentLocaleDidChangeNotification;
+
+
+
+/** \name Creating a Locale
+    \{
+ */
+CF_EXPORT CFLocaleRef
+CFLocaleCopyCurrent (void);
+
+CF_EXPORT CFLocaleRef
+CFLocaleCreate (CFAllocatorRef allocator,
+                CFStringRef localeIdent);
+
+CF_EXPORT CFLocaleRef
+CFLocaleCreateCopy (CFAllocatorRef allocator,
+                    CFLocaleRef locale);
+
+CF_EXPORT CFLocaleRef
+CFLocaleGetSystem (void);
+/** \} */
+
+/** \name Getting System Locale Information
+    \{
+ */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT CFArrayRef
+CFLocaleCopyAvailableLocaleIdentifiers (void);
+#endif
+/** \} */
+
+/** \name Getting ISO Information
+    \{
+ */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT CFArrayRef
+CFLocaleCopyISOCountryCodes (void);
+
+CF_EXPORT CFArrayRef
+CFLocaleCopyISOLanguageCodes (void);
+
+CF_EXPORT CFArrayRef
+CFLocaleCopyISOCurrencyCodes (void);
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+CF_EXPORT CFArrayRef
+CFLocaleCopyCommonISOCurrencyCodes (void);
+#endif
+/** \{ */
+
+/** \name Accessing Language Information
+    \{
+ */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+CF_EXPORT CFArrayRef
+CFLocaleCopyPreferredLanguages (void);
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+CF_EXPORT CFLocaleLanguageDirection
+CFLocaleGetLanguageCharacterDirection (CFStringRef isoLangCode);
+
+CF_EXPORT CFLocaleLanguageDirection
+CFLocaleGetLanguageLineDirection (CFStringRef isoLangCode);
+#endif
+/** \} */
+
+/** \name Getting Information About a Locale
+    \{
+ */
+CF_EXPORT CFStringRef
+CFLocaleCopyDisplayNameForPropertyValue (CFLocaleRef displayLocale,
+                                         CFStringRef key,
+                                         CFStringRef value);
+
+CF_EXPORT CFTypeRef
+CFLocaleGetValue (CFLocaleRef locale,
+                  CFStringRef key);
+
+CF_EXPORT CFStringRef
+CFLocaleGetIdentifier (CFLocaleRef locale);
+/** \} */
+
+/** \name Getting and Creating Locale Identifiers
+    \{
+ */
+CF_EXPORT CFStringRef
+CFLocaleCreateCanonicalLocaleIdentifierFromString (CFAllocatorRef allocator,
+                                                   CFStringRef localeIdent);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+CF_EXPORT CFStringRef
+CFLocaleCreateCanonicalLanguageIdentifierFromString (CFAllocatorRef allocator,
+                                                     CFStringRef localeIdent);
+
+CF_EXPORT CFDictionaryRef
+CFLocaleCreateComponentsFromLocaleIdentifier (CFAllocatorRef allocator,
+                                              CFStringRef localeIdent);
+
+CF_EXPORT CFStringRef
+CFLocaleCreateLocaleIdentifierFromComponents (CFAllocatorRef allocator,
+                                              CFDictionaryRef dictionary);
+#endif
+/** \} */
+
+/** \name Windows Locale Codes
+    \{
+ */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+CF_EXPORT CFStringRef
+CFLocaleCreateLocaleIdentifierFromWindowsLocaleCode (CFAllocatorRef allocator,
+                                                     UInt32 lcid);
+
+CF_EXPORT UInt32
+CFLocaleGetWindowsLocaleCodeFromLocaleIdentifier (CFStringRef localeIdent);
+#endif
+/** \} */
+
+/** \name Getting the CFLocale Type ID
+    \{
+ */
+CF_EXPORT CFTypeID
+CFLocaleGetTypeID (void);
+/** \} */
+
+/** \} */
+
+CF_EXTERN_C_END
+
+#endif /* OS_API_VERSION >= MAC_OS_X_VERSION_10_3 */
+
+#endif /* __COREFOUNDATION_CFLOCALE__ */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSObjCRuntime.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSObjCRuntime.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSObjCRuntime.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSObjCRuntime.h	(revision 278653)
@@ -0,0 +1,631 @@
+/** Interface to ObjC runtime for GNUStep
+   Copyright (C) 1995, 1997, 2000, 2002, 2003 Free Software Foundation, Inc.
+
+   Written by:  Andrew Kachites McCallum <mccallum@gnu.ai.mit.edu>
+   Date: 1995
+   Written by:  Richard Frith-Macdonald <rfm@gnu.org>
+   Date: 2002
+   
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+   
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+    AutogsdocSource: Additions/GSObjCRuntime.m
+
+   */ 
+
+#ifndef __GSObjCRuntime_h_GNUSTEP_BASE_INCLUDE
+#define __GSObjCRuntime_h_GNUSTEP_BASE_INCLUDE
+
+#import "GSVersionMacros.h"
+#import "GSConfig.h"
+
+#include <stdio.h>
+
+#if 1 || NeXT_RUNTIME
+ #include <objc/objc.h>
+ #include <objc/objc-class.h>
+ #include <objc/objc-runtime.h>
+ #ifndef _C_ATOM
+  #define _C_ATOM '%'
+ #endif
+ #define _F_CONST    0x01
+ #define _F_IN       0x01
+ #define _F_OUT      0x02
+ #define _F_INOUT    0x03
+ #define _F_BYCOPY   0x04
+ #define _F_ONEWAY   0x08
+ #define _C_CONST    'r'
+ #define _C_IN       'n'
+ #define _C_INOUT    'N'
+ #define _C_OUT      'o'
+ #define _C_BYCOPY   'O'
+ #define _C_ONEWAY   'V'
+#else				/* GNU Objective C Runtime */
+ #include <objc/objc.h>
+ #if defined (__GNU_LIBOBJC__)
+  #include <objc/runtime.h>
+ #else
+  #include <objc/objc-api.h>
+  #include <objc/encoding.h>
+ #endif
+#endif
+
+/*
+ * Hack for older compiler versions that don't have all defines
+ * needed in  objc-api.h
+ */
+#ifndef	_C_LNG_LNG
+#define	_C_LNG_LNG	'q'
+#endif
+#ifndef	_C_ULNG_LNG
+#define	_C_ULNG_LNG	'Q'
+#endif
+
+#if	OBJC2RUNTIME
+/* We have a real ObjC2 runtime.
+ */
+#include <objc/runtime.h>
+#else
+/* We emulate an ObjC2 runtime.
+ */
+#include <ObjectiveC2/objc/runtime.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+@class	NSArray;
+@class	NSDictionary;
+@class	NSObject;
+@class	NSString;
+@class	NSValue;
+
+#ifndef YES
+#define YES		1
+#endif
+#ifndef NO
+#define NO		0
+#endif
+#ifndef nil
+#define nil		0
+#endif
+
+#if	!defined(_C_CONST)
+#define _C_CONST        'r'
+#endif
+#if	!defined(_C_IN)
+#define _C_IN           'n'
+#endif
+#if	!defined(_C_INOUT)
+#define _C_INOUT        'N'
+#endif
+#if	!defined(_C_OUT)
+#define _C_OUT          'o'
+#endif
+#if	!defined(_C_BYCOPY)
+#define _C_BYCOPY       'O'
+#endif
+#if	!defined(_C_BYREF)
+#define _C_BYREF        'R'
+#endif
+#if	!defined(_C_ONEWAY)
+#define _C_ONEWAY       'V'
+#endif
+#if	!defined(_C_GCINVISIBLE)
+#define _C_GCINVISIBLE  '!'
+#endif
+
+/*
+ * Functions for accessing instance variables directly -
+ * We can copy an ivar into arbitrary data,
+ * Get the type encoding for a named ivar,
+ * and copy a value into an ivar.
+ */
+GS_EXPORT BOOL
+GSObjCFindVariable(id obj, const char *name,
+		   const char **type, unsigned int *size, int *offset);
+
+GS_EXPORT void
+GSObjCGetVariable(id obj, int offset, unsigned int size, void *data);
+
+GS_EXPORT void
+GSObjCSetVariable(id obj, int offset, unsigned int size, const void *data);
+
+GS_EXPORT NSArray *
+GSObjCMethodNames(id obj, BOOL recurse);
+
+GS_EXPORT NSArray *
+GSObjCVariableNames(id obj, BOOL recurse);
+
+/**
+ * <p>A Behavior can be seen as a "Protocol with an implementation" or a
+ * "Class without any instance variables".  A key feature of behaviors
+ * is that they give a degree of multiple inheritance.
+ * </p>
+ * <p>Behavior methods, when added to a class, override the class's
+ * superclass methods, but not the class's methods.
+ * </p>
+ * <p>Whan a behavior class is added to a receiver class, not only are the
+ * methods defined in the behavior class added, but the methods from the
+ * behavior's class hierarchy are also added (unless already present).
+ * </p>
+ * <p>It's not the case that a class adding behaviors from another class
+ * must have "no instance vars".  The receiver class just has to have the
+ * same layout as the behavior class (optionally with some additional
+ * ivars after those of the behavior class).
+ * </p>
+ * <p>This function provides Behaviors without adding any new syntax to
+ * the Objective C language.  Simply define a class with the methods you
+ * want to add, then call this function with that class as the behavior
+ * argument.
+ * </p>
+ * <p>This function should be called in the +initialize method of the receiver.
+ * </p>
+ * <p>If you add several behaviors to a class, be aware that the order of
+ * the additions is significant.
+ * </p>
+ */
+GS_EXPORT void
+GSObjCAddClassBehavior(Class receiver, Class behavior);
+
+/**
+ * <p>An Override can be seen as a "category implemented as a separate class
+ * and manually added to the receiver class under program control, rather
+ * than automatically added by the compiler/runtime.
+ * </p>
+ * <p>Override methods, when added to a receiver class, replace the class's
+ * class's methods of the same name (or are added if the class did not define
+ * methods with that name).
+ * </p>
+ * <p>It's not the case that a class adding overrides from another class
+ * must have "no instance vars".  The receiver class just has to have the
+ * same layout as the override class (optionally with some additional
+ * ivars after those of the override class).
+ * </p>
+ * <p>This function provides overrides without adding any new syntax to
+ * the Objective C language.  Simply define a class with the methods you
+ * want to add, then call this function with that class as the override
+ * argument.
+ * </p>
+ * <p>This function should usually be called in the +initialize method
+ * of the receiver.
+ * </p>
+ * <p>If you add several overrides to a class, be aware that the order of
+ * the additions is significant.
+ * </p>
+ */
+GS_EXPORT void
+GSObjCAddClassOverride(Class receiver, Class override);
+
+/** Turn on (YES), off (NO) or test (-1) behavior debugging.
+ */
+GS_EXPORT BOOL GSObjCBehaviorDebug(int setget);
+
+GS_EXPORT NSValue *
+GSObjCMakeClass(NSString *name, NSString *superName, NSDictionary *iVars);
+
+GS_EXPORT void
+GSObjCAddClasses(NSArray *classes);
+
+/**
+ * Given a NULL terminated list of methods, add them to the class.<br />
+ * If the method already exists in a superclass, the new version overrides
+ * that one, but if the method already exists in the class itsself, the
+ * new one is quietly ignored (replace==NO) or replaced with the new
+ * version (if replace==YES).<br />
+ * To add class methods, cls should be the metaclass of the class to
+ * which the methods are being added.
+ */
+GS_EXPORT void
+GSObjCAddMethods(Class cls, Method *list, BOOL replace);
+
+/*
+ * Functions for key-value encoding ... they access values in an object
+ * either by selector or directly, but do so using NSNumber for the
+ * scalar types of data.
+ */
+GS_EXPORT id
+GSObjCGetVal(NSObject *self, const char *key, SEL sel,
+  const char *type, unsigned size, int offset);
+
+GS_EXPORT void
+GSObjCSetVal(NSObject *self, const char *key, id val, SEL sel,
+  const char *type, unsigned size, int offset);
+
+/*
+ * This section includes runtime functions
+ * to query and manipulate the ObjC runtime structures.
+ * These functions take care to not use ObjC code so
+ * that they can safely be used in +(void)load implementations
+ * where applicable.
+ */
+
+/**
+ * Deprecated ... use objc_getClassList()
+ */
+GS_EXPORT unsigned int
+GSClassList(Class *buffer, unsigned int max, BOOL clearCache);
+
+/**
+ * GSObjCClass() is deprecated ... use object_getClass()
+ */
+GS_EXPORT Class GSObjCClass(id obj);
+
+/**
+ * GSObjCSuper() is deprecated ... use class_getSuperclass()
+ */
+GS_EXPORT Class GSObjCSuper(Class cls);
+
+/**
+ * GSObjCIsInstance() is deprecated ... use object_getClass()
+ * in conjunction with class_isMetaClass()
+ */
+GS_EXPORT BOOL GSObjCIsInstance(id obj);
+
+/**
+ * GSObjCIsClass() is deprecated ... use object_getClass()
+ * in conjunction with class_isMetaClass()
+ */
+GS_EXPORT BOOL GSObjCIsClass(Class cls);
+
+/**
+ * Test to see if class inherits from another class
+ * The argument to this function must NOT be nil.
+ */
+GS_EXPORT BOOL GSObjCIsKindOf(Class cls, Class other);
+
+/**
+ * GSClassFromName() is deprecated ... use objc_lookUpClass()
+ */
+GS_EXPORT Class GSClassFromName(const char *name);
+
+/**
+ * GSNameFromClass() is deprecated ... use class_getName()
+ */
+GS_EXPORT const char *GSNameFromClass(Class cls);
+
+/**
+ * GSClassNameFromObject() is deprecated ... use object_getClass()
+ * in conjunction with class_getName()
+ */
+GS_EXPORT const char *GSClassNameFromObject(id obj);
+
+/**
+ * GSNameFromSelector() is deprecated ... use sel_getName()
+ */
+GS_EXPORT const char *GSNameFromSelector(SEL sel);
+
+/**
+ * GSSelectorFromName() is deprecated ... use sel_getUid()
+ */
+GS_EXPORT SEL
+GSSelectorFromName(const char *name);
+
+/**
+ * Return the selector for the specified name and types.<br />
+ * Returns a nul pointer if the name is nul.<br />
+ * Creates a new selector if necessary.<br />
+ * Code must NOT rely on this providing a selector with type information.
+ */
+GS_EXPORT SEL
+GSSelectorFromNameAndTypes(const char *name, const char *types);
+
+/**
+ * Return the type information from the specified selector.<br />
+ * May return a nul pointer if the selector was a nul pointer or if it
+ * was not typed (or if the runtime does not support typed selectors).<br />
+ * Code must NOT rely on this providing any type information.
+ */
+GS_EXPORT const char *
+GSTypesFromSelector(SEL sel);
+
+/**
+ * Compare only the type information ignoring qualifiers, the frame layout
+ * and register markers.  Unlike sel_types_match, this function also
+ * handles comparisons of types with and without any layout information.
+ */
+GS_EXPORT BOOL
+GSSelectorTypesMatch(const char *types1, const char *types2);
+
+/** Takes full type information and skips forward to the actual type
+ * as specified in the _C_... constants.
+ */
+GS_EXPORT const char *
+GSSkipTypeQualifierAndLayoutInfo(const char *types);
+
+/**
+ * Returns a protocol object with the corresponding name.
+ * This function searches the registered classes for any protocol
+ * with the supplied name.  If one is found, it is cached in
+ * for future requests.  If efficiency is a factor then use
+ * GSRegisterProtocol() to insert a protocol explicitly into the cache
+ * used by this function.  If no protocol is found this function returns
+ * nil.
+ */
+GS_EXPORT Protocol *
+GSProtocolFromName(const char *name);
+
+/**
+ * Registers proto in the cache used by GSProtocolFromName().
+ */
+GS_EXPORT void
+GSRegisterProtocol(Protocol *proto);
+
+/**
+ * A variant of protocol_getMethodDescription which recursively searches
+ * parent protocols if the requested selector isn't found in the given
+ * protocol.
+ *
+ * Returns a {NULL, NULL} structure if the requested selector couldn't be
+ * found.
+ */
+GS_EXPORT struct objc_method_description
+GSProtocolGetMethodDescriptionRecursive(Protocol *aProtocol, SEL aSel, BOOL isRequired, BOOL isInstance);
+
+/*
+ * Unfortunately the definition of the symbols
+ * 'Method(_t)', 'MethodList(_t)'  and 'IVar(_t)'
+ * are incompatible between the GNU and NeXT/Apple runtimes.
+ * We introduce GSMethod, GSMethodList and GSIVar to allow portability.
+ */
+typedef Method	GSMethod;
+typedef Ivar	GSIVar;
+
+/**
+ * Returns the pointer to the method structure
+ * for the selector in the specified class.
+ * Depending on searchInstanceMethods, this function searches
+ * either instance or class methods.
+ * Depending on searchSuperClassesm this function searches
+ * either the specified class only or also its superclasses.<br/>
+ * To obtain the implementation pointer IMP use returnValue->method_imp
+ * which should be safe across all runtimes.<br/>
+ * It should be safe to use this function in +load implementations.<br/>
+ * This function should currently (June 2004) be considered WIP.
+ * Please follow potential changes (Name, parameters, ...) closely until
+ * it stabilizes.
+ */
+GS_EXPORT GSMethod
+GSGetMethod(Class cls, SEL sel,
+	    BOOL searchInstanceMethods,
+	    BOOL searchSuperClasses);
+
+/**
+ * Deprecated .. does nothing.
+ */
+GS_EXPORT void
+GSFlushMethodCacheForClass (Class cls);
+
+/**
+ * Deprecated .. use class_getInstanceVariable()
+ */
+GS_EXPORT GSIVar
+GSCGetInstanceVariableDefinition(Class cls, const char *name);
+
+/**
+ * Deprecated .. use class_getInstanceVariable()
+ */
+GS_EXPORT GSIVar
+GSObjCGetInstanceVariableDefinition(Class cls, NSString *name);
+
+/**
+ * GSObjCVersion() is deprecated ... use class_getVersion()
+ */
+GS_EXPORT int GSObjCVersion(Class cls);
+
+/**
+ * Quickly return autoreleased data storage area.
+ */
+GS_EXPORT void *
+GSAutoreleasedBuffer(unsigned size);
+
+/**
+ * <p>Prints a message to fptr using the format string provided and any
+ * additional arguments.  The format string is interpreted as by
+ * the NSString formatted initialisers, and understands the '%@' syntax
+ * for printing an object.
+ * </p>
+ * <p>The data is written to the file pointer in the default CString
+ * encoding if possible, as a UTF8 string otherwise.
+ * </p>
+ * <p>This function is recommended for printing general log messages.
+ * For debug messages use NSDebugLog() and friends.  For error logging
+ * use NSLog(), and for warnings you might consider NSWarnLog().
+ * </p>
+ */
+GS_EXPORT BOOL
+GSPrintf (FILE *fptr, NSString *format, ...);
+
+
+
+GS_EXPORT NSArray *
+GSObjCAllSubclassesOfClass(Class cls);
+
+GS_EXPORT NSArray *
+GSObjCDirectSubclassesOfClass(Class cls);
+
+/** Function to change the class of the specified instance to newClass.
+ * This handles memory debugging issues in GNUstep-base and also
+ * deals with class finalisation issues in a garbage collecting
+ * environment, so you should use this function rather than attempting
+ * to swizzle class pointers directly.
+ */
+GS_EXPORT void
+GSClassSwizzle(id instance, Class newClass);
+
+#if !defined(GS_GNUSTEP_V) || (GS_GNUSTEP_V >= GS_API_ANY && GS_GNUSTEP_V < 011500)
+//GS_API_VERSION(GS_API_ANY,011500)
+
+GS_EXPORT const char *
+GSLastErrorStr(long error_id) GS_DEPRECATED_FUNC;
+
+#endif
+
+
+
+#ifndef	GS_MAX_OBJECTS_FROM_STACK
+/**
+ * The number of objects to try to get from varargs into an array on
+ * the stack ... if there are more than this, use the heap.
+ * NB. This MUST be a multiple of 2
+ */
+#define	GS_MAX_OBJECTS_FROM_STACK	128
+#endif
+
+/**
+ * <p>This is a macro designed to minimise the use of memory allocation and
+ * deallocation when you need to work with a vararg list of objects.<br />
+ * The objects are unpacked from the vararg list into two 'C' arrays and
+ * then a code fragment you specify is able to make use of them before
+ * that 'C' array is destroyed. 
+ * </p>
+ * <p>The firstObject argument is the name of the formal parameter in your
+ * method or function which precedes the ', ...' denoting variable args.
+ * </p>
+ * <p>The code argument is a piece of objective-c code to be executed to
+ * make use of the objects stored in the 'C' arrays.<br />
+ * When this code is called the unsigned integer '__count' will contain the
+ * number of objects unpacked, the pointer '__objects' will point to
+ * the first object in each pair, and the pointer '__pairs' will point
+ * to an array containing the second halves of the pairs of objects
+ * whose first halves are in '__objects'.<br />
+ * This lets you pack a list of the form 'key, value, key, value, ...'
+ * into an array of keys and an array of values.
+ * </p>
+ */
+#define GS_USEIDPAIRLIST(firstObject, code...) ({\
+  va_list	__ap; \
+  unsigned int	__max = GS_MAX_OBJECTS_FROM_STACK; \
+  unsigned int	__count = 0; \
+  id		__buf[__max]; \
+  id		*__objects = __buf; \
+  id		*__pairs = &__objects[__max/2]; \
+  id		__obj = firstObject; \
+  va_start(__ap, firstObject); \
+  while (__obj != nil && __count < __max) \
+    { \
+      if ((__count % 2) == 0) \
+	{ \
+	  __objects[__count/2] = __obj; \
+	} \
+      else \
+	{ \
+	  __pairs[__count/2] = __obj; \
+	} \
+      __obj = va_arg(__ap, id); \
+      if (++__count == __max) \
+	{ \
+	  while (__obj != nil) \
+	    { \
+	      __count++; \
+	      __obj = va_arg(__ap, id); \
+	    } \
+	} \
+    } \
+  if ((__count % 2) == 1) \
+    { \
+      __pairs[__count/2] = nil; \
+      __count++; \
+    } \
+  va_end(__ap); \
+  if (__count > __max) \
+    { \
+      unsigned int	__tmp; \
+      __objects = (id*)malloc(__count*sizeof(id)); \
+      __pairs = &__objects[__count/2]; \
+      __objects[0] = firstObject; \
+      va_start(__ap, firstObject); \
+      for (__tmp = 1; __tmp < __count; __tmp++) \
+	{ \
+	  if ((__tmp % 2) == 0) \
+	    { \
+	      __objects[__tmp/2] = va_arg(__ap, id); \
+	    } \
+	  else \
+	    { \
+	      __pairs[__tmp/2] = va_arg(__ap, id); \
+	    } \
+	} \
+      va_end(__ap); \
+    } \
+  code; \
+  if (__objects != __buf) free(__objects); \
+})
+
+/**
+ * <p>This is a macro designed to minimise the use of memory allocation and
+ * deallocation when you need to work with a vararg list of objects.<br />
+ * The objects are unpacked from the vararg list into a 'C' array and
+ * then a code fragment you specify is able to make use of them before
+ * that 'C' array is destroyed. 
+ * </p>
+ * <p>The firstObject argument is the name of the formal parameter in your
+ * method or function which precedes the ', ...' denoting variable args.
+ * </p>
+ * <p>The code argument is a piece of objective-c code to be executed to
+ * make use of the objects stored in the 'C' array.<br />
+ * When this code is called the unsigned integer '__count' will contain the
+ * number of objects unpacked, and the pointer '__objects' will point to
+ * the unpacked objects, ie. firstObject followed by the vararg arguments
+ * up to (but not including) the first nil.
+ * </p>
+ */
+#define GS_USEIDLIST(firstObject, code...) ({\
+  va_list	__ap; \
+  unsigned int	__max = GS_MAX_OBJECTS_FROM_STACK; \
+  unsigned int	__count = 0; \
+  id		__buf[__max]; \
+  id		*__objects = __buf; \
+  id		__obj = firstObject; \
+  va_start(__ap, firstObject); \
+  while (__obj != nil && __count < __max) \
+    { \
+      __objects[__count] = __obj; \
+      __obj = va_arg(__ap, id); \
+      if (++__count == __max) \
+	{ \
+	  while (__obj != nil) \
+	    { \
+	      __count++; \
+	      __obj = va_arg(__ap, id); \
+	    } \
+	} \
+    } \
+  va_end(__ap); \
+  if (__count > __max) \
+    { \
+      unsigned int	__tmp; \
+      __objects = (id*)NSZoneMalloc(NSDefaultMallocZone(),__count*sizeof(id)); \
+      va_start(__ap, firstObject); \
+      __objects[0] = firstObject; \
+      for (__tmp = 1; __tmp < __count; __tmp++) \
+	{ \
+	  __objects[__tmp] = va_arg(__ap, id); \
+	} \
+      va_end(__ap); \
+    } \
+  code; \
+  if (__objects != __buf) NSZoneFree (NSDefaultMallocZone(),__objects); \
+})
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __GSObjCRuntime_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSArray+GNUstepBase.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSArray+GNUstepBase.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSArray+GNUstepBase.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSArray+GNUstepBase.h	(revision 278653)
@@ -0,0 +1,78 @@
+/** Declaration of extension methods for base additions
+
+   Copyright (C) 2003-2010 Free Software Foundation, Inc.
+
+   Written by:  Richard Frith-Macdonald <rfm@gnu.org>
+   and:         Adam Fedor <fedor@gnu.org>
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+*/
+
+#ifndef	INCLUDED_NSArray_GNUstepBase_h
+#define	INCLUDED_NSArray_GNUstepBase_h
+
+#import "../GNUstepBase/GSVersionMacros.h"
+#import "../Foundation/NSArray.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+#if	OS_API_VERSION(GS_API_NONE,GS_API_LATEST)
+
+@interface NSArray (GNUstepBase)
+
+/** <p>Method for working with sorted arrays - use a binary chop
+ * to determine the insertion location for an object.  If equal objects
+ * already exist in the array, they will be located immediately before
+ * the insertion position.
+ * </p>
+ * <p>The comparator function takes two items as arguments, the first is the
+ * item to be added, the second is the item already in the array.
+ * The function should return NSOrderedAscending if the item to be
+ * added is 'less than' the item in the array, NSOrderedDescending
+ * if it is greater, and NSOrderedSame if it is equal.
+ * </p>
+ */
+- (NSUInteger) insertionPosition: (id)item
+		   usingFunction: (NSComparisonResult (*)(id, id, void *))sorter
+		         context: (void *)context;
+
+/* <p>Method for working with sorted arrays - use a binary chop
+ * to determine the insertion location for an object.  If equal objects
+ * already exist in the array, they will be located immediately before
+ * the insertion position.
+ * </p> 
+ * <p>The selector identifies a method returning NSOrderedAscending if
+ * the receiver is 'less than' the argument, and NSOrderedDescending if
+ * it is greate.
+ * </p>
+ */
+- (NSUInteger) insertionPosition: (id)item
+		   usingSelector: (SEL)comp;
+@end
+
+#endif	/* OS_API_VERSION */
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif	/* INCLUDED_NSArray_GNUstepBase_h */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSMutableString+GNUstepBase.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSMutableString+GNUstepBase.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSMutableString+GNUstepBase.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSMutableString+GNUstepBase.h	(revision 278653)
@@ -0,0 +1,57 @@
+/** Declaration of extension methods for base additions
+
+   Copyright (C) 2003-2010 Free Software Foundation, Inc.
+
+   Written by:  Richard Frith-Macdonald <rfm@gnu.org>
+   and:         Adam Fedor <fedor@gnu.org>
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+*/
+
+#ifndef	INCLUDED_NSMutableString_GNUstepBase_h
+#define	INCLUDED_NSMutableString_GNUstepBase_h
+
+#import "GSVersionMacros.h"
+#import "../Foundation/NSString.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+#if	OS_API_VERSION(GS_API_NONE,GS_API_LATEST)
+
+@interface NSMutableString (GNUstepBase)
+- (void) deleteSuffix: (NSString*)suffix;
+- (void) deletePrefix: (NSString*)prefix;
+- (NSString*) immutableProxy;
+- (void) replaceString: (NSString*)replace
+            withString: (NSString*)by;
+- (void) trimLeadSpaces;
+- (void) trimTailSpaces;
+- (void) trimSpaces;
+@end
+
+#endif	/* OS_API_VERSION */
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif	/* INCLUDED_NSMutableString_GNUstepBase_h */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSConfig.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSConfig.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSConfig.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSConfig.h	(revision 278653)
@@ -0,0 +1,462 @@
+/* Machine/OS specific configuration information for GNUstep
+
+   Please NOTE - GSConfig.h is generated by the configure script from the
+   file GSConfig.h.in - changes/fixes need to be made to the original file,
+   not to the GSConfig.h generated from it.
+
+   Copyright (C) 1998-2010 Free Software Foundation, Inc.
+
+   Written by:  Richard frith-Macdonald <richard@brainstorm.co.uk>
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+   */
+
+#ifndef	included_GSConfig_h
+#define	included_GSConfig_h
+
+/* Check the compiler to see if we are building on/for ms-windows.
+ * Whatever the compiler uses, we want a standard setting of _WIN64
+ * to indicate 64bit AND _WIN32 to indicate ms-windows.
+ * These are defined by gcc, clang, and microsoft compilers anyway.
+ */
+#if     defined(__WIN32__) \
+	|| defined(__MS_WIN32__) \
+	|| defined(__MINGW32__)
+#  if	!defined(_WIN32)
+#    define _WIN32
+#  endif
+#endif
+#if     defined(__WIN64__) \
+	|| defined(__MS_WIN64__) \
+	|| defined(__MINGW64__)
+#  if	!defined(__WIN64__)
+#    define __WIN64__
+#  endif
+#  if	!defined(_WIN32)
+#    define _WIN32
+#  endif
+#endif
+
+/* Check to see if this is a MINGW build (all we currently support)
+ */
+#if	defined(__MINGW32__) || defined(__MINGW64__)
+#  if	!defined(__MINGW__)
+#    define __MINGW__
+#  endif
+#endif
+
+// Make sure we expose the constants that we use in ObjC++ mode
+#ifndef __STDC_CONSTANT_MACROS
+#define __STDC_CONSTANT_MACROS 1
+#endif
+#ifndef __STDC_LIMIT_MACROS 
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#if !defined(NeXT_Foundation_LIBRARY)
+
+/* An alternate to GS_FAKE_MAIN which forces the user to call the
+   NSProcessInfo initialization in 'main', GS_FAKE_MAIN must also
+   be undefined. */
+#if 0
+#define GS_PASS_ARGUMENTS 0
+#endif
+
+#define GS_FAKE_MAIN	0
+#if	GS_FAKE_MAIN
+
+/*
+ * NOTE - if GS_FAKE_MAIN (above) is set to 1, this hack applies - and you
+ * must make sure that this file is included in any file that implements
+ * the 'main()' function and links with the GNUstep base libarary.
+ * You should NOT include this file in a program that does not link with
+ * the base library.
+ * This file is included automatically in NSObject.h and Foundation.h
+ *
+ * The Foundation classe NSProcessInfo need access to the argc, argv,
+ * and env variables of the main() function. The purpose of this (ugly hack)
+ * definition is to give the gstep-base library the opportunity to implement
+ * its own main function with private access to the global vars. The private
+ * main() implementation (in NSProcessInfo.m) will then call the user defined
+ * gnustep_base_user_main() function.
+ *
+ * The original hack was -
+ ** Written by:  Georg Tuparev, EMBL & Academia Naturalis,
+ **              Heidelberg, Germany
+ **              Tuparev@EMBL-Heidelberg.de
+ **
+ **  NOTE! This is very dirty and dangerous trick. I spend several hours
+ ** on thinking and man pages browsing, but couldn't find better solution.
+ ** I know that I will spend 666 years in the Computer Hell for writing
+ ** this hack, and the master devil (Bully Boy) will send me to write
+ ** Windowz software.
+ ** BTW, for writing this hack I got personal congratulations from Dennis
+ ** Ritchie and Bjarne Stroustrup sent me a bunch of flowers and asked me
+ ** to participate in the standardization committee for C-- v.6.0 as
+ ** responsible for the new Tab-Overriding-Operator and Scope-Sensitive-
+ ** Comments ... but this makes my situation even worse ;-)
+ ** - Georg
+ *
+ * On some systems, there are other relatively clean workarounds, if this
+ * applies to the system you are running on, your configuration script
+ * should have set GS_FAKE_MAIN to zero, so that this define hack will
+ * not be used.
+ */
+
+#define main gnustep_base_user_main
+
+#endif	/* GS_FAKE_MAIN */
+#endif
+
+/*
+ * Definition to specify if your processor stores words with the most
+ * significant byte first (like Motorola and SPARC, unlike Intel and VAX).
+ */
+#define GS_WORDS_BIGENDIAN	0
+
+/*
+ *	Size definitions for standard types
+ */
+#define	GS_SIZEOF_SHORT		2
+#define	GS_SIZEOF_INT		4
+#define	GS_SIZEOF_LONG		8
+#define	GS_SIZEOF_LONG_LONG	8
+#define	GS_SIZEOF_FLOAT		4
+#define	GS_SIZEOF_DOUBLE	8
+#define	GS_SIZEOF_VOIDP		8
+
+/*
+ *	Size information to be places in bits 5 and 6 of type encoding bytes
+ *	in archives (bits 0 to 4 are used for basic type info and bit 7 is
+ *	used to mark cross-references to previously encoded objects).
+ */
+#define	_GSC_S_SHT	_GSC_I16
+#define	_GSC_S_INT	_GSC_I32
+#define	_GSC_S_LNG	_GSC_I64
+#define	_GSC_S_LNG_LNG	_GSC_I64
+
+/*
+ * Type definitions for types with known sizes.
+ */
+typedef signed char gss8;
+typedef unsigned char gsu8;
+typedef signed short gss16;
+typedef unsigned short gsu16;
+typedef signed int gss32;
+typedef unsigned int gsu32;
+typedef signed long gss64;
+typedef unsigned long gsu64;
+typedef struct { gsu8 a[16]; } gss128;
+typedef struct { gsu8 a[16]; } gsu128;
+typedef float gsf32;
+typedef double gsf64;
+
+/*
+ * Integer type with same size as a pointer
+ */
+typedef	unsigned long gsuaddr;
+typedef	long gssaddr;
+typedef	gsuaddr gsaddr;
+
+/*
+ *	Do we have real 64-bit and 128-bit integers or are we just pretending.
+ */
+#define GS_HAVE_I64	1
+#define GS_HAVE_I128	0
+
+/*
+ * Ensure some standard types are defined.
+ */
+#include <inttypes.h>
+
+
+
+
+
+
+
+
+
+
+
+/*
+ * PTR Limit information replacements for buggy headers
+ */ 
+#if 0
+#undef INTPTR_MAX
+#define INTPTR_MAX 
+#undef INTPTR_MIN
+#define INTPTR_MIN 
+#undef UINTPTR_MAX
+#define UINTPTR_MAX 
+#endif
+
+
+/*
+ *	Do we have zlib for file handle compression?
+ */
+#define USE_ZLIB	1
+
+/*
+ *	Do we have the GNU Multiple-precision library for NSDecimal?
+ */
+//#define USE_GMP	1
+#define USE_GMP	0
+
+#ifdef	GS_WITH_GC
+#undef  GS_WITH_GC
+#endif
+#define	GS_WITH_GC	0
+
+/*
+ * Define to say if we use NXConstantString or NSConstantString
+ */
+#define NXConstantString	NSConstantString
+
+
+/*
+ * Wide unicode character type.
+ */
+#ifndef	UTF32Char
+#define	UTF32Char	uint32_t
+#endif
+
+/*
+ * Native character type for use in systemcalls etc.
+ */
+
+#if	defined(__MINGW__)
+#  define	GSNativeChar	uint16_t
+#else
+#  define	GSNativeChar	char
+#endif
+
+/*
+ * Types used to avoid exposing pthread header in NSLock.h
+ * NB. These types should *never* be used except to provide enough space
+ * in a class layout for the type of data actually used by the pthread
+ * implementation of the current platform.
+ */
+typedef	struct {
+  uint8_t	dummy[48];
+} gs_cond_t	__attribute__((aligned (8)));
+typedef	struct {
+  uint8_t	dummy[40];
+} gs_mutex_t	__attribute__((aligned (8)));
+
+#define	OBJC2RUNTIME 1
+#define BASE_NATIVE_OBJC_EXCEPTIONS     1
+#define GS_NONFRAGILE     0
+#define GS_MIXEDABI     0
+#define GS_USE_LIBXML 0
+#define GS_USE_GNUTLS 0
+#define GS_USE_AVAHI 0
+#define GS_USE_MDNS 0
+#define GS_USE_ICU 0
+#define GS_USE_LIBDISPATCH 0
+#define GS_USE_LIBDISPATCH_RUNLOOP 0
+#define GS_HAVE_OBJC_ROOT_CLASS_ATTR 0
+
+#ifndef __has_include
+#  define __has_include(x) 0
+#endif
+#ifndef __has_feature
+#  define __has_feature(x) 0
+#endif
+#ifndef __has_builtin
+#  define __has_builtin(x) 0
+#endif
+
+/*
+ * __has_extension has slightly different semantics from __has_feature.
+ * It evaluates to true if the feature is supported by by clang for the
+ * current compilation unit (language and -f switches), regardless of
+ * whether it is part of the language standard or just a (non-standard)
+ * extension.
+ */
+#ifndef __has_extension
+#  define __has_extension(x) __has_feature(x)
+#endif
+
+#if defined(_WIN32)
+#define BOOL WinBOOL
+#define __OBJC_BOOL 1
+#include <w32api.h>
+#ifndef _WIN32_WINNT
+#define _WIN32_WINNT Windows2000
+#endif
+#if	!defined(WINVER)
+#define WINVER Windows2000
+#elif (WINVER < Windows2000)
+#undef	WINVER
+#define WINVER Windows2000
+#endif
+
+#if defined(__WIN64__)
+#include <winsock2.h>
+#include <windows.h>
+#else
+#include <windows.h>
+#include <winsock2.h>
+#endif
+
+#undef __OBJC_BOOL
+#undef  BOOL
+#endif
+
+/* Include the blocks runtime header if it's available (It shouldn't matter
+ * that this doesn't work on compilers that don't support __has_include(),
+ * because they also don't support blocks).
+ */
+#if __has_include(<objc/block_runtime.h>)
+#  include <objc/block_runtime.h>
+#endif
+
+#ifndef _WIN32
+#include <sys/param.h> /* Hack to get rid of warning in GNU libc 2.0.3. */
+#endif
+
+/* The following group of lines maintained by the gstep-base configure */
+#define GNUSTEP_BASE_VERSION            1.26.0
+#define GNUSTEP_BASE_MAJOR_VERSION      1
+#define GNUSTEP_BASE_MINOR_VERSION      26
+#define GNUSTEP_BASE_SUBMINOR_VERSION   0
+#define GNUSTEP_BASE_GCC_VERSION        4.0.0
+
+/* Do not use the following macros!
+ */
+#define OBJC_DEP(M) \
+  ({ static BOOL beenHere = NO; if (beenHere == NO) {\
+    beenHere = YES; fprintf(stderr, "%s:%d %s", __FILE__, __LINE__, (M));}})
+
+#define OBJC_MALLOC(VAR, TYPE, NUM) \
+   (OBJC_DEP("OBJC_MALLOC is deprecated ... use malloc\n"),(VAR) = (TYPE *) malloc ((unsigned)(NUM)*sizeof(TYPE)))
+#define OBJC_VALLOC(VAR, TYPE, NUM) \
+   (OBJC_DEP("OBJC_VALLOC is deprecated\n"),(VAR) = (TYPE *) valloc ((unsigned)(NUM)*sizeof(TYPE)))
+#define OBJC_ATOMIC_MALLOC(VAR, TYPE, NUM) \
+   (OBJC_DEP("OBJC_ATOMIC_MALLOC is deprecated\n"),(VAR) = (TYPE *) malloc ((unsigned)(NUM)*sizeof(TYPE)))
+#define OBJC_REALLOC(VAR, TYPE, NUM) \
+   (OBJC_DEP("OBJC_REALLOC is deprecated ... use realloc\n"),(VAR) = (TYPE *) realloc ((VAR), (unsigned)(NUM)*sizeof(TYPE)))
+#define OBJC_CALLOC(VAR, TYPE, NUM) \
+   (OBJC_DEP("OBJC_CALLOC is deprecated ... use calloc\n"),(VAR) = (TYPE *) calloc ((unsigned)(NUM), sizeof(TYPE)))
+#define OBJC_FREE(PTR) (OBJC_DEP("OBJC_FREE is deprecated ... use free\n"), free (PTR))
+
+#ifndef MAX
+#define MAX(a,b) \
+       ({__typeof__(a) _MAX_a = (a); __typeof__(b) _MAX_b = (b);  \
+         _MAX_a > _MAX_b ? _MAX_a : _MAX_b; })
+#endif
+
+#ifndef MIN
+#define MIN(a,b) \
+       ({__typeof__(a) _MIN_a = (a); __typeof__(b) _MIN_b = (b);  \
+         _MIN_a < _MIN_b ? _MIN_a : _MIN_b; })
+#endif
+
+#ifndef ABS
+#define ABS(a) \
+       ({__typeof__(a) _ABS_a = (a); \
+         _ABS_a < 0 ? -_ABS_a : _ABS_a; })
+#endif
+
+#ifndef STRINGIFY
+#define STRINGIFY(s) XSTRINGIFY(s)
+#define XSTRINGIFY(s) #s
+#endif
+
+#ifndef OBJC_STRINGIFY
+#define OBJC_STRINGIFY(s) OBJC_XSTRINGIFY(s)
+#define OBJC_XSTRINGIFY(s) @#s
+#endif
+
+#ifndef PTR2LONG
+#define PTR2LONG(P) (((char*)(P))-(char*)0)
+#endif
+#ifndef LONG2PTR
+#define LONG2PTR(L) (((char*)0)+(L))
+#endif
+
+#if VSPRINTF_RETURNS_LENGTH
+#define VSPRINTF_LENGTH(VSPF_CALL) (VSPF_CALL)
+#else
+#define VSPRINTF_LENGTH(VSPF_CALL) strlen((VSPF_CALL))
+#endif /* VSPRINTF_RETURNS_LENGTH */
+
+#if VASPRINTF_RETURNS_LENGTH
+#define VASPRINTF_LENGTH(VASPF_CALL) (VASPF_CALL)
+#else
+#define VASPRINTF_LENGTH(VASPF_CALL) strlen((VASPF_CALL))
+#endif /* VSPRINTF_RETURNS_LENGTH */
+
+/* Evil hack to stop gcc-4.1 complaining about a dealloc method which
+ * does not call the superclass implementation.
+ */
+#define	GSNOSUPERDEALLOC	if (0) [super dealloc]
+
+#ifndef CF_EXCLUDE_CSTD_HEADERS
+#include <sys/types.h>
+#include <stdarg.h>
+#include <assert.h>
+#include <ctype.h>
+#include <errno.h>
+#include <float.h>
+#include <limits.h>
+#include <locale.h>
+#include <math.h>
+#include <setjmp.h>
+#include <signal.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <stdbool.h>
+#endif
+
+#if !__has_feature(objc_arc)
+// NetBSD > 6 defines __weak in cdefs_elf.h
+#ifdef __NetBSD__
+#undef __weak
+#endif
+#  if !defined(__weak)
+#    define __weak
+#  endif
+#  if !defined(__strong)
+#    define __strong
+#  endif
+#endif
+
+#ifndef __unsafe_unretained
+#  if !__has_feature(objc_arc)
+#    define __unsafe_unretained
+#  endif
+#endif
+#ifndef __bridge
+#  if !__has_feature(objc_arc)
+#    define __bridge
+#  endif
+#endif
+
+#if __has_builtin(__builtin_unreachable)
+#  define GS_UNREACHABLE() __builtin_unreachable()
+#else
+#  define GS_UNREACHABLE() abort()
+#endif
+
+#endif	/* included_GSConfig_h */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSObject+GNUstepBase.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSObject+GNUstepBase.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSObject+GNUstepBase.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSObject+GNUstepBase.h	(revision 278653)
@@ -0,0 +1,242 @@
+/** Declaration of extension methods for base additions
+
+   Copyright (C) 2003-2010 Free Software Foundation, Inc.
+
+   Written by:  Richard Frith-Macdonald <rfm@gnu.org>
+   and:         Adam Fedor <fedor@gnu.org>
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+*/
+
+#ifndef	INCLUDED_NSObject_GNUstepBase_h
+#define	INCLUDED_NSObject_GNUstepBase_h
+
+#import "GSVersionMacros.h"
+#import "../Foundation/NSObject.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+#if	OS_API_VERSION(GS_API_NONE,GS_API_LATEST)
+
+@class  NSHashTable;
+
+@interface NSObject (GNUstepBase)
+
+/**
+  WARNING: The -compare: method for NSObject is deprecated
+           due to subclasses declaring the same selector with 
+	   conflicting signatures.
+           Comparision of arbitrary objects is not just meaningless
+           but also dangerous as most concrete implementations
+           expect comparable objects as arguments often accessing
+	   instance variables directly.
+	   This method will be removed in a future release.
+*/
+- (NSComparisonResult) compare: (id)anObject;
+
+/** For backward compatibility only ... use class_isMetaClass() on the
+ * class of the receiver instead.
+ */
+- (BOOL) isInstance;
+
+/** DEPRECATED ... do not use.
+ * Transmutes the receiver into an immutable version of the same object
+ * and returns the result.<br />
+ * If the receiver is not a mutable object or cannot be simply transmuted,
+ * then this method either returns the receiver unchanged or,
+ * if the force flag is set to YES, returns an autoreleased copy of the
+ * receiver.<br />
+ * Mutable classes should override this default implementation.<br />
+ * This method is used in methods which are declared to return immutable
+ * objects (eg. an NSArray), but which create and build mutable ones
+ * internally.
+ */
+- (id) makeImmutableCopyOnFail: (BOOL)force;
+
+/** Transmutes the receiver into an immutable version of the same object.
+ * Returns YES if the receiver has become immutable, NO otherwise.<br />
+ * The default implementation returns NO.<br />
+ * Mutable classes which have an immutable counterpart they can efficiently
+ * change into, should override to transmute themselves and return YES.<br />
+ * Immutable classes should override this to simply return YES with no
+ * further action.<br />
+ * This method is used in methods which are declared to return immutable
+ * objects (eg. an NSArray), but which create and build mutable ones
+ * internally.
+ */
+- (BOOL) makeImmutable;
+
+/**
+ * Message sent when an implementation wants to explicitly exclude a method
+ * (but cannot due to compiler constraint), and wants to make sure it is not
+ * called by mistake.  Default implementation raises an exception at runtime.
+ */
+- (id) notImplemented: (SEL)aSel GS_NORETURN_METHOD;
+
+/**
+ * Message sent when an implementation wants to explicitly require a subclass
+ * to implement a method (but cannot at compile time since there is no
+ * <code>abstract</code> keyword in Objective-C).  Default implementation
+ * raises an exception at runtime to alert developer that he/she forgot to
+ * override a method.
+ */
+- (id) subclassResponsibility: (SEL)aSel GS_NORETURN_METHOD;
+
+/**
+ * Message sent when an implementation wants to explicitly exclude a method
+ * (but cannot due to compiler constraint) and forbid that subclasses
+ * implement it.  Default implementation raises an exception at runtime.  If a
+ * subclass <em>does</em> implement this method, however, the superclass's
+ * implementation will not be called, so this is not a perfect mechanism.
+ */
+- (id) shouldNotImplement: (SEL)aSel GS_NORETURN_METHOD;
+
+@end
+
+/** This is an informal protocol ... classes may implement the method to
+ * report how much memory is used by the instance and any objects it acts
+ * as a container for.
+ */
+@interface      NSObject(MemoryFootprint)
+/* This method returns the memory usage of the receiver, excluding any
+ * objects already present in the exclude table.<br />
+ * The argument is a hash table configured to hold non-retained pointer
+ * objects and is used to inform the receiver that its size should not
+ * be counted again if it's already in the table.<br />
+ * The NSObject implementation returns zero if the receiver is in the
+ * table, but otherwise adds itself to the table and returns its memory
+ * footprint (the sum of all of its instance variables, but not any
+ * memory pointed to by those variables).<br />
+ * Subclasses should override this method by calling the superclass
+ * implementation, and either return the result (if it was zero) or
+ * return that value plus the sizes of any memory owned by the receiver
+ * (eg found by calling the same method on objects pointed to by the
+ * receiver's instance variables).
+ */
+- (NSUInteger) sizeInBytesExcluding: (NSHashTable*)exclude;
+@end
+
+/** This is an informal protocol ... classes may implement the method and
+ * register themselves to have it called on process exit.
+ */
+@interface NSObject(GSAtExit)
+/** This method is called on exit for any class which implements it and which
+ * has called +registerAtExit to register it to be called.<br />
+ * The order in which methods for different classes is called is the reverse
+ * of the order in which the classes were registered, but it's best to assume
+ * the method can not depend on any other class being in a usable state
+ * at the point when the method is called (rather like +load).<br />
+ * Typical use would be to release memory occupied by class data structures
+ * so that memory usage analysis software will not think the memory has
+ * been leaked.
+ */
++ (void) atExit;
+@end
+
+/** Category for methods handling leaked memory cleanup on exit of process
+ * (for use when debugging memory leaks).<br />
+ * You enable this by calling the +setShouldCleanUp: method (done implicitly
+ * by gnustep-base if the GNUSTEP_SHOULD_CLEAN_UP environment variable is
+ * set to YES).<br />
+ * Your class then has two options for performing cleanup when the process
+ * ends:
+ * <p>1. Use the +leak: method to register objects which are simply to be 
+ * retained until the process ends, and then either ignored or released
+ * depending on the cleanup setting in force.  This mechanism is simple
+ * and should be sufficient for many classes.
+ * </p>
+ * <p>2. Implement a +atExit method to be run when the process ends and,
+ * within your +initialize implementation, call +shouldCleanUp to determine
+ * whether cleanup should be done, and if it returns YES then call
+ * +registerAtExit to have your +atExit method called when the process
+ * terminates.
+ * </p>
+ * <p>The order in which 'leaked' objects are released and +atExit methods
+ * are called on process exist is the reverse of the order in which they
+ * werse set up suing this API.
+ * </p>
+ */
+@interface NSObject(GSCleanup)
+
+
+/** This method simply retains its argument so that it will never be
+ * deallocated during normal operation, but keeps track of it so that
+ * it is released during process exit if cleanup is enabled.<br />
+ * Returns its argument.
+ */
++ (id) NS_RETURNS_RETAINED leak: (id)anObject;
+
+/** This method retains the object at *anAddress so that it will never be
+ * deallocated during normal operation, but keeps track of the address
+ * so that the object is released and the address is zeroed during process
+ * exit if cleanup is enabled.<br />
+ * Returns the object at *anAddress.
+ */
++ (id) NS_RETURNS_RETAINED leakAt: (id*)anAddress;
+
+/** Sets the receiver to have its +atExit method called at the point when
+ * the process terminates.<br />
+ * Returns YES on success and NO on failure (if the class does not implement
+ * the method or if it is already registered to call it).<br />
+ * Implemented as a call to +registerAtExit: with the selector for the +atExit
+ * method as its argument.
+ */
++ (BOOL) registerAtExit;
+
+/** Sets the receiver to have the specified  method called at the point when
+ * the process terminates.<br />
+ * Returns YES on success and NO on failure (if the class does not implement
+ * the method ir if it is already registered to call it).
+ */
++ (BOOL) registerAtExit: (SEL)aSelector;
+
+/** Specifies the default cleanup behavior on process exit ... the value
+ * returned by the NSObject implementation of the +shouldClanUp method.<br />
+ * Calling this method with a YES argument implicitly calls the +enableAtExit
+ * method as well.<br />
+ * The GNUstep Base library calls this method with the value obtained from
+ * the GNUSTEP_SHOULD_CLEAN_UP environment variable when NSObject is
+ * initialised.
+ */
++ (void) setShouldCleanUp: (BOOL)aFlag;
+
+/** Returns a flag indicating whether the receiver should clean up
+ * its data structures etc at process exit.<br />
+ * The NSObject implementation returns the value set by the +setShouldCleanUp:
+ * method but subclasses may override this.
+ */
++ (BOOL) shouldCleanUp;
+
+@end
+
+/* Macro to take an autoreleased object and either make it immutable or
+ * create an autoreleased copy of the original.
+ */
+#define GS_IMMUTABLE(O) ([O makeImmutable] == YES ? O : AUTORELEASE([O copy]))
+
+#endif	/* OS_API_VERSION */
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif	/* INCLUDED_NSObject_GNUstepBase_h */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSString+GNUstepBase.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSString+GNUstepBase.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSString+GNUstepBase.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSString+GNUstepBase.h	(revision 278653)
@@ -0,0 +1,105 @@
+/** Declaration of extension methods for base additions
+
+   Copyright (C) 2003-2010 Free Software Foundation, Inc.
+
+   Written by:  Richard Frith-Macdonald <rfm@gnu.org>
+   and:         Adam Fedor <fedor@gnu.org>
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+*/
+
+#ifndef	INCLUDED_NSString_GNUstepBase_h
+#define	INCLUDED_NSString_GNUstepBase_h
+
+#import "GSVersionMacros.h"
+#import "../Foundation/NSString.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+#if	OS_API_VERSION(GS_API_NONE,GS_API_LATEST)
+
+/**
+ * Provides some additional (non-standard) utility methods.
+ */
+@interface NSString (GNUstepBase)
+
+/**
+ * Alternate way to invoke <code>stringWithFormat</code> if you have or wish
+ * to build an explicit <code>va_list</code> structure.
+ */
++ (id) stringWithFormat: (NSString*)format
+	      arguments: (va_list)argList NS_FORMAT_FUNCTION(1,0);
+
+/**
+ * Returns a string formed by removing the prefix string from the
+ * receiver.  Raises an exception if the prefix is not present.
+ */
+- (NSString*) stringByDeletingPrefix: (NSString*)prefix;
+
+/**
+ * Returns a string formed by removing the suffix string from the
+ * receiver.  Raises an exception if the suffix is not present.
+ */
+- (NSString*) stringByDeletingSuffix: (NSString*)suffix;
+
+/**
+ * Returns a string formed by removing leading white space from the
+ * receiver.
+ */
+- (NSString*) stringByTrimmingLeadSpaces;
+
+/**
+ * Returns a string formed by removing trailing white space from the
+ * receiver.
+ */
+- (NSString*) stringByTrimmingTailSpaces;
+
+/**
+ * Returns a string formed by removing both leading and trailing
+ * white space from the receiver.
+ */
+- (NSString*) stringByTrimmingSpaces;
+
+/**
+ * Returns a string in which any (and all) occurrences of
+ * replace in the receiver have been replaced with by.
+ * Returns the receiver if replace
+ * does not occur within the receiver.  NB. an empty string is
+ * not considered to exist within the receiver.
+ */
+- (NSString*) stringByReplacingString: (NSString*)replace
+			   withString: (NSString*)by;
+
+/**
+ * An obsolete name for -substringWithRange: ... deprecated.
+ */
+- (NSString*) substringFromRange: (NSRange)aRange;
+
+@end
+
+#endif	/* OS_API_VERSION */
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif	/* INCLUDED_NSString_GNUstepBase_h */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSVersionMacros.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSVersionMacros.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSVersionMacros.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSVersionMacros.h	(revision 278653)
@@ -0,0 +1,460 @@
+/* GSVersionMacros.h - macros for managing API versioning and visibility
+   Copyright (C) 2006-2014 Free Software Foundation, Inc.
+
+   Written by: Richard Frith-Macdonald <rfm@gnu.org>
+   Date: Oct, October 2006
+
+   This file is part of GNUstep.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifndef __GNUSTEP_GSVERSIONMACROS_H_INCLUDED_
+#define __GNUSTEP_GSVERSIONMACROS_H_INCLUDED_
+
+/* By default we defined NO_GNUSTEP to 0 so that we will include extensions.
+ */
+#if	!defined(NO_GNUSTEP)
+#  define	NO_GNUSTEP	0
+#endif
+
+/* Check consistency of definitions for system compatibility.
+ */
+#if	defined(STRICT_OPENSTEP)
+#  define	GS_OPENSTEP_V	 10000
+#  undef	NO_GNUSTEP
+#  define	NO_GNUSTEP	1
+#elif	defined(STRICT_MACOS_X)
+#  define	GS_OPENSTEP_V	100600
+#  undef	NO_GNUSTEP
+#  define	NO_GNUSTEP	1
+#endif
+
+/* Define the GS_OSX_ADJUST() macro to adjust OSX style version macros
+ * to GNUstep style version macros.
+ */
+#define	GS_OSX_ADJUST(V) ((V) >= 10000 ? (V) : ((V)/100*10000 + (V)%100*10))
+
+/* Define OSX compatibility version macros if necessary.
+ */
+#if     !defined(MAC_OS_X_VERSION_10_0)
+#define	MAC_OS_X_VERSION_10_0	1000
+#define	MAC_OS_X_VERSION_10_1	1010
+#define	MAC_OS_X_VERSION_10_2	1020
+#define	MAC_OS_X_VERSION_10_3	1030
+#define	MAC_OS_X_VERSION_10_4	1040
+#define	MAC_OS_X_VERSION_10_5	1050
+#define	MAC_OS_X_VERSION_10_6	1060
+#define	MAC_OS_X_VERSION_10_7	1070
+#define	MAC_OS_X_VERSION_10_8	1080
+#define	MAC_OS_X_VERSION_10_9	1090
+#define MAC_OS_X_VERSION_10_10	1100
+#define MAC_OS_X_VERSION_10_11	1110
+#define MAC_OS_X_VERSION_10_12	1120
+#define MAC_OS_X_VERSION_10_13	1130
+#define MAC_OS_X_VERSION_10_14	1140
+#endif	/* MAC_OS_X_VERSION_10_0 */
+
+/* Allow MAC_OS_X_VERSION_MAX_ALLOWED to be used in place of GS_OPENSTEP_V
+ * if GS_OPENSTEP_V is not defined.
+ */
+#ifndef	GS_OPENSTEP_V
+#ifdef	MAC_OS_X_VERSION_MAX_ALLOWED
+#define	GS_OPENSTEP_V	GS_OSX_ADJUST(MAC_OS_X_VERSION_MAX_ALLOWED)
+#endif	/* MAC_OS_X_VERSION_MAX_ALLOWED */
+#endif	/* GS_OPENSTEP_V */
+
+/*
+ * NB. The version values below must be integers ... by convention these are
+ * made up of two digits each for major, minor and subminor version numbers
+ * (ie each is in the range 00 to 99 though a leading zero in the major
+ * number is not permitted).
+ * So for a MacOS-X 10.3.9 release the version number would be 100309
+ *
+ * You may define GS_GNUSTEP_V or GS_OPENSTEP_V to ensure that your
+ * program only 'sees' the specified varsion of the API.
+ */
+
+/**
+ * <p>Macro to check a defined GNUstep version number (GS_GNUSTEP_V) against
+ * the supplied arguments.  Returns true if no GNUstep version is specified,
+ * or if ADD &lt;= version &lt; REM, where ADD is the version
+ * number at which a feature guarded by the macro was introduced and
+ * REM is the version number at which it was removed.
+ * </p>
+ * <p>The version number arguments are six digit integers where the first
+ * two digits are the major version number, the second two are the minor
+ * version number and the last two are the subminor number (all left padded
+ * with a zero where necessary).  However, for convenience you can also
+ * use the predefined constants ...
+ * <ref type="macro" id="GS_API_NONE">GS_API_NONE</ref>,
+ * <ref type="macro" id="GS_API_LATEST">GS_API_LATEST</ref>,
+ * </p>
+ * <p>Also see <ref type="macro" id="OS_API_VERSION">OS_API_VERSION</ref>
+ * </p>
+ * <p>NB. If you are changing the API (eg adding a new feature) you need
+ * to control the visibility io the new header file code using<br />
+ * <code>#if GS_API_VERSION(ADD,GS_API_LATEST)</code><br />
+ * where <code>ADD</code> is the version number of the next minor
+ * release after the most recent one.<br />
+ * As a general principle you should <em>not</em> change the API with
+ * changing subminor version numbers ... as that tends to confuse
+ * people (though Apple has sometimes done it).
+ * </p>
+ */
+#define	GS_API_VERSION(ADD,REM) \
+  (!defined(GS_GNUSTEP_V) || (GS_GNUSTEP_V >= ADD && GS_GNUSTEP_V < REM))
+
+/**
+ * <p>Macro to check a defined OpenStep/OPENSTEP/MacOS-X version against the
+ * supplied arguments.  Returns true if no version is specified, or if
+ * ADD &lt;= version &lt; REM, where ADD is the version
+ * number at which a feature guarded by the macro was introduced and
+ * REM is the version number at which it was removed.
+ * </p>
+ * <p>The version number arguments are six digit integers where the first
+ * two digits are the major version number, the second two are the minor
+ * version number and the last two are the subminor number (all left padded
+ * with a zero where necessary).  However, for convenience you can also
+ * use any of several predefined constants ...
+ * <ref type="macro" id="GS_API_NONE">GS_API_NONE</ref>,
+ * <ref type="macro" id="GS_API_LATEST">GS_API_LATEST</ref>,
+ * <ref type="macro" id="GS_API_OSSPEC">GS_API_OSSPEC</ref>,
+ * <ref type="macro" id="GS_API_OPENSTEP">GS_API_OPENSTEP</ref>,
+ * <ref type="macro" id="GS_API_MACOSX">GS_API_MACOSX</ref>
+ * </p>
+ * <p>Also see <ref type="macro" id="GS_API_VERSION">GS_API_VERSION</ref>
+ * </p>
+ * <p>For OSX compatibility, this macro also supports the use of Apple's
+ * symbolic constants for version numbering.  Their contants are currently
+ * four digit values (two digits for the major version, one for the minor,
+ * and one for the subminor). 
+ * </p>
+ * <p>The Apple compatibility version macros are currently:
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_0">MAC_OS_X_VERSION_10_0</ref>,
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_1">MAC_OS_X_VERSION_10_1</ref>,
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_2">MAC_OS_X_VERSION_10_2</ref>,
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_3">MAC_OS_X_VERSION_10_3</ref>,
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_4">MAC_OS_X_VERSION_10_4</ref>,
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_5">MAC_OS_X_VERSION_10_5</ref>,
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_6">MAC_OS_X_VERSION_10_6</ref>,
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_7">MAC_OS_X_VERSION_10_7</ref>,
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_8">MAC_OS_X_VERSION_10_8</ref>
+ * <ref type="macro" id="MAC_OS_X_VERSION_10_9">MAC_OS_X_VERSION_10_9</ref>
+ * </p>
+ */
+#define	OS_API_VERSION(ADD,REM) \
+  (!defined(GS_OPENSTEP_V) \
+  || (GS_OPENSTEP_V>=GS_OSX_ADJUST(ADD) && GS_OPENSTEP_V<GS_OSX_ADJUST(REM)))
+
+/**
+ * A constant which is the lowest possible version number (0) so that
+ * when used as the removal version (second argument of the GS_API_VERSION
+ * or OS_API_VERSION macro) represents a feature which is not present in
+ * any version.<br />
+ * eg.<br />
+ * #if <ref type="macro" id="OS_API_VERSION">OS_API_VERSION</ref>
+ * (GS_API_NONE, GS_API_NONE)<br />
+ * denotes  code not present in OpenStep/OPENSTEP/MacOS-X
+ */
+#define	GS_API_NONE	     0
+
+/**
+ * A constant to represent a feature which is still present in the latest
+ * version.  This is the highest possible version number.<br />
+ * eg.<br />
+ * #if <ref type="macro" id="OS_API_VERSION">OS_API_VERSION</ref>
+ * (GS_API_MACOSX, GS_API_LATEST)<br />
+ * denotes code present from the initial MacOS-X version onwards.
+ */
+#define	GS_API_LATEST	999999
+
+/**
+ * The version number of the initial OpenStep specification.<br />
+ * eg.<br />
+ * #if <ref type="macro" id="OS_API_VERSION">OS_API_VERSION</ref>
+ * (GS_API_OSSPEC, GS_API_LATEST)<br />
+ * denotes code present from the OpenStep specification onwards.
+ */
+#define	GS_API_OSSPEC	 10000
+
+/**
+ * The version number of the first OPENSTEP implementation.<br />
+ * eg.<br />
+ * #if <ref type="macro" id="OS_API_VERSION">OS_API_VERSION</ref>
+ * (GS_API_OPENSTEP, GS_API_LATEST)<br />
+ * denotes code present from the initial OPENSTEP version onwards.
+ */
+#define	GS_API_OPENSTEP	 40000
+
+/**
+ * The version number of the first MacOS-X implementation.<br />
+ * eg.<br />
+ * #if <ref type="macro" id="OS_API_VERSION">OS_API_VERSION</ref>
+ * (GS_API_MACOSX, GS_API_LATEST)<br />
+ * denotes code present from the initial MacOS-X version onwards.
+ */
+#define	GS_API_MACOSX	100000
+
+/* Allow OSX code comparing MAC_OS_X_VERSION_MAX_ALLOWED with a specific
+ * version to see if that version is allowed, to always have it allowed
+ * on GNUstep.
+ */
+#ifndef	MAC_OS_X_VERSION_MAX_ALLOWED
+#define	MAC_OS_X_VERSION_MAX_ALLOWED    GS_API_LATEST
+#endif  /* MAC_OS_X_VERSION_MAX_ALLOWED */
+
+
+#if	defined(GNUSTEP_BASE_INTERNAL)
+#include "GNUstepBase/GSConfig.h"
+#else
+#include "GSConfig.h"
+#endif
+
+
+#if defined(__GNUC__) && defined(__GNUC_MINOR__) && !defined(__clang__)
+#  define GS_GCC_MINREQ(maj, min) \
+  ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
+#else
+#  define GS_GCC_MINREQ(maj, min) 0
+#endif
+
+#if defined(__clang__)
+#  define GS_CLANG_MINREQ(maj, min) \
+  ((__clang_major__ << 16) + __clang_minor__ >= ((maj) << 16) + (min))
+#else
+#  define GS_CLANG_MINREQ(maj, min) 0
+#endif
+
+/* Attribute definitions for attributes which may or may not be supported
+ * depending on the compiler being used.
+ * NB we currently expect gcc to be version 4 or later.
+ *
+ * The definition should be of the form GS_XXX_CONTEXT where XXX is the
+ * name of the attribute and CONTEXT is one of FUNC, METH, or IVAR
+ * depending on where the attribute can be applied.
+ */
+
+#if defined(__clang__) || GS_GCC_MINREQ(3,1)
+#  define GS_DEPRECATED_FUNC __attribute__ ((deprecated))
+#else
+#  define GS_DEPRECATED_FUNC
+#endif
+
+#define GS_UNUSED_ARG __attribute__((unused))
+
+#define GS_UNUSED_FUNC __attribute__((unused))
+
+// FIXME ... what version of gcc?
+#if __clang__
+#  define GS_UNUSED_IVAR __attribute__((unused))
+#else
+#  define GS_UNUSED_IVAR 
+#endif
+
+
+
+#ifndef __has_feature
+#define __has_feature(x) 0
+#endif
+
+/* The following is for deciding whether private instance variables
+ * should be visible ... if we are building with a compiler which
+ * does not define __has_feature then we know we don't have non-fragile
+ * ivar support.
+ * In the header we bracket instance variable declarations in a
+ * '#if	GS_EXPOSE(classname) ... #endif' sequence, so that the variables
+ * will not be visible to code which uses the library.
+ * In the source file we define EXPOSE_classname_IVARS to be 1
+ * before including the header, so that the ivars are always available
+ * in the class source itsself
+ */
+
+#if	GS_MIXEDABI
+#  undef	GS_NONFRAGILE
+#  define	GS_NONFRAGILE	0	/* Mixed is treated as fragile */
+#else
+#  if (__has_feature(objc_nonfragile_abi))
+#    if	!GS_NONFRAGILE
+#      if	defined(GNUSTEP_BASE_INTERNAL)
+#        error "You are building gnustep-base using the objc-nonfragile-abi but your gnustep-base was not configured to use it."
+#      endif
+#    endif
+#  else
+#    if	GS_NONFRAGILE
+#      error "Your gnustep-base was configured for the objc-nonfragile-abi but you are not using it now."
+#    endif
+#  endif
+#endif
+
+#define	GS_EXPOSE(X)	(!GS_NONFRAGILE || defined(EXPOSE_##X##_IVARS))
+
+/* Static analyser macros: Provide annotations to help the analyser */
+#ifdef __clang__
+#  define GS_NORETURN_METHOD __attribute__((__noreturn__))
+#else
+#  define GS_NORETURN_METHOD
+#endif
+
+#ifndef NS_RETURNS_RETAINED
+#  if __has_feature(attribute_ns_returns_retained)
+#    define NS_RETURNS_RETAINED __attribute__((ns_returns_retained))
+#  else
+#    define NS_RETURNS_RETAINED
+#  endif
+#endif
+
+#ifndef NS_RETURNS_NOT_RETAINED
+#  if __has_feature(attribute_ns_returns_not_retained)
+#    define NS_RETURNS_NOT_RETAINED __attribute__((ns_returns_not_retained))
+#  else
+#    define NS_RETURNS_NOT_RETAINED
+#  endif
+#endif
+
+#ifndef NS_CONSUMED
+#  if __has_feature(attribute_ns_consumed)
+#    define NS_CONSUMED __attribute__((ns_consumed))
+#  else
+#    define NS_CONSUMED
+#  endif
+#endif
+
+
+#ifndef NS_CONSUMES_SELF
+#  if __has_feature(attribute_ns_consumes_self)
+#    define NS_CONSUMES_SELF __attribute__((ns_consumes_self))
+#  else
+#    define NS_CONSUMES_SELF
+#  endif
+#endif
+
+#if defined(__clang__) && defined(__OBJC__)
+static inline void gs_consumed(id NS_CONSUMED o) GS_UNUSED_FUNC;
+static inline void gs_consumed(id NS_CONSUMED GS_UNUSED_ARG o) { return; }
+#define	GS_CONSUMED(O)	gs_consumed(O);
+#else
+#define	GS_CONSUMED(O)
+#endif
+
+/* Include the appropriate header for ObjC2 blocks support if it is in use.
+ *
+ * FIXME: "OBJC2RUNTIME" is set to "1" if the runtime supports the ObjC2
+ * runtime API, which is unrelated to whether the compiler has blocks
+ * support or not.
+ */
+#if __has_feature(blocks)
+#  if	OBJC2RUNTIME
+#    if defined(__APPLE__)
+#      include <Block.h>
+#    else
+#      include <objc/blocks_runtime.h>
+#    endif
+#  else
+#    include <ObjectiveC2/blocks_runtime.h>
+#  endif
+#endif
+
+/* Attribute definition for root classes, annotates the interface declaration
+ * of the class.
+ */
+#ifndef GS_ROOT_CLASS
+#  if GS_HAVE_OBJC_ROOT_CLASS_ATTR || __has_feature(attribute_objc_root_class)
+#    define GS_ROOT_CLASS __attribute__((objc_root_class))
+#  else
+#    define GS_ROOT_CLASS
+#  endif
+#endif
+
+
+
+#if	defined(GNUSTEP_WITH_DLL)
+
+#if BUILD_libgnustep_base_DLL
+#
+# if defined(__MINGW__)
+  /* On Mingw, the compiler will export all symbols automatically, so
+   * __declspec(dllexport) is not needed.
+   */
+#  define GS_EXPORT  extern
+#  define GS_DECLARE
+# else
+#  define GS_EXPORT  __declspec(dllexport)
+#  define GS_DECLARE __declspec(dllexport)
+# endif
+#else
+#  define GS_EXPORT  extern __declspec(dllimport)
+#  define GS_DECLARE __declspec(dllimport)
+#endif
+
+#else /* GNUSTEP_WITH[OUT]_DLL */
+
+#  define GS_EXPORT extern
+#  define GS_DECLARE
+
+#endif
+
+
+/* Attribute macros compatible with Apple.
+ */
+
+#ifndef NS_FORMAT_ARGUMENT
+#if defined(__clang__) || GS_GCC_MINREQ(4,2)
+#  define NS_FORMAT_ARGUMENT(A) __attribute__((format_arg(A)))
+#else
+#  define NS_FORMAT_ARGUMENT(F,A) 
+#endif
+#endif
+
+// FIXME ... what version of gcc?
+#ifndef NS_FORMAT_FUNCTION
+#if __clang__
+#  define NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A)))
+#else
+#  define NS_FORMAT_FUNCTION(F,A) 
+#endif
+#endif
+
+#ifndef NS_REQUIRES_NIL_TERMINATION
+#define NS_REQUIRES_NIL_TERMINATION __attribute__((sentinel))
+#endif
+
+// FIXME ... what exact version of clang and gcc?
+#ifndef UNAVAILABLE_ATTRIBUTE
+#if defined(__clang__) || GS_GCC_MINREQ(4,0)
+#  define UNAVAILABLE_ATTRIBUTE __attribute__((unavailable))
+#else
+#  define UNAVAILABLE_ATTRIBUTE
+#endif
+#endif
+
+/* Check if compiler supports @optional in protocols
+ */
+#if defined(__clang__) || GS_GCC_MINREQ(4,6)
+#  define GS_PROTOCOLS_HAVE_OPTIONAL 1
+#else
+#  define GS_PROTOCOLS_HAVE_OPTIONAL 0
+#endif
+
+/* Check if compiler supports declared properties
+ */
+#if defined(__clang__) || GS_GCC_MINREQ(4,6)
+#  define GS_HAS_DECLARED_PROPERTIES 1
+#else
+#  define GS_HAS_DECLARED_PROPERTIES 0
+#endif
+
+#endif /* __GNUSTEP_GSVERSIONMACROS_H_INCLUDED_ */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GNUstep.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GNUstep.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GNUstep.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GNUstep.h	(revision 278653)
@@ -0,0 +1,418 @@
+/* GNUstep.h - macros to make easier to port gnustep apps to macos-x
+   Copyright (C) 2001 Free Software Foundation, Inc.
+
+   Written by: Nicola Pero <n.pero@mi.flashnet.it>
+   Date: March, October 2001
+   
+   This file is part of GNUstep.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+   
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/ 
+
+#ifndef __GNUSTEP_GNUSTEP_H_INCLUDED_
+#define __GNUSTEP_GNUSTEP_H_INCLUDED_
+
+/* The contents of this file are designed to be usable with either
+ * GNUstep-base or MacOS-X Foundation.
+ */
+
+#ifndef __has_feature
+#  define __has_feature(x) 0
+#endif
+
+/*
+ * __has_extension has slightly different semantics from __has_feature.
+ * It evaluates to true if the feature is supported by by clang for the
+ * current compilation unit (language and -f switches), regardless of 
+ * whether it is part of the language standard or just a (non-standard)
+ * extension.
+ */
+#ifndef __has_extension
+#  define __has_extension(x) __has_feature(x)
+#endif
+
+/*
+ * __has_attribute is the equivalent to __has_feature and __has_extension
+ * for GNU-style attributes.
+ */
+#ifndef __has_attribute
+#  define __has_attribute(x) 0
+#endif
+
+#if	__has_feature(objc_arc)
+
+#ifndef	RETAIN
+#define	RETAIN(object)		        (object)
+#endif
+#ifndef	RELEASE
+#define	RELEASE(object)		
+#endif
+#ifndef	AUTORELEASE
+#define	AUTORELEASE(object)	        (object)
+#endif
+
+#ifndef	TEST_RETAIN
+#define	TEST_RETAIN(object)	        (object)
+#endif
+#ifndef	TEST_RELEASE
+#define	TEST_RELEASE(object)
+#endif
+#ifndef	TEST_AUTORELEASE
+#define	TEST_AUTORELEASE(object)	(object)
+#endif
+
+#ifndef	ASSIGN
+#define	ASSIGN(object,value)	        object = (value)
+#endif
+#ifndef	ASSIGNCOPY
+#define	ASSIGNCOPY(object,value)	object = [(value) copy]
+#endif
+#ifndef	DESTROY
+#define	DESTROY(object) 	        object = nil
+#endif
+
+#define	IF_NO_GC(X)	
+
+#ifndef ENTER_POOL
+#define ENTER_POOL                      @autoreleasepool{do{
+#endif
+
+#ifndef LEAVE_POOL
+#define LEAVE_POOL                      }while(0);}
+#endif
+
+#ifndef DEALLOC
+#define DEALLOC
+#endif
+
+#else
+
+#ifndef	RETAIN
+/**
+ *	Basic retain operation ... calls [NSObject-retain]<br />
+ *	Deprecated ... pointless on modern processors.
+ *	Simply call the -retain method.
+ */
+#define	RETAIN(object)		[(object) retain]
+#endif
+
+#ifndef	RELEASE
+/**
+ *	Basic release operation ... calls [NSObject-release]<br />
+ *	Deprecated ... pointless on modern processors.
+ *	Simply call the -release method.
+ */
+#define	RELEASE(object)		[(object) release]
+#endif
+
+#ifndef	AUTORELEASE
+/**
+ *	Basic autorelease operation ... calls [NSObject-autorelease]<br />
+ *	Deprecated ... pointless on modern processors.
+ *	Simply call the -autorelease method.
+ */
+#define	AUTORELEASE(object)	[(object) autorelease]
+#endif
+
+#ifndef	TEST_RETAIN
+/**
+ *	Tested retain - only invoke the
+ *	objective-c method if the receiver is not nil.<br />
+ *	Deprecated ... pointless on modern processors.
+ *	Simply call the -retain method.
+ */
+#define	TEST_RETAIN(object)	({\
+id __object = (object); (__object != nil) ? [__object retain] : nil; })
+#endif
+
+#ifndef	TEST_RELEASE
+/**
+ *	Tested release - only invoke the
+ *	objective-c method if the receiver is not nil.<br />
+ *	Deprecated ... pointless on modern processors.
+ *	Simply call the -release method.
+ */
+#define	TEST_RELEASE(object)	({\
+id __object = (object); if (__object != nil) [__object release]; })
+#endif
+
+#ifndef	TEST_AUTORELEASE
+/**
+ *	Tested autorelease - only invoke the
+ *	objective-c method if the receiver is not nil.<br />
+ *	Deprecated ... pointless on modern processors.
+ *	Simply call the -autorelease method.
+ */
+#define	TEST_AUTORELEASE(object)	({\
+id __object = (object); (__object != nil) ? [__object autorelease] : nil; })
+#endif
+
+#ifndef	ASSIGN
+/**
+ *	ASSIGN(object,value) assigns the value to the object with
+ *	appropriate retain and release operations.<br />
+ *	Use this to avoid retain/release errors.
+ */
+#define	ASSIGN(object,value)	({\
+  id __object = object; \
+  object = [(value) retain]; \
+  [__object release]; \
+})
+#endif
+
+#ifndef	ASSIGNCOPY
+/**
+ *	ASSIGNCOPY(object,value) assigns a copy of the value to the object
+ *	with release of the original.<br />
+ *	Use this to avoid retain/release errors.
+ */
+#define	ASSIGNCOPY(object,value)	({\
+  id __object = object; \
+  object = [(value) copy];\
+  [__object release]; \
+})
+#endif
+
+#ifndef	DESTROY
+/**
+ *	DESTROY() is a release operation which also sets the variable to be
+ *	a nil pointer for tidiness - we can't accidentally use a DESTROYED
+ *	object later.  It also makes sure to set the variable to nil before
+ *	releasing the object - to avoid side-effects of the release trying
+ *	to reference the object being released through the variable.
+ */
+#define	DESTROY(object) 	({ \
+  id __o = object; \
+  object = nil; \
+  [__o release]; \
+})
+#endif
+
+#define	IF_NO_GC(X)	X
+
+#ifndef ENTER_POOL
+/**
+ *	ENTER_POOL creates an autorelease pool and places subsequent code
+ *	in a do/while loop (executed only once) which can be broken out of
+ *	to reach the point when the pool is drained.<br />
+ *	The block must be terminated with a corresponding LEAVE_POOL.<br />
+ *	You should not return from such a block of code (to do so could
+ *	leak an autorelease pool and give objects a longer lifetime than
+ *	they ought to have.  If you wish to leave the block of code early,
+ *	you may do so using a 'break' statement.
+ */
+#define ENTER_POOL      {NSAutoreleasePool *_lARP=[NSAutoreleasePool new];do{
+#endif
+
+#ifndef LEAVE_POOL
+/**
+ *	LEAVE_POOL terminates a block of code started with ENTER_POOL.
+ */
+#define LEAVE_POOL      }while(0);[_lARP drain];}
+#endif
+
+#ifndef DEALLOC
+/**
+ *	DEALLOC calls the superclass implementation of dealloc, unless
+ *	ARC is in use (in which case it does nothing).
+ */
+#define DEALLOC         [super dealloc];
+#endif
+#endif
+
+#ifndef	CREATE_AUTORELEASE_POOL
+/** DEPRECATED ... use ENTER_POOL and LEAVE_POOL
+ */
+#define	CREATE_AUTORELEASE_POOL(X)	\
+  NSAutoreleasePool *X = [NSAutoreleasePool new]
+#endif
+
+#ifndef RECREATE_AUTORELEASE_POOL
+/** DEPRECATED ... use ENTER_POOL and LEAVE_POOL
+ */
+#define RECREATE_AUTORELEASE_POOL(X)  \
+  DESTROY(X);\
+  X = [NSAutoreleasePool new]
+#endif
+
+
+/**
+ * <p>
+ *   This function (macro) is a GNUstep extension.
+ * </p>
+ * <p>
+ *   <code>_(@"My string to translate")</code>
+ * </p>
+ * <p>
+ *   is basically equivalent to
+ * </p>
+ * <p>
+ *   <code>NSLocalizedString(@"My string to translate", @"")</code>
+ * </p>
+ * <p>
+ * It is useful when you need to translate an application
+ * very quickly, as you just need to enclose all strings
+ * inside <code>_()</code>.  But please note that when you
+ * use this macro, you are not taking advantage of comments
+ * for the translator, so consider using
+ * <code>NSLocalizedString</code> instead when you need a
+ * comment.
+ * </p>
+ * <p>You may define GS_LOCALISATION_BUNDLE_ID to the bundle identifier
+ * of the bundle which is to provide the localisation information.<br />
+ * This can be used when compiling a single file by specifying something like
+ * '-D GS_LOCALISATION_BUNDLE_ID=$(FRAMEWORK_NAME)' in your make file.<br />
+ * If this is not defined, the localisation is provided by your application's
+ * main bundle exactly like the NSLocalizedString function.
+ * </p>
+ * <p>Alternatively you may define GS_LOCALISATION_BUNDLE to be the bundle
+ * to be used to prvide the localisation information.
+ * </p>
+ */
+# define _(X) \
+  [GS_LOCALISATION_BUNDLE localizedStringForKey: (X) value: @"" table: nil]
+
+#if	!defined(GS_LOCALISATION_BUNDLE)
+# if	defined(GS_LOCALISATION_BUNDLE_ID)
+#   define	GS_LOCALISATION_BUNDLE	[NSBundle bundleWithIdentifier: \
+  GS_LOCALISATION_BUNDLE_ID]
+# else
+#   define	GS_LOCALISATION_BUNDLE	[NSBundle mainBundle]
+# endif
+#endif
+
+
+ 
+/**
+ * <p>
+ *   This function (macro) is a GNUstep extension.
+ * </p>
+ * <p>
+ *   <code>__(@"My string to translate")</code>
+ * </p>
+ * <p>
+ *   is exactly the same as
+ * </p>
+ * <p>
+ *   <code>GSLocalizedStaticString(@"My string to translate", @"")</code>
+ * </p>
+ * <p>
+ *   It is useful when you need to translate an application very
+ *   quickly.  You would use it as follows for static strings:
+ * </p>
+ * <p>
+ *  <code>
+ *    NSString *message = __(@"Hello there");
+ *    ... more code ...
+ *    NSLog (_(messages));
+ *  </code>
+ * </p>
+ * <p>
+ *   But please note that when you use this macro, you are not
+ *   taking advantage of comments for the translator, so
+ *   consider using <code>GSLocalizedStaticString</code>
+ *   instead when you need a comment.
+ * </p>
+ */
+#define __(X) X
+
+/* The better way for a static string, with a comment - use as follows -
+ *
+ * static NSString *string = GSLocalizedStaticString (@"New Game",
+ *                                                    @"Menu Option");
+ *
+ * NSLog (_(string));
+ *
+ * If you need anything more complicated than this, please initialize
+ * the static strings manually.
+ */
+
+/**
+ * <p>
+ *   This function (macro) is a GNUstep extensions, and it is used
+ *   to localize static strings.  Here is an example of a static
+ *   string:
+ * </p>
+ * <p>
+ *   <code>
+ *     NSString *message = @"Hi there";
+ *     ... some code ...
+ *     NSLog (message);
+ *  </code>
+ * </p>
+ * <p>
+ *   This string can not be localized using the standard
+ *   openstep functions/macros.  By using this gnustep extension,
+ *   you can localize it as follows:
+ * </p>
+ * <p>
+ *   <code>
+ *     NSString *message = GSLocalizedStaticString (@"Hi there",
+ *       @"Greeting");
+ * 
+ *     ... some code ...
+ * 
+ *     NSLog (NSLocalizedString (message, @""));
+ *  </code>
+ * </p>
+ * <p>
+ *   When the tools generate the
+ *   <code>Localizable.strings</code> file from the source
+ *   code, they will ignore the <code>NSLocalizedString</code>
+ *   call while they will extract the string (and the comment)
+ *   to localize from the <code>GSLocalizedStaticString</code>
+ *   call.
+ * </p>
+ * <p>
+ *   When the code is compiled, instead, the
+ *   <code>GSLocalizedStaticString</code> call is ignored (discarded,
+ *   it is a macro which simply expands to <code>key</code>), while
+ *   the <code>NSLocalizedString</code> will actually look up the
+ *   string for translation in the <code>Localizable.strings</code>
+ *   file.
+ * </p>
+ * <p>
+ *   Please note that there is currently no macro/function to
+ *   localize static strings using different tables.  If you
+ *   need that functionality, you have either to prepare the
+ *   localization tables by hand, or to rewrite your code in
+ *   such a way as not to use static strings.
+ * </p>
+ */
+#define GSLocalizedStaticString(key, comment) key
+
+/**
+ * To be used inside a method for making sure that a range does not specify
+ * anything outside the size of an array/string.  Raises exception if range
+ * extends beyond [0,size]. Size must be an unsigned integer (NSUInteger).
+ */
+#define GS_RANGE_CHECK(RANGE, SIZE) \
+  if (RANGE.location > (NSUInteger)SIZE \
+    || RANGE.length > ((NSUInteger)SIZE - RANGE.location)) \
+    [NSException raise: NSRangeException format: @"in %s, range { %"\
+      PRIuPTR ", %" PRIuPTR " } extends beyond size (%" PRIuPTR ")", \
+      GSNameFromSelector(_cmd), RANGE.location, RANGE.length, (NSUInteger)SIZE]
+
+/** Checks whether INDEX is strictly less than OVER (within C array space).
+ * INDEX and OVER must be unsigned integers (NSUInteger).
+ */
+#define CHECK_INDEX_RANGE_ERROR(INDEX, OVER) \
+if ((NSUInteger)INDEX >= (NSUInteger)OVER) \
+  [NSException raise: NSRangeException \
+    format: @"in %s, index %" PRIuPTR " is out of range", \
+    GSNameFromSelector(_cmd), (NSUInteger)INDEX]
+
+#endif /* __GNUSTEP_GNUSTEP_H_INCLUDED_ */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSNumber+GNUstepBase.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSNumber+GNUstepBase.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSNumber+GNUstepBase.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/NSNumber+GNUstepBase.h	(revision 278653)
@@ -0,0 +1,56 @@
+/** Declaration of extension methods for base additions
+
+   Copyright (C) 2003-2010 Free Software Foundation, Inc.
+
+   Written by:  Richard Frith-Macdonald <rfm@gnu.org>
+   and:         Adam Fedor <fedor@gnu.org>
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+*/
+
+#ifndef	INCLUDED_NSNumber_GNUstepBase_h
+#define	INCLUDED_NSNumber_GNUstepBase_h
+
+#import "GSVersionMacros.h"
+#import "../Foundation/NSValue.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+#if	OS_API_VERSION(GS_API_NONE,GS_API_LATEST)
+
+@interface NSNumber(GNUstepBase)
+/**
+ * Parses string as a <code>double</code>, <code>int</code>, or <code>unsigned
+ * int</code> depending on what characters are present.  Uses
+ * <code>atof</code> and <code>atoi</code> which don't report errors, so be
+ * careful if the string might contain an invalid value.
+ */
++ (NSValue*) valueFromString: (NSString *)string;
+@end
+
+#endif	/* OS_API_VERSION */
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif	/* INCLUDED_NSNumber_GNUstepBase_h */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSBlocks.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSBlocks.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSBlocks.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/GNUstepBase/GSBlocks.h	(revision 278653)
@@ -0,0 +1,145 @@
+/** Definitions for block support for GNUStep
+   Copyright (C) 2011 Free Software Foundation, Inc.
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+   */
+
+#ifndef __GSBlocks_h_GNUSTEP_BASE_INCLUDE
+#define __GSBlocks_h_GNUSTEP_BASE_INCLUDE
+
+/* Define the has_feature pseudo-macro for GCC. */
+#ifndef __has_feature
+#define __has_feature(x) 0
+#endif
+
+#ifndef GCC_VERSION
+#define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)
+#endif
+
+#if __has_feature(blocks)
+
+#define BLOCK_SCOPE __block
+/**
+ * Defines a block type.  Will work whether or not the compiler natively
+ * supports blocks.
+ */
+#define DEFINE_BLOCK_TYPE(name, retTy, argTys, ...) \
+typedef retTy(^name)(argTys, ## __VA_ARGS__)
+
+#define DEFINE_BLOCK_TYPE_NO_ARGS(name, retTy) \
+typedef retTy(^name)()
+
+/**
+ * Calls a block.  Works irrespective of whether the compiler supports blocks.
+ */
+#define CALL_BLOCK(block, args, ...) block(args, ## __VA_ARGS__)
+
+/**
+ * Calls a block without arguments.
+ */
+#define CALL_BLOCK_NO_ARGS(block) block()
+#else
+
+/* Fall-back versions for when the compiler doesn't have native blocks support.
+ */
+#if (GCC_VERSION >= 3000)
+
+#define DEFINE_BLOCK_TYPE(name, retTy, argTys, ...) \
+  typedef struct {\
+    void *isa;\
+    int flags;\
+    int reserved;\
+    retTy (*invoke)(void*, argTys, ## __VA_ARGS__);\
+  } *name
+
+#define DEFINE_BLOCK_TYPE_NO_ARGS(name, retTy) \
+  typedef struct {\
+    void *isa;\
+    int flags;\
+    int reserved;\
+    retTy (*invoke)(void*);\
+  } *name
+
+#define CALL_BLOCK(block, args, ...) block->invoke(block, args, ## __VA_ARGS__)
+
+#define CALL_BLOCK_NO_ARGS(block) block->invoke(block)
+#define BLOCK_SCOPE
+
+#else /* GCC_VERSION >= 3000 */
+
+#define DEFINE_BLOCK_TYPE(name, retTy, argTys...) \
+  typedef struct {\
+    void *isa;\
+    int flags;\
+    int reserved;\
+    retTy (*invoke)(void*, argTys);\
+  } *name
+
+#define DEFINE_BLOCK_TYPE_NO_ARGS(name, retTy) \
+  typedef struct {\
+    void *isa;\
+    int flags;\
+    int reserved;\
+    retTy (*invoke)(void*);\
+  } *name
+
+
+#define CALL_BLOCK(block, args...) block->invoke(block, args)
+#define CALL_BLOCK_NO_ARGS(block) block->invoke(block)
+#define BLOCK_SCOPE
+#endif /* GCC_VERSION >= 3000 */
+
+#endif /* __has_feature(blocks) */
+
+#if __has_include(<objc/blocks_runtime.h>)
+#  include <objc/blocks_runtime.h>
+#else
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * _Block_copy and _Block_release are weakly imported, but can be assumed
+ * to be available whenever a feature using blocks is accessed
+ * by an application.
+ */
+
+/* weak attributed supported only with ELF, MINGW is COFF */
+#ifndef __MINGW32__
+
+void *_Block_copy(const void *) __attribute__((weak));
+void _Block_release(const void *) __attribute__((weak));
+
+#endif /* __MINGW32__ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#ifndef Block_copy
+#  define Block_copy(x) ((__typeof(x))_Block_copy((const void *)(x)))
+#endif
+#ifndef Block_release
+#  define Block_release(x) _Block_release((const void *)(x))
+#endif
+
+#endif /* __has_include(<objc/blocks_runtime.h>) */
+#endif /* __GSBlocks_h_GNUSTEP_BASE_INCLUDE */
+
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSGeometry.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSGeometry.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSGeometry.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSGeometry.h	(revision 278653)
@@ -0,0 +1,609 @@
+/* Interface for NSGeometry routines for GNUStep
+ * Copyright (C) 1995 Free Software Foundation, Inc.
+ * 
+ * Written by:  Adam Fedor <fedor@boulder.colorado.edu>
+ * Date: 1995,199
+ * 
+ * This file is part of the GNUstep Base Library.
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02111 USA.
+ */ 
+
+#ifndef __NSGeometry_h_GNUSTEP_BASE_INCLUDE
+#define __NSGeometry_h_GNUSTEP_BASE_INCLUDE
+#import	"../GNUstepBase/GSVersionMacros.h"
+
+#import <objc/objc.h>
+
+#import "NSString.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+/**** Type, Constant, and Macro Definitions **********************************/
+
+#ifndef MAX
+#define MAX(a,b) \
+       ({__typeof__(a) _MAX_a = (a); __typeof__(b) _MAX_b = (b);  \
+         _MAX_a > _MAX_b ? _MAX_a : _MAX_b; })
+#define	GS_DEFINED_MAX
+#endif
+
+#ifndef MIN
+#define MIN(a,b) \
+       ({__typeof__(a) _MIN_a = (a); __typeof__(b) _MIN_b = (b);  \
+         _MIN_a < _MIN_b ? _MIN_a : _MIN_b; })
+#define	GS_DEFINED_MIN
+#endif
+
+/**
+<example>{
+  CGFloat x;
+  CGFloat y;
+}</example>
+ <p>Represents a 2-d cartesian position.</p> */
+typedef struct _NSPoint NSPoint;
+struct _NSPoint
+{
+  CGFloat x;
+  CGFloat y;
+};
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+/** Array of NSPoint structs. */
+typedef NSPoint *NSPointArray;
+/** Pointer to NSPoint struct. */
+typedef NSPoint *NSPointPointer;
+#endif
+
+/**
+<example>{
+  CGFloat width;
+  CGFloat height;
+}</example>
+ <p>Floating point rectangle size.</p> */
+typedef struct _NSSize NSSize;
+struct _NSSize
+{
+  CGFloat width;
+  CGFloat height;
+};
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+/** Array of NSSize structs. */
+typedef NSSize *NSSizeArray;
+/** Pointer to NSSize struct. */
+typedef NSSize *NSSizePointer;
+#endif
+
+/**
+<example>{
+  NSPoint origin;
+  NSSize size;
+}</example>
+
+ <p>Rectangle.</p> */
+typedef struct _NSRect NSRect;
+struct _NSRect
+{
+  NSPoint origin;
+  NSSize size;
+};
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+/** Array of NSRect structs. */
+typedef NSRect *NSRectArray;
+/** Pointer to NSRect struct. */
+typedef NSRect *NSRectPointer;
+#endif
+
+enum
+{
+  NSMinXEdge = 0,
+  NSMinYEdge = 1,
+  NSMaxXEdge = 2,
+  NSMaxYEdge = 3
+};
+/** Sides of a rectangle.
+<example>
+{
+  NSMinXEdge,
+  NSMinYEdge,
+  NSMaxXEdge,
+  NSMaxYEdge
+}
+</example>
+ */
+typedef NSUInteger NSRectEdge;
+
+/**
+<example>{
+  CGFloat top;
+  CGFloat left;
+  CGFloat bottom;
+  CGFloat right;
+}</example>
+
+ <p>A description of the distance between the edges of two rectangles.</p> */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_7, GS_API_LATEST)
+typedef struct NSEdgeInsets {
+    CGFloat top;
+    CGFloat left;
+    CGFloat bottom;
+    CGFloat right;
+} NSEdgeInsets;
+#endif
+
+/** Point at 0,0 */
+static const NSPoint NSZeroPoint __attribute__((unused)) = {0.0,0.0};
+/** Zero-size rectangle at 0,0 */
+static const NSRect NSZeroRect __attribute__((unused)) = {{0.0,0.0},{0.0,0.0}};
+/** Zero size */
+static const NSSize NSZeroSize __attribute__((unused)) = {0.0,0.0};
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_7, GS_API_LATEST)
+/** Zero edge insets **/
+static const NSEdgeInsets NSEdgeInsetsZero __attribute__((unused))  = {0.0,0.0,0.0,0.0};
+#endif
+
+/**** Function Prototypes ****************************************************/
+
+/*
+ *	All but the most complex functions are declared static inline in this
+ *	header file so that they are maximally efficient.  In order to provide
+ *	true functions (for code modules that don't have this header) this
+ *	header is included in NSGeometry.m where the functions are no longer
+ *	declared inline.
+ */
+#ifdef	IN_NSGEOMETRY_M
+#define	GS_GEOM_SCOPE	extern
+#define GS_GEOM_ATTR	
+#else
+#define	GS_GEOM_SCOPE	static inline
+#define GS_GEOM_ATTR	__attribute__((unused))
+#endif
+
+/** Create Basic Structures... **/
+
+GS_GEOM_SCOPE NSPoint
+NSMakePoint(CGFloat x, CGFloat y) GS_GEOM_ATTR;
+
+/** Returns an NSPoint having x-coordinate X and y-coordinate Y. */
+GS_GEOM_SCOPE NSPoint
+NSMakePoint(CGFloat x, CGFloat y)
+{
+  NSPoint point;
+
+  point.x = x;
+  point.y = y;
+  return point;
+}
+
+GS_GEOM_SCOPE NSSize
+NSMakeSize(CGFloat w, CGFloat h) GS_GEOM_ATTR;
+
+/** Returns an NSSize having width w and height h. */
+GS_GEOM_SCOPE NSSize
+NSMakeSize(CGFloat w, CGFloat h)
+{
+  NSSize size;
+
+  size.width = w;
+  size.height = h;
+  return size;
+}
+
+GS_GEOM_SCOPE NSRect
+NSMakeRect(CGFloat x, CGFloat y, CGFloat w, CGFloat h) GS_GEOM_ATTR;
+
+/** Returns an NSRect having point of origin (x, y) and size {w, h}. */
+GS_GEOM_SCOPE NSRect
+NSMakeRect(CGFloat x, CGFloat y, CGFloat w, CGFloat h)
+{
+  NSRect rect;
+
+  rect.origin.x = x;
+  rect.origin.y = y;
+  rect.size.width = w;
+  rect.size.height = h;
+  return rect;
+}
+
+/** Constructs NSEdgeInsets. **/
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_7, GS_API_LATEST)
+GS_GEOM_SCOPE NSEdgeInsets
+NSEdgeInsetsMake(CGFloat top, CGFloat left,
+                 CGFloat bottom, CGFloat right) GS_GEOM_ATTR;
+
+GS_GEOM_SCOPE NSEdgeInsets
+NSEdgeInsetsMake(CGFloat top, CGFloat left, CGFloat bottom, CGFloat right)
+{
+  NSEdgeInsets edgeInsets;
+
+  edgeInsets.top = top;
+  edgeInsets.left = left;
+  edgeInsets.bottom = bottom;
+  edgeInsets.right = right;
+
+  return edgeInsets;
+}
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_10, GS_API_LATEST)
+/** Compares two edge insets for equality. **/
+GS_EXPORT BOOL
+NSEdgeInsetsEqual(NSEdgeInsets e1, NSEdgeInsets e2);
+#endif
+
+#endif
+
+/** Get a Rectangle's Coordinates... **/
+
+GS_GEOM_SCOPE CGFloat
+NSMaxX(NSRect aRect) GS_GEOM_ATTR;
+
+/** Returns the greatest x-coordinate value still inside aRect. */
+GS_GEOM_SCOPE CGFloat
+NSMaxX(NSRect aRect)
+{
+  return aRect.origin.x + aRect.size.width;
+}
+
+GS_GEOM_SCOPE CGFloat
+NSMaxY(NSRect aRect) GS_GEOM_ATTR;
+
+/** Returns the greatest y-coordinate value still inside aRect. */
+GS_GEOM_SCOPE CGFloat
+NSMaxY(NSRect aRect)
+{
+  return aRect.origin.y + aRect.size.height;
+}
+
+GS_GEOM_SCOPE CGFloat
+NSMidX(NSRect aRect) GS_GEOM_ATTR;
+
+/** Returns the x-coordinate of aRect's middle point. */
+GS_GEOM_SCOPE CGFloat
+NSMidX(NSRect aRect)
+{
+  return aRect.origin.x + (aRect.size.width / 2.0);
+}
+
+GS_GEOM_SCOPE CGFloat
+NSMidY(NSRect aRect) GS_GEOM_ATTR;
+
+/** Returns the y-coordinate of aRect's middle point. */
+GS_GEOM_SCOPE CGFloat
+NSMidY(NSRect aRect)
+{
+  return aRect.origin.y + (aRect.size.height / 2.0);
+}
+
+GS_GEOM_SCOPE CGFloat
+NSMinX(NSRect aRect) GS_GEOM_ATTR;
+
+/** Returns the least x-coordinate value still inside aRect. */
+GS_GEOM_SCOPE CGFloat
+NSMinX(NSRect aRect)
+{
+  return aRect.origin.x;
+}
+
+GS_GEOM_SCOPE CGFloat
+NSMinY(NSRect aRect) GS_GEOM_ATTR;
+
+/** Returns the least y-coordinate value still inside aRect. */
+GS_GEOM_SCOPE CGFloat
+NSMinY(NSRect aRect)
+{
+  return aRect.origin.y;
+}
+
+GS_GEOM_SCOPE CGFloat
+NSWidth(NSRect aRect) GS_GEOM_ATTR;
+
+/** Returns aRect's width. */
+GS_GEOM_SCOPE CGFloat
+NSWidth(NSRect aRect)
+{
+  return aRect.size.width;
+}
+
+GS_GEOM_SCOPE CGFloat
+NSHeight(NSRect aRect) GS_GEOM_ATTR;
+
+/** Returns aRect's height. */
+GS_GEOM_SCOPE CGFloat
+NSHeight(NSRect aRect)
+{
+  return aRect.size.height;
+}
+
+GS_GEOM_SCOPE BOOL
+NSIsEmptyRect(NSRect aRect) GS_GEOM_ATTR;
+
+/** Returns 'YES' iff the area of aRect is zero (i.e., iff either
+ * of aRect's width or height is negative or zero). */
+GS_GEOM_SCOPE BOOL
+NSIsEmptyRect(NSRect aRect)
+{
+  return ((NSWidth(aRect) > 0) && (NSHeight(aRect) > 0)) ? NO : YES;
+}
+
+/** Modify a Copy of a Rectangle... **/
+
+GS_GEOM_SCOPE NSRect
+NSOffsetRect(NSRect aRect, CGFloat dx, CGFloat dy) GS_GEOM_ATTR;
+
+/** Returns the rectangle obtained by translating aRect
+ * horizontally by dx and vertically by dy. */
+GS_GEOM_SCOPE NSRect
+NSOffsetRect(NSRect aRect, CGFloat dx, CGFloat dy)
+{
+  NSRect rect = aRect;
+
+  rect.origin.x += dx;
+  rect.origin.y += dy;
+  return rect;
+}
+
+GS_GEOM_SCOPE NSRect
+NSInsetRect(NSRect aRect, CGFloat dX, CGFloat dY) GS_GEOM_ATTR;
+
+/** Returns the rectangle obtained by moving each of aRect's
+ * horizontal sides inward by dy and each of aRect's vertical
+ * sides inward by dx.<br />
+ * NB. For MacOS-X compatability, this is permitted to return
+ * a rectanglew with nagative width or height, strange as that seems.
+ */
+GS_GEOM_SCOPE NSRect
+NSInsetRect(NSRect aRect, CGFloat dX, CGFloat dY)
+{
+  NSRect rect;
+
+  rect = NSOffsetRect(aRect, dX, dY);
+  rect.size.width -= (2 * dX);
+  rect.size.height -= (2 * dY);
+  return rect;
+}
+
+/** Divides aRect into two rectangles (namely slice and remainder) by
+ * "cutting" aRect---parallel to, and a distance amount from the given edge
+ * of aRect.  You may pass 0 in as either of slice or
+ * remainder to avoid obtaining either of the created rectangles. */
+GS_EXPORT void
+NSDivideRect(NSRect aRect,
+             NSRect *slice,
+             NSRect *remainder,
+             CGFloat amount,
+             NSRectEdge edge);
+
+/** Returns a rectangle obtained by expanding aRect minimally
+ * so that all four of its defining components are integers. */
+GS_EXPORT NSRect
+NSIntegralRect(NSRect aRect);
+
+/** Compute a Third Rectangle from Two Rectangles... **/
+
+GS_GEOM_SCOPE NSRect
+NSUnionRect(NSRect aRect, NSRect bRect) GS_GEOM_ATTR;
+
+/** Returns the smallest rectangle which contains both aRect
+ * and bRect (modulo a set of measure zero).  If either of aRect
+ * or bRect is an empty rectangle, then the other rectangle is
+ * returned.  If both are empty, then the empty rectangle is returned. */
+GS_GEOM_SCOPE NSRect
+NSUnionRect(NSRect aRect, NSRect bRect)
+{
+  NSRect rect;
+
+  if (NSIsEmptyRect(aRect) && NSIsEmptyRect(bRect))
+    return NSMakeRect(0.0,0.0,0.0,0.0);
+  else if (NSIsEmptyRect(aRect))
+    return bRect;
+  else if (NSIsEmptyRect(bRect))
+    return aRect;
+
+  rect = NSMakeRect(MIN(NSMinX(aRect), NSMinX(bRect)),
+                    MIN(NSMinY(aRect), NSMinY(bRect)), 0.0, 0.0);
+
+  rect = NSMakeRect(NSMinX(rect),
+                    NSMinY(rect),
+                    MAX(NSMaxX(aRect), NSMaxX(bRect)) - NSMinX(rect),
+                    MAX(NSMaxY(aRect), NSMaxY(bRect)) - NSMinY(rect));
+
+  return rect;
+}
+
+GS_GEOM_SCOPE NSRect
+NSIntersectionRect(NSRect aRect, NSRect bRect) GS_GEOM_ATTR;
+
+/** Returns the largest rectangle which lies in both aRect and
+ * bRect.  If aRect and bRect have empty intersection (or, rather,
+ * intersection of measure zero, since this includes having their
+ * intersection be only a point or a line), then the empty
+ * rectangle is returned. */
+GS_GEOM_SCOPE NSRect
+NSIntersectionRect (NSRect aRect, NSRect bRect)
+{
+  if (NSMaxX(aRect) <= NSMinX(bRect) || NSMaxX(bRect) <= NSMinX(aRect)
+    || NSMaxY(aRect) <= NSMinY(bRect) || NSMaxY(bRect) <= NSMinY(aRect)) 
+    {
+      return NSMakeRect(0.0, 0.0, 0.0, 0.0);
+    }
+  else
+    {
+      NSRect    rect;
+
+      if (NSMinX(aRect) <= NSMinX(bRect))
+        rect.origin.x = bRect.origin.x;
+      else
+        rect.origin.x = aRect.origin.x;
+
+      if (NSMinY(aRect) <= NSMinY(bRect))
+        rect.origin.y = bRect.origin.y;
+      else
+        rect.origin.y = aRect.origin.y;
+
+      if (NSMaxX(aRect) >= NSMaxX(bRect))
+        rect.size.width = NSMaxX(bRect) - rect.origin.x;
+      else
+        rect.size.width = NSMaxX(aRect) - rect.origin.x;
+
+      if (NSMaxY(aRect) >= NSMaxY(bRect))
+        rect.size.height = NSMaxY(bRect) - rect.origin.y;
+      else
+        rect.size.height = NSMaxY(aRect) - rect.origin.y;
+
+      return rect;
+    }
+}
+
+/** Test geometric relationships... **/
+
+/** Returns 'YES' iff aRect's and bRect's origin and size are the same. */
+GS_EXPORT BOOL
+NSEqualRects(NSRect aRect, NSRect bRect) GS_GEOM_ATTR;
+
+/** Returns 'YES' iff aSize's and bSize's width and height are the same. */
+GS_EXPORT BOOL
+NSEqualSizes(NSSize aSize, NSSize bSize) GS_GEOM_ATTR;
+
+/** Returns 'YES' iff aPoint's and bPoint's x- and y-coordinates
+ * are the same. */
+GS_EXPORT BOOL
+NSEqualPoints(NSPoint aPoint, NSPoint bPoint) GS_GEOM_ATTR;
+
+GS_GEOM_SCOPE BOOL
+NSMouseInRect(NSPoint aPoint, NSRect aRect, BOOL flipped) GS_GEOM_ATTR;
+
+/** Returns 'YES' iff aPoint is inside aRect. */ 
+GS_GEOM_SCOPE BOOL
+NSMouseInRect(NSPoint aPoint, NSRect aRect, BOOL flipped)
+{
+  if (flipped)
+    {
+      return ((aPoint.x >= NSMinX(aRect))
+        && (aPoint.y >= NSMinY(aRect))
+        && (aPoint.x < NSMaxX(aRect))
+        && (aPoint.y < NSMaxY(aRect))) ? YES : NO;
+    }
+  else
+    {
+      return ((aPoint.x >= NSMinX(aRect))
+        && (aPoint.y > NSMinY(aRect))
+        && (aPoint.x < NSMaxX(aRect))
+        && (aPoint.y <= NSMaxY(aRect))) ? YES : NO;
+    }
+}
+
+GS_GEOM_SCOPE BOOL
+NSPointInRect(NSPoint aPoint, NSRect aRect) GS_GEOM_ATTR;
+
+/** Just like 'NSMouseInRect(aPoint, aRect, YES)'. */
+GS_GEOM_SCOPE BOOL
+NSPointInRect(NSPoint aPoint, NSRect aRect)
+{
+  return NSMouseInRect(aPoint, aRect, YES);
+}
+
+GS_GEOM_SCOPE BOOL
+NSContainsRect(NSRect aRect, NSRect bRect) GS_GEOM_ATTR;
+
+/** Returns 'YES' iff aRect totally encloses bRect.  NOTE: For
+ * this to be the case, aRect cannot be empty, nor can any side
+ * of bRect go beyond any side of aRect. Note that this behavior
+ * is different than the original OpenStep behavior, where the sides
+ * of bRect could not touch aRect. */
+GS_GEOM_SCOPE BOOL
+NSContainsRect(NSRect aRect, NSRect bRect)
+{
+  return (!NSIsEmptyRect(bRect)
+    && (NSMinX(aRect) <= NSMinX(bRect))
+    && (NSMinY(aRect) <= NSMinY(bRect))
+    && (NSMaxX(aRect) >= NSMaxX(bRect))
+    && (NSMaxY(aRect) >= NSMaxY(bRect))) ? YES : NO;
+}
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+GS_GEOM_SCOPE BOOL
+NSIntersectsRect(NSRect aRect, NSRect bRect) GS_GEOM_ATTR;
+
+/** Returns YES if aRect and bRect have non-zero intersection area
+    (intersecting at a line or a point doesn't count). */
+GS_GEOM_SCOPE BOOL
+NSIntersectsRect(NSRect aRect, NSRect bRect)
+{
+  /* Note that intersecting at a line or a point doesn't count */
+  return (NSMaxX(aRect) <= NSMinX(bRect)
+    || NSMaxX(bRect) <= NSMinX(aRect)
+    || NSMaxY(aRect) <= NSMinY(bRect)
+    || NSMaxY(bRect) <= NSMinY(aRect)
+    || NSIsEmptyRect(aRect)
+    || NSIsEmptyRect(bRect)) ? NO : YES;
+}
+#endif
+
+/** Get a String Representation... **/
+
+#ifdef __OBJC__
+/** Returns an NSString of the form "{x=X; y=Y}", where
+ * X and Y are the x- and y-coordinates of aPoint, respectively. */
+GS_EXPORT NSString *
+NSStringFromPoint(NSPoint aPoint);
+
+/** Returns an NSString of the form "{x=X; y=Y; width=W; height=H}",
+ * where X, Y, W, and H are the x-coordinate, y-coordinate,
+ * width, and height of aRect, respectively. */
+GS_EXPORT NSString *
+NSStringFromRect(NSRect aRect);
+
+/** Returns an NSString of the form "{width=W; height=H}", where
+ * W and H are the width and height of aSize, respectively. */
+GS_EXPORT NSString *
+NSStringFromSize(NSSize aSize);
+
+/** Parses point from string of form "<code>{x=a; y=b}</code>". (0,0) returned
+    if parsing fails. */
+GS_EXPORT NSPoint	NSPointFromString(NSString* string);
+
+/** Parses size from string of form "<code>{width=a; height=b}</code>". Size of
+    0,0 returned if parsing fails. */
+GS_EXPORT NSSize	NSSizeFromString(NSString* string);
+
+/** Parses point from string of form "<code>{x=a; y=b; width=c;
+    height=d}</code>".  Rectangle of 0 size at origin returned if parsing
+    fails.
+*/
+GS_EXPORT NSRect	NSRectFromString(NSString* string);
+
+#endif /* __OBJC__ */
+
+#ifdef	GS_DEFINED_MAX
+#undef	GS_DEFINED_MAX
+#undef	MAX
+#endif
+
+#ifdef	GS_DEFINED_MIN
+#undef	GS_DEFINED_MIN
+#undef	MIN
+#endif
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif /* __NSGeometry_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSZone.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSZone.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSZone.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSZone.h	(revision 278653)
@@ -0,0 +1,335 @@
+/** Zone memory management. -*- Mode: ObjC -*-
+   Copyright (C) 1997,1998,1999 Free Software Foundation, Inc.
+
+   Written by: Yoo C. Chung <wacko@laplace.snu.ac.kr>
+   Date: January 1997
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+    AutogsdocSource:	NSZone.m
+    AutogsdocSource:	NSPage.m
+
+   */
+
+#ifndef __NSZone_h_GNUSTEP_BASE_INCLUDE
+#define __NSZone_h_GNUSTEP_BASE_INCLUDE
+#import	"../GNUstepBase/GSVersionMacros.h"
+
+/**
+ * Primary structure representing an <code>NSZone</code>.  Technically it
+ * consists of a set of function pointers for zone upkeep functions plus some
+ * other things-
+<example>
+{
+  // Functions for zone.
+  void *(*malloc)(struct _NSZone *zone, size_t size);
+  void *(*realloc)(struct _NSZone *zone, void *ptr, size_t size);
+  void (*free)(struct _NSZone *zone, void *ptr);
+  void (*recycle)(struct _NSZone *zone);
+  BOOL (*check)(struct _NSZone *zone);
+  BOOL (*lookup)(struct _NSZone *zone, void *ptr);
+
+  // Zone statistics (not always maintained).
+  struct NSZoneStats (*stats)(struct _NSZone *zone);
+  
+  size_t gran;    // Zone granularity (passed in on initialization)
+  NSString *name; // Name of zone (default is 'nil')
+  NSZone *next;   // Pointer used for internal management of multiple zones.
+}</example>
+ */
+typedef struct _NSZone NSZone;
+
+#import	"NSObjCRuntime.h"
+
+@class NSString;
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+struct _NSZone
+{
+  /* Functions for zone. */
+  void *(*malloc)(struct _NSZone *zone, size_t size);
+  void *(*realloc)(struct _NSZone *zone, void *ptr, size_t size);
+  void (*free)(struct _NSZone *zone, void *ptr);
+  void (*recycle)(struct _NSZone *zone);
+  BOOL (*check)(struct _NSZone *zone);
+  BOOL (*lookup)(struct _NSZone *zone, void *ptr);
+  struct NSZoneStats (*stats)(struct _NSZone *zone);
+  
+  size_t gran; // Zone granularity
+  __unsafe_unretained NSString *name; // Name of zone (default is 'nil')
+  NSZone *next;
+};
+
+/**
+ * Creates a new zone of start bytes, which will grow and shrink by
+ * granularity bytes.  If canFree is 0, memory in zone is allocated but
+ * never freed, meaning allocation will be very fast.  The whole zone can
+ * still be freed with NSRecycleZone(), and you should still call NSZoneFree
+ * on memory in the zone that is no longer needed, since a count of allocated
+ * pointers is kept and must reach zero before freeing the zone.<br />
+ * If Garbage Collection is enabled, this function does nothing other than
+ * log a warning and return the same value as the NSDefaultMallocZone()
+ * function.
+ */
+GS_EXPORT NSZone*
+NSCreateZone (NSUInteger start, NSUInteger gran, BOOL canFree);
+
+/** Returns the default zone for memory allocation.  Memory created in this
+ * zone is the same as memory allocates using the system malloc() function.
+ */
+GS_EXPORT NSZone*
+NSDefaultMallocZone (void);
+
+/**
+ * Searches and finds the zone ptr was allocated from.  The speed depends
+ * upon the number of zones and their size.<br />
+ * If Garbage Collection is enabled, this function always returns the
+ * same as the NSDefaultMallocZone() function.
+ */
+GS_EXPORT NSZone*
+NSZoneFromPointer (void *ptr);
+
+/**
+ * Allocates and returns memory for elems items of size bytes, in the
+ * given zone.  Returns NULL if allocation of size 0 requested.  Raises
+ * <code>NSMallocException</code> if not enough free memory in zone to
+ * allocate and no more can be obtained from system, unless using the
+ * default zone, in which case NULL is returned.<br />
+ * If Garbage Collection is enabled, this function always allocates
+ * non-scanned, non-collectable memory in the NSDefaultMallocZone() and
+ * the zone argument is ignored.
+ */
+GS_EXPORT void*
+NSZoneMalloc (NSZone *zone, NSUInteger size);
+
+/**
+ * Allocates and returns cleared memory for elems items of size bytes, in the
+ * given zone.  Returns NULL if allocation of size 0 requested.  Raises
+ * <code>NSMallocException</code> if not enough free memory in zone to
+ * allocate and no more can be obtained from system, unless using the
+ * default zone, in which case NULL is returned.<br />
+ * If Garbage Collection is enabled, this function always allocates
+ * non-scanned, non-collectable memory in the NSDefaultMallocZone() and
+ * the zone argument is ignored.
+ */
+GS_EXPORT void*
+NSZoneCalloc (NSZone *zone, NSUInteger elems, NSUInteger bytes);
+
+/**
+ * Reallocates the chunk of memory in zone pointed to by ptr to a new one of
+ * size bytes.  Existing contents in ptr are copied over.  Raises an
+ * <code>NSMallocException</code> if insufficient memory is available in the
+ * zone and no more memory can be obtained from the system, unless using the
+ * default zone, in which case NULL is returned.<br />
+ * If Garbage Collection is enabled, the zone argument is ignored.
+ */
+GS_EXPORT void*
+NSZoneRealloc (NSZone *zone, void *ptr, NSUInteger size);
+
+/**
+ * Return memory for an entire zone to system.  In fact, this will not be done
+ * unless all memory in the zone has been explicitly freed (by calls to
+ * NSZoneFree()).  For "non-freeable" zones, the number of NSZoneFree() calls
+ * must simply equal the number of allocation calls.  The default zone, on the
+ * other hand, cannot be recycled.<br />
+ * If Garbage Collection is enabled, this function has not effect.
+ */
+GS_EXPORT void
+NSRecycleZone (NSZone *zone);
+
+/**
+ * Frees memory pointed to by ptr (which should have been allocated by a
+ * previous call to NSZoneMalloc(), NSZoneCalloc(), or NSZoneRealloc()) and
+ * returns it to zone.  Note, if this is a nonfreeable zone, the memory is
+ * not actually freed, but the count of number of free()s is updated.<br />
+ * If Garbage Collection is enabled, the zone argument is ignored and this
+ * function causes ptr to be deallocated immediately.
+ */
+GS_EXPORT void
+NSZoneFree (NSZone *zone, void *ptr);
+
+/**
+ * Sets name of the given zone (useful for debugging and logging).
+ */
+GS_EXPORT void
+NSSetZoneName (NSZone *zone, NSString *name);
+
+/**
+ * Returns the name of the given zone (useful for debugging and logging).
+ */
+GS_EXPORT NSString*
+NSZoneName (NSZone *zone);
+
+#if OS_API_VERSION(GS_API_NONE, GS_API_NONE)
+
+/** Deprecated ...<br />
+ * Checks integrity of a zone.  Not defined by OpenStep or OS X.
+ */
+BOOL
+NSZoneCheck (NSZone *zone);
+
+/**
+ *  <code>NSZoneStats</code> is the structure returned by the NSZoneStats()
+ *  function that summarizes the current usage of a zone.  It is similar to
+ *  the structure <em>mstats</em> in the GNU C library.  It has 5 fields of
+ *  type <code>size_t</code>-
+ *  <deflist>
+ *    <term><code>bytes_total</code></term>
+ *    <desc>
+ *    This is the total size of memory managed by the zone, in bytes.</desc>
+ *    <term><code>chunks_used</code></term>
+ *    <desc>This is the number of memory chunks in use in the zone.</desc>
+ *    <term><code>bytes_used</code></term>
+ *    <desc>This is the number of bytes in use.</desc>
+ *    <term><code>chunks_free</code></term>
+ *    <desc>This is the number of memory chunks that are not in use.</desc>
+ *    <term><code>bytes_free</code></term>
+ *    <desc>
+ *    This is the number of bytes managed by the zone that are not in use.
+ *    </desc>
+ *  </deflist>
+ */
+struct NSZoneStats
+{
+  size_t bytes_total;
+  size_t chunks_used;
+  size_t bytes_used;
+  size_t chunks_free;
+  size_t bytes_free;
+};
+
+/** Deprecated ...<br />
+ *  Obtain statistics about the zone.  Implementation emphasis is on
+ *  correctness, not speed.  Not defined by OpenStep or OS X.
+ */
+struct NSZoneStats
+NSZoneStats (NSZone *zone);
+
+/**
+ * Try to get more memory - the normal process has failed.
+ * If we can't do anything, just return a null pointer.
+ * Try to do some logging if possible.
+ */
+void*
+GSOutOfMemory(NSUInteger size, BOOL retry);
+
+/**
+ * Called during +initialize to tell the class that instances created
+ * in future should have the specified instance variable as a weak
+ * pointer for garbage collection.<br />
+ * NB. making a pointer weak does not mean that it is automatically
+ * zeroed when the object it points to is garbage collected. To get that
+ * behavior you must asign values to the pointer using the
+ * GSAssignZeroingWeakPointer() function.<br />
+ * This function has no effect if the system is
+ * not built for garbage collection.
+ */
+GS_EXPORT void
+GSMakeWeakPointer(Class theClass, const char *iVarName);
+
+/**
+ * This function must be used to assign a value to a zeroing weak pointer.<br />
+ * A zeroing weak pointer is one where, when the garbage collector collects
+ * the object pointed to, it also clears the weak pointer.<br />
+ * Assigning zero (nil) will always succeed and has the effect of telling the
+ * garbage collector that it no longer needs to track the previously assigned
+ * object.  Apart from that case, a source needs to be garbage collectable for
+ * this function to work, and using a non-garbage collectable value will
+ * cause the function to return NO.<br />
+ * If the destination object (the weak pointer watching the source object)
+ * belongs to a chunk of memory which may be collected before the source
+ * object is collected, it is important that it is finalised and the
+ * finalisation code assigns zero to the pointer.<br />
+ * If garbage collection is not in use, this function performs a simple
+ * assignment returning YES, unless destination is null in which case it
+ * returns NO.
+ */
+GS_EXPORT BOOL
+GSAssignZeroingWeakPointer(void **destination, void *source);
+
+#endif
+
+GS_EXPORT NSUInteger
+NSPageSize (void) __attribute__ ((const));
+
+GS_EXPORT NSUInteger
+NSLogPageSize (void) __attribute__ ((const));
+
+GS_EXPORT NSUInteger
+NSRoundDownToMultipleOfPageSize (NSUInteger bytes) __attribute__ ((const));
+
+GS_EXPORT NSUInteger
+NSRoundUpToMultipleOfPageSize (NSUInteger bytes) __attribute__ ((const));
+
+GS_EXPORT NSUInteger
+NSRealMemoryAvailable (void);
+
+GS_EXPORT void*
+NSAllocateMemoryPages (NSUInteger bytes);
+
+GS_EXPORT void
+NSDeallocateMemoryPages (void *ptr, NSUInteger bytes);
+
+GS_EXPORT void
+NSCopyMemoryPages (const void *src, void *dest, NSUInteger bytes);
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, OS_API_LATEST)
+
+enum {
+  NSScannedOption = (1<<0),
+  NSCollectorDisabledOption = (1<<1)
+};
+
+/** Allocate memory.  If garbage collection is not enabled this uses the
+ * default malloc zone and the options are ignored.<br />
+ * If garbage collection is enabled, the allocate memory is normally not
+ * scanned for pointers but is itsself garbage collectable.  The options
+ * argument is a bitmask in which NSScannedOption sets the memory to be
+ * scanned for pointers by the garbage collector, and
+ * NSCollectorDisabledOption causes the memory to be excempt from being
+ * garbage collected itsself.<br />
+ * In any case the memory returned is zero'ed.
+ */
+GS_EXPORT void *
+NSAllocateCollectable(NSUInteger size, NSUInteger options);
+
+/** Reallocate memory to be of a different size and/or to have different
+ * options settings.  The behavior of options is as for
+ * the NSAllocateCollectable() function.
+ */ 
+GS_EXPORT void *
+NSReallocateCollectable(void *ptr, NSUInteger size, NSUInteger options);
+
+#endif
+
+static inline id NSMakeCollectable(const void *cf) {
+#if __has_feature(objc_arc)
+    return nil;
+#else
+    return (id)cf; // Unimplemented; garbage collection is deprecated.
+#endif
+}
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif /* not __NSZone_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSRange.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSRange.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSRange.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSRange.h	(revision 278653)
@@ -0,0 +1,235 @@
+/* 
+ * Copyright (C) 1995,1999 Free Software Foundation, Inc.
+ * 
+ * Written by:  Adam Fedor <fedor@boulder.colorado.edu>
+ * Date: 1995
+ * 
+ * This file is part of the GNUstep Base Library.
+ * 
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ * 
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ * 
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02111 USA.
+ */ 
+
+#ifndef __NSRange_h_GNUSTEP_BASE_INCLUDE
+#define __NSRange_h_GNUSTEP_BASE_INCLUDE
+#import	"../GNUstepBase/GSVersionMacros.h"
+
+/**** Included Headers *******************************************************/
+
+#import	"NSObject.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+@class NSException;
+@class NXConstantString;
+
+/**** Type, Constant, and Macro Definitions **********************************/
+
+#ifndef MAX
+#define MAX(a,b) \
+       ({__typeof__(a) _MAX_a = (a); __typeof__(b) _MAX_b = (b);  \
+         _MAX_a > _MAX_b ? _MAX_a : _MAX_b; })
+#define	GS_DEFINED_MAX
+#endif
+
+#ifndef MIN
+#define MIN(a,b) \
+       ({__typeof__(a) _MIN_a = (a); __typeof__(b) _MIN_b = (b);  \
+         _MIN_a < _MIN_b ? _MIN_a : _MIN_b; })
+#define	GS_DEFINED_MIN
+#endif
+
+/**
+ * <example>
+{
+  NSUInteger location;
+  NSUInteger length;
+}</example>
+ * <p>
+ *   The NSRange type is used to specify ranges of locations,
+ *   typically items in an array, characters in a string, and bytes
+ *   in a data object.
+ * </p>
+ * <p>
+ *   As 'boundary' or 'fencepost' errors are a particularly common
+ *   problem in programming, it is important that you understand
+ *   how an NSRange works.
+ * </p>
+ * <p>
+ *   An NSRange consists of a <em>location</em> and a <em>length</em>.  The
+ *   points that are considered to lie in a range are the integers from
+ *   the location to the location plus the length, so the number
+ *   of points in a range is the length of the range plus one.<br />
+ *   However, if you consider these points like the marks on a
+ *   ruler, you can only store information <strong>between</strong>
+ *   points.  So the number of items that can be stored in a range
+ *   is the length of the range.
+ * </p>
+ */
+typedef struct _NSRange NSRange;
+struct _NSRange
+{
+  NSUInteger location;
+  NSUInteger length;
+};
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+/** Pointer to an NSRange structure. */
+typedef NSRange *NSRangePointer;
+#endif
+
+/**** Function Prototypes ****************************************************/
+
+/*
+ *      All but the most complex functions are declared static inline in this
+ *      header file so that they are maximally efficient.  In order to provide
+ *      true functions (for code modules that don't have this header) this
+ *      header is included in NSRange.m where the functions are no longer
+ *      declared inline.
+ */
+#ifdef  IN_NSRANGE_M
+#define GS_RANGE_SCOPE   extern
+#define GS_RANGE_ATTR
+#else
+#define GS_RANGE_SCOPE   static inline
+#define GS_RANGE_ATTR    __attribute__((unused))
+#endif
+
+GS_RANGE_SCOPE NSUInteger
+NSMaxRange(NSRange range) GS_RANGE_ATTR;
+
+/** Returns top end of range (location + length). */
+GS_RANGE_SCOPE NSUInteger
+NSMaxRange(NSRange range) 
+{
+  return range.location + range.length;
+}
+
+GS_RANGE_SCOPE BOOL 
+NSLocationInRange(NSUInteger location, NSRange range) GS_RANGE_ATTR;
+
+/** Returns whether location is greater than or equal to range's location
+ *  and less than its max.
+ */
+GS_RANGE_SCOPE BOOL 
+NSLocationInRange(NSUInteger location, NSRange range) 
+{
+  return (location >= range.location) && (location < NSMaxRange(range));
+}
+
+/** Convenience method for raising an NSRangeException. */
+GS_EXPORT void _NSRangeExceptionRaise (void);
+/* NB: The implementation of _NSRangeExceptionRaise is: 
+   [NSException raise: NSRangeException
+	       format: @"Range location + length too great"]; 
+
+   _NSRangeExceptionRaise is defined in NSRange.m so that this
+   file (NSRange.h) can be included without problems in the
+   implementation of the base classes themselves. */
+
+GS_RANGE_SCOPE NSRange
+NSMakeRange(NSUInteger location, NSUInteger length) GS_RANGE_ATTR;
+
+/** Creates new range starting at location and of given length. */
+GS_RANGE_SCOPE NSRange
+NSMakeRange(NSUInteger location, NSUInteger length)
+{
+  NSRange range;
+  NSUInteger end = location + length;
+
+  if (end < location || end < length)
+    {
+      _NSRangeExceptionRaise ();
+    }
+  range.location = location;
+  range.length   = length;
+  return range;
+}
+
+GS_RANGE_SCOPE BOOL
+NSEqualRanges(NSRange range1, NSRange range2) GS_RANGE_ATTR;
+
+/** Returns whether range1 and range2 have same location and length. */
+GS_RANGE_SCOPE BOOL
+NSEqualRanges(NSRange range1, NSRange range2)
+{
+  return ((range1.location == range2.location)
+                && (range1.length == range2.length));
+}
+
+GS_RANGE_SCOPE NSRange
+NSUnionRange(NSRange range1, NSRange range2) GS_RANGE_ATTR;
+
+/** Returns range going from minimum of aRange's and bRange's locations to
+    maximum of their two max's. */
+GS_RANGE_SCOPE NSRange
+NSUnionRange(NSRange aRange, NSRange bRange)
+{
+  NSRange range;
+
+  range.location = MIN(aRange.location, bRange.location);
+  range.length   = MAX(NSMaxRange(aRange), NSMaxRange(bRange))
+                - range.location;
+  return range;
+}
+
+GS_RANGE_SCOPE NSRange
+NSIntersectionRange(NSRange range1, NSRange range2) GS_RANGE_ATTR;
+
+/** Returns range containing indices existing in both aRange and bRange.  If
+ *  the returned length is 0, the location is undefined and should be ignored.
+ */
+GS_RANGE_SCOPE NSRange
+NSIntersectionRange (NSRange aRange, NSRange bRange)
+{
+  NSRange range;
+
+  if (NSMaxRange(aRange) < bRange.location
+                || NSMaxRange(bRange) < aRange.location)
+    return NSMakeRange(0, 0);
+
+  range.location = MAX(aRange.location, bRange.location);
+  range.length   = MIN(NSMaxRange(aRange), NSMaxRange(bRange))
+                - range.location;
+  return range;
+}
+
+
+@class NSString;
+
+/** Returns string of form {location=a, length=b}. */
+GS_EXPORT NSString *NSStringFromRange(NSRange range);
+
+/** Parses range from string of form {location=a, length=b}; returns range
+    with 0 location and length if this fails. */
+GS_EXPORT NSRange NSRangeFromString(NSString *aString);
+
+#ifdef	GS_DEFINED_MAX
+#undef	GS_DEFINED_MAX
+#undef	MAX
+#endif
+
+#ifdef	GS_DEFINED_MIN
+#undef	GS_DEFINED_MIN
+#undef	MIN
+#endif
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif /* __NSRange_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSValue.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSValue.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSValue.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSValue.h	(revision 278653)
@@ -0,0 +1,370 @@
+/* Interface for NSValue for GNUStep
+   Copyright (C) 1995, 1996 Free Software Foundation, Inc.
+
+   Written by:  Adam Fedor <fedor@boulder.colorado.edu>
+   Created: 1995
+   
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+   
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+   */ 
+
+#ifndef __NSValue_h_GNUSTEP_BASE_INCLUDE
+#define __NSValue_h_GNUSTEP_BASE_INCLUDE
+#import	"../GNUstepBase/GSVersionMacros.h"
+
+#import	"NSObject.h"
+#import	"NSGeometry.h"
+#import	"NSRange.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+@class NSString;
+
+/**
+ * The <code>NSValue</code> class can wrap a single primitive value as an
+ * object so it can be used in the containers and other places where an object
+ * reference is needed. Once initialized, an <code>NSValue</code> is
+ * immutable, and there is no <code>NSMutableValue</code> class. You
+ * initialize it by giving it a pointer to the primitive value, and you should
+ * be careful this does not get freed until after the <code>NSValue</code> is
+ * no longer used.
+ */
+@interface NSValue : NSObject <NSCopying, NSCoding>
+
+// Allocating and Initializing 
+
+/**
+ * Create new instance with specified value (a pointer) of given type, which
+ * is a string code obtainable through the compile-time operator
+ * <code>@encode(...)</code>.  For example:
+<example>
+    NSValue *theValue = [NSValue value: &amp;n withObjCType: @encode(int)];
+</example>
+ */
++ (NSValue*) value: (const void*)value withObjCType: (const char*)type;
+
+/**
+ * Create new instance holding anObject.  This is useful if you want to add
+ * anObject to a collection such as [NSArray] but don't want it to be retained
+ * (a weak reference).
+ */
++ (NSValue*) valueWithNonretainedObject: (id)anObject;
+
+/**
+ * Convenience method to create instance holding an <code>NSPoint</code>
+ * structure.
+ */
++ (NSValue*) valueWithPoint: (NSPoint)point;
+
+/**
+ * Convenience method to create instance holding a pointer.  Same as
+ * using <code>@encode(void *)</code> in +value:withObjCType: .
+ */
++ (NSValue*) valueWithPointer: (const void*)pointer;
+
+/**
+ * Convenience method to create instance holding an <code>NSRange</code>
+ * structure.
+ */
++ (NSValue*) valueWithRange: (NSRange)range;
+
+/**
+ * Convenience method to create instance holding an <code>NSRect</code>
+ * structure.
+ */
++ (NSValue*) valueWithRect: (NSRect)rect;
+
+/**
+ * Convenience method to create instance holding an <code>NSSize</code>
+ * structure.
+ */
++ (NSValue*) valueWithSize: (NSSize)size;
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+/**
+ * Synonym for value:withObjCType: .
+ */
++ (NSValue*) valueWithBytes: (const void*)value objCType: (const char*)type;
+
+/** <init/>
+ * Initialize with value of type, parallel to value:withObjCType: .
+ */
+- (id) initWithBytes: (const void*)data objCType: (const char*)type;
+
+/**
+ * Compares this instance to another <code>NSValue</code>.  For equality,
+ * both contents and declared type of the two values must match.
+ */
+- (BOOL) isEqualToValue: (NSValue*)other;
+#endif	/* GS_API_MACOSX */
+
+// Accessing Data 
+
+/**
+ * Copies bytes from the pointer receiver was initialized with into buffer
+ * pointed to by value.  Number of bytes copied is determined by the type.  If
+ * type was a void * pointer or object id, the memory address itself is
+ * copied.
+ */
+- (void) getValue: (void*)value;
+
+/**
+ * Returns the string <code>@encode(...)</code> compatible type the receiver
+ * was initialized with.
+ */
+- (const char*) objCType;
+
+/**
+ * If receiver was initialized with an object ID, return it, else raises
+ * <code>NSInternalInconsistencyException</code>.
+ */
+- (id) nonretainedObjectValue;
+
+/**
+ * If receiver was initialized with a void * pointer, return it, else raises
+ * <code>NSInternalInconsistencyException</code>.
+ */
+- (void*) pointerValue;
+
+/**
+ * If receiver was initialized with an <code>NSRange</code> value, return it,
+ * else raises <code>NSInternalInconsistencyException</code>.
+ */
+- (NSRange) rangeValue;
+
+/**
+ * If receiver was initialized with an <code>NSRect</code> value, return it,
+ * else raises <code>NSInternalInconsistencyException</code>.
+ */
+- (NSRect) rectValue;
+
+/**
+ * If receiver was initialized with an <code>NSSize</code> value, return it,
+ * else raises <code>NSInternalInconsistencyException</code>.
+ */
+- (NSSize) sizeValue;
+
+/**
+ * If receiver was initialized with an <code>NSPoint</code> value, return it,
+ * else raises <code>NSInternalInconsistencyException</code>.
+ */
+- (NSPoint) pointValue;
+
+@end
+
+/**
+ * Subclass of [NSValue] offering convenience methods for initializing from
+ * and accessing as any C primitive numeric type.  On access, the value will
+ * be type-converted if necessary, using standard C conversion rules.
+ */
+@interface NSNumber : NSValue <NSCopying,NSCoding>
+
+// Allocating and Initializing
+
+/** New instance from boolean value. */
++ (NSNumber*) numberWithBool: (BOOL)value; 
+/** New instance from signed char value. */
++ (NSNumber*) numberWithChar: (signed char)value;
+/** New instance from double value. */
++ (NSNumber*) numberWithDouble: (double)value;
+/** New instance from float value. */
++ (NSNumber*) numberWithFloat: (float)value;
+/** New instance from (signed) int value. */
++ (NSNumber*) numberWithInt: (signed int)value;
+/** New instance from (signed) long value. */
++ (NSNumber*) numberWithLong: (signed long)value;
+/** New instance from (signed) long long value. */
++ (NSNumber*) numberWithLongLong: (signed long long)value;
+/** New instance from (signed) short value. */
++ (NSNumber*) numberWithShort: (signed short)value;
+/** New instance from unsigned char value. */
++ (NSNumber*) numberWithUnsignedChar: (unsigned char)value;
+/** New instance from unsigned int value. */
++ (NSNumber*) numberWithUnsignedInt: (unsigned int)value;
+/** New instance from unsigned long value. */
++ (NSNumber*) numberWithUnsignedLong: (unsigned long)value;
+/** New instance from unsigned long long value. */
++ (NSNumber*) numberWithUnsignedLongLong: (unsigned long long)value;
+/** New instance from unsigned short value. */
++ (NSNumber*) numberWithUnsignedShort: (unsigned short)value;
+
+/** Initialize from boolean value. */
+- (id) initWithBool: (BOOL)value;
+/** Initialize from signed char value. */
+- (id) initWithChar: (signed char)value;
+/** Initialize from double value. */
+- (id) initWithDouble: (double)value;
+/** Initialize from float value. */
+- (id) initWithFloat: (float)value;
+/** Initialize from (signed) int value. */
+- (id) initWithInt: (signed int)value;
+/** Initialize from (signed) long value. */
+- (id) initWithLong: (signed long)value;
+/** Initialize from (signed) long long value. */
+- (id) initWithLongLong: (signed long long)value;
+/** Initialize from (signed) short value. */
+- (id) initWithShort: (signed short)value;
+/** Initialize from unsigned char value. */
+- (id) initWithUnsignedChar: (unsigned char)value;
+/** Initialize from unsigned int value. */
+- (id) initWithUnsignedInt: (unsigned int)value;
+/** Initialize from unsigned long value. */
+- (id) initWithUnsignedLong: (unsigned long)value;
+/** Initialize from unsigned long long value. */
+- (id) initWithUnsignedLongLong: (unsigned long long)value;
+/** Initialize from unsigned short value. */
+- (id) initWithUnsignedShort: (unsigned short)value;
+
+// Accessing Data 
+
+/**
+ * Return value as a BOOL; this will in fact be a char value converted
+ * if necessary from type initialized with; if you wish to consider anything
+ * nonzero TRUE do not compare directly to YES, but use <code>'!= NO'</code>.
+ */
+- (BOOL) boolValue;
+/** Returns value as a signed char, converting if necessary. */
+- (signed char) charValue;
+/** Returns value as a double, converting if necessary. */
+- (double) doubleValue;
+/** Returns value as a float, converting if necessary. */
+- (float) floatValue;
+/** Returns value as a (signed) int, converting if necessary. */
+- (signed int) intValue;
+/** Returns value as a (signed) long, converting if necessary. */
+- (signed long) longValue;
+/** Returns value as a (signed) long long, converting if necessary. */
+- (signed long long) longLongValue;
+/** Returns value as a (signed) short, converting if necessary. */
+- (signed short) shortValue;
+/** Returns value as an unsigned char, converting if necessary. */
+- (unsigned char) unsignedCharValue;
+/** Returns value as an unsigned int, converting if necessary. */
+- (unsigned int) unsignedIntValue;
+/** Returns value as an unsigned long, converting if necessary. */
+- (unsigned long) unsignedLongValue;
+/** Returns value as an unsigned long long, converting if necessary. */
+- (unsigned long long) unsignedLongLongValue;
+/** Returns value as an unsigned short, converting if necessary. */
+- (unsigned short) unsignedShortValue;
+
+/** Returns -description . */
+- (NSString*) stringValue;
+
+/**
+ * Returns the string representation of this number using a non-localised
+ * conversion (decimal point is '.' irrespective of the locale).
+ */
+- (NSString*) description;
+
+/**
+ * <p>
+ *   Produces a string representation of the number.  For a boolean
+ *   this will be either 'true' or 'false'.  For other numbers the
+ *   format is produced using the initWithFormat:locale:... method
+ *   of NSString, and the format depends on the type of number as
+ *   follows -
+ * </p>
+ * <deflist>
+ *   <term>char</term>
+ *   <desc>%i</desc>
+ *   <term> short</term>
+ *   <desc>%hi</desc>
+ *   <term> int</term>
+ *   <desc>%i</desc>
+ *   <term> long</term>
+ *   <desc>%li</desc>
+ *   <term> long long</term>
+ *   <desc>%lli</desc>
+ *   <term> unsigned char</term>
+ *   <desc>%u</desc>
+ *   <term> unsigned short</term>
+ *   <desc>%hu</desc>
+ *   <term> unsigned int</term>
+ *   <desc>%u</desc>
+ *   <term> unsigned long</term>
+ *   <desc>%lu</desc>
+ *   <term> unsigned long long</term>
+ *   <desc>%llu</desc>
+ *   <term> float</term>
+ *   <desc>%0.7g</desc>
+ *   <term> double</term>
+ *   <desc>%0.16g</desc>
+ * </deflist>
+ */
+- (NSString*) descriptionWithLocale: (id)locale;
+
+/**
+ * Compares receiver with otherNumber, using C type conversion if necessary,
+ * and returns <code>NSOrderedAscending</code>,
+ * <code>NSOrderedDescending</code>, or <code>NSOrderedSame</code> depending
+ * on whether it is less than, greater than, or equal to otherNumber.
+ */
+- (NSComparisonResult) compare: (NSNumber*)otherNumber;
+
+/**
+ * Returns whether receiver and otherNumber represent the same numerical value.
+ */
+- (BOOL) isEqualToNumber: (NSNumber*)otherNumber;
+
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+/** Return a number intialised with NSInteger.
+ */
++ (NSNumber*) numberWithInteger: (NSInteger)value;
+/** Return a number intialised with NSUInteger.
+ */
++ (NSNumber*) numberWithUnsignedInteger: (NSUInteger)value;
+/** Initialise the receiver with NSInteger content.
+ */
+- (id) initWithInteger: (NSInteger)value;
+/** Initialise the receiver with NSUInteger content.
+ */
+- (id) initWithUnsignedInteger: (NSUInteger)value;
+/** Return the contents of the receiver as NSInteger.
+ */
+- (NSInteger) integerValue;
+/** Return the contents of the receiver as NSUInteger.
+ */
+- (NSUInteger) unsignedIntegerValue;
+#endif
+
+@end
+
+#if OS_API_VERSION(GS_API_NONE, GS_API_NONE)
+
+/** Note: Defines a method that is not in the OpenStep spec, but makes
+    subclassing easier. */
+@interface NSValue (Subclassing)
+
+/** Used by value: withObjCType: to determine the concrete subclass to alloc. */
++ (Class) valueClassWithObjCType: (const char*)type;
+
+@end
+#endif
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#if     !NO_GNUSTEP && !defined(GNUSTEP_BASE_INTERNAL)
+#import "../GNUstepBase/NSNumber+GNUstepBase.h"
+#endif
+
+#endif /* __NSValue_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSDate.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSDate.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSDate.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSDate.h	(revision 278653)
@@ -0,0 +1,300 @@
+/* Interface for NSDate for GNUStep
+   Copyright (C) 1994, 1996, 1999 Free Software Foundation, Inc.
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+  */
+
+#ifndef __NSDate_h_GNUSTEP_BASE_INCLUDE
+#define __NSDate_h_GNUSTEP_BASE_INCLUDE
+#import	"../GNUstepBase/GSVersionMacros.h"
+
+#import	"NSObjCRuntime.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+GS_EXPORT NSString * const NSSystemClockDidChangeNotification;
+
+/**
+ * Time interval difference between two dates, in seconds.
+ */
+typedef double NSTimeInterval;
+
+/**
+ * Time interval between the unix standard reference date of 1 January 1970
+ * and the OpenStep reference date of 1 January 2001<br />
+ * This number comes from:<br />
+ * (((31 years * 365 days) + 8 days for leap years) = total number of days<br />
+ * 24 hours * 60 minutes * 60 seconds)<br />
+ * This ignores leap-seconds.
+ */
+GS_EXPORT const NSTimeInterval NSTimeIntervalSince1970;
+
+#import	"NSObject.h"
+
+@class NSArray;
+@class NSCalendarDate;
+@class NSData;
+@class NSDictionary;
+@class NSString;
+@class NSTimeZone;
+@class NSTimeZoneDetail;
+
+@interface NSDate : NSObject <NSCoding,NSCopying>
+{
+}
+
+/** Returns an autoreleased instance with the current date/time.
+ */
++ (id) date;
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+/** Returns an autoreleased instance representing the date and time given
+ * by string. The value of string may be a 'natural' specification as
+ * specified by the preferences in the user defaults database, allowing
+ * phrases like 'last tuesday'
+ */
++ (id) dateWithNaturalLanguageString: (NSString*)string;
+
+/**
+ * <p>Returns an autoreleased instance representing the date and time given
+ * by string. The value of string may be a 'natural' specification as
+ * specified by the preferences in the user defaults database, allowing
+ * phrases like 'last tuesday'
+ * </p>
+ * The locale contains keys such as -
+ * <deflist>
+ *   <term>NSDateTimeOrdering</term>
+ *   <desc>Controls the use of ambiguous numbers. This is done as a
+ *   sequence of the letters D(ay), M(onth), Y(ear), and H(our).
+ *   YMDH means that the first number encountered is assumed to be a
+ *   year, the second a month, the third a day, and the last an hour.
+ *   </desc>
+ *   <term>NSEarlierTimeDesignations</term>
+ *   <desc>An array of strings for times in the past.<br />
+ *   Defaults are <em>ago</em>, <em>last</em>, <em>past</em>, <em>prior</em>
+ *   </desc>
+ *   <term>NSHourNameDesignations</term>
+ *   <desc>An array of arrays of strings identifying the time of day.
+ *   Each array has an hour as its first value, and one or more words
+ *   as subsequent values.<br />
+ *   Defaults are: (0, midnight), (10, morning), (12, noon, lunch),
+ *   (14, afternoon), (19, dinner).
+ *   </desc>
+ *   <term>NSLaterTimeDesignations</term>
+ *   <desc>An array of strings for times in the future.<br />
+ *   Default is <em>next</em>
+ *   </desc>
+ *   <term>NSNextDayDesignations</term>
+ *   <desc>The day after today. Default is <em>tomorrow.</em>
+ *   </desc>
+ *   <term>NSNextNextDayDesignations</term>
+ *   <desc>The day after tomorrow. Default is <em>nextday.</em>
+ *   </desc>
+ *   <term>NSPriorDayDesignations</term>
+ *   <desc>The day before today. Default is <em>yesterday.</em>
+ *   </desc>
+ *   <term>NSThisDayDesignations</term>
+ *   <desc>Identifies the current day. Default is <em>today.</em>
+ *   </desc>
+ *   <term>NSYearMonthWeekDesignations</term>
+ *   <desc>An array giving the word for year, month, and week.<br />
+ *   Defaults are <em>year</em>, <em>month</em> and <em>week</em>.
+ *   </desc>
+ * </deflist>
+ */
++ (id) dateWithNaturalLanguageString: (NSString*)string
+                              locale: (NSDictionary*)locale;
+#endif
+
+/** Returns an autoreleased instance with the date and time value given
+ * by the string using the ISO standard format YYYY-MM-DD HH:MM:SS +/-HHHMM
+ * (all the fields of which must be present).
+ */
++ (id) dateWithString: (NSString*)description;
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6,GS_API_LATEST)
+/** Returns an autoreleased NSDate instance whose value is offset from
+ * that of the given date by the specified interval in seconds.
+ */
++ (id) dateWithTimeInterval: (NSTimeInterval)seconds sinceDate: (NSDate*)date;
+#endif
+
+/** Returns an autoreleased instance with the offset from the unix system
+ * reference date of 1 January 1970, GMT.
+ */
++ (id) dateWithTimeIntervalSince1970: (NSTimeInterval)seconds;
+
+/** Returns an autoreleased instance with the offset from the current
+ * date/time given by seconds (which may be fractional).
+ */
++ (id) dateWithTimeIntervalSinceNow: (NSTimeInterval)seconds;
+
+/** Returns an autoreleased instance with the offset from the OpenStep
+ * reference date of 1 January 2001, GMT.
+ */
++ (id) dateWithTimeIntervalSinceReferenceDate: (NSTimeInterval)seconds;
+
+/** Returns an autoreleased instance with the date/time set in the far
+ * past.
+ */
++ (id) distantPast;
+
+/** Returns an autoreleased instance with the date/time set in the far
+ * future.
+ */
++ (id) distantFuture;
+
+/** Returns the time interval between the reference date and the current
+ * time.
+ */
++ (NSTimeInterval) timeIntervalSinceReferenceDate;
+
+/** Returns an autorelease date instance formed by adding the specified
+ * time interval in seconds to the receiver's time interval.
+ */
+- (id) addTimeInterval: (NSTimeInterval)seconds;
+
+/** Returns the time interval between the receivers value and the
+ * OpenStep reference date of 1 Jan 2001 GMT.
+ */
+- (NSComparisonResult) compare: (NSDate*)otherDate;
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6,GS_API_LATEST)
+/** Returns an autoreleased NSDate instance whose value is offset from
+ * that of the receiver by the specified interval.
+ */
+- (id) dateByAddingTimeInterval: (NSTimeInterval)ti;
+#endif
+
+/** Returns an autoreleased instance of the [NSCalendarDate] class whose
+ * date/time value is the same as that of the receiver, and which uses
+ * the formatString and timeZone specified.
+ */
+- (NSCalendarDate*) dateWithCalendarFormat: (NSString*)formatString
+				  timeZone: (NSTimeZone*)timeZone;
+
+/** Returns a string representation of the receiver formatted according
+ * to the default format string, time zone, and locale.
+ */
+- (NSString*) description;
+
+/** Returns a string representation of the receiver formatted according
+ * to the specified format string, time zone, and locale.
+ */
+- (NSString*) descriptionWithCalendarFormat: (NSString*)format
+				   timeZone: (NSTimeZone*)aTimeZone
+				     locale: (NSDictionary*)l;
+
+/** Returns a string representation of the receiver formatted according
+ * to the default format string and time zone, but using the given locale.
+ */
+- (NSString*) descriptionWithLocale: (id)locale;
+
+/** Returns the earlier of the receiver and otherDate.<br />
+ * If the two represent identical date/time values, returns the receiver.
+ */
+- (NSDate*) earlierDate: (NSDate*)otherDate;
+
+/** Returns an instance initialised with the current date/time.
+ */
+- (id) init;
+
+/** Returns an instance with the date and time value given
+ * by the string using the ISO standard format YYYY-MM-DD HH:MM:SS +/-HHHMM
+ * (all the fields of which must be present).
+ */
+- (id) initWithString: (NSString*)description;
+
+/** Returns an instance with the given offset from anotherDate.
+ */
+- (id) initWithTimeInterval: (NSTimeInterval)secsToBeAdded
+		  sinceDate: (NSDate*)anotherDate;
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+/** Returns an instance with the offset from the unix system
+ * reference date of 1 January 1970, GMT.
+ */
+- (id) initWithTimeIntervalSince1970: (NSTimeInterval)seconds;
+#endif
+
+/** Returns an instance with the offset from the current date/time.
+ */
+- (id) initWithTimeIntervalSinceNow: (NSTimeInterval)secsToBeAdded;
+
+/** <init />
+ * Returns an instance with the given offset from the OpenStep
+ * reference date of 1 January 2001, GMT.
+ */
+- (id) initWithTimeIntervalSinceReferenceDate: (NSTimeInterval)secs;
+
+/** Returns NO if other is not a date, otherwise returns the result of
+ * calling the -isEqualtoDate: method.
+ */
+- (BOOL) isEqual: (id)other;
+
+/**  Returns whether the receiver is exactly equal to other, to the limit
+ *  of the NSTimeInterval precision.<br />
+ *  This is the behavior of the current MacOS-X system, not that of the
+ *  OpenStep specification (which counted two dates within a second of
+ *  each other as being equal).<br />
+ *  The old behavior meant that two dates equal to a third date were not
+ *  necessarily equal to each other (confusing), and meant that there was
+ *  no reasonable way to use a date as a dictionary key or store dates
+ *  in a set.
+ */
+- (BOOL) isEqualToDate: (NSDate*)other;
+
+/** Returns the earlier of the receiver and otherDate.<br />
+ * If the two represent identical date/time values, returns the receiver.
+ */
+- (NSDate*) laterDate: (NSDate*)otherDate;
+
+/** Returns the time interval between the receivers value and the
+ * unix system reference date of 1 January 1970, GMT.
+ */
+- (NSTimeInterval) timeIntervalSince1970;
+
+/** Returns the time interval between the receivers value and that of the
+ * otherDate argument.  If otherDate is earlier than the receiver, the
+ * returned value will be positive, if it is later it will be negative.<br />
+ * For current (2011) OSX compatibility, this method returns NaN if otherDate
+ * is nil ... do not write code depending on that behavior.
+ */
+- (NSTimeInterval) timeIntervalSinceDate: (NSDate*)otherDate;
+
+/** Returns the time interval between the receivers value and the
+ * current date/time.  If the receiver represents a date/time in
+ * the past this will be negative, if it is in the future the
+ * returned value will be positive.
+ */
+- (NSTimeInterval) timeIntervalSinceNow;
+
+/** Returns the time interval between the receivers value and the
+ * OpenStep reference date of 1 Jan 2001 GMT.
+ */
+- (NSTimeInterval) timeIntervalSinceReferenceDate;
+
+@end
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif  /* __NSDate_h_GNUSTEP_BASE_INCLUDE*/
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSArray.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSArray.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSArray.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSArray.h	(revision 278653)
@@ -0,0 +1,430 @@
+/* Interface for NSArray for GNUStep
+   Copyright (C) 1995-2015 Free Software Foundation, Inc.
+
+   Written by:  Andrew Kachites McCallum <mccallum@gnu.ai.mit.edu>
+   Created: 1995
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+   */
+
+#ifndef __NSArray_h_GNUSTEP_BASE_INCLUDE
+#define __NSArray_h_GNUSTEP_BASE_INCLUDE
+#import	"../GNUstepBase/GSVersionMacros.h"
+
+#import	"NSObject.h"
+#import	"NSRange.h"
+#import "NSEnumerator.h"
+#if __BLOCKS__
+#import "../GNUstepBase/GSBlocks.h"
+#endif
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+@class NSString;
+@class NSURL;
+@class NSIndexSet;
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+enum
+{
+  NSBinarySearchingFirstEqual = (1UL << 8), /** Specifies that the binary
+   * search should find the first object equal in the array.
+   */
+  NSBinarySearchingLastEqual = (1UL << 9), /** Specifies that the binary
+   * search should find the last object equal in the array.
+   */
+  NSBinarySearchingInsertionIndex = (1UL << 10), /** Specifies that the binary
+   * search should find the index at which an equal object should be inserted
+   * in order to keep the array sorted
+   */
+};
+
+typedef NSUInteger NSBinarySearchingOptions;
+#endif
+
+@interface GS_GENERIC_CLASS(NSArray, __covariant ElementT) : NSObject
+  <NSCoding, NSCopying, NSMutableCopying, NSFastEnumeration>
+
++ (instancetype) array;
++ (instancetype) arrayWithArray: (GS_GENERIC_CLASS(NSArray, ElementT) *)array;
++ (instancetype) arrayWithContentsOfFile: (NSString*)file;
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
++ (instancetype) arrayWithContentsOfURL: (NSURL*)aURL;
+#endif
++ (instancetype) arrayWithObject: (id)anObject;
++ (instancetype) arrayWithObjects: (id)firstObject, ...;
++ (instancetype) arrayWithObjects: (const id[])objects count: (NSUInteger)count;
+
+- (GS_GENERIC_CLASS(NSArray, ElementT) *) arrayByAddingObject:
+  (GS_GENERIC_TYPE(ElementT))anObject;
+- (GS_GENERIC_CLASS(NSArray, ElementT) *) arrayByAddingObjectsFromArray:
+  (GS_GENERIC_CLASS(NSArray, ElementT)*)anotherArray;
+- (BOOL) containsObject: (GS_GENERIC_TYPE(ElementT))anObject;
+
+/** <override-subclass />
+ * Returns the number of elements contained in the receiver.
+ */
+- (NSUInteger) count;
+- (void) getObjects: (__unsafe_unretained GS_GENERIC_TYPE(ElementT)[])aBuffer;
+- (void) getObjects: (__unsafe_unretained GS_GENERIC_TYPE(ElementT)[])aBuffer
+              range: (NSRange)aRange;
+- (NSUInteger) indexOfObject: (GS_GENERIC_TYPE(ElementT))anObject;
+- (NSUInteger) indexOfObject: (GS_GENERIC_TYPE(ElementT))anObject
+                     inRange: (NSRange)aRange;
+- (NSUInteger) indexOfObjectIdenticalTo: (GS_GENERIC_TYPE(ElementT))anObject;
+- (NSUInteger) indexOfObjectIdenticalTo: (GS_GENERIC_TYPE(ElementT))anObject
+                                inRange: (NSRange)aRange;
+- (instancetype) init;
+- (instancetype) initWithArray: (GS_GENERIC_CLASS(NSArray, ElementT)*)array;
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+- (instancetype) initWithArray: (GS_GENERIC_CLASS(NSArray, ElementT)*)array
+                     copyItems: (BOOL)shouldCopy;
+#endif
+- (instancetype) initWithContentsOfFile: (NSString*)file;
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+- (instancetype) initWithContentsOfURL: (NSURL*)aURL;
+#endif
+- (instancetype) initWithObjects: (GS_GENERIC_TYPE(ElementT)) firstObject, ...;
+
+/** <init /> <override-subclass />
+ * This should initialize the array with count (may be zero) objects.<br />
+ * Retains each object placed in the array.<br />
+ * Calls -init (which does nothing but maintain MacOS-X compatibility),
+ * and needs to be re-implemented in subclasses in order to have all
+ * other initialisers work.
+ */
+- (instancetype) initWithObjects: (const GS_GENERIC_TYPE(ElementT)[])objects
+                           count: (NSUInteger)count;
+- (GS_GENERIC_TYPE(ElementT)) lastObject;
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+- (GS_GENERIC_TYPE(ElementT)) firstObject;
+#endif
+
+/** <override-subclass />
+ * Returns the object at the specified index.
+ * Raises an exception of the index is beyond the array.
+ */
+- (GS_GENERIC_TYPE(ElementT)) objectAtIndex: (NSUInteger)index;
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+- (GS_GENERIC_CLASS(NSArray, ElementT) *) objectsAtIndexes:
+  (NSIndexSet *)indexes;
+#endif
+
+- (GS_GENERIC_TYPE(ElementT)) firstObjectCommonWithArray:
+    (GS_GENERIC_CLASS(NSArray, ElementT) *)otherArray;
+- (BOOL) isEqualToArray: (NSArray*)otherArray;
+
+#if OS_API_VERSION(GS_API_OPENSTEP, GS_API_MACOSX)
+- (void) makeObjectsPerform: (SEL)aSelector;
+- (void) makeObjectsPerform: (SEL)aSelector withObject: (id)argument;
+#endif
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+- (void) makeObjectsPerformSelector: (SEL)aSelector;
+- (void) makeObjectsPerformSelector: (SEL)aSelector withObject: (id)arg;
+#endif
+
+- (NSData*) sortedArrayHint;
+- (GS_GENERIC_CLASS(NSArray, ElementT)*) sortedArrayUsingFunction:
+    (NSComparisonResult (*)(id, id, void*))comparator
+			        context: (void*)context;
+- (GS_GENERIC_CLASS(NSArray, ElementT)*) sortedArrayUsingFunction:
+    (NSComparisonResult (*)(id, id, void*))comparator
+			      context: (void*)context
+				     hint: (NSData*)hint;
+- (GS_GENERIC_CLASS(NSArray, ElementT)*) sortedArrayUsingSelector:
+  (SEL)comparator;
+- (GS_GENERIC_CLASS(NSArray, ElementT)*) subarrayWithRange: (NSRange)aRange;
+
+- (NSString*) componentsJoinedByString: (NSString*)separator;
+- (GS_GENERIC_CLASS(NSArray, NSString*)*) pathsMatchingExtensions:
+    (GS_GENERIC_CLASS(NSArray, NSString*)*)extensions;
+
+- (GS_GENERIC_CLASS(NSEnumerator, ElementT)*) objectEnumerator;
+- (GS_GENERIC_CLASS(NSEnumerator, ElementT)*) reverseObjectEnumerator;
+
+- (NSString*) description;
+- (NSString*) descriptionWithLocale: (id)locale;
+- (NSString*) descriptionWithLocale: (id)locale
+			     indent: (NSUInteger)level;
+
+- (BOOL) writeToFile: (NSString*)path atomically: (BOOL)useAuxiliaryFile;
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+- (BOOL) writeToURL: (NSURL*)url atomically: (BOOL)useAuxiliaryFile;
+- (GS_GENERIC_TYPE(ElementT)) valueForKey: (NSString*)key;
+- (void) setValue: (GS_GENERIC_TYPE(ElementT))value forKey: (NSString*)key;
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+
+#if __BLOCKS__
+DEFINE_BLOCK_TYPE(GSEnumeratorBlock, void, GS_GENERIC_TYPE(ElementT),
+  NSUInteger, BOOL*);
+DEFINE_BLOCK_TYPE(GSPredicateBlock, BOOL, GS_GENERIC_TYPE(ElementT),
+  NSUInteger, BOOL*);
+/**
+ * Enumerate over the collection using the given block.  The first argument is
+ * the object and the second is the index in the array.  The final argument is
+ * a pointer to a BOOL indicating whether the enumeration should stop.  Setting
+ * this to YES will interrupt the enumeration.
+ */
+- (void) enumerateObjectsUsingBlock: (GSEnumeratorBlock)aBlock;
+
+/**
+ * Enumerate over the collection using the given block.  The first argument is
+ * the object and the second is the index in the array.  The final argument is
+ * a pointer to a BOOL indicating whether the enumeration should stop.  Setting
+ * this to YES will interrupt the enumeration.
+ *
+ * The opts argument is a bitfield.  Setting the NSNSEnumerationConcurrent flag
+ * specifies that it is thread-safe.  The NSEnumerationReverse bit specifies
+ * that it should be enumerated in reverse order.
+ */
+- (void) enumerateObjectsWithOptions: (NSEnumerationOptions)opts
+			  usingBlock: (GSEnumeratorBlock)aBlock;
+/**
+ * Enumerate over the specified indexes in the collection using the given
+ * block.  The first argument is the object and the second is the index in the
+ * array.  The final argument is a pointer to a BOOL indicating whether the
+ * enumeration should stop.  Setting this to YES will interrupt the
+ * enumeration.
+ *
+ * The opts argument is a bitfield.  Setting the NSNSEnumerationConcurrent flag
+ * specifies that it is thread-safe.  The NSEnumerationReverse bit specifies
+ * that it should be enumerated in reverse order.
+ */
+- (void) enumerateObjectsAtIndexes: (NSIndexSet*)indexSet
+			   options: (NSEnumerationOptions)opts
+			usingBlock: (GSEnumeratorBlock)block;
+/**
+ * Returns the indexes of the objects in a collection that match the condition
+ * specified by the block.
+ *
+ * The opts argument is a bitfield.  Setting the NSNSEnumerationConcurrent flag
+ * specifies that it is thread-safe.  The NSEnumerationReverse bit specifies
+ * that it should be enumerated in reverse order.
+ */
+- (NSIndexSet *) indexesOfObjectsWithOptions: (NSEnumerationOptions)opts
+				 passingTest: (GSPredicateBlock)predicate;
+
+/**
+ * Returns the indexes of the objects in a collection that match the condition
+ * specified by the block.
+ */
+- (NSIndexSet*) indexesOfObjectsPassingTest: (GSPredicateBlock)predicate;
+
+/**
+ * Returns the indexes of the objects in a collection that match the condition
+ * specified by the block and are in the range specified by the index set.
+ *
+ * The opts argument is a bitfield.  Setting the NSNSEnumerationConcurrent flag
+ * specifies that it is thread-safe.  The NSEnumerationReverse bit specifies
+ * that it should be enumerated in reverse order.
+ */
+- (NSIndexSet*) indexesOfObjectsAtIndexes: (NSIndexSet*)indexSet
+				  options: (NSEnumerationOptions)opts
+			      passingTest: (GSPredicateBlock)predicate;
+
+/**
+ * Returns the index of the first object in the array that matches the
+ * condition specified by the block.
+ *
+ * The opts argument is a bitfield.  Setting the NSNSEnumerationConcurrent flag
+ * specifies that it is thread-safe.  The NSEnumerationReverse bit specifies
+ * that it should be enumerated in reverse order.
+ */
+- (NSUInteger) indexOfObjectWithOptions: (NSEnumerationOptions)opts
+			    passingTest: (GSPredicateBlock)predicate;
+
+/**
+ * Returns the index of the first object in the array that matches the
+ * condition specified by the block.
+ */
+- (NSUInteger) indexOfObjectPassingTest: (GSPredicateBlock)predicate;
+
+/**
+ * Returns the index of the first object in the specified range in a collection
+ * that matches the condition specified by the block.
+ *
+ * The opts argument is a bitfield.  Setting the NSNSEnumerationConcurrent flag
+ * specifies that it is thread-safe.  The NSEnumerationReverse bit specifies
+ * that it should be enumerated in reverse order.
+ */
+- (NSUInteger) indexOfObjectAtIndexes: (NSIndexSet*)indexSet
+			      options: (NSEnumerationOptions)opts
+			  passingTest: (GSPredicateBlock)predicate;
+
+/** Returns a sorted array using the comparator to determine the
+ * order of objects.
+ */
+- (GS_GENERIC_CLASS(NSArray, ElementT) *) sortedArrayUsingComparator:
+    (NSComparator)comparator;
+
+/** Returns a sorted array using the block to determine the order of objects.
+ *
+ * The opts argument is a bitfield.  Setting the NSSortConcurrent flag
+ * specifies that it is thread-safe.  The NSSortStable bit specifies that
+ * it should keep equal objects in the same order.
+ */
+- (GS_GENERIC_CLASS(NSArray, ElementT) *)
+    sortedArrayWithOptions: (NSSortOptions)options
+           usingComparator: (NSComparator)comparator;
+
+/**
+ * Performs a binary search of the array within the specified range for the
+ * index of an object equal to obj according to cmp.
+ * If NSBinarySearchingInsertionIndex is specified, searches for the index
+ * at which such an object should be inserted.
+ */
+- (NSUInteger) indexOfObject: (id)key
+               inSortedRange: (NSRange)range
+                     options: (NSBinarySearchingOptions)options
+             usingComparator: (NSComparator)comparator;
+#endif
+#endif
+/**
+ * Accessor for subscripting.  This is called by the compiler when you write
+ * code like anArray[12].  It should not be called directly.
+ */
+- (GS_GENERIC_TYPE(ElementT)) objectAtIndexedSubscript: (NSUInteger)anIndex;
+@end
+
+
+@interface GS_GENERIC_CLASS(NSMutableArray, ElementT) : NSArray
+
++ (instancetype) arrayWithCapacity: (NSUInteger)numItems;
+
+/** <override-subclass />
+ * Adds anObject at the end of the array, thus increasing the size of
+ * the array.  The object is retained upon addition.
+ */
+- (void) addObject: (GS_GENERIC_TYPE(ElementT))anObject;
+- (void) addObjectsFromArray: (GS_GENERIC_CLASS(NSArray, ElementT)*)otherArray;
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+- (void) exchangeObjectAtIndex: (NSUInteger)i1
+	     withObjectAtIndex: (NSUInteger)i2;
+#endif
+
+/** <init /> <override-subclass />
+ * Initialise the array with the specified capacity ... this
+ * should ensure that the array can have numItems added efficiently.<br />
+ * Calls -init (which does nothing but maintain MacOS-X compatibility),
+ * and needs to be re-implemented in subclasses in order to have all
+ * other initialisers work.
+ */
+- (instancetype) initWithCapacity: (NSUInteger)numItems;
+
+/** <override-subclass />
+ * Inserts an object into the receiver at the specified location.<br />
+ * Raises an exception if given an array index which is too large.<br />
+ * The size of the array increases by one.<br />
+ * The object is retained by the array.
+ */
+- (void) insertObject: (GS_GENERIC_TYPE(ElementT))anObject
+              atIndex: (NSUInteger)index;
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+- (void) insertObjects: (GS_GENERIC_CLASS(NSArray, ElementT) *)objects
+             atIndexes: (NSIndexSet *)indexes;
+#endif
+
+/** <override-subclass />
+ * Removes an object from the receiver at the specified location.<br />
+ * The size of the array decreases by one.<br />
+ * Raises an exception if given an array index which is too large.<br />
+ */
+- (void) removeObjectAtIndex: (NSUInteger)index;
+
+- (void) removeObjectsAtIndexes: (NSIndexSet *)indexes;
+
+/** <override-subclass />
+ * Places an object into the receiver at the specified location.<br />
+ * Raises an exception if given an array index which is too large.<br />
+ * The object is retained by the array.
+ */
+- (void) replaceObjectAtIndex: (NSUInteger)index
+		   withObject: (GS_GENERIC_TYPE(ElementT))anObject;
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+- (void) replaceObjectsAtIndexes: (NSIndexSet *)indexes
+                     withObjects: (GS_GENERIC_CLASS(NSArray, ElementT)*)objects;
+#endif
+
+- (void) replaceObjectsInRange: (NSRange)aRange
+          withObjectsFromArray: (GS_GENERIC_CLASS(NSArray, ElementT)*)anArray;
+
+- (void) replaceObjectsInRange: (NSRange)aRange
+          withObjectsFromArray: (GS_GENERIC_CLASS(NSArray, ElementT)*)anArray
+                         range: (NSRange)anotherRange;
+
+- (void) setArray: (GS_GENERIC_CLASS(NSArray, ElementT) *)otherArray;
+
+- (void) removeAllObjects;
+- (void) removeLastObject;
+- (void) removeObject: (GS_GENERIC_TYPE(ElementT))anObject;
+- (void) removeObject: (GS_GENERIC_TYPE(ElementT))anObject
+              inRange: (NSRange)aRange;
+- (void) removeObjectIdenticalTo: (GS_GENERIC_TYPE(ElementT))anObject;
+- (void) removeObjectIdenticalTo: (GS_GENERIC_TYPE(ElementT))anObject
+                         inRange: (NSRange)aRange;
+- (void) removeObjectsInArray: (GS_GENERIC_CLASS(NSArray, ElementT)*)otherArray;
+- (void) removeObjectsInRange: (NSRange)aRange;
+- (void) removeObjectsFromIndices: (NSUInteger*)indices
+		       numIndices: (NSUInteger)count;
+
+- (void) sortUsingFunction:
+    (NSComparisonResult (*)(GS_GENERIC_TYPE(ElementT),
+       GS_GENERIC_TYPE(ElementT),void*))compare
+		           context: (void*)context;
+- (void) sortUsingSelector: (SEL)comparator;
+
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+#if __BLOCKS__
+/**
+ * Sorts the array using the specified comparator block.
+ */
+- (void) sortUsingComparator: (NSComparator)comparator;
+
+/**
+ * Sorts the array using the specified comparator block and options.
+ */
+- (void) sortWithOptions: (NSSortOptions)options
+         usingComparator: (NSComparator)comparator;
+#endif
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_8, GS_API_LATEST)
+/** Set method called by the compiler with array subscripting.<br />
+ * Replaces the object at anIndex or, if anIndex is the length of the array,
+ * this method appends abObject to the array.
+ */
+- (void) setObject: (GS_GENERIC_TYPE(ElementT))anObject
+atIndexedSubscript: (NSUInteger)anIndex;
+#endif
+@end
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#if	!NO_GNUSTEP && !defined(GNUSTEP_BASE_INTERNAL)
+#import	"../GNUstepBase/NSArray+GNUstepBase.h"
+#endif
+
+#endif /* __NSArray_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSEnumerator.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSEnumerator.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSEnumerator.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSEnumerator.h	(revision 278653)
@@ -0,0 +1,63 @@
+/*
+   NSEnumerator.h
+
+   Copyright (C) 1998 Free Software Foundation, Inc.
+
+   Author:  Scott Christley <scottc@net-community.com>
+   Date: January 1998
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+*/
+
+#ifndef __NSEnumerator_h_GNUSTEP_BASE_INCLUDE
+#define __NSEnumerator_h_GNUSTEP_BASE_INCLUDE
+#import	"../GNUstepBase/GSVersionMacros.h"
+
+#import	"NSObject.h"
+
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+@class GS_GENERIC_CLASS(NSArray, ElementT);
+
+typedef struct
+{
+  unsigned long	state;
+  __unsafe_unretained id		*itemsPtr;
+  unsigned long	*mutationsPtr;
+  unsigned long	extra[5];
+} NSFastEnumerationState;
+
+@protocol NSFastEnumeration
+- (NSUInteger) countByEnumeratingWithState: (NSFastEnumerationState *)state
+				   objects: (__unsafe_unretained id[])stackbuf
+				     count: (NSUInteger)len;
+@end
+
+@interface GS_GENERIC_CLASS(NSEnumerator, IterT) : NSObject <NSFastEnumeration>
+- (GS_GENERIC_CLASS(NSArray, IterT) *) allObjects;
+- (GS_GENERIC_TYPE(IterT)) nextObject;
+@end
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif /* __NSEnumerator_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSObjCRuntime.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSObjCRuntime.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSObjCRuntime.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSObjCRuntime.h	(revision 278653)
@@ -0,0 +1,317 @@
+/** Interface to ObjC runtime for GNUStep
+   Copyright (C) 1995, 1997, 2000 Free Software Foundation, Inc.
+
+   Written by:  Andrew Kachites McCallum <mccallum@gnu.ai.mit.edu>
+   Date: 1995
+
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+    AutogsdocSource: NSObjCRuntime.m
+    AutogsdocSource: NSLog.m
+
+   */
+
+#ifndef __NSObjCRuntime_h_GNUSTEP_BASE_INCLUDE
+#define __NSObjCRuntime_h_GNUSTEP_BASE_INCLUDE
+
+#ifdef __cplusplus
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+#endif
+
+#import	"../GNUstepBase/GSVersionMacros.h"
+#import	"../GNUstepBase/GSConfig.h"
+#import	"../GNUstepBase/GNUstep.h"
+#if __BLOCKS__
+#import	"../GNUstepBase/GSBlocks.h"
+#endif
+
+#include <stdarg.h>
+#include <limits.h>
+#include <float.h>
+
+/* PA HP-UX kludge.  */
+#if defined(__hppa__) && defined(__hpux__) && !defined(PRIuPTR)
+#define PRIuPTR "lu"
+#endif
+
+/* IRIX kludge.  */
+#if defined(__sgi)
+/* IRIX 6.5 <inttypes.h> provides all definitions, but only for C99
+   compilations.  */
+#define PRId8 "hhd"
+#define PRIu8 "hhu"
+#if (_MIPS_SZLONG == 32)
+#define PRId64 "lld"
+#define PRIu64 "llu"
+#endif
+/* This doesn't match <inttypes.h>, which always has "lld" here, but the
+   arguments are uint64_t, int64_t, which are unsigned long, long for
+   64-bit in <sgidefs.h>.  */
+#if (_MIPS_SZLONG == 64)
+#define PRId64 "ld"
+#define PRIu64 "lu"
+#endif
+/* This doesn't match <inttypes.h>, which has "u" here, but the arguments
+   are uintptr_t, which is always unsigned long.  */
+#define PRIuPTR "lu"
+#endif
+
+/* Solaris < 10 kludge.  */
+#if defined(__sun__) && defined(__svr4__) && !defined(PRIuPTR)
+#if defined(__arch64__) || defined (__x86_64__)
+#define PRIuPTR "lu"
+#define PRIdPTR "ld"
+#define PRIxPTR "lx"
+#else
+#define PRIuPTR "u"
+#define PRIdPTR "d"
+#define PRIxPTR "x"
+#endif
+#endif
+
+
+/* These typedefs must be in place before GSObjCRuntime.h is imported.
+ */
+
+#if     !defined(NSINTEGER_DEFINED)
+typedef	intptr_t	NSInteger;
+typedef	uintptr_t	NSUInteger;
+#	define NSIntegerMax  INTPTR_MAX
+#	define NSIntegerMin  INTPTR_MIN
+#	define NSUIntegerMax UINTPTR_MAX
+#endif /* !defined(NSINTEGER_DEFINED) */
+
+#if     !defined(CGFLOAT_DEFINED)
+#if     GS_SIZEOF_VOIDP == 8
+#define CGFLOAT_IS_DBL  1
+typedef double          CGFloat;
+#define CGFLOAT_MIN	DBL_MIN
+#define CGFLOAT_MAX	DBL_MAX
+#else
+typedef float           CGFloat;
+#define CGFLOAT_MIN	FLT_MIN
+#define CGFLOAT_MAX	FLT_MAX
+#endif
+#endif /* !defined(CGFLOAT_DEFINED) */
+
+#define NSINTEGER_DEFINED 1
+#define CGFLOAT_DEFINED 1
+#ifndef NS_AUTOMATED_REFCOUNT_UNAVAILABLE
+#  if __has_feature(objc_arc)
+#    define NS_AUTOMATED_REFCOUNT_UNAVAILABLE \
+      __attribute__((unavailable("Not available with automatic reference counting")))
+#  else
+#    define NS_AUTOMATED_REFCOUNT_UNAVAILABLE
+#  endif
+#endif
+
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/*
+ * We can have strongly typed enums in C++11 mode or when the objc_fixed_enum
+ * feature is availble.
+ */
+#if (__has_feature(objc_fixed_enum) || (__cplusplus && (__cplusplus > 199711L) && __has_extension(cxx_strong_enums)))
+#  define _GS_NAMED_ENUM(ty, name) enum name : ty name; enum name : ty
+#  define _GS_ANON_ENUM(ty) enum : ty
+#  if __cplusplus
+#    define NS_OPTIONS(ty,name) ty name; enum : ty
+#  else
+#    define NS_OPTIONS(ty,name) NS_ENUM(ty,name)
+#  endif
+#else // this provides less information, but works with older compilers
+#  define _GS_NAMED_ENUM(ty, name) ty name; enum
+#  define _GS_ANON_ENUM(ty) enum
+#  define NS_OPTIONS(ty, name) NS_ENUM(ty, name)
+#endif
+// A bit of fairy dust to expand NS_ENUM to the correct variant
+#define _GS_GET_ENUM_MACRO(_first,_second,NAME,...) NAME
+/* The trick here is that placing the variadic args first will push the name
+ * that the _GS_GET_ENUM_MACRO expands to into the correct position.
+ */
+#define NS_ENUM(...) _GS_GET_ENUM_MACRO(__VA_ARGS__,_GS_NAMED_ENUM,_GS_ANON_ENUM)(__VA_ARGS__)
+
+/*
+ * If the compiler supports nullability qualifiers, we define the macros for
+ * non-null sections.
+ */
+#if __has_feature(nullability)
+#  define NS_ASSUME_NONNULL_BEGIN _Pragma("clang assume_nonnull begin")
+#  define NS_ASSUME_NONNULL_END   _Pragma("clang assume_nonnull end")
+#else
+#  define NS_ASSUME_NONNULL_BEGIN
+#  define NS_ASSUME_NONNULL_END
+#endif
+
+/*
+ * Backwards compatibility macro for instance type.
+ */
+#if !__has_feature(objc_instancetype)
+# define instancetype id
+#endif
+
+/*
+ * Backwards compatibility macros for Objective-C lightweight generics.
+ */
+#if __has_feature(objc_generics)
+# define GS_GENERIC_CLASS(clz, ...) clz<__VA_ARGS__>
+# define GS_GENERIC_TYPE_F(typeRef, fallback) typeRef
+#else
+# define GS_GENERIC_CLASS(clz, ...) clz
+# define GS_GENERIC_TYPE_F(typeRef, fallback) fallback
+#endif
+#define GS_GENERIC_TYPE(typeRef) GS_GENERIC_TYPE_F(typeRef, id)
+
+/**
+ * Backwards compatibility macro for the objc_designated_initializer attribute
+ */
+#if __has_attribute(objc_designated_initializer)
+#  define NS_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
+#else
+#  define NS_DESIGNATED_INITIALIZER
+#endif
+
+/** Bitfield used to specify options to control enumeration over collections.
+ */
+typedef NS_OPTIONS(NSUInteger, NSEnumerationOptions)
+{
+  NSEnumerationConcurrent = (1UL << 0), /** Specifies that the enumeration
+   * is concurrency-safe.  Note that this does not mean that it will be
+   * carried out in a concurrent manner, only that it can be.
+   */
+
+  NSEnumerationReverse = (1UL << 1) /** Specifies that the enumeration should
+   * happen in the opposite of the natural order of the collection.
+   */
+};
+
+
+/** Bitfield used to specify options to control the sorting of collections.
+ */
+typedef NS_OPTIONS(NSUInteger, NSSortOptions)
+{
+    NSSortConcurrent = (1UL << 0), /** Specifies that the sort
+     * is concurrency-safe.  Note that this does not mean that it will be
+     * carried out in a concurrent manner, only that it can be.
+     */
+    NSSortStable = (1UL << 4) /** Specifies that the sort should keep
+     * equal objects in the same order in the collection.
+     */
+};
+
+
+#import "../GNUstepBase/GSObjCRuntime.h"
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST)
+GS_EXPORT NSString	*NSStringFromProtocol(Protocol *aProtocol);
+GS_EXPORT Protocol	*NSProtocolFromString(NSString *aProtocolName);
+#endif
+GS_EXPORT SEL		NSSelectorFromString(NSString *aSelectorName);
+GS_EXPORT NSString	*NSStringFromSelector(SEL aSelector);
+GS_EXPORT SEL		NSSelectorFromString(NSString *aSelectorName);
+GS_EXPORT Class		NSClassFromString(NSString *aClassName);
+GS_EXPORT NSString	*NSStringFromClass(Class aClass);
+GS_EXPORT const char	*NSGetSizeAndAlignment(const char *typePtr,
+  NSUInteger *sizep, NSUInteger *alignp);
+
+#if OS_API_VERSION(GS_API_NONE, GS_API_NONE)
+/* Logging */
+/**
+ *  OpenStep spec states that log messages go to stderr, but just in case
+ *  someone wants them to go somewhere else, they can implement a function
+ *  like this and assign a pointer to it to _NSLog_printf_handler.
+ */
+typedef void NSLog_printf_handler (NSString* message);
+GS_EXPORT NSLog_printf_handler	*_NSLog_printf_handler;
+GS_EXPORT int	_NSLogDescriptor;
+@class NSRecursiveLock;
+GS_EXPORT NSRecursiveLock	*GSLogLock(void);
+#endif
+
+GS_EXPORT void	NSLog(NSString *format, ...) NS_FORMAT_FUNCTION(1,2);
+GS_EXPORT void	NSLogv(NSString *format, va_list args) NS_FORMAT_FUNCTION(1,0);
+
+#ifndef YES
+#define YES		1
+#endif
+#ifndef NO
+#define NO		0
+#endif
+#ifndef nil
+#define nil		0
+#endif
+
+/**
+ * Contains values <code>NSOrderedSame</code>, <code>NSOrderedAscending</code>
+ * <code>NSOrderedDescending</code>, for left hand side equals, less than, or
+ * greater than right hand side.
+ */
+typedef NS_ENUM(NSInteger, NSComparisonResult)
+{
+  NSOrderedAscending = (NSInteger)-1, NSOrderedSame, NSOrderedDescending
+};
+
+enum {NSNotFound = NSIntegerMax};
+
+#if __BLOCKS__
+DEFINE_BLOCK_TYPE(NSComparator, NSComparisonResult, id, id);
+#endif
+
+/**
+ * Declare the foundation export macro as an alias to GS_EXPORT 
+ */
+#define FOUNDATION_EXPORT GS_EXPORT
+
+#if	defined(__cplusplus)
+}
+#endif
+
+/**
+ * Declare Apple availability macros for compatibility purposes as no-ops.
+ */
+#define NS_CLASS_AVAILABLE(...)
+#define NS_AVAILABLE(...)
+#define NS_AVAILABLE_MAC(...)
+#define NS_DEPRECATED(...)
+#define NS_DEPRECATED_MAC(...)
+#define NS_ENUM_AVAILABLE(...)
+#define NS_ENUM_AVAILABLE_MAC(...)
+#define NS_ENUM_DEPRECATED(...)
+#define NS_ENUM_DEPRECATED_MAC(...)
+#define NS_CLASS_AVAILABLE(...)
+#define NS_CLASS_DEPRECATED(...)
+#define NS_CLASS_AVAILABLE_MAC(...)
+#define NS_CLASS_DEPRECATED_MAC(...)
+#define NS_UNAVAILABLE
+
+/* Define root class NS macro */
+#ifndef NS_ROOT_CLASS
+#if __has_attribute(objc_root_class)
+#define NS_ROOT_CLASS __attribute__((objc_root_class))
+#else
+#define NS_ROOT_CLASS
+#endif
+#endif
+
+#endif /* __NSObjCRuntime_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSAutoreleasePool.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSAutoreleasePool.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSAutoreleasePool.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSAutoreleasePool.h	(revision 278653)
@@ -0,0 +1,333 @@
+/* Interface for NSAutoreleasePool for GNUStep
+   Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.
+
+   Written by:  Andrew Kachites McCallum <mccallum@gnu.ai.mit.edu>
+   Date: 1995
+   
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+   
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+   */ 
+
+#ifndef __NSAutoreleasePool_h_GNUSTEP_BASE_INCLUDE
+#define __NSAutoreleasePool_h_GNUSTEP_BASE_INCLUDE
+#import	"../GNUstepBase/GSVersionMacros.h"
+
+#import	"NSObject.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+@class NSAutoreleasePool;
+@class NSThread;
+
+
+/**
+ * Each thread has its own copy of these variables.
+ <example>
+{
+  NSAutoreleasePool *current_pool; // current pool for thread
+  unsigned total_objects_count;    // total #/autoreleased objects over thread's lifetime
+  id *pool_cache;                  // cache of previously-allocated pools,
+  int pool_cache_size;             //  used internally for recycling
+  int pool_cache_count;
+}
+ </example>
+*/
+typedef struct autorelease_thread_vars
+{
+  /* The current, default NSAutoreleasePool for the calling thread;
+     the one that will hold objects that are arguments to
+     [NSAutoreleasePool +addObject:]. */
+  __unsafe_unretained NSAutoreleasePool *current_pool;
+
+  /* The total number of objects autoreleased since the thread was
+     started, or since -resetTotalAutoreleasedObjects was called
+     in this thread. (if compiled in) */
+  unsigned total_objects_count;
+
+  /* A cache of NSAutoreleasePool's already alloc'ed.  Caching old pools
+     instead of deallocating and re-allocating them will save time. */
+  __unsafe_unretained id *pool_cache;
+  int pool_cache_size;
+  int pool_cache_count;
+} thread_vars_struct;
+
+/* Initialize an autorelease_thread_vars structure for a new thread.
+   This function is called in NSThread each time an NSThread is created.
+   TV should be of type `struct autorelease_thread_vars *' */
+#define init_autorelease_thread_vars(TV) \
+memset (TV, 0, sizeof (__typeof__ (*TV)))
+
+
+
+/**
+ *  Each pool holds its objects-to-be-released in a linked-list of 
+    these structures.
+    <example>
+{
+  struct autorelease_array_list *next;
+  unsigned size;
+  unsigned count;
+  id objects[0];
+}
+    </example>
+ */
+typedef struct autorelease_array_list
+{
+  struct autorelease_array_list *next;
+  unsigned size;
+  unsigned count;
+  __unsafe_unretained id objects[0];
+} array_list_struct;
+
+
+
+/**
+ * <p>
+ *   The standard OpenStep system of memory management employs retain counts.
+ *   When an object is created, it has a retain count of 1.  When an object
+ *   is retained, the retain count is incremented.  When it is released the
+ *   retain count is decremented, and when the retain count goes to zero the
+ *   object gets deallocated.
+ * </p>
+ * <p>
+ *   A simple retain/release mechanism has problems with passing objects
+ *   from one scope to another,
+ *   so it's augmented with autorelease pools.  You can use the
+ *   AUTORELEASE() macro to call the [NSObject-autorelease]
+ *   method, which adds an object to the current autorelease pool by
+ *   calling [NSAutoreleasePool+addObject:].<br />
+ *   An autorelease pool simply maintains a reference to each object
+ *   added to it, and for each addition, the autorelease pool will
+ *   call the [NSObject-release] method of the object when the pool
+ *   is released.  So doing an AUTORELEASE() is just the same as
+ *   doing a RELEASE(), but deferred until the current autorelease
+ *   pool is deallocated.
+ * </p>
+ * <p>
+ *   The NSAutoreleasePool class maintains a separate stack of
+ *   autorelease pools objects in each thread.
+ * </p>
+ * <p>
+ *   When an autorelease pool is created, it is automatically
+ *   added to the stack of pools in the thread.
+ * </p>
+ * <p>
+ *   When a pool is destroyed, it (and any pool later in
+ *   the stack) is removed from the stack.
+ * </p>
+ * <p>
+ *   This mechanism provides a simple but controllable and reasonably
+ *   efficient way of managing temporary objects.  An object can be
+ *   autoreleased and then passed around and used until the topmost 
+ *   pool in the stack is destroyed.
+ * </p>   
+ * <p>
+ *   Most methods return objects which are either owned by autorelease
+ *   pools or by the receiver of the method, so the lifetime of the
+ *   returned object can be assumed to be the shorter of the lifetime
+ *   of the current autorelease pool, or that of the receiver on which
+ *   the method was called.<br />
+ *   The exceptions to this are those object returned by -
+ * </p>
+ * <deflist>
+ *   <term>[NSObject+alloc], [NSObject+allocWithZone:]</term>
+ *   <desc>
+ *     Methods whose names begin with alloc return an uninitialised
+ *     object, owned by the caller.
+ *   </desc>
+ *   <term>[NSObject-init]</term>
+ *   <desc>
+ *     Methods whose names begin with init return an initialised
+ *     version of the receiving object, owned by the caller.<br />
+ *     NB. The returned object may not actually be the same as the
+ *     receiver ... sometimes an init method releases the original
+ *     receiver and returns an alternative.
+ *   </desc>
+ *   <term>[NSObject+new]</term>
+ *   <desc>
+ *     Methods whose names begin with new combine the effects of
+ *     allocation and initialisation.
+ *   </desc>
+ *   <term>[NSObject-copy], [(NSCopying)-copyWithZone:]</term>
+ *   <desc>
+ *     Methods whose names begin with copy create a copy of the receiver
+ *     which is owned by the caller.
+ *   </desc>
+ *   <term>
+ *     [NSObject-mutableCopy], [(NSMutableCopying)-mutableCopyWithZone:]
+ *   </term>
+ *   <desc>
+ *     Methods whose names begin with mutableCopy create a copy of the receiver
+ *     which is owned by the caller.
+ *   </desc>
+ * </deflist>
+ */
+NS_AUTOMATED_REFCOUNT_UNAVAILABLE
+@interface NSAutoreleasePool : NSObject 
+{
+#if	GS_EXPOSE(NSAutoreleasePool) && !__has_feature(objc_arc)
+  /* For re-setting the current pool when we are dealloc'ed. */
+  NSAutoreleasePool *_parent;
+  /* This pointer to our child pool is  necessary for co-existing
+     with exceptions. */
+  NSAutoreleasePool *_child;
+  /* A collection of the objects to be released. */
+  struct autorelease_array_list *_released;
+  struct autorelease_array_list *_released_head;
+  /* The total number of objects autoreleased in this pool. */
+  unsigned _released_count;
+  /* The method to add an object to this pool */
+  void 	(*_addImp)(id, SEL, id);
+#endif
+#if     GS_NONFRAGILE
+#else
+  /* Pointer to private additional data used to avoid breaking ABI
+   * when we don't have the non-fragile ABI available.
+   * Use this mechanism rather than changing the instance variable
+   * layout (see Source/GSInternal.h for details).
+   */
+  @private id _internal GS_UNUSED_IVAR;
+#endif
+}
+
+/**
+ * Adds anObj to the current autorelease pool.<br />
+ * If there is no autorelease pool in the thread,
+ * a warning is logged and the object is leaked (ie it will not be released).
+ */
++ (void) addObject: (id)anObj;
+
+/**
+ * Allocate and return an autorelease pool instance.<br />
+ * If there is an already-allocated NSAutoreleasePool available,
+ * save time by just returning that, rather than allocating a new one.<br />
+ * The pool instance becomes the current autorelease pool for this thread.
+ */
++ (id) allocWithZone: (NSZone*)zone;
+
+/**
+ * Adds anObj to this autorelease pool.
+ */
+- (void) addObject: (id)anObj;
+
+/**
+ * Raises an exception - pools should not be autoreleased.
+ */
+- (id) autorelease;
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4, GS_API_LATEST)
+/**
+ * Intended to trigger a garbage collection run (if needed) when called in
+ * a garbage collected environment.<br />
+ * In a non-garbage collected environment, this method implements the
+ * undocumented MacOS-X behavior, and releases the receiver.
+ */
+- (void) drain;
+#endif
+
+/**
+ * Destroys the receiver (calls -dealloc).
+ */
+- (oneway void) release;
+
+/**
+ * Raises an exception ... pools should not be retained.
+ */
+- (id) retain;
+
+#if OS_API_VERSION(GS_API_NONE, GS_API_NONE)
+/**
+ * <p>
+ *   Counts the number of times that the specified object occurs
+ *   in autorelease pools in the current thread.
+ * </p>
+ * <p>
+ *   This method is <em>slow</em> and should probably only be
+ *   used for debugging purposes.
+ * </p>
+ */
++ (unsigned) autoreleaseCountForObject: (id)anObject;
+
+/** 
+ * Return the currently active autorelease pool.
+ */
++ (id) currentPool;
+
+/**
+ * <p>
+ *   Specifies whether objects contained in autorelease pools are to
+ *   be released when the pools are deallocated (by default YES).
+ * </p>
+ * <p>
+ *   You can set this to NO for debugging purposes.
+ * </p>
+ */
++ (void) enableRelease: (BOOL)enable;
+
+/**
+ * <p>
+ *   When autorelease pools are deallocated, the memory they used
+ *   is retained in a cache for re-use so that new polls can be
+ *   created very quickly.
+ * </p>
+ * <p>
+ *   This method may be used to empty that cache, ensuring that
+ *   the minimum memory is used by the application.
+ * </p>
+ */
++ (void) freeCache;
+
+/**
+ * <p>
+ *   Specifies a limit to the number of objects that may be added to
+ *   an autorelease pool.  When this limit is reached an exception is
+ *   raised.
+ * </p>
+ * <p>
+ *   You can set this to a smallish value to catch problems with code
+ *   that autoreleases too many objects to operate efficiently.
+ * </p>
+ * <p>
+ *   Default value is maxint.
+ * </p>
+ */
++ (void) setPoolCountThreshold: (unsigned)c;
+
+/**
+ * Return the number of objects in this pool.
+ */
+- (unsigned) autoreleaseCount;
+
+/**
+ * Empties the current pool by releasing all the autoreleased objects
+ * in it.  Also destroys any child pools (ones created after
+ * the receiver in the same thread) causing any objects in those pools
+ * to be released.<br />
+ * This is a low cost (efficient) method which may be used to get rid of
+ * autoreleased objects in the pool, but carry on using the pool.
+ */
+- (void) emptyPool;
+#endif
+@end
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#endif /* __NSAutoreleasePool_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSObject.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSObject.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSObject.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSObject.h	(revision 278653)
@@ -0,0 +1,594 @@
+/**Interface for NSObject for GNUStep
+   Copyright (C) 1995, 1996, 1998 Free Software Foundation, Inc.
+
+   Written by:  Andrew Kachites McCallum <mccallum@gnu.ai.mit.edu>
+   Date: 1995
+   
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+   
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+
+   AutogsdocSource: NSObject.m
+   */ 
+
+#ifndef __NSObject_h_GNUSTEP_BASE_INCLUDE
+#define __NSObject_h_GNUSTEP_BASE_INCLUDE
+
+#import	"NSObjCRuntime.h"
+#import <objc/objc.h>
+#import	"NSZone.h"
+
+#ifdef	GS_WITH_GC
+#undef  GS_WITH_GC
+#endif
+#define	GS_WITH_GC	0
+
+#import	"../GNUstepBase/GNUstep.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+@class NSArchiver;
+@class NSArray;
+@class NSCoder;
+@class NSDictionary;
+@class NSPortCoder;
+@class NSMethodSignature;
+@class NSMutableString;
+@class NSRecursiveLock;
+@class NSString;
+@class NSInvocation;
+@class Protocol;
+
+/**
+ * The NSObject protocol describes a minimal set of methods that all
+ * objects are expected to support.  You should be able to send any
+ * of the messages listed in this protocol to an object, and be safe
+ * in assuming that the receiver can handle it.
+ */
+@protocol NSObject
+/**
+ * Returns the class of the receiver.  If the receiver is a proxy, then this
+ * may return the class of the proxy target.  Use -isProxy to determine whether
+ * the receiver is a proxy.  If you wish to find the real class of the
+ * receiver, ignoring proxies, then use object_getClass().  
+ */
+- (Class) class;
+/**
+ * Returns the superclass of receiver's class.  If the receiver is a proxy,
+ * then this may return the class of the proxy target.  Use -isProxy to
+ * determine whether the receiver is a proxy.  If you wish to find the real
+ * superclass of the receiver's class, ignoring proxies, then use
+ * class_getSuperclass(object_getClass()).
+ */
+- (Class) superclass;
+/**
+ * Returns whether the receiver is equal to the argument.  Defining equality is
+ * complex, so be careful when implementing this method.  Collections such as
+ * NSSet depend on the behaviour of this method.  In particular, this method
+ * must be commutative, so for any objects a and b:
+ *
+ * [a isEqual: b] == [b isEqual: a]
+ *
+ * This means that you must be very careful when returning YES if the argument
+ * is of another class.  For example, if you define a number class that returns
+ * YES if the argument is a string representation of the number, then this will
+ * break because the string will not recognise your object as being equal to
+ * itself.
+ *
+ * If two objects are equal, then they must have the same hash value, however
+ * equal hash values do not imply equality.
+ */
+- (BOOL) isEqual: (id)anObject;
+/**
+ * Returns YES if the receiver is an instance of the class, an instance of the
+ * subclass, or (in the case of proxies), an instance of something that can be
+ * treated as an instance of the class.
+ */
+- (BOOL) isKindOfClass: (Class)aClass;
+/**
+ * Returns YES if the receiver is an instance of the class or (in the case of
+ * proxies), an instance of something that can be treated as an instance of the
+ * class.
+ *
+ * Calling this method is rarely the correct thing to do.  In most cases, a
+ * subclass can be substituted for a superclass, so you should never need to
+ * check that an object is really an instance of a specific class and not a
+ * subclass.  
+ */
+- (BOOL) isMemberOfClass: (Class)aClass;
+/**
+ * Returns YES if the receiver is a proxy, NO otherwise.  The default
+ * implementation of this method in NSObject returns NO, while the
+ * implementation in NSProxy returns YES.
+ */
+- (BOOL) isProxy;
+/**
+ * Returns a hash value for the object.  All objects that are equal *MUST*
+ * return the same hash value.  For efficient storage in sets, or as keys in
+ * dictionaries, different objects should return hashes spread evenly over the
+ * range of an integer.
+ *
+ * An object may not return different values from this method after being
+ * stored in a collection.  This typically means that ether the hash value must
+ * be constant after the object's creation, or that the object may not be
+ * modified while stored in an unordered collection.
+ */
+- (NSUInteger) hash;
+/**
+ * Returns the receiver.  In a proxy, this may (but is not required to) return
+ * the proxied object.
+ */
+- (id) self;
+/**
+ * Performs the specified selector.  The selector must correspond to a method
+ * that takes no arguments.
+ */
+- (id) performSelector: (SEL)aSelector;
+/**
+ * Performs the specified selector, with the object as the argument.  This
+ * method does not perform any automatic unboxing, so the selector must
+ * correspond to a method that takes one object argument.
+ */
+- (id) performSelector: (SEL)aSelector
+	    withObject: (id)anObject;
+/**
+ * Performs the specified selector, with the objects as the arguments.  This
+ * method does not perform any automatic unboxing, so the selector must
+ * correspond to a method that takes two object arguments.
+ */
+- (id) performSelector: (SEL)aSelector
+	    withObject: (id)object1
+	    withObject: (id)object2;
+/**
+ * Returns YES if the object can respond to messages with the specified
+ * selector.  The default implementation in NSObject returns YES if the
+ * receiver has a method corresponding to the method, but other classes may
+ * return YES if they can respond to a selector using one of the various
+ * forwarding mechanisms.
+ */
+- (BOOL) respondsToSelector: (SEL)aSelector;
+/**
+ * Returns YES if the receiver conforms to the specified protocol.
+ */
+- (BOOL) conformsToProtocol: (Protocol*)aProtocol;
+/**
+ * Increments the reference count of the object and returns the receiver.  In
+ * garbage collected mode, this method does nothing.  In automated reference
+ * counting mode, you may neither implement this method nor call it directly.
+ */
+- (id) retain NS_AUTOMATED_REFCOUNT_UNAVAILABLE;
+/**
+ * Decrements the reference count of the object and destroys if it there are no
+ * remaining references.  In garbage collected mode, this method does nothing.
+ * In automated reference counting mode, you may neither implement this method
+ * nor call it directly.
+ */
+- (oneway void) release NS_AUTOMATED_REFCOUNT_UNAVAILABLE;
+/**
+ * Performs a deferred -release operation.  The object's reference count is
+ * decremented at the end of the scope of the current autorelease pool,
+ * identified either by a -drain message sent to the current NSAutoreleasePool
+ * instance, or in more recent versions of Objective-C by the end of an
+ * @autorelease_pool scope.
+ *
+ * In garbage collected mode, this method does nothing.  In automated reference
+ * counting mode, you may neither implement this method nor call it directly.
+ */
+- (id) autorelease NS_AUTOMATED_REFCOUNT_UNAVAILABLE;
+/**
+ * Returns the current retain count of an object.  This does not include the
+ * result of any pending autorelease operations.
+ *
+ * Code that relies on this method returning a sane value is broken.  For
+ * singletons, it may return NSUIntegerMax.  Even when it is tracking a retain
+ * count, it will not include on-stack pointers in manual retain/release mode,
+ * pointers marked as __unsafe_unretain or __weak in ARC mode, or pending
+ * autorelease operations.  Its value is therefore largely meaningless.  It can
+ * occasionally be useful for debugging.
+ */
+- (NSUInteger) retainCount NS_AUTOMATED_REFCOUNT_UNAVAILABLE;
+/**
+ * Returns the description of the object.  This is used by the %@ format
+ * specifier in strings.
+ */
+- (NSString*) description;
+/**
+ * Returns the zone of the object.
+ */
+- (NSZone*) zone NS_AUTOMATED_REFCOUNT_UNAVAILABLE;
+@end
+
+/**
+ * This protocol must be adopted by any class wishing to support copying -
+ * ie where instances of the class should be able to create new instances
+ * which are copies of the original and, where a class has mutable and
+ * immutable versions, where the copies are immutable.
+ */
+@protocol NSCopying
+/**
+ * Called by [NSObject-copy] passing NSDefaultMallocZone() as zone.<br />
+ * This method returns a copy of the receiver and, where the receiver is a
+ * mutable variant of a class which has an immutable partner class, the
+ * object returned is an instance of that immutable class.<br />
+ * The new object is <em>not</em> autoreleased, and is considered to be
+ * 'owned' by the calling code ... which is therefore responsible for
+ * releasing it.<br />
+ * In the case where the receiver is an instance of a container class,
+ * it is undefined whether contained objects are merely retained in the
+ * new copy, or are themselves copied, or whether some other mechanism
+ * entirely is used.
+ */
+- (id) copyWithZone: (NSZone*)zone;
+@end
+
+/**
+ * This protocol must be adopted by any class wishing to support
+ * mutable copying - ie where instances of the class should be able
+ * to create mutable copies of themselves.
+ */
+@protocol NSMutableCopying
+/**
+ * Called by [NSObject-mutableCopy] passing NSDefaultMallocZone() as zone.<br />
+ * This method returns a copy of the receiver and, where the receiver is an
+ * immutable variant of a class which has a mutable partner class, the
+ * object returned is an instance of that mutable class.
+ * The new object is <em>not</em> autoreleased, and is considered to be
+ * 'owned' by the calling code ... which is therefore responsible for
+ * releasing it.<br />
+ * In the case where the receiver is an instance of a container class,
+ * it is undefined whether contained objects are merely retained in the
+ * new copy, or are themselves copied, or whether some other mechanism
+ * entirely is used.
+ */
+- (id) mutableCopyWithZone: (NSZone*)zone;
+@end
+
+/**
+ * This protocol must be adopted by any class wishing to support
+ * saving and restoring instances to an archive, or copying them
+ * to remote processes via the Distributed Objects mechanism.
+ */
+@protocol NSCoding
+
+/**
+ * Called when it is time for receiver to be serialized for writing to an
+ * archive or network connection.  Receiver should record all of its instance
+ * variables using methods on aCoder.  See documentation for [NSCoder],
+ * [NSArchiver], [NSKeyedArchiver], and/or [NSPortCoder] for more information.
+ */
+- (void) encodeWithCoder: (NSCoder*)aCoder;
+
+/**
+ * Called on a freshly allocated receiver when it is time to reconstitute from
+ * serialized bytes in an archive or from a network connection.  Receiver
+ * should load all of its instance variables using methods on aCoder.  See
+ * documentation for [NSCoder], [NSUnarchiver], [NSKeyedUnarchiver], and/or
+ * [NSPortCoder] for more information.
+ */
+- (id) initWithCoder: (NSCoder*)aDecoder;
+@end
+
+@protocol NSSecureCoding <NSCoding>
++ (BOOL)supportsSecureCoding;
+@end
+
+
+GS_ROOT_CLASS @interface NSObject <NSObject>
+{
+ /**
+  * Points to instance's class.  Used by runtime to access method
+  * implementations, etc..  Set in +alloc, Unlike other instance variables,
+  * which are cleared there.
+  */
+  Class isa;
+}
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+/** On a system which performs garbage collection, you should implement
+ * this method to execute code when the receiver is collected.<br />
+ * You must not call this method yourself (except when a subclass
+ * calls the superclass method within its own implementation).
+ */
+- (void) finalize;
+#endif
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+- (NSString*) className;
+#endif
+
++ (id) allocWithZone: (NSZone*)z;
++ (id) alloc;
++ (Class) class;
+
+/**
+ * This method is automatically invoked on any class which implements it
+ * when the class is loaded into the runtime.<br />
+ * It is also invoked on any category where the method is implemented
+ * when that category is loaded into the runtime.<br />
+ * The +load method is called directly by the runtime and you should never
+ * send a +load message to a class yourself.<br />
+ * This method is called <em>before</em> the +initialize message is sent
+ * to the class, so you cannot depend on class initialisation having been
+ * performed, or upon other classes existing (apart from superclasses of
+ * the receiver, since +load is called on superclasses before it is called
+ * on their subclasses).<br />
+ * As a gross generalisation, it is safe to use C code, including
+ * most ObjectiveC runtime functions within +load, but attempting to send
+ * messages to ObjectiveC objects is likely to fail.<br />
+ * In GNUstep, this method is implemented for NSObject to perform some
+ * initialisation for the base library.<br />
+ * If you implement +load for a class, don't call [super load] in your
+ * implementation.
+ */
++ (void) load;
+
+/**
+ * This message is automatically sent to a class by the runtime.  It is
+ * sent once for each class, just before the class is used for the first
+ * time (excluding any automatic call to +load by the runtime).<br />
+ * The message is sent in a thread-safe manner ... other threads may not
+ * call methods of the class until +initialize has finished executing.<br />
+ * If the class has a superclass, its implementation of +initialize is
+ * called first.<br />
+ * If the class does not implement +initialize then the implementation
+ * in the closest superclass may be called.  This means that +initialize may
+ * be called more than once, and the recommended way to handle this by
+ * using the
+ * <code>
+ * if (self == [classname class])
+ * </code>
+ * conditional to check whether the method is being called for a subclass.<br />
+ * You should never call +initialize yourself ... let the runtime do it.<br />
+ * You can implement +initialize in your own class if you need to.
+ * NSObject's implementation handles essential root object and base
+ * library initialization.<br />
+ * It should be safe to call [super initialize] in your implementation
+ * of +initialize.
+ */
++ (void) initialize;
++ (IMP) instanceMethodForSelector: (SEL)aSelector;
++ (NSMethodSignature*) instanceMethodSignatureForSelector: (SEL)aSelector;
++ (BOOL) instancesRespondToSelector: (SEL)aSelector;
++ (BOOL) isSubclassOfClass: (Class)aClass;
++ (id) new;
++ (void) poseAsClass: (Class)aClassObject;
++ (id) setVersion: (NSInteger)aVersion;
++ (NSInteger) version;
+
+- (id) awakeAfterUsingCoder: (NSCoder*)aDecoder;
+- (Class) classForArchiver;
+- (Class) classForCoder;
+- (id) copy;
+- (void) dealloc;
+- (void) doesNotRecognizeSelector: (SEL)aSelector;
+- (void) forwardInvocation: (NSInvocation*)anInvocation;
+- (id) init;
+- (IMP) methodForSelector: (SEL)aSelector;
+- (NSMethodSignature*) methodSignatureForSelector: (SEL)aSelector;
+- (id) mutableCopy;
+- (id) replacementObjectForArchiver: (NSArchiver*)anArchiver;
+- (id) replacementObjectForCoder: (NSCoder*)anEncoder;
+- (Class) superclass;
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5, GS_API_LATEST)
+/**
+ * This method will be called when attempting to send a message a class that
+ * does not understand it.  The class may install a new method for the given
+ * selector and return YES, otherwise it should return NO.
+ *
+ * Note: This method is only reliable when using the GNUstep runtime.  If you
+ * require compatibility with the GCC runtime, you must also implement
+ * -forwardInvocation: with equivalent semantics.  This will be considerably
+ *  slower, but more portable.
+ */
++ (BOOL) resolveClassMethod: (SEL)name;
+
+/**
+ * This method will be called when attempting to send a message an instance
+ * that does not understand it.  The class may install a new method for the
+ * given selector and return YES, otherwise it should return NO.
+ *
+ * Note: This method is only reliable when using the GNUstep runtime.  If you
+ * require compatibility with the GCC runtime, you must also implement
+ * -forwardInvocation: with equivalent semantics.  This will be considerably
+ *  slower, but more portable.
+ */
++ (BOOL) resolveInstanceMethod: (SEL)name;
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+/**
+ * Returns an auto-accessing proxy for the given object.  This proxy sends a
+ * -beginContentAccess message to the receiver when it is created and an
+ * -endContentAccess message when it is destroyed.  This prevents an object
+ * that implements the NSDiscardableContent protocol from having its contents
+ * discarded for as long as the proxy exists.  
+ *
+ * On systems using the GNUstep runtime, messages send to the proxy will be
+ * slightly slower than direct messages.  With the GCC runtime, they will be
+ * approximately two orders of magnitude slower.  The GNUstep runtime,
+ * therefore, is strongly recommended for code calling this method.
+ */
+- (id) autoContentAccessingProxy;
+
+/**
+ * If an object does not understand a message, it may delegate it to another
+ * object.  Returning nil indicates that forwarding should not take place.  The
+ * default implementation of this returns nil, but care should be taken when
+ * subclassing NSObject subclasses and overriding this method that
+ * the superclass implementation is called if returning nil.
+ *
+ * Note: This method is only reliable when using the GNUstep runtime and code
+ * compiled with clang.  If you require compatibility with GCC and the GCC
+ * runtime, you must also implement -forwardInvocation: with equivalent
+ * semantics.  This will be considerably slower, but more portable.
+ */
+- (id) forwardingTargetForSelector: (SEL)aSelector;
+
+#endif
+@end
+
+/**
+ * Used to allocate memory to hold an object, and initialise the
+ * class of the object to be aClass etc.  The allocated memory will
+ * be extraBytes larger than the space actually needed to hold the
+ * instance variables of the object.<br />
+ * This function is used by the [NSObject+allocWithZone:] method.
+ */
+GS_EXPORT id
+NSAllocateObject(Class aClass, NSUInteger extraBytes, NSZone *zone);
+
+/**
+ * Used to release the memory used by an object.<br />
+ * This function is used by the [NSObject-dealloc] method.
+ */
+GS_EXPORT void
+NSDeallocateObject(id anObject);
+
+/**
+ * Used to copy anObject.  This makes a bitwise copy of anObject to
+ * memory allocated from zone.  The allocated memory will be extraBytes
+ * longer than that necessary to actually store the instance variables
+ * of the copied object.<br />
+ */
+GS_EXPORT NSObject *
+NSCopyObject(NSObject *anObject, NSUInteger extraBytes, NSZone *zone);
+
+/**
+ * Returns a flag to indicate whether anObject should be retained or
+ * copied in order to make a copy in the specified zone.<br />
+ * Basically, this tests to see if anObject was allocated from
+ * requestedZone and returns YES if it was.
+ */
+GS_EXPORT BOOL
+NSShouldRetainWithZone(NSObject *anObject, NSZone *requestedZone);
+
+GS_EXPORT BOOL
+NSDecrementExtraRefCountWasZero(id anObject);
+
+GS_EXPORT NSUInteger
+NSExtraRefCount(id anObject);
+
+GS_EXPORT void
+NSIncrementExtraRefCount(id anObject);
+
+#if OS_API_VERSION(GS_API_NONE, GS_API_NONE)
+
+/** Global lock to be used by classes when operating on any global
+    data that invoke other methods which also access global; thus,
+    creating the potential for deadlock. */
+GS_EXPORT NSRecursiveLock *gnustep_global_lock;
+
+@interface NSObject (NEXTSTEP)
+- (id) error:(const char *)aString, ...;
+/* - (const char *) name;
+   Removed because OpenStep has -(NSString*)name; */
+@end
+
+#if GS_API_VERSION(GS_API_NONE, 011700)
+@interface NSObject (GNUstep)
++ (void) enableDoubleReleaseCheck: (BOOL)enable;
+@end
+#endif
+
+#endif
+
+#import	"NSDate.h"
+/**
+ *  Declares some methods for sending messages to self after a fixed delay.
+ *  (These methods <em>are</em> in OpenStep and OS X.)
+ */
+@interface NSObject (TimedPerformers)
+
+/**
+ * Cancels any perform operations set up for the specified target
+ * in the current run loop.
+ */
++ (void) cancelPreviousPerformRequestsWithTarget: (id)obj;
+
+/**
+ * Cancels any perform operations set up for the specified target
+ * in the current loop, but only if the value of aSelector and argument
+ * with which the performs were set up match those supplied.<br />
+ * Matching of the argument may be either by pointer equality or by
+ * use of the [NSObject-isEqual:] method.
+ */
++ (void) cancelPreviousPerformRequestsWithTarget: (id)obj
+					selector: (SEL)s
+					  object: (id)arg;
+/**
+ * Sets given message to be sent to this instance after given delay,
+ * in any run loop mode.  See [NSRunLoop].
+ */
+- (void) performSelector: (SEL)s
+	      withObject: (id)arg
+	      afterDelay: (NSTimeInterval)seconds;
+
+/**
+ * Sets given message to be sent to this instance after given delay,
+ * in given run loop modes.  See [NSRunLoop].
+ */
+- (void) performSelector: (SEL)s
+	      withObject: (id)arg
+	      afterDelay: (NSTimeInterval)seconds
+		 inModes: (NSArray*)modes;
+@end
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_6, GS_API_LATEST)
+/**
+ * The NSDiscardableContent protocol is used by objects which encapsulate data
+ * which may be discarded if resource constraints are exceeded.  These
+ * constraints are typically, but not always, related memory.  
+ */
+@protocol NSDiscardableContent
+
+/**
+ * This method is called before any access to the object.  It returns YES if
+ * the object's content is still valid.  The caller must call -endContentAccess
+ * once for every call to -beginContentAccess;
+ */
+- (BOOL) beginContentAccess;
+
+/**
+ * Discards the contents of the object if it is not currently being edited.
+ */
+- (void) discardContentIfPossible;
+
+/**
+ * This method indicates that the caller has finished accessing the contents of
+ * the object adopting this protocol.  Every call to -beginContentAccess must
+ * be be paired with a call to this method after the caller has finished
+ * accessing the contents.
+ */
+- (void) endContentAccess;
+
+/**
+ * Returns YES if the contents of the object have been discarded, either via a
+ * call to -discardContentIfPossible while the object is not in use, or by some
+ * implementation dependent mechanism.  
+ */
+- (BOOL) isContentDiscarded;
+@end
+#endif
+#if	defined(__cplusplus)
+}
+#endif
+
+#if     !NO_GNUSTEP && !defined(GNUSTEP_BASE_INTERNAL)
+#import "../GNUstepBase/NSObject+GNUstepBase.h"
+#endif
+
+#endif /* __NSObject_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSString.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSString.h b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSString.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/GNUStep/Foundation/NSString.h	(revision 278653)
@@ -0,0 +1,977 @@
+/* Interface for NSString for GNUstep
+   Copyright (C) 1995, 1996, 1999 Free Software Foundation, Inc.
+
+   Written by:  Andrew Kachites McCallum <mccallum@gnu.ai.mit.edu>
+   Date: 1995
+   
+   This file is part of the GNUstep Base Library.
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+   
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+   
+   You should have received a copy of the GNU Lesser General Public
+   License along with this library; if not, write to the Free
+   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02111 USA.
+  */
+
+/**
+<chapter>
+ <heading>Portable path handling</heading>
+ <p>Portable path handling (across both unix-like and mswindows operating
+ systems) requires some care.  A modern operating system uses the concept
+ of a single root to the filesystem, but mswindows has multiple filesystems
+ with no common root, so code must be aware of this.  There is also the
+ more minor issue that windows often uses a backslash as a separator between
+ the components of a path and unix-like systems always use forward slash.<br />
+ On windows there is also the issue that two styles of path are used,
+ most commonly with a drive letter and a path on that drive
+ (eg. 'C:\directory\file') but also UNC paths
+ (eg. '//host/share/directory/file') so path handling functions must deal
+ with both formats.
+ </p>
+ <p>GNUstep has three path handling modes, 'gnustep', 'unix', and 'windows'.
+ The mode defaults to 'gnustep' but may be set using the GSPathHandling()
+ function.<br />
+ You should probably stick to using the default 'gnustep' mode in which the
+ path handling methods cope with both 'unix' and 'windows' style paths in
+ portable and tolerant manner:<br />
+ Paths are read in literally so they can be in the native format provided
+ by the operating system or in a non-native format. See
+ [NSFileManager-stringWithFileSystemRepresentation:length:].<br />
+ Paths are written out using the native format of the system the application
+ is running on (eg on windows slashes are converted to backslashes).
+ See [NSFileManager-fileSystemRepresentationWithPath:].<br />
+ The path handling methods accept either a forward or backward slash as a
+ path separator when parsing any path.<br />
+ Unless operating in 'unix' mode, a leading letter followed by a colon is
+ considered the start of a windows style path (the drive specifier), and a
+ path beginning with something of the form '//host/share/' is considered
+ the start of a UNC style path.<br />
+ The path handling methods add forward slashes when building new paths
+ internally or when standardising paths, so those path strings provide
+ a portable representation (as long as they are relative paths, not including
+ system specific roots).<br />
+ An important case to note is that on windows a path which looks at first
+ glance like an absolute path may actually be a relative one.<br />
+ 'C:file' is a relative path because it specifies  a file on the C drive
+ but does not say what directory it is in.<br />
+Similarly, '/dir/file' is a relative path because it specifies the full
+location fo a file on a drive, but does not specify which drive it is on.
+ </p>
+<p>As a consequence of this path handling, you are able to work completely
+portably using relative paths (adding components, extensions and
+relative paths to a pth, or removing components, extensions and relative
+paths from a path etc), and when you save paths as strings in files
+which may be transferred to another platform, you should save a relative
+path.<br />
+When you need to know absolute paths of various points in the filesystem,
+you can use various path utility functions to obtain those absolute paths.
+For instance, instead of saving an absolute path to a file, you might want
+to save a path relative to a user's home directory.  You could do that by
+calling NSHomeDirectory() to get the home directory, and only saving the
+part of the full path after that prefix.
+</p>
+</chapter>
+ */ 
+
+#ifndef __NSString_h_GNUSTEP_BASE_INCLUDE
+#define __NSString_h_GNUSTEP_BASE_INCLUDE
+#import	"../GNUstepBase/GSVersionMacros.h"
+
+#import	"NSObject.h"
+#import	"NSRange.h"
+
+#if	defined(__cplusplus)
+extern "C" {
+#endif
+
+/**
+ * Type for representing unicode characters.  (16-bit)
+ */
+typedef uint16_t unichar;
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
+#define NSMaximumStringLength   (INT_MAX-1)
+#endif
+
+@class NSArray;
+@class NSCharacterSet;
+@class NSData;
+@class NSDictionary;
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+@class NSError;
+@class NSLocale;
+@class NSURL;
+#endif
+
+#define NSMaximumStringLength	(INT_MAX-1)
+
+enum 
+{
+  NSCaseInsensitiveSearch = 1,
+  NSLiteralSearch = 2,
+  NSBackwardsSearch = 4,
+  NSAnchoredSearch = 8,
+  NSNumericSearch = 64	/* MacOS-X 10.2 */
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
+ ,
+ NSDiacriticInsensitiveSearch = 128,
+ NSWidthInsensitiveSearch = 256,
+ NSForcedOrderingSearch = 512
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_7,GS_API_LATEST) 
+ ,
+ /**
+  * Treats the search string as a regular expression.  This option may be
+  * combined with NSCaseInsensitiveSearch and NSAnchoredSearch, but no other
+  * search options.
+  *
+  * This option may only be used with the -rangeOfString: family of methods.
+  */
+ NSRegularExpressionSearch = 1024
+#endif
+};
+typedef NSUInteger NSStringCompareOptions;
+
+/**
+ *  <p>Enumeration of available encodings for converting between bytes and
+ *  characters (in [NSString]s).  The ones that are shared with OpenStep and
+ *  Cocoa are: <code>NSASCIIStringEncoding, NSNEXTSTEPStringEncoding,
+ *  NSJapaneseEUCStringEncoding, NSUTF8StringEncoding,
+ *  NSISOLatin1StringEncoding, NSSymbolStringEncoding,
+ *  NSNonLossyASCIIStringEncoding, NSShiftJISStringEncoding,
+ *  NSISOLatin2StringEncoding, NSUnicodeStringEncoding,
+ *  NSWindowsCP1251StringEncoding, NSWindowsCP1252StringEncoding,
+ *  NSWindowsCP1253StringEncoding, NSWindowsCP1254StringEncoding,
+ *  NSWindowsCP1250StringEncoding, NSISO2022JPStringEncoding,
+ *  NSMacOSRomanStringEncoding, NSProprietaryStringEncoding</code>.</p>
+ *  
+ *  <p>Additional encodings available under GNUstep are:
+ *  <code>NSKOI8RStringEncoding, NSISOLatin3StringEncoding,
+ *  NSISOLatin4StringEncoding, NSISOCyrillicStringEncoding,
+ *  NSISOArabicStringEncoding, NSISOGreekStringEncoding,
+ *  NSISOHebrewStringEncoding, NSISOLatin5StringEncoding,
+ *  NSISOLatin6StringEncoding, NSISOThaiStringEncoding,
+ *  NSISOLatin7StringEncoding, NSISOLatin8StringEncoding,
+ *  NSISOLatin9StringEncoding, NSGB2312StringEncoding, NSUTF7StringEncoding,
+ *  NSGSM0338StringEncoding, NSBIG5StringEncoding,
+ *  NSKoreanEUCStringEncoding</code>.</p>
+ */
+typedef enum _NSStringEncoding
+{
+/* NB. Must not have an encoding with value zero - so we can use zero to
+   tell that a variable that should contain an encoding has not yet been
+   initialised */
+  GSUndefinedEncoding = 0,
+  NSASCIIStringEncoding = 1,
+  NSNEXTSTEPStringEncoding = 2,
+  NSJapaneseEUCStringEncoding = 3,
+  NSUTF8StringEncoding = 4,
+  NSISOLatin1StringEncoding = 5,	// ISO-8859-1; West European
+  NSSymbolStringEncoding = 6,
+  NSNonLossyASCIIStringEncoding = 7,
+  NSShiftJISStringEncoding = 8,
+  NSISOLatin2StringEncoding = 9,	// ISO-8859-2; East European
+  NSUnicodeStringEncoding = 10,
+  NSUTF16StringEncoding = NSUnicodeStringEncoding,      // An alias
+  NSWindowsCP1251StringEncoding = 11,
+  NSWindowsCP1252StringEncoding = 12,	// WinLatin1
+  NSWindowsCP1253StringEncoding = 13,	// Greek
+  NSWindowsCP1254StringEncoding = 14,	// Turkish
+  NSWindowsCP1250StringEncoding = 15,	// WinLatin2
+  NSISO2022JPStringEncoding = 21,
+  NSMacOSRomanStringEncoding = 30,
+  NSProprietaryStringEncoding = 31,
+
+  NSKOI8RStringEncoding = 50,		// Russian/Cyrillic
+  NSISOLatin3StringEncoding = 51,	// ISO-8859-3; South European
+  NSISOLatin4StringEncoding = 52,	// ISO-8859-4; North European
+  NSISOCyrillicStringEncoding = 22,	// ISO-8859-5
+  NSISOArabicStringEncoding = 53,	// ISO-8859-6
+  NSISOGreekStringEncoding = 54,	// ISO-8859-7
+  NSISOHebrewStringEncoding = 55,	// ISO-8859-8
+  NSISOLatin5StringEncoding = 57,	// ISO-8859-9; Turkish
+  NSISOLatin6StringEncoding = 58,	// ISO-8859-10; Nordic
+  NSISOThaiStringEncoding = 59,		// ISO-8859-11
+/* Possible future ISO-8859 additions
+					// ISO-8859-12
+*/
+  NSISOLatin7StringEncoding = 61,	// ISO-8859-13
+  NSISOLatin8StringEncoding = 62,	// ISO-8859-14
+  NSISOLatin9StringEncoding = 63,	// ISO-8859-15; Replaces ISOLatin1
+  NSGB2312StringEncoding = 56,
+  NSUTF7StringEncoding = 64,		// RFC 2152
+  NSGSM0338StringEncoding,		// GSM (mobile phone) default alphabet
+  NSBIG5StringEncoding,			// Traditional chinese
+  NSKoreanEUCStringEncoding		// Korean
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST) 
+  ,
+  NSUTF16BigEndianStringEncoding = 0x90000100,
+  NSUTF16LittleEndianStringEncoding = 0x94000100,
+  NSUTF32StringEncoding = 0x8c000100,
+  NSUTF32BigEndianStringEncoding = 0x98000100,
+  NSUTF32LittleEndianStringEncoding = 0x9c000100
+#endif
+} NSStringEncoding;
+
+enum {
+  NSOpenStepUnicodeReservedBase = 0xF400
+};
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST) 
+enum {
+  NSStringEncodingConversionAllowLossy = 1,
+  NSStringEncodingConversionExternalRepresentation = 2
+};
+typedef NSUInteger NSStringEncodingConversionOptions;
+#endif
+
+/**
+ * <p>
+ *   <code>NSString</code> objects represent an immutable string of Unicode 3.0
+ *   characters.  These may be accessed individually as type
+ *   <code>unichar</code>, an unsigned short.<br/>
+ *   The [NSMutableString] subclass represents a modifiable string.  Both are
+ *   implemented as part of a class cluster and the instances you receive may
+ *   actually be of unspecified concrete subclasses.
+ * </p>
+ * <p>
+ *   A constant <code>NSString</code> can be created using the following syntax:
+ *   <code>@"..."</code>, where the contents of the quotes are the
+ *   string, using only ASCII characters.
+ * </p>
+ * <p>
+ *   A variable string can be created using a C printf-like <em>format</em>,
+ *   as in <code>[NSString stringWithFormat: @"Total is %f", t]</code>.
+ * </p>
+ * <p>
+ *   To create a concrete subclass of <code>NSString</code>, you must have your
+ *   class inherit from <code>NSString</code> and override at least the two
+ *   primitive methods - -length and -characterAtIndex:
+ * </p>
+ * <p>
+ *   In general the rule is that your subclass must override any
+ *   initialiser that you want to use with it.  The GNUstep
+ *   implementation relaxes that to say that, you may override
+ *   only the <em>designated initialiser</em> and the other
+ *   initialisation methods should work.
+ * </p>
+ * <p>
+ *   Where an NSString instance method returns an NSString object,
+ *   the class of the actual object returned may be any subclass
+ *   of NSString.  The actual value returned may be a new
+ *   autoreleased object, an autoreleased copy of the receiver,
+ *   or the receiver itsself.  While the abstract base class
+ *   implementations of methods (other than initialisers) will
+ *   avoid returning mutable strings by returning an autoreleased
+ *   copy of a mutable receiver, concrete subclasses may behave
+ *   differently, so code should not rely upon the mutability of
+ *   returned strings nor upon their lifetime being greater than
+ *   that of the receiver which returned them.
+ * </p>
+ */
+@interface NSString :NSObject <NSCoding, NSCopying, NSMutableCopying>
+
++ (id) string;
++ (id) stringWithCharacters: (const unichar*)chars
+		     length: (NSUInteger)length;
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST) && GS_API_VERSION( 10200,GS_API_LATEST)
++ (id) stringWithCString: (const char*)byteString
+		encoding: (NSStringEncoding)encoding;
+#endif
++ (id) stringWithCString: (const char*)byteString
+		  length: (NSUInteger)length;
++ (id) stringWithCString: (const char*)byteString;
++ (id) stringWithFormat: (NSString*)format, ... NS_FORMAT_FUNCTION(1,2);
++ (id) stringWithContentsOfFile:(NSString *)path;
+
+// Initializing Newly Allocated Strings
+- (id) init;
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST) && GS_API_VERSION( 10200,GS_API_LATEST)
+- (id) initWithBytes: (const void*)bytes
+	      length: (NSUInteger)length
+	    encoding: (NSStringEncoding)encoding;
+- (id) initWithBytesNoCopy: (void*)bytes
+		    length: (NSUInteger)length
+		  encoding: (NSStringEncoding)encoding 
+	      freeWhenDone: (BOOL)flag;
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST)
++ (id) stringWithContentsOfFile: (NSString*)path
+                   usedEncoding: (NSStringEncoding*)enc
+                          error: (NSError**)error;
+- (id) initWithContentsOfFile: (NSString*)path
+                 usedEncoding: (NSStringEncoding*)enc
+                        error: (NSError**)error;
++ (id) stringWithContentsOfFile: (NSString*)path
+                       encoding: (NSStringEncoding)enc
+                          error: (NSError**)error;
+- (id) initWithContentsOfFile: (NSString*)path
+                     encoding: (NSStringEncoding)enc
+                        error: (NSError**)error;
++ (id) stringWithContentsOfURL: (NSURL*)url
+                  usedEncoding: (NSStringEncoding*)enc
+                         error: (NSError**)error;
+- (id) initWithContentsOfURL: (NSURL*)url
+                usedEncoding: (NSStringEncoding*)enc
+                       error: (NSError**)error;
++ (id) stringWithContentsOfURL: (NSURL*)url
+                      encoding: (NSStringEncoding)enc
+                         error: (NSError**)error;
+- (id) initWithContentsOfURL: (NSURL*)url
+                    encoding: (NSStringEncoding)enc
+                       error: (NSError**)error;
+- (BOOL) writeToFile: (NSString*)path
+	  atomically: (BOOL)atomically
+	    encoding: (NSStringEncoding)enc
+	       error: (NSError**)error;
+- (BOOL) writeToURL: (NSURL*)url
+	 atomically: (BOOL)atomically
+	   encoding: (NSStringEncoding)enc
+	      error: (NSError**)error;
+#endif
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST)
+- (NSString*)stringByReplacingOccurrencesOfString: (NSString*)replace
+                                       withString: (NSString*)by
+                                          options: (NSStringCompareOptions)opts
+                                            range: (NSRange)searchRange;
+- (NSString*)stringByReplacingOccurrencesOfString: (NSString*)replace
+                                       withString: (NSString*)by;
+- (NSString*) stringByReplacingCharactersInRange: (NSRange)aRange 
+                                      withString: (NSString*)by;
+#endif
+- (id) initWithCharactersNoCopy: (unichar*)chars
+			 length: (NSUInteger)length
+		   freeWhenDone: (BOOL)flag;
+- (id) initWithCharacters: (const unichar*)chars
+		   length: (NSUInteger)length;
+- (id) initWithCStringNoCopy: (char*)byteString
+		      length: (NSUInteger)length
+	        freeWhenDone: (BOOL)flag;
+- (id) initWithCString: (const char*)byteString
+	        length: (NSUInteger)length;
+- (id) initWithCString: (const char*)byteString;
+- (id) initWithString: (NSString*)string;
+- (id) initWithFormat: (NSString*)format, ... NS_FORMAT_FUNCTION(1,2);
+- (id) initWithFormat: (NSString*)format
+	    arguments: (va_list)argList NS_FORMAT_FUNCTION(1,0);
+- (id) initWithData: (NSData*)data
+	   encoding: (NSStringEncoding)encoding;
+- (id) initWithContentsOfFile: (NSString*)path;
+
+// Getting a String's Length
+- (NSUInteger) length;
+
+// Accessing Characters
+- (unichar) characterAtIndex: (NSUInteger)index;
+- (void) getCharacters: (unichar*)buffer;
+- (void) getCharacters: (unichar*)buffer
+		 range: (NSRange)aRange;
+
+// Combining Strings
+- (NSString*) stringByAppendingFormat: (NSString*)format, ...
+  NS_FORMAT_FUNCTION(1,2);
+- (NSString*) stringByAppendingString: (NSString*)aString;
+
+// Dividing Strings into Substrings
+- (NSArray*) componentsSeparatedByString: (NSString*)separator;
+- (NSString*) substringFromIndex: (NSUInteger)index;
+- (NSString*) substringToIndex: (NSUInteger)index;
+
+// Finding Ranges of Characters and Substrings
+- (NSRange) rangeOfCharacterFromSet: (NSCharacterSet*)aSet;
+- (NSRange) rangeOfCharacterFromSet: (NSCharacterSet*)aSet
+			    options: (NSUInteger)mask;
+- (NSRange) rangeOfCharacterFromSet: (NSCharacterSet*)aSet
+			    options: (NSUInteger)mask
+			      range: (NSRange)aRange;
+- (NSRange) rangeOfString: (NSString*)string;
+- (NSRange) rangeOfString: (NSString*)string
+		  options: (NSUInteger)mask;
+- (NSRange) rangeOfString: (NSString*)aString
+		  options: (NSUInteger)mask
+		    range: (NSRange)aRange;
+
+// Determining Composed Character Sequences
+- (NSRange) rangeOfComposedCharacterSequenceAtIndex: (NSUInteger)anIndex;
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_2,GS_API_LATEST) 
+/** Returns a copy of the receiver normalised using the KD form.
+ */
+- (NSString *) decomposedStringWithCompatibilityMapping;
+
+/** Returns a copy of the receiver normalised using the D form.
+ */
+- (NSString *) decomposedStringWithCanonicalMapping;
+
+/** Returns a copy of the receiver normalised using the KC form.
+ */
+- (NSString *) precomposedStringWithCompatibilityMapping;
+
+/** Returns a copy of the receiver normalised using the C form.
+ */
+- (NSString *) precomposedStringWithCanonicalMapping;
+#endif
+
+// Converting String Contents into a Property List
+- (id) propertyList;
+- (NSDictionary*) propertyListFromStringsFileFormat;
+
+// Identifying and Comparing Strings
+- (NSComparisonResult) compare: (NSString*)aString;
+- (NSComparisonResult) compare: (NSString*)aString	
+		       options: (NSUInteger)mask;
+- (NSComparisonResult) compare: (NSString*)aString
+		       options: (NSUInteger)mask
+			 range: (NSRange)aRange;
+- (BOOL) hasPrefix: (NSString*)aString;
+- (BOOL) hasSuffix: (NSString*)aString;
+- (BOOL) isEqual: (id)anObject;
+- (BOOL) isEqualToString: (NSString*)aString;
+- (NSUInteger) hash;
+
+// Getting a Shared Prefix
+- (NSString*) commonPrefixWithString: (NSString*)aString
+			     options: (NSUInteger)mask;
+
+// Changing Case
+- (NSString*) capitalizedString;
+- (NSString*) lowercaseString;
+- (NSString*) uppercaseString;
+
+// Getting C Strings
+- (const char*) cString;
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_4,GS_API_LATEST) && GS_API_VERSION( 10200,GS_API_LATEST)
+- (const char*) cStringUsingEncoding: (NSStringEncoding)encoding;
+- (BOOL) getCString: (char*)buffer
+	  maxLength: (NSUInteger)maxLength
+	   encoding: (NSStringEncoding)encoding;
+- (id) initWithCString: (const char*)byteString
+	      encoding: (NSStringEncoding)encoding;
+- (NSUInteger) lengthOfBytesUsingEncoding: (NSStringEncoding)encoding;
+- (NSUInteger) maximumLengthOfBytesUsingEncoding: (NSStringEncoding)encoding;
+#endif
+
+#endif
+- (NSUInteger) cStringLength;
+- (void) getCString: (char*)buffer;
+- (void) getCString: (char*)buffer
+	  maxLength: (NSUInteger)maxLength;
+- (void) getCString: (char*)buffer
+	  maxLength: (NSUInteger)maxLength
+	      range: (NSRange)aRange
+     remainingRange: (NSRange*)leftoverRange;
+
+// Getting Numeric Values
+- (float) floatValue;
+- (int) intValue;
+
+// Working With Encodings
+- (BOOL) canBeConvertedToEncoding: (NSStringEncoding)encoding;
+- (NSData*) dataUsingEncoding: (NSStringEncoding)encoding;
+- (NSData*) dataUsingEncoding: (NSStringEncoding)encoding
+	 allowLossyConversion: (BOOL)flag;
++ (NSStringEncoding) defaultCStringEncoding;
+- (NSString*) description;
+- (NSStringEncoding) fastestEncoding;
+- (NSStringEncoding) smallestEncoding;
+
+/**
+ * Attempts to complete this string as a path in the filesystem by finding
+ * a unique completion if one exists and returning it by reference in
+ * outputName (which must be a non-nil pointer), or if it finds a set of
+ * completions they are returned by reference in outputArray, if it is non-nil.
+ * filterTypes can be an array of strings specifying extensions to consider;
+ * files without these extensions will be ignored and will not constitute
+ * completions.  Returns 0 if no match found, else a positive number that is
+ * only accurate if outputArray was non-nil.
+ */
+- (NSUInteger) completePathIntoString: (NSString**)outputName
+			caseSensitive: (BOOL)flag
+		     matchesIntoArray: (NSArray**)outputArray
+			  filterTypes: (NSArray*)filterTypes;
+
+/**
+ * Converts the receiver to a C string path expressed in the character
+ * encoding appropriate for the local host file system.  This string will be
+ * automatically freed soon after it is returned, so copy it if you need it
+ * for long.<br />
+ * NB. On mingw32 systems the filesystem representation of a path is a 16-bit
+ * unicode character string, so you should only pass the value returned by
+ * this method to functions expecting wide characters.<br />
+ * This method uses [NSFileManager-fileSystemRepresentationWithPath:] to
+ * perform the conversion.
+ */
+- (const GSNativeChar*) fileSystemRepresentation;
+
+/**
+ * Converts the receiver to a C string path using the character encoding
+ * appropriate to the local file system.  This string will be stored
+ * into buffer if it is shorter (number of characters) than size,
+ * otherwise NO is returned.<br />
+ * NB. On mingw32 systems the filesystem representation of a path is a 16-bit
+ * unicode character string, so the buffer you pass to this method must be
+ * twice as many bytes as the size (number of characters) you expect to
+ * receive.<br />
+ * This method uses [NSFileManager-fileSystemRepresentationWithPath:] to
+ * perform the conversion.
+ */
+- (BOOL) getFileSystemRepresentation: (GSNativeChar*)buffer
+			   maxLength: (NSUInteger)size;
+
+/**
+ * Returns a string containing the last path component of the receiver.<br />
+ * The path component is the last non-empty substring delimited by the ends
+ * of the string, or by path separator characters.<br />
+ * If the receiver only contains a root part, this method returns it.<br />
+ * If there are no non-empty substrings, this returns an empty string.<br />
+ * NB. In a windows UNC path, the host and share specification is treated as
+ * a single path component, even though it contains separators.
+ * So a string of the form '//host/share' may be returned.<br />
+ * Other special cases are apply when the string is the root.
+ * <example>
+ *   @"foo/bar" produces @"bar"
+ *   @"foo/bar/" produces @"bar"
+ *   @"/foo/bar" produces @"bar"
+ *   @"/foo" produces @"foo"
+ *   @"/" produces @"/" (root is a special case)
+ *   @"" produces @""
+ *   @"C:/" produces @"C:/" (root is a special case)
+ *   @"C:" produces @"C:"
+ *   @"//host/share/" produces @"//host/share/" (root is a special case)
+ *   @"//host/share" produces @"//host/share"
+ * </example>
+ */
+- (NSString*) lastPathComponent;
+
+/**
+ * Returns a new string containing the path extension of the receiver.<br />
+ * The path extension is a suffix on the last path component which starts
+ * with the extension separator (a '.') (for example .tiff is the
+ * pathExtension for /foo/bar.tiff).<br />
+ * Returns an empty string if no such extension exists.
+ * <example>
+ *   @"a.b" produces @"b"
+ *   @"a.b/" produces @"b"
+ *   @"/path/a.ext" produces @"ext"
+ *   @"/path/a." produces @""
+ *   @"/path/.a" produces @"" (.a is not an extension to a file)
+ *   @".a" produces @"" (.a is not an extension to a file)
+ * </example>
+ */
+- (NSString*) pathExtension;
+
+/**
+ * Returns a string where a prefix of the current user's home directory is
+ * abbreviated by '~', or returns the receiver (or an immutable copy) if
+ * it was not found to have the home directory as a prefix.
+ */
+- (NSString*) stringByAbbreviatingWithTildeInPath;
+
+/**
+ * Returns a new string with the path component given in aString
+ * appended to the receiver.<br />
+ * This removes trailing path separators from the receiver and the root
+ * part from aString and replaces them with a single slash as a path
+ * separator.<br />
+ * Also condenses any multiple separator sequences in the result into
+ * single path separators.
+ * <example>
+ *   @"" with @"file" produces @"file"
+ *   @"path" with @"file" produces @"path/file"
+ *   @"/" with @"file" produces @"/file"
+ *   @"/" with @"file" produces @"/file"
+ *   @"/" with @"/file" produces @"/file"
+ *   @"path with @"C:/file" produces @"path/file"
+ * </example>
+ * NB. Do not use this method to modify strings other than filesystem
+ * paths as the behavior in such cases is undefined ... for instance
+ * the string may have repeated slashes or slash-dot-slash sequences
+ * removed.
+ */
+- (NSString*) stringByAppendingPathComponent: (NSString*)aString;
+
+/**
+ * Returns a new string with the path extension given in aString
+ * appended to the receiver after an extensionSeparator ('.').<br />
+ * If the receiver has trailing path separator characters, they are
+ * stripped before the extension separator is added.<br />
+ * If the receiver contains no components after the root, the extension
+ * cannot be appended (an extension can only be appended to a file name),
+ * so a copy of the unmodified receiver is returned.<br />
+ * An empty string may be used as an extension ... in which case the extension
+ * separator is appended.<br />
+ * This behavior mirrors that of the -stringByDeletingPathExtension method.
+ * <example>
+ *   @"Mail" with @"app" produces @"Mail.app"
+ *   @"Mail.app" with @"old" produces @"Mail.app.old"
+ *   @"file" with @"" produces @"file."
+ *   @"/" with @"app" produces @"/" (no file name to append to)
+ *   @"" with @"app" produces @"" (no file name to append to)
+ * </example>
+ * NB. Do not use this method to modify strings other than filesystem
+ * paths as the behavior in such cases is undefined ... for instance
+ * the string may have repeated slashes or slash-dot-slash sequences
+ * removed.
+ */
+- (NSString*) stringByAppendingPathExtension: (NSString*)aString;
+
+/**
+ * Returns a new string with the last path component (including any final
+ * path separators) removed from the receiver.<br />
+ * A string without a path component other than the root is returned
+ * without alteration.<br />
+ * See -lastPathComponent for a definition of a path component.
+ * <example>
+ *   @"hello/there" produces @"hello" (a relative path)
+ *   @"hello" produces @"" (a relative path)
+ *   @"/hello" produces @"/" (an absolute unix path)
+ *   @"/" produces @"/" (an absolute unix path)
+ *   @"C:file" produces @"C:" (a relative windows path)
+ *   @"C:" produces @"C:" (a relative windows path)
+ *   @"C:/file" produces @"C:/" (an absolute windows path)
+ *   @"C:/" produces @"C:/" (an absolute windows path)
+ *   @"//host/share/file" produces @"//host/share/" (a UNC path)
+ *   @"//host/share/" produces @"//host/share/" (a UNC path)
+ *   @"//path/file" produces @"//path" (an absolute Unix path)
+ * </example>
+ * NB. Do not use this method to modify strings other than filesystem
+ * paths as the behavior in such cases is undefined ... for instance
+ * the string may have repeated slashes or slash-dot-slash sequences
+ * removed.
+ */
+- (NSString*) stringByDeletingLastPathComponent;
+
+/**
+ * Returns a new string with the path extension removed from the receiver.<br />
+ * Strips any trailing path separators before checking for the extension
+ * separator.<br />
+ * NB. This method does not consider a string which contains nothing
+ * between the root part and the extension separator ('.') to be a path
+ * extension. This mirrors the behavior of the -stringByAppendingPathExtension:
+ * method.
+ * <example>
+ *   @"file.ext" produces @"file"
+ *   @"/file.ext" produces @"/file"
+ *   @"/file.ext/" produces @"/file" (trailing path separators are ignored)
+ *   @"/file..ext" produces @"/file."
+ *   @"/file." produces @"/file"
+ *   @"/.ext" produces @"/.ext" (there is no file to strip from)
+ *   @".ext" produces @".ext" (there is no file to strip from)
+ * </example>
+ * NB. Do not use this method to modify strings other than filesystem
+ * paths as the behavior in such cases is undefined ... for instance
+ * the string may have repeated slashes or slash-dot-slash sequences
+ * removed.
+ */
+- (NSString*) stringByDeletingPathExtension;
+
+/**
+ * Returns a string created by expanding the initial tilde ('~') and any
+ * following username to be the home directory of the current user or the
+ * named user.<br />
+ * Returns the receiver or an immutable copy if it was not possible to
+ * expand it.
+ */
+- (NSString*) stringByExpandingTildeInPath;
+
+/**
+ * First calls -stringByExpandingTildeInPath if necessary.<br />
+ * Replaces path string by one in which path components representing symbolic
+ * links have been replaced by their referents.<br />
+ * Removes a leading '/private' if the result is valid.<br />
+ * If links cannot be resolved, returns an unmodified copy of the receiver.
+ */
+- (NSString*) stringByResolvingSymlinksInPath;
+
+/**
+ * Returns a standardised form of the receiver, with unnecessary parts
+ * removed, tilde characters expanded, and symbolic links resolved
+ * where possible.<br />
+ * NB. Refers to the local filesystem to resolve symbolic links in
+ * absolute paths, and to expand tildes ... so this can't be used for
+ * general path manipulation.<br />
+ * If the string is an invalid path, the unmodified receiver is returned.<br />
+ * <p>
+ *   Uses -stringByExpandingTildeInPath to expand tilde expressions.<br />
+ *   Simplifies '//' and '/./' sequences and removes trailing '/' or '.'.<br />
+ * </p>
+ * <p>
+ *  For absolute paths, uses -stringByResolvingSymlinksInPath to resolve
+ *  any links, then gets rid of '/../' sequences and removes any '/private'
+ *  prefix.
+ * </p>
+ */
+- (NSString*) stringByStandardizingPath;
+
+
+// for methods working with decomposed strings
+- (int) _baseLength;
+
+#if OS_API_VERSION(GS_API_MACOSX, GS_API_LATEST)
+/**
+ * Concatenates the path components in the array and returns the result.<br />
+ * This method does not remove empty path components, but does recognize an
+ * empty initial component as a special case meaning that the string
+ * returned will begin with a slash.
+ */
++ (NSString*) pathWithComponents: (NSArray*)components;
+
+/**
+ * Returns YES if the receiver represents an absolute path ...<br />
+ * Returns NO otherwise.<br />
+ * An absolute path in unix mode is one which begins
+ * with a slash or tilde.<br />
+ * In windows mode a drive specification (eg C:) followed by a slash or
+ * backslash, is an absolute path, as is any path beginning with a tilde.<br />
+ * In any mode a UNC path (//host/share...) is always absolute.<br />
+ * In the default gnustep path handling mode,
+ * the rules are the same as for windows,
+ * except that a path whose root is a slash denotes an absolute path
+ * when running on unix and a relative path when running under windows.
+ */
+- (BOOL) isAbsolutePath;
+
+/**
+ * Returns the path components of the receiver separated into an array.<br />
+ * If the receiver begins with a root sequence such as the path separator
+ * character (or a drive specification in windows) then that is used as the
+ * first element in the array.<br />
+ * Empty components are removed.<br />
+ * If a trailing path separator (which was not part of the root) was present,
+ * it is added as the last element in the array.
+ */
+- (NSArray*) pathComponents;
+
+/**
+ * Returns an array of strings made by appending the values in paths
+ * to the receiver.
+ */
+- (NSArray*) stringsByAppendingPaths: (NSArray*)paths;
+
++ (NSString*) localizedStringWithFormat: (NSString*)format, ...
+  NS_FORMAT_FUNCTION(1,2);
+
++ (id) stringWithString: (NSString*)aString;
++ (id) stringWithContentsOfURL: (NSURL*)url;
++ (id) stringWithUTF8String: (const char*)bytes;
+- (id) initWithFormat: (NSString*)format
+	       locale: (NSDictionary*)locale, ... NS_FORMAT_FUNCTION(1,3);
+- (id) initWithFormat: (NSString*)format
+	       locale: (NSDictionary*)locale
+	    arguments: (va_list)argList NS_FORMAT_FUNCTION(1,0);
+- (id) initWithUTF8String: (const char *)bytes;
+- (id) initWithContentsOfURL: (NSURL*)url;
+- (NSString*) substringWithRange: (NSRange)aRange;
+- (NSComparisonResult) caseInsensitiveCompare: (NSString*)aString;
+- (NSComparisonResult) compare: (NSString*)string 
+		       options: (NSUInteger)mask 
+			 range: (NSRange)compareRange 
+			locale: (id)locale;
+- (NSComparisonResult) localizedCompare: (NSString *)string;
+- (NSComparisonResult) localizedCaseInsensitiveCompare: (NSString *)string;
+- (BOOL) writeToFile: (NSString*)filename
+	  atomically: (BOOL)useAuxiliaryFile;
+- (BOOL) writeToURL: (NSURL*)url atomically: (BOOL)atomically;
+- (double) doubleValue;
++ (NSStringEncoding*) availableStringEncodings;
++ (NSString*) localizedNameOfStringEncoding: (NSStringEncoding)encoding;
+- (void) getLineStart: (NSUInteger *)startIndex
+                  end: (NSUInteger *)lineEndIndex
+          contentsEnd: (NSUInteger *)contentsEndIndex
+             forRange: (NSRange)aRange;
+- (NSRange) lineRangeForRange: (NSRange)aRange;
+- (const char*) lossyCString;
+- (NSString*) stringByAddingPercentEscapesUsingEncoding: (NSStringEncoding)e;
+- (NSString*) stringByPaddingToLength: (NSUInteger)newLength
+			   withString: (NSString*)padString
+		      startingAtIndex: (NSUInteger)padIndex;
+- (NSString*) stringByReplacingPercentEscapesUsingEncoding: (NSStringEncoding)e;
+- (NSString*) stringByTrimmingCharactersInSet: (NSCharacterSet*)aSet;
+- (const char *)UTF8String;
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_9,GS_API_LATEST)
+- (NSString *) stringByAddingPercentEncodingWithAllowedCharacters: (NSCharacterSet *)aSet;
+- (NSString *) stringByRemovingPercentEncoding;
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_3,GS_API_LATEST) 
+/** Not implemented */
+- (void) getParagraphStart: (NSUInteger *)startIndex
+                       end: (NSUInteger *)parEndIndex
+               contentsEnd: (NSUInteger *)contentsEndIndex
+                 forRange: (NSRange)range;
+/** Not implemented */
+ - (NSRange) paragraphRangeForRange: (NSRange)range;
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_5,GS_API_LATEST) 
+/**
+ * Returns YES when scanning the receiver's text from left to right
+ * finds an initial digit in the range 1-9 or a letter in the set
+ * ('Y', 'y', 'T', 't').<br />
+ * Any trailing characters are ignored.<br />
+ * Any leading whitespace or zeros or signs are also ignored.<br />
+ * Returns NO if the above conditions are not met.
+ */
+- (BOOL) boolValue;
+- (NSArray *) componentsSeparatedByCharactersInSet: (NSCharacterSet *)separator;
+- (NSInteger) integerValue;
+- (long long) longLongValue;
+/** Not implemented */
+- (NSRange) rangeOfComposedCharacterSequencesForRange: (NSRange)range;
+/** Not implemented */
+- (NSRange) rangeOfString: (NSString *)aString
+                  options: (NSStringCompareOptions)mask
+                    range: (NSRange)searchRange
+                   locale: (NSLocale *)locale;
+
+#endif
+
+#if OS_API_VERSION(MAC_OS_X_VERSION_10_10,GS_API_LATEST) 
+
+/**
+  * Returns YES if the receiver contains string, otherwise, NO.
+  */
+- (BOOL) containsString: (NSString *)string;
+
+#endif
+
+#if OS_API_VERSION(GS_API_NONE, GS_API_NONE)
++ (Class) constantStringClass;
+#endif	/* GS_API_NONE */
+
+@end
+
+@interface NSMutableString : NSString
+
+// Creating Temporary Strings
++ (id) string;
++ (id) stringWithCharacters: (const unichar*)characters
+		     length: (NSUInteger)length;
++ (id) stringWithCString: (const char*)byteString
+		  length: (NSUInteger)length;
++ (id) stringWithCString: (const char*)byteString;
++ (id) stringWithFormat: (NSString*)format, ... NS_FORMAT_FUNCTION(1,2);
++ (id) stringWithContentsOfFile: (NSString*)path;
++ (NSMutableString*) stringWithCapacity: (NSUInteger)capacity;
+
+// Initializing Newly Allocated Strings
+- (id) initWithCapacity: (NSUInteger)capacity;
+
+// Modify A String
+- (void) appendFormat: (NSString*)format, ... NS_FORMAT_FUNCTION(1,2);
+- (void) appendString: (NSString*)aString;
+- (void) deleteCharactersInRange: (NSRange)range;
+- (void) insertString: (NSString*)aString atIndex: (NSUInteger)loc;
+- (void) replaceCharactersInRange: (NSRange)range 
+		       withString: (NSString*)aString;
+- (NSUInteger) replaceOccurrencesOfString: (NSString*)replace
+				 withString: (NSString*)by
+				    options: (NSUInteger)opts
+				      range: (NSRange)searchRange;
+- (void) setString: (NSString*)aString;
+
+@end
+
+#ifdef __OBJC_GNUSTEP_RUNTIME_ABI__
+#  if __OBJC_GNUSTEP_RUNTIME_ABI__ >= 20
+#    define GNUSTEP_NEW_STRING_ABI
+#  endif
+#endif
+
+/**
+ * <p>The NXConstantString class is used to hold constant 8-bit character
+ * string objects produced by the compiler where it sees @"..." in the
+ * source.  The compiler generates the instances of this class - which
+ * has three instance variables -</p>
+ * <list>
+ * <item>a pointer to the class (this is the sole ivar of NSObject)</item>
+ * <item>a pointer to the 8-bit data</item>
+ * <item>the length of the string</item>
+ * </list>
+ * <p>In older versions of the compiler, the isa variable is always set to
+ * the NXConstantString class.  In newer versions a compiler option was
+ * added for GNUstep, to permit the isa variable to be set to another
+ * class, and GNUstep uses this to avoid conflicts with the default
+ * implementation of NXConstantString in the ObjC runtime library (the
+ * preprocessor is used to change all occurrences of NXConstantString
+ * in the source code to NSConstantString).</p>
+ * <p>Since GNUstep will generally use the GNUstep extension to the
+ * compiler, you should never refer to the constant string class by
+ * name, but should use the [NSString+constantStringClass] method to
+ * get the actual class being used for constant strings.</p>
+ * What follows is a dummy declaration of the class to keep the compiler
+ * happy.
+ */
+@interface NXConstantString : NSString
+{
+@public
+#ifdef GNUSTEP_NEW_STRING_ABI
+  /**
+   * Flags.  The low 16 bits are reserved for the compiler, the top 16 for use
+   * by the Foundation Framework.  Currently only the low 2 bits are used, to
+   * indicate the encoding of the string, with the following values:
+   *
+   * 0. ASCII (UTF-8 using only 7-bit characters)
+   * 1. UTF-8
+   * 2. UTF-16
+   * 3. UTF-32
+   *
+   */
+  uint32_t flags;
+  /**
+   * The number of characters (UTF-16 code units) in the string.
+   */
+  uint32_t nxcslen;
+  /**
+   * The number of bytes in the string.  For fixed-length encodings, this is a
+   * fixed multiple of nxcslen, but for UTF-8 it can be different.
+   */
+  uint32_t size;
+  /**
+   * Hash value.
+   */
+  uint32_t hash;
+  /**
+   * Pointer to the byte data of the string.  Note that `char*` is the correct
+   * type only if the low two bits of the flags indicate that this is an ASCII
+   * or UTF-8 string, otherwise it is a pointer to 16- or 32-bit characters in
+   * native byte order.
+   */
+  const char * const nxcsptr;
+#else
+  const char * const nxcsptr;
+  const unsigned int nxcslen;
+#endif
+}
+@end
+
+#ifdef NeXT_RUNTIME
+/** For internal use with NeXT runtime;
+    needed, until Apple Radar 2870817 is fixed. */
+extern struct objc_class _NSConstantStringClassReference;
+#endif
+
+#if	defined(__cplusplus)
+}
+#endif
+
+#if     !NO_GNUSTEP && !defined(GNUSTEP_BASE_INTERNAL)
+#import "../GNUstepBase/NSString+GNUstepBase.h"
+#import "../GNUstepBase/NSMutableString+GNUstepBase.h"
+#endif
+
+#endif /* __NSString_h_GNUSTEP_BASE_INCLUDE */
Index: gcc/testsuite/objc-obj-c++-shared/F-NSValue.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/F-NSValue.h b/gcc/testsuite/objc-obj-c++-shared/F-NSValue.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/F-NSValue.h	(revision 278653)
@@ -0,0 +1,33 @@
+/* Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef _OBJC_F_NSSTRING_H_
+#define _OBJC_F_NSSTRING_H_
+
+/* This is a workaround to PR90709 for the NeXT runtime.
+   If we're on a system version that has headers with items we can't
+   consume, then use the GNUStep header instead.
+*/
+
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1090
+#  import "GNUStep/Foundation/NSValue.h"
+#else 
+#  import <Foundation/NSValue.h>
+#endif
+
+#endif /* _OBJC_F_NSSTRING_H_ */
Index: gcc/testsuite/objc-obj-c++-shared/F-NSArray.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/F-NSArray.h b/gcc/testsuite/objc-obj-c++-shared/F-NSArray.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/F-NSArray.h	(revision 278653)
@@ -0,0 +1,33 @@
+/* Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef _OBJC_F_NSARRAY_H_
+#define _OBJC_F_NSARRAY_H_
+
+/* This is a workaround to PR90709 for the NeXT runtime.
+   If we're on a system version that has headers with items we can't
+   consume, then use the GNUStep header instead.
+*/
+
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1090
+#  import "GNUStep/Foundation/NSArray.h"
+#else 
+#  import <Foundation/NSArray.h>
+#endif
+
+#endif /* _OBJC_F_NSARRAY_H_ */
Index: gcc/testsuite/objc-obj-c++-shared/CF-CFString.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/CF-CFString.h b/gcc/testsuite/objc-obj-c++-shared/CF-CFString.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/CF-CFString.h	(revision 278653)
@@ -0,0 +1,33 @@
+/* Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef _OBJC_CF_CFSTRING_H_
+#define _OBJC_CF_CFSTRING_H_
+
+/* This is a workaround to PR90709 for the NeXT runtime.
+   If we're on a system version that has headers with items we can't
+   consume, then use the GNUStep header instead.
+*/
+
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1090
+#  import "GNUStep/CoreFoundation/CFString.h"
+#else 
+#  import <CoreFoundation/CFString.h>
+#endif
+
+#endif /* _OBJC_CF_CFSTRING_H_ */
Index: gcc/testsuite/objc-obj-c++-shared/F-NSAutoreleasePool.h
===================================================================
diff --git a/gcc/testsuite/objc-obj-c++-shared/F-NSAutoreleasePool.h b/gcc/testsuite/objc-obj-c++-shared/F-NSAutoreleasePool.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc-obj-c++-shared/F-NSAutoreleasePool.h	(revision 278653)
@@ -0,0 +1,33 @@
+/* Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#ifndef _OBJC_F_NSAUTORELEASEPOOL_H_
+#define _OBJC_F_NSAUTORELEASEPOOL_H_
+
+/* This is a workaround to PR90709 for the NeXT runtime.
+   If we're on a system version that has headers with items we can't
+   consume, then use the GNUStep header instead.
+*/
+
+#if __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1090
+#  import "GNUStep/Foundation/NSAutoreleasePool.h"
+#else 
+#  import <Foundation/NSAutoreleasePool.h>
+#endif
+
+#endif /* _OBJC_F_NSAUTORELEASEPOOL_H_ */
Index: gcc/testsuite/g++.dg/ubsan/vptr-14.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ubsan/vptr-14.C b/gcc/testsuite/g++.dg/ubsan/vptr-14.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ubsan/vptr-14.C	(revision 278653)
@@ -0,0 +1,18 @@
+// PR sanitizer/89869
+// { dg-do run }
+// { dg-options "-fsanitize=vptr -fno-sanitize-recover=vptr" }
+
+struct S { S *s = 0; virtual ~S () {} };
+
+void
+foo (S *x, S *y)
+{
+  (x->s ? y : x) = x->s;
+}
+
+int
+main ()
+{
+  S a;
+  foo (&a, 0);
+}
Index: gcc/testsuite/g++.dg/lookup/missing-std-include-8.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/lookup/missing-std-include-8.C b/gcc/testsuite/g++.dg/lookup/missing-std-include-8.C
--- a/gcc/testsuite/g++.dg/lookup/missing-std-include-8.C	(revision 278653)
+++ b/gcc/testsuite/g++.dg/lookup/missing-std-include-8.C	(revision 278653)
@@ -13,6 +13,15 @@
   // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
 }
 
+template<class T>
+void test_make_unique ()
+{
+  std::make_unique<T>(); // { dg-error "'make_unique' is not a member of 'std'" }
+  // { dg-message "'std::make_unique' is only available from C\\+\\+14 onwards" "" { target *-*-* } .-1 }
+  // { dg-error "expected primary-expression before '>' token" "" { target *-*-* } .-2 }
+  // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
+}
+
 void test_array ()
 {
   std::array a; // { dg-error "'array' is not a member of 'std'" }
Index: gcc/testsuite/g++.dg/lookup/missing-std-include-5.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/lookup/missing-std-include-5.C b/gcc/testsuite/g++.dg/lookup/missing-std-include-5.C
--- a/gcc/testsuite/g++.dg/lookup/missing-std-include-5.C	(revision 278653)
+++ b/gcc/testsuite/g++.dg/lookup/missing-std-include-5.C	(revision 278653)
@@ -1,2 +1,3 @@
+// { dg-do compile { target c++14 } }
 using namespace std::complex_literals; // { dg-error "" }
 // { dg-message "#include <complex>" "" { target *-*-* } .-1 }
Index: gcc/testsuite/g++.dg/lookup/missing-std-include-6.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/lookup/missing-std-include-6.C b/gcc/testsuite/g++.dg/lookup/missing-std-include-6.C
--- a/gcc/testsuite/g++.dg/lookup/missing-std-include-6.C	(revision 278653)
+++ b/gcc/testsuite/g++.dg/lookup/missing-std-include-6.C	(revision 278653)
@@ -11,15 +11,6 @@
   // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
 }
 
-template<class T>
-void test_make_unique ()
-{
-  auto p = std::make_unique<T>(); // { dg-error "'make_unique' is not a member of 'std'" }
-  // { dg-message "'#include <memory>'" "" { target *-*-* } .-1 }
-  // { dg-error "expected primary-expression before '>' token" "" { target *-*-* } .-2 }
-  // { dg-error "expected primary-expression before '\\)' token" "" { target *-*-* } .-3 }
-}
-
 std::shared_ptr<int> test_shared_ptr; // { dg-error "'shared_ptr' in namespace 'std' does not name a template type" }
 // { dg-message "'#include <memory>'" "" { target *-*-* } .-1 }
 
Index: gcc/testsuite/g++.dg/warn/conv5.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/warn/conv5.C b/gcc/testsuite/g++.dg/warn/conv5.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/warn/conv5.C	(revision 278653)
@@ -0,0 +1,11 @@
+// PR c++/89876
+// { dg-do compile { target c++11 } }
+// { dg-prune-output "sorry" }
+
+template <typename T>
+T f (T, char*);
+
+template <typename T>
+decltype (f (T (), "")) g (T) { return ""; } // { dg-error "invalid conversion" }
+
+void h () { g (0); }
Index: gcc/testsuite/g++.dg/asan/pr90570.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/asan/pr90570.C b/gcc/testsuite/g++.dg/asan/pr90570.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/asan/pr90570.C	(revision 278653)
@@ -0,0 +1,18 @@
+/* PR sanitizer/90570 */
+/* { dg-do run } */
+
+#include <vector>
+
+struct stru
+{
+  std::vector<int> v{1,2,3,4};
+  int i{5};
+};
+
+int main()
+{
+  stru s1;
+  stru s2;
+
+  return 0;
+}
Index: gcc/testsuite/g++.dg/gcov/pr16855.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/gcov/pr16855.C b/gcc/testsuite/g++.dg/gcov/pr16855.C
--- a/gcc/testsuite/g++.dg/gcov/pr16855.C	(revision 278653)
+++ b/gcc/testsuite/g++.dg/gcov/pr16855.C	(revision 278653)
@@ -1,6 +1,8 @@
 /* { dg-options "-fprofile-arcs -ftest-coverage" } */
 /* { dg-do run { target native } } */
 
+/* See PR91087 for information on Darwin xfails. */
+
 #include <stdlib.h>
 #include <stdio.h>
 
@@ -18,7 +20,9 @@
 {
 public:
   Test (void) { fprintf (stderr, "In Test::Test\n"); /* count(1) */ }
-  ~Test (void) { fprintf (stderr, "In Test::~Test\n"); /* count(1) */ }
+  ~Test (void) {
+   fprintf (stderr, "In Test::~Test\n"); /* count(1) { xfail *-*-darwin* } */
+  }
 } T1;
 
 void
@@ -42,7 +46,7 @@
 
 static void __attribute__ ((destructor)) dtor_default ()
 {
-  fprintf (stderr, "in destructor(())\n"); /* count(1) */
+  fprintf (stderr, "in destructor(())\n"); /* count(1) { xfail *-*-darwin* } */
 }
 
-/* { dg-final { run-gcov branches { -b pr16855.C } } } */
+/* { dg-final { run-gcov branches { -b pr16855.C } { xfail *-*-darwin* } } } */
Index: gcc/testsuite/g++.dg/debug/dwarf2/pr91887.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/debug/dwarf2/pr91887.C b/gcc/testsuite/g++.dg/debug/dwarf2/pr91887.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/debug/dwarf2/pr91887.C	(revision 278653)
@@ -0,0 +1,12 @@
+// { dg-do compile }
+// { dg-require-effective-target c++11 }
+// { dg-options "-g -fdebug-types-section" }
+class A {
+public:
+  A();
+  template <typename U> A(U);
+};
+template <class> struct B { typedef A type; };
+template <class R, typename... Args>
+int Bind(R(Args...), typename B<Args>::type...) { return 0; }
+void KeepBufferRefs(A, A) { A a, b(Bind(KeepBufferRefs, a, b)); }
Index: gcc/testsuite/g++.dg/pr92022.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/pr92022.C b/gcc/testsuite/g++.dg/pr92022.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/pr92022.C	(revision 278653)
@@ -0,0 +1,13 @@
+// { dg-do compile { target alpha*-*-* } }
+// { dg-options "-O1 -g -fno-var-tracking -mcpu=ev4 -mieee" }
+
+struct a {
+  a(long);
+};
+long b;
+void c() {
+  a d(1);
+  double e = b;
+  for (; b;)
+    d = e;
+}
Index: gcc/testsuite/g++.dg/opt/pr90026.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/opt/pr90026.C b/gcc/testsuite/g++.dg/opt/pr90026.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/opt/pr90026.C	(revision 278653)
@@ -0,0 +1,24 @@
+// PR rtl-optimization/90026
+// { dg-do compile }
+// { dg-options "-fnon-call-exceptions -ftracer -O2 -w" }
+
+typedef __SIZE_TYPE__ size_t;
+struct S { int *b; ~S () { delete b; } };
+void bar ();
+char c[sizeof (int)];
+
+void *
+operator new (size_t, void *)
+{
+  __builtin_unreachable ();
+}
+
+void
+foo ()
+{
+  S a;
+  if (a.b)
+    a.b = new int ();
+  bar ();
+  new (c) int ();
+}
Index: gcc/testsuite/g++.dg/opt/pr90187.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/opt/pr90187.C b/gcc/testsuite/g++.dg/opt/pr90187.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/opt/pr90187.C	(revision 278653)
@@ -0,0 +1,15 @@
+// PR target/90187
+// { dg-do compile }
+// { dg-options "-Ofast -ffloat-store" }
+
+double a[64];
+double *foo (void);
+
+void
+bar (int x, const double *y)
+{
+  int i;
+  for (i = 0; i < x; i++)
+    if (y[i] < a[i])
+      a[i] = y[i];
+}
Index: gcc/testsuite/g++.dg/opt/pr90090.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/opt/pr90090.C b/gcc/testsuite/g++.dg/opt/pr90090.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/opt/pr90090.C	(revision 278653)
@@ -0,0 +1,19 @@
+// PR tree-optimization/90090
+// { dg-do compile }
+// { dg-options "-Ofast -fno-associative-math -fsignaling-nans -fno-tree-dce -fnon-call-exceptions" }
+
+double bar (double, double, double, double, double);
+double baz ();
+
+double
+foo (double a)
+{
+  try
+    {
+      return bar (1.0/a, 2.0/a, 4.0/a, 8.0/a, 16.0/a);
+    }
+  catch (...)
+    {
+      return baz ();
+    }
+}
Index: gcc/testsuite/g++.dg/tree-prof/devirt.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tree-prof/devirt.C b/gcc/testsuite/g++.dg/tree-prof/devirt.C
--- a/gcc/testsuite/g++.dg/tree-prof/devirt.C	(revision 278653)
+++ b/gcc/testsuite/g++.dg/tree-prof/devirt.C	(revision 278653)
@@ -1,5 +1,5 @@
 /* PR ipa/88561 */
-/* { dg-options "-O3 -fdump-tree-dom3-details" } */
+/* { dg-options "-O3 -fdump-tree-tracer-details -fdump-tree-dom3-details" } */
 
 struct nsISupports
 {
@@ -121,6 +121,6 @@
     __builtin_abort ();
 }
 
-/* { dg-final-use-not-autofdo { scan-tree-dump-times "folding virtual function call to virtual unsigned int mozPersonalDictionary::_ZThn16" 1 "dom3" { target { lp64 || llp64 } } } } */
-/* { dg-final-use-not-autofdo { scan-tree-dump-times "folding virtual function call to virtual unsigned int mozPersonalDictionary::_ZThn8" 1 "dom3" { target ilp32 } } } */
-/* { dg-final-use-not-autofdo { scan-tree-dump-times "folding virtual function call to virtual unsigned int mozPersonalDictionary::AddRef" 1 "dom3" } } */
+/* { dg-final-use-not-autofdo { scan-tree-dump-times "folding virtual function call to virtual unsigned int mozPersonalDictionary::_ZThn16" 1 "tracer" { target { lp64 || llp64 } } } } */
+/* { dg-final-use-not-autofdo { scan-tree-dump-times "folding virtual function call to virtual unsigned int mozPersonalDictionary::_ZThn8" 1 "tracer" { target ilp32 } } } */
+/* { dg-final-use-not-autofdo { scan-tree-dump-times "folding virtual function call to virtual unsigned int mozPersonalDictionary::AddRef" 1 "tracer" } } */
Index: gcc/testsuite/g++.dg/pr91173.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/pr91173.C b/gcc/testsuite/g++.dg/pr91173.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/pr91173.C	(revision 278653)
@@ -0,0 +1,45 @@
+class a {
+  int b;
+  void *c;
+
+public:
+  bool aa();
+  int &ab() {
+    if (aa()) {
+      void *d(c);
+      return static_cast<int *>(d)[b];
+    }
+    return *(int *)0;
+  }
+};
+typedef enum {E} e;
+class f : public a {
+  int g;
+
+public:
+  int ac() {
+    if (g)
+      return 1;
+    return ac();
+  }
+};
+int *ad;
+struct h {
+  static int ae(e, int *m) {
+    f ag;
+    int *ah;
+    while (!0) {
+      ad = &ag.ab();
+      ah = ad + ag.ac();
+      while (ad < ah)
+        *m = *ad++;
+    }
+  }
+};
+template <class, class>
+void i(int *, int *, int, int *, e n, int *o) {
+  h::ae(n, o);
+}
+int aq, ar, as, at, au;
+void aw() { i<int, bool>(&aq, &ar, as, &at, (e)0, &au); }
+
Index: gcc/testsuite/g++.dg/pr71694.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/pr71694.C b/gcc/testsuite/g++.dg/pr71694.C
--- a/gcc/testsuite/g++.dg/pr71694.C	(revision 278653)
+++ b/gcc/testsuite/g++.dg/pr71694.C	(revision 278653)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-O2 -fno-store-merging" } */
+/* { dg-additional-options "-fno-common -mdynamic-no-pic" { target { ia32 && { x86_64-*-darwin* i?86-*-darwin* } } } } */
 
 struct B {
     B() {}
Index: gcc/testsuite/g++.dg/asm-qual-3.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/asm-qual-3.C b/gcc/testsuite/g++.dg/asm-qual-3.C
--- a/gcc/testsuite/g++.dg/asm-qual-3.C	(revision 278653)
+++ b/gcc/testsuite/g++.dg/asm-qual-3.C	(revision 278653)
@@ -2,11 +2,11 @@
 // { dg-do compile }
 // { dg-options "-std=gnu++98" }
 
-asm const ("");    // { dg-error {expected '\(' before 'const'} }
-asm volatile (""); // { dg-error {expected '\(' before 'volatile'} }
+asm const ("");    // { dg-error {'const' is not an asm qualifier} }
+asm volatile ("");
 asm restrict (""); // { dg-error {expected '\(' before 'restrict'} }
-asm inline ("");   // { dg-error {expected '\(' before 'inline'} }
-asm goto ("");     // { dg-error {expected '\(' before 'goto'} }
+asm inline ("");   // { dg-error {asm qualifier outside of function body} }
+asm goto ("");     // { dg-error {asm qualifier outside of function body} }
 
 // There are many other things wrong with this code, so:
 // { dg-excess-errors "" }
Index: gcc/testsuite/g++.dg/cpp0x/using-enum-3.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/using-enum-3.C b/gcc/testsuite/g++.dg/cpp0x/using-enum-3.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/using-enum-3.C	(revision 278653)
@@ -0,0 +1,21 @@
+// PR c++/89511
+// { dg-do compile { target c++11 } }
+
+void f ()
+{
+  enum e { a };
+  using e::a; // { dg-error "not a namespace or unscoped enum" }
+}
+
+struct S {
+  enum E { A };
+  using E::A; // { dg-error "type .S. is not a base type for type .S." }
+};
+
+namespace N {
+  enum E { B };
+}
+
+struct T {
+  using N::E::B; // { dg-error "using-declaration for non-member at class scope" }
+};
Index: gcc/testsuite/g++.dg/cpp0x/lambda/lambda-defarg9.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-defarg9.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-defarg9.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-defarg9.C	(revision 278653)
@@ -0,0 +1,10 @@
+// PR c++/89422
+// { dg-do compile { target c++11 } }
+// { dg-additional-options -g }
+
+template <int> struct S
+{
+  friend void foo (int a = []{ return 0; }()) {}
+  int b;
+};
+S<0> t;
Index: gcc/testsuite/g++.dg/cpp0x/implicit16.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/implicit16.C b/gcc/testsuite/g++.dg/cpp0x/implicit16.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/implicit16.C	(revision 278653)
@@ -0,0 +1,37 @@
+// PR c++/89381
+// { dg-do compile { target c++11 } }
+
+template<typename T>
+struct base
+{
+  base() { }
+  base(const base&) { }
+  base(base&&) { }
+  base& operator=(const base&) { return *this; }
+  base& operator=(base&&) { return *this; }
+};
+
+struct foo : base<int>
+{
+    using base<int>::base;
+    using base<int>::operator=;
+};
+
+//using workaround = decltype(foo{*static_cast<foo const*>(0)});
+
+struct bar
+{
+    bar& operator=(foo ve)
+    {
+        value = ve;
+        return *this;
+    }
+
+    foo value;
+};
+
+int main()
+{
+    foo a;
+    foo b{a};
+}
Index: gcc/testsuite/g++.dg/cpp0x/nullptr41.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/nullptr41.C b/gcc/testsuite/g++.dg/cpp0x/nullptr41.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/nullptr41.C	(revision 278653)
@@ -0,0 +1,19 @@
+// PR c++/89212
+// { dg-do compile { target c++11 } }
+
+template <int, typename T> using enable_if_t = int;
+
+template<typename U, typename W, typename Y, class X, W(X::*foo)() = nullptr>
+struct p
+{
+    template<U(Y::*fun)() = foo, typename T = enable_if_t<nullptr == fun, int>>
+    p(T) { }
+    p() = default;
+};
+
+struct A
+{
+    p<void, void, A, A> i = 1;
+    void bar();
+    p<void, void, A, A, &A::bar> j;
+};
Index: gcc/testsuite/g++.dg/cpp0x/pr84497.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/pr84497.C b/gcc/testsuite/g++.dg/cpp0x/pr84497.C
--- a/gcc/testsuite/g++.dg/cpp0x/pr84497.C	(revision 278653)
+++ b/gcc/testsuite/g++.dg/cpp0x/pr84497.C	(revision 278653)
@@ -1,6 +1,7 @@
 // PR 84497 mismatch with thread constructor fn weakness
 // { dg-do compile { target c++11 } }
 // { dg-require-weak "" }
+// { dg-require-alias "" }
 
 struct Base
 {
Index: gcc/testsuite/g++.dg/cpp0x/decltype-tid1.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/decltype-tid1.C b/gcc/testsuite/g++.dg/cpp0x/decltype-tid1.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/decltype-tid1.C	(revision 278653)
@@ -0,0 +1,9 @@
+// PR c++/87513
+// { dg-do compile { target c++11 } }
+
+struct A { template <long> void foo (); };
+template <long t> auto bar () -> decltype (&A::foo<t>);
+void foo ()
+{
+  bar<0> ();
+}
Index: gcc/testsuite/g++.dg/cpp0x/rv-conv2.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/rv-conv2.C b/gcc/testsuite/g++.dg/cpp0x/rv-conv2.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/rv-conv2.C	(revision 278653)
@@ -0,0 +1,18 @@
+// PR c++/89705
+// { dg-do compile { target c++11 } }
+
+struct W { operator const volatile int(); };
+const int& rci = W();
+
+struct X { operator const int(); };
+int&& rri = X();
+
+struct Y { operator volatile int(); };
+int&& rri2 = Y();
+
+struct Z { operator const volatile int(); };
+volatile int&& rri3 = Z();
+
+enum E { A };
+struct S { operator const E(); };
+E&& rre = S();
Index: gcc/testsuite/g++.dg/cpp0x/initlist-value4.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist-value4.C b/gcc/testsuite/g++.dg/cpp0x/initlist-value4.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist-value4.C	(revision 278653)
@@ -0,0 +1,12 @@
+// PR c++/88857
+// { dg-do compile { target c++11 } }
+
+class S { int a; };
+void foo (const S &, int);
+
+template <int N>
+void
+bar ()
+{
+  foo ({}); // { dg-error "too few arguments to function" }
+}
Index: gcc/testsuite/g++.dg/cpp0x/alignas4.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/alignas4.C b/gcc/testsuite/g++.dg/cpp0x/alignas4.C
--- a/gcc/testsuite/g++.dg/cpp0x/alignas4.C	(revision 278653)
+++ b/gcc/testsuite/g++.dg/cpp0x/alignas4.C	(revision 278653)
@@ -1,8 +1,14 @@
 // PR c++/59012
 // { dg-do compile { target c++11 } }
 // { dg-final { scan-assembler "align 8" { target { { i?86-*-* x86_64-*-* } && { { ! ia32 } && { ! *-*-darwin* } } } } } }
-// { dg-final { scan-assembler "align 4" { target ia32 } } }
+// { dg-final { scan-assembler "align 4" { target { ia32 && { ! *-*-darwin* } } } } }
 
+// Darwin produces aligned .zerofill directives for these.
+// { dg-final { scan-assembler {zerofill[^\n\r]+_a,4,2} { target { ilp32 && *-*-darwin* } } } }
+// { dg-final { scan-assembler {zerofill[^\n\r]+_a,8,3} { target { lp64 && *-*-darwin* } } } }
+// { dg-final { scan-assembler {zerofill[^\n\r]+_a2,4,2} { target { ilp32 && *-*-darwin* } } } }
+// { dg-final { scan-assembler {zerofill[^\n\r]+_a2,8,3} { target { lp64 && *-*-darwin* } } } }
+
 template <class... T>
 struct A
 {
Index: gcc/testsuite/g++.dg/cpp0x/pr89403.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/pr89403.C b/gcc/testsuite/g++.dg/cpp0x/pr89403.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/pr89403.C	(revision 278653)
@@ -0,0 +1,18 @@
+// PR c++/89403
+// { dg-do compile { target c++11 } }
+// { dg-options "-Os -fsyntax-only" }
+
+template <typename T>
+struct A : T {
+  constexpr A() : T() { }
+};
+
+template <typename T>
+struct B {
+  A<T> b;
+  constexpr B() { }
+};
+
+struct C { struct {} s; };
+constexpr B<C> b{};
+constexpr C c = b.b;
Index: gcc/testsuite/g++.dg/cpp0x/nullptr40.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/nullptr40.C b/gcc/testsuite/g++.dg/cpp0x/nullptr40.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/nullptr40.C	(revision 278653)
@@ -0,0 +1,19 @@
+// PR c++/89212
+// { dg-do compile { target c++11 } }
+
+template <int, typename T> using enable_if_t = int;
+
+template<class X, void(X::*foo)() = nullptr>
+struct p
+{
+    template<void(X::*fun)() = foo, typename T = enable_if_t<nullptr == fun, int>>
+    p(T) { }
+    p() = default;
+};
+
+struct A
+{
+    p<A> i = 1;
+    void bar();
+    p<A, &A::bar> j;
+};
Index: gcc/testsuite/g++.dg/eh/o32-fp.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/eh/o32-fp.C b/gcc/testsuite/g++.dg/eh/o32-fp.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/eh/o32-fp.C	(revision 278653)
@@ -0,0 +1,47 @@
+// Test whether call saved float are restored properly for O32 ABI
+// { dg-do run { target { { { mips*-*-linux* } && hard_float } && { ! mips64 } } } }
+// { dg-options "-O2" }
+
+void __attribute__((noinline))
+bar (void)
+{
+  throw 1;
+}
+
+void __attribute__((noinline))
+foo (void)
+{
+  register double f20 __asm__ ("f20") = 0.0;
+  register double f22 __asm__ ("f22") = 0.0;
+  register double f24 __asm__ ("f24") = 0.0;
+  register double f26 __asm__ ("f26") = 0.0;
+  register double f28 __asm__ ("f28") = 0.0;
+  register double f30 __asm__ ("f30") = 0.0;
+  __asm__ __volatile__("":"+f"(f20),"+f"(f22),"+f"(f24),"+f"(f26),"+f"(f30));
+  bar ();
+}
+
+int
+main (void)
+{
+  register double f20 __asm__ ("f20") = 12.0;
+  register double f22 __asm__ ("f22") = 13.0;
+  register double f24 __asm__ ("f24") = 14.0;
+  register double f26 __asm__ ("f26") = 15.0;
+  register double f28 __asm__ ("f28") = 16.0;
+  register double f30 __asm__ ("f30") = 17.0;
+
+  try
+    {
+      foo ();
+    }
+  catch (...)
+    {
+      __asm__ ("":"+f"(f20),"+f"(f22),"+f"(f24),"+f"(f26),"+f"(f30));
+    }
+
+  if (f20 != 12.0 || f22 != 13.0 || f24 != 14.0
+      || f26 != 15.0 || f28 != 16.0 || f30 != 17.0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/g++.dg/torture/pr91280.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/torture/pr91280.C b/gcc/testsuite/g++.dg/torture/pr91280.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/torture/pr91280.C	(revision 278653)
@@ -0,0 +1,223 @@
+// { dg-do compile }
+
+enum { Aligned, RowMajor };
+enum { ReadOnlyAccessors };
+template <typename> struct K {
+  enum { value };
+};
+template <typename> struct traits;
+template <typename T> struct traits<const T> : traits<T> {};
+struct A {
+  enum { has_write_access, value };
+};
+template <typename, int n> class array {
+public:
+  int operator[](unsigned long p1) { return values[p1]; }
+  int values[n];
+};
+template <typename> struct I;
+template <typename, int, template <class> class = I> class M;
+template <typename, int, int, typename> class J;
+template <typename, int> class N;
+template <typename, typename> class D;
+template <typename, typename, typename, typename> class TensorContractionOp;
+template <long, typename> class TensorChippingOp;
+class C;
+template <typename DenseIndex, int NumDims>
+struct K<array<DenseIndex, NumDims>> {
+  static const long value = NumDims;
+};
+template <typename Scalar_, int NumIndices_, int Options_, typename IndexType_>
+struct traits<J<Scalar_, NumIndices_, Options_, IndexType_>> {
+  typedef IndexType_ Index;
+};
+template <typename PlainObjectType, int Options_,
+          template <class> class MakePointer_>
+struct traits<M<PlainObjectType, Options_, MakePointer_>>
+    : traits<PlainObjectType> {};
+template <typename T> struct B { typedef T type; };
+template <typename Derived> class N<Derived, ReadOnlyAccessors> {
+public:
+  typedef typename traits<Derived>::Index Index;
+  D<int, Derived> m_fn1();
+  template <typename OtherDerived, typename Dimensions>
+  TensorContractionOp<Dimensions, Derived, const OtherDerived, int>
+      m_fn2(OtherDerived, Dimensions);
+  template <Index> TensorChippingOp<1, Derived> m_fn3(Index);
+};
+template <typename Derived, int = A::value>
+class N : public N<Derived, ReadOnlyAccessors> {
+public:
+  template <typename DeviceType> C m_fn4(DeviceType);
+};
+template <typename, typename> struct TensorEvaluator;
+template <typename UnaryOp, typename ArgType, typename Device>
+struct TensorEvaluator<const D<UnaryOp, ArgType>, Device> {
+  TensorEvaluator(D<UnaryOp, ArgType>, Device);
+};
+template <typename, typename> class D {
+public:
+  typedef typename B<D>::type Nested;
+};
+template <typename Indices_, typename LeftArgType_, typename RightArgType_,
+          typename OutputKernelType_, typename Device_>
+struct traits<
+    TensorEvaluator<const TensorContractionOp<Indices_, LeftArgType_,
+                                              RightArgType_, OutputKernelType_>,
+                    Device_>> {
+  typedef Indices_ Indices;
+  typedef LeftArgType_ LeftArgType;
+  typedef RightArgType_ RightArgType;
+  typedef OutputKernelType_ OutputKernelType;
+  typedef Device_ Device;
+};
+template <typename, typename LhsXprType, typename RhsXprType, typename>
+class TensorContractionOp {
+public:
+  typedef typename B<TensorContractionOp>::type Nested;
+  typename LhsXprType::Nested m_fn5();
+  typename RhsXprType::Nested m_fn6();
+};
+template <typename Derived> struct TensorContractionEvaluatorBase {
+  typedef typename traits<Derived>::LeftArgType LeftArgType;
+  typedef typename traits<Derived>::RightArgType RightArgType;
+  typedef typename traits<Derived>::Device Device;
+  TensorContractionEvaluatorBase(
+      TensorContractionOp<typename traits<Derived>::Indices, LeftArgType,
+                          RightArgType,
+                          typename traits<Derived>::OutputKernelType>
+          p1,
+      Device p2)
+      : m_leftImpl(p1.m_fn6(), p2), m_rightImpl(p1.m_fn5(), p2) {
+    long nocontract_idx;
+    for (int i;; i++) {
+      bool contracting;
+      if (contracting) {
+        if (nocontract_idx < K<int>::value)
+          m_j_size = m_j_strides[nocontract_idx];
+        nocontract_idx++;
+      }
+    }
+  }
+  array<long, 1> m_j_strides;
+  long m_j_size;
+  TensorEvaluator<RightArgType, Device> m_leftImpl;
+  TensorEvaluator<LeftArgType, Device> m_rightImpl;
+};
+template <typename Indices, typename LeftArgType, typename RightArgType,
+          typename OutputKernelType, typename Device>
+struct TensorEvaluator<
+    const TensorContractionOp<Indices, LeftArgType, RightArgType,
+                              OutputKernelType>,
+    Device>
+    : TensorContractionEvaluatorBase<TensorEvaluator<
+          const TensorContractionOp<Indices, LeftArgType, RightArgType,
+                                    OutputKernelType>,
+          Device>> {
+  typedef TensorEvaluator Self;
+  typedef TensorContractionEvaluatorBase<Self> Base;
+  TensorEvaluator(
+      TensorContractionOp<Indices, LeftArgType, RightArgType, OutputKernelType>
+          p1,
+      Device p2)
+      : Base(p1, p2) {}
+};
+template <long DimId, typename XprType>
+struct traits<TensorChippingOp<DimId, XprType>> : traits<XprType> {};
+template <long, typename XprType>
+class TensorChippingOp : public N<TensorChippingOp<1, XprType>> {
+public:
+  typedef typename B<TensorChippingOp>::type Nested;
+};
+template <long DimId, typename ArgType, typename Device>
+struct TensorEvaluator<const TensorChippingOp<DimId, ArgType>, Device> {
+  static const int NumInputDims = K<typename ArgType::Dimensions>::value;
+  array<long, NumInputDims> m_dimensions;
+};
+template <long DimId, typename ArgType, typename Device>
+struct TensorEvaluator<TensorChippingOp<DimId, ArgType>, Device>
+    : TensorEvaluator<const TensorChippingOp<1, ArgType>, Device> {
+  TensorEvaluator(TensorChippingOp<DimId, ArgType>, Device);
+};
+template <typename, typename RhsXprType> class TensorAssignOp {
+public:
+  TensorAssignOp(TensorChippingOp<0, const M<J<int, 3, 1, int>, 1>>,
+                 RhsXprType);
+  TensorChippingOp<0, const M<J<int, 3, 1, int>, 1>> m_fn7();
+  typename RhsXprType::Nested m_fn8();
+};
+template <typename LeftArgType, typename RightArgType, typename Device>
+struct TensorEvaluator<const TensorAssignOp<LeftArgType, RightArgType>,
+                       Device> {
+  TensorEvaluator(TensorAssignOp<LeftArgType, RightArgType> p1, Device p2)
+      : m_leftImpl(p1.m_fn7(), p2), m_rightImpl(p1.m_fn8(), p2) {}
+  TensorEvaluator<LeftArgType, Device> m_leftImpl;
+  TensorEvaluator<RightArgType, Device> m_rightImpl;
+};
+template <typename Expression> class F {
+public:
+  static void m_fn9(Expression p1) {
+    int device;
+    TensorEvaluator<Expression, int>(p1, device);
+  }
+};
+class C {
+public:
+  void
+  operator=(TensorContractionOp<array<int, 1>,
+                                TensorChippingOp<1, M<J<float, 3, 1, int>, 0>>,
+                                const D<int, M<J<float, 3, 1, int>, 0>>, int>
+                p1) {
+    TensorAssignOp<
+        TensorChippingOp<0, const M<J<int, 3, 1, int>, 1>>,
+        const TensorContractionOp<
+            array<int, 1>, TensorChippingOp<1, M<J<float, 3, 1, int>, 0>>,
+            const D<int, M<J<float, 3, 1, int>, 0>>, int>>
+        assign(m_expression, p1);
+    F<const TensorAssignOp<
+        TensorChippingOp<0, const M<J<int, 3, 1, int>, 1>>,
+        const TensorContractionOp<
+            array<int, 1>, TensorChippingOp<1, M<J<float, 3, 1, int>, 0>>,
+            const D<int, M<J<float, 3, 1, int>, 0>>, int>>>::m_fn9(assign);
+  }
+  TensorChippingOp<0, const M<J<int, 3, 1, int>, 1>> m_expression;
+};
+template <typename, int NumIndices_, int, typename> class J {
+public:
+  typedef array<long, NumIndices_> Dimensions;
+};
+template <typename PlainObjectType, int Options_, template <class> class>
+class M : public N<M<PlainObjectType, Options_>> {
+public:
+  typedef typename PlainObjectType::Dimensions Dimensions;
+};
+template <int NDIMS> struct TTypes {
+  typedef M<J<float, NDIMS, RowMajor, int>, Aligned> ConstTensor;
+};
+class L {
+public:
+  template <typename, long NDIMS> typename TTypes<NDIMS>::ConstTensor m_fn10();
+};
+class H {
+public:
+  H(int *);
+};
+class G {
+public:
+  G(H *(int *));
+};
+int Run_d;
+class O : H {
+public:
+  int BatchMatMul_context;
+  O() : H(&BatchMatMul_context) {
+    L out, in_y, in_x;
+    auto Tx = in_x.m_fn10<float, 3>(), Ty = in_y.m_fn10<float, 3>(),
+         Tz = out.m_fn10<float, 3>(), z = Tz;
+    array<int, 1> contract_pairs;
+    auto x = Tx.m_fn3<0>(0);
+    auto y = Ty.m_fn1();
+    z.m_fn4(Run_d) = x.m_fn2(y, contract_pairs);
+  }
+};
+G registrar__body__0__object([](int *) -> H * { O(); return 0; });
Index: gcc/testsuite/g++.dg/torture/pr92384.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/torture/pr92384.C b/gcc/testsuite/g++.dg/torture/pr92384.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/torture/pr92384.C	(revision 278653)
@@ -0,0 +1,38 @@
+// PR c++/92384
+// { dg-do run }
+
+struct S {};
+struct T : public S { S a, b, c, d, e, f, g, h, i, j, k, l, m; };
+struct U { long long a, b, c; };
+
+U
+foo (S, S, S, T, T, T, U g)
+{
+  return g;
+}
+
+__attribute__((noipa)) bool
+bar (S a, S b, S c, T d, T e, T f, U g, void **h)
+{
+  h[0] = (void *) &a;
+  h[1] = (void *) &b;
+  h[2] = (void *) &c;
+  h[3] = (void *) &d;
+  h[4] = (void *) &e;
+  h[5] = (void *) &f;
+  h[6] = (void *) &g;
+  asm volatile ("" : : "r" (h) : "memory");
+  return (h[0] != h[1] && h[1] != h[2] && h[2] != h[3]
+	  && h[3] != h[4] && h[4] != h[5] && h[5] != h[6]);
+}
+
+int
+main ()
+{
+  S a;
+  T b;
+  U c = { 1, 2, 3 };
+  void *d[7];
+  if (!bar (a, a, a, b, b, b, c, d))
+    __builtin_abort ();
+}
Index: gcc/testsuite/g++.dg/torture/pr90194.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/torture/pr90194.C b/gcc/testsuite/g++.dg/torture/pr90194.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/torture/pr90194.C	(revision 278653)
@@ -0,0 +1,18 @@
+// { dg-do compile }
+// { dg-additional-options "-g" }
+
+struct cb {
+    int yr;
+};
+
+void *
+operator new (__SIZE_TYPE__, void *nq)
+{
+  return nq;
+}
+
+void
+af (int xn)
+{
+  new (&xn) cb { };
+}
Index: gcc/testsuite/g++.dg/torture/pr91355.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/torture/pr91355.C b/gcc/testsuite/g++.dg/torture/pr91355.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/torture/pr91355.C	(revision 278653)
@@ -0,0 +1,28 @@
+// PR tree-optimization/91355
+// { dg-do run }
+// { dg-options "-std=c++14" }
+
+unsigned int d = 0;
+
+struct S {
+  S () { d++; }
+  S (const S &) { d++; }
+  ~S () { d--; }
+};
+
+void
+foo (int i) throw (int) // { dg-warning "dynamic exception specifications are deprecated" }
+{
+  if (i == 0)
+    throw 3;
+  S d;
+  throw 3;
+}
+
+int
+main ()
+{
+  try { foo (1); } catch (...) {}
+  if (d)
+    __builtin_abort ();
+}
Index: gcc/testsuite/g++.dg/torture/pr89698.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/torture/pr89698.C b/gcc/testsuite/g++.dg/torture/pr89698.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/torture/pr89698.C	(revision 278653)
@@ -0,0 +1,28 @@
+/* { dg-do run } */
+
+extern "C" void abort (void);
+
+class A {
+    virtual void f(){};
+public:
+    int x;
+    A(int in): x(in) {};
+};
+
+class B: public A {
+public:
+    int y;
+    B(int in):A(in-1), y(in) {};
+};
+
+int test(void)
+{
+  int res;
+  B b(2);
+  A* bp = &b;
+  void* vp = dynamic_cast<void*>(bp);
+  if (((A*)vp)->x == 1 && ((B*)vp)->y == 2)
+    return 1;
+  return 0;
+}
+int main() { if (test() != 1) abort (); return 0; }
Index: gcc/testsuite/g++.dg/ipa/pr88235.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ipa/pr88235.C b/gcc/testsuite/g++.dg/ipa/pr88235.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ipa/pr88235.C	(revision 278653)
@@ -0,0 +1,55 @@
+// { dg-do compile }
+// { dg-options "-O1 -fdevirtualize -finline-small-functions -fipa-cp -fipa-cp-clone --param ipa-cp-eval-threshold=125 --param max-inline-insns-single=4" }
+
+extern "C" int printf (const char *, ...);
+enum E { vf_request, vf_event } want;
+
+int errs = 0;
+
+class ivResource {
+public:
+  virtual ~ivResource () { }
+};
+
+class ivHandler   : public ivResource   {
+public:
+  virtual void event() { }
+};
+
+class ivGlyph   : public ivResource   {
+public:
+  virtual ~ivGlyph  () { }
+  virtual void request () {
+    if (want!=vf_request)
+      ++errs;
+  }
+};
+
+class ItemView : public ivGlyph, public ivHandler {
+public:
+  virtual void event () {
+    if (want!=vf_event)
+      ++errs;
+  }
+} a;
+
+ivGlyph *bar() {
+  return &a;
+}
+
+ivHandler *bar2() {
+  return &a;
+}
+
+int main() {
+  want=vf_request;
+  bar()->request();
+  want=vf_event;
+  bar2()->event();
+  if (errs) {
+    printf("FAIL\n");
+    return 1;
+  }
+  printf("PASS\n");
+  return 0;
+}
Index: gcc/testsuite/g++.dg/ipa/pr89693.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ipa/pr89693.C b/gcc/testsuite/g++.dg/ipa/pr89693.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ipa/pr89693.C	(revision 278653)
@@ -0,0 +1,52 @@
+// Copyright (C) 2005 Free Software Foundation, Inc.
+// Contributed by Nathan Sidwell 4 Apr 2005 <nathan@codesourcery.com>
+// Re-purposed to check for re-rurgesnce of PR 89693 in 2019.
+
+// { dg-do compile }
+// { dg-options "-O3 -fno-ipa-icf-functions" }
+
+// Origin: yanliu@ca.ibm.com
+//         nathan@codesourcery.com
+
+struct A {
+  virtual void One ();
+};
+struct B  {
+  virtual B *Two ();
+  virtual B &Three ();
+};
+
+struct C : A, B
+{
+  virtual C *Two ();
+  virtual C &Three ();
+};
+void A::One () {}
+B *B::Two()    {return this;}
+B &B::Three()    {return *this;}
+C *C::Two ()   {return 0;}
+C &C::Three ()   {return *(C *)0;}
+
+B *Foo (B *b)
+{
+  return b->Two ();
+}
+
+B &Bar (B *b)
+{
+  return b->Three ();
+}
+
+int main ()
+{
+  C c;
+
+  /* We should not adjust a null pointer.  */
+  if (Foo (&c))
+    return 1;
+  /* But we should adjust a (bogus) null reference.  */
+  if (!&Bar (&c))
+    return 2;
+
+  return 0;
+}
Index: gcc/testsuite/g++.dg/cet-notrack-1.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cet-notrack-1.C b/gcc/testsuite/g++.dg/cet-notrack-1.C
--- a/gcc/testsuite/g++.dg/cet-notrack-1.C	(revision 278653)
+++ b/gcc/testsuite/g++.dg/cet-notrack-1.C	(revision 278653)
@@ -1,7 +1,7 @@
 /* { dg-do compile { target i?86-*-* x86_64-*-* } } */
 /* { dg-options "-fcf-protection" } */
 /* { dg-final { scan-assembler "endbr32|endbr64" } } */
-/* { dg-final { scan-assembler-times "\tcall\[ \t]+puts" 2 } } */
+/* { dg-final { scan-assembler-times "\tcall\[ \t]+_?puts" 2 } } */
 /* { dg-final { scan-assembler-times "notrack call\[ \t]+" 1 } } */
 #include <stdio.h>
 
Index: gcc/testsuite/g++.dg/cpp1y/var-templ61.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/var-templ61.C b/gcc/testsuite/g++.dg/cpp1y/var-templ61.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1y/var-templ61.C	(revision 278653)
@@ -0,0 +1,20 @@
+// PR c++/89512
+// { dg-do compile { target c++14 } }
+
+struct A {
+  template <typename T>
+  static const int a = 0;
+};
+
+struct B {
+  template <typename T>
+  static int foo ()
+  {
+    return T::a;		// { dg-error "missing template arguments" }
+  }
+};
+
+int bar ()
+{
+  return B::foo<A> ();		// { dg-message "required from here" }
+}
Index: gcc/testsuite/g++.dg/cpp1y/pr89767.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/pr89767.C b/gcc/testsuite/g++.dg/cpp1y/pr89767.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1y/pr89767.C	(revision 278653)
@@ -0,0 +1,32 @@
+// PR c++/89767
+// { dg-do compile { target c++14 } }
+// { dg-options "-O2 -Wall" }
+
+template <typename d> struct e { using g = d; };
+template <typename d, template <typename> class> using h = e<d>;
+template <typename d, template <typename> class i>
+using j = typename h<d, i>::g;
+template <typename c> int k(c);
+template <typename...> class au;
+struct l { template <typename c> using m = typename c::f; };
+struct s : l { using af = j<au<int, int> *, m>; };
+template <unsigned long, typename> struct o;
+template <long p, typename c> using q = typename o<p, c>::g;
+template <typename> struct r;
+template <typename c> struct r<c *> { typedef c aj; };
+template <typename ak, typename> struct al { typename r<ak>::aj operator*(); void operator++(); };
+template <typename am, typename an, typename ao>
+bool operator!=(al<am, ao>, al<an, ao>);
+template <unsigned long, typename...> struct ap;
+template <unsigned long aq, typename ar, typename... as>
+struct ap<aq, ar, as...> : ap<1, as...> {};
+template <unsigned long aq, typename ar> struct ap<aq, ar> {};
+template <typename... at> class au : public ap<0, at...> {};
+template <unsigned long p, typename ar, typename... as>
+struct o<p, au<ar, as...>> : o<p - 1, au<as...>> {};
+template <typename ar, typename... as> struct o<0, au<ar, as...>> { typedef ar g; };
+template <long p, typename ar> constexpr ar av(ap<p, ar> __t) { return ar (); }
+template <int p, typename... at> constexpr q<p, au<at...>> aw(au<at...> __t) { av<p>(__t); return q<p, au<at...>> (); }
+struct bg { typedef s::af af; };
+struct F { typedef al<bg::af, int> bk; bk begin(); bk end(); };
+void bo() { int t = 0; F cv; for (auto bp : cv) [t, n = k(aw<1>(bp))] {}; }
Index: gcc/testsuite/g++.dg/cpp1y/lambda-init18.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-init18.C b/gcc/testsuite/g++.dg/cpp1y/lambda-init18.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-init18.C	(revision 278653)
@@ -0,0 +1,12 @@
+// PR c++/89767
+// { dg-do compile { target c++14 } }
+
+void bar (int);
+
+void
+foo ()
+{
+  int x = 0;
+  auto z = [x, y = [x] { bar (x); }] { y (); bar (x); };
+  z ();
+}
Index: gcc/testsuite/g++.dg/cpp1y/lambda-init19.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-init19.C b/gcc/testsuite/g++.dg/cpp1y/lambda-init19.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-init19.C	(revision 278653)
@@ -0,0 +1,15 @@
+// PR c++/89767
+// { dg-do compile { target c++14 } }
+
+void bar (int);
+
+void
+foo ()
+{
+  int x = 0;
+  int a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0;
+  auto z = [x, y = [x] { bar (x); }, x] { y (); bar (x); };	// { dg-error "already captured 'x' in lambda expression" }
+  auto w = [x, a, b, c, d, y = [x] { bar (x); }, e, f, g, h, x] { y (); bar (x + a + b + c + d + e + f + g + h); };	// { dg-error "already captured 'x' in lambda expression" }
+  z ();
+  w ();
+}
Index: gcc/testsuite/g++.dg/cpp1z/constexpr-if28.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-if28.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-if28.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-if28.C	(revision 278653)
@@ -0,0 +1,11 @@
+// PR c++/89576
+// { dg-do compile { target c++17 } }
+
+template <class T>
+void foo()
+{
+    constexpr int x = 0;
+    [&] {
+        if constexpr (x) {}
+    };
+}
Index: gcc/testsuite/g++.dg/cpp1z/decomp49.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp49.C b/gcc/testsuite/g++.dg/cpp1z/decomp49.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp49.C	(revision 278653)
@@ -0,0 +1,14 @@
+// PR c++/82075
+// { dg-do run { target c++11 } }
+// { dg-options "" }
+
+struct B { };
+struct D : B { int i; };
+
+int
+main ()
+{
+  auto [i] = D{};	// { dg-warning "only available with" "" { target c++14_down } }
+  if (i != 0)
+    __builtin_abort ();
+}
Index: gcc/testsuite/g++.dg/cpp1z/decomp50.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp50.C b/gcc/testsuite/g++.dg/cpp1z/decomp50.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp50.C	(revision 278653)
@@ -0,0 +1,51 @@
+// PR c++/92106 - ICE with structured bindings and -Wreturn-local-addr. 
+// { dg-do compile { target c++17 } }
+
+template <typename> struct B;
+template <typename _Tp> struct B<_Tp *> { typedef _Tp& reference; };
+struct C {
+  template <typename _Up> using rebind = _Up *;
+};
+template <typename _Iterator, typename> class D {
+public:
+  typename B<_Iterator>::reference operator*();
+  void operator++();
+};
+
+template <typename _Iterator, typename _Container>
+bool operator!=(D<_Iterator, _Container>, D<_Iterator, _Container>);
+template <typename _Tp> class F {
+public:
+  typedef _Tp value_type;
+};
+
+template <typename _Alloc> struct G {
+  template <typename _Tp> struct H { using type = C::rebind<_Tp>; };
+  using const_pointer = typename H<typename _Alloc::value_type>::type;
+};
+template <typename _Tp, typename _Alloc = F<_Tp>> class I {
+  typedef D<typename G<_Alloc>::const_pointer, int> const_iterator;
+
+public:
+  const_iterator begin();
+  const_iterator end();
+};
+
+struct A {
+  struct J {
+    int name;
+    int value;
+  };
+  I<J> members;
+  template <typename Key> const int *find(Key) {
+    for (const auto &[name, value] : members)
+      // See <https://gcc.gnu.org/ml/gcc-patches/2019-10/msg01107.html>
+      // for why we don't warn here.
+      return &value; // { dg-bogus "address of local variable" }
+    return nullptr;
+  }
+};
+int main() {
+  A a;
+  a.find("");
+}
Index: gcc/testsuite/g++.dg/cpp1z/aggr-base7.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/aggr-base7.C b/gcc/testsuite/g++.dg/cpp1z/aggr-base7.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/aggr-base7.C	(revision 278653)
@@ -0,0 +1,8 @@
+// PR c++/88690
+// { dg-do compile { target c++11 } }
+
+struct A { int a = 1; };
+struct B { int b = 0; };
+struct C { C() = default; C (const C&) = delete; };
+struct D : public B, public C {};
+struct E : A { D f; } g{};
Index: gcc/testsuite/g++.dg/cpp1z/inline-var5.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/inline-var5.C b/gcc/testsuite/g++.dg/cpp1z/inline-var5.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/inline-var5.C	(revision 278653)
@@ -0,0 +1,27 @@
+// PR c++/89405
+// { dg-do compile { target c++17 } }
+// { dg-options "-fno-weak" }
+
+template <int N>
+struct S
+{
+  static constexpr int a = N;	// { dg-warning "semantics of inline variable" }
+};				// { dg-message "you can work around this" "" { target *-*-* } .-1 }
+
+const int *x = &S<0>::a;
+// PR c++/87921
+// { dg-do compile { target c++17 } }
+
+template <class H>
+struct X
+{
+  static inline long x[] = { 1L };
+  long foo () { return x[0]; }
+};
+
+void
+bar ()
+{
+  class L {};
+  X<L> v {};
+}
Index: gcc/testsuite/g++.dg/cpp1z/aggr-base8.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/aggr-base8.C b/gcc/testsuite/g++.dg/cpp1z/aggr-base8.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/aggr-base8.C	(revision 278653)
@@ -0,0 +1,48 @@
+// PR c++/89214
+// { dg-do compile { target c++17 } }
+
+struct A
+{
+  A (int);
+};
+
+struct BB
+{
+  A a;
+};
+
+struct B : BB
+{
+};
+
+void
+foo ()
+{
+  B b1 = {42};
+  B b2 = {{42}};
+  B b3 = {{{42}}};
+
+  B b4 = B{42};
+  B b5 = B{{42}};
+  B b6 = B{{{42}}};
+
+  B b7 = {B{42}};
+  B b8 = {B{{42}}};
+  B b9 = {B{{{42}}}};
+
+  B b10 = {{B{42}}}; // { dg-warning "initializing a base class of type .BB. results in object slicing" }
+  B b11 = {{B{{42}}}}; // { dg-warning "initializing a base class of type .BB. results in object slicing" }
+  B b12 = {{B{{{42}}}}}; // { dg-warning "initializing a base class of type .BB. results in object slicing" }
+
+  B bb1{42};
+  B bb2{{42}};
+  B bb3{{{42}}};
+
+  B bb7{B{42}};
+  B bb8{B{{42}}};
+  B bb9{B{{{42}}}};
+
+  B bb10{{B{42}}}; // { dg-warning "initializing a base class of type .BB. results in object slicing" }
+  B bb11{{B{{42}}}}; // { dg-warning "initializing a base class of type .BB. results in object slicing" }
+  B bb12{{B{{{42}}}}}; // { dg-warning "initializing a base class of type .BB. results in object slicing" }
+}
Index: gcc/testsuite/g++.dg/cpp1z/class-deduction62.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction62.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction62.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction62.C	(revision 278653)
@@ -0,0 +1,22 @@
+// PR c++/88419
+// { dg-do compile { target c++17 } }
+
+template<class> struct ref_view {
+  template<class T> ref_view(T&&);
+};
+
+template<class R> ref_view(R&) -> ref_view<R>;
+
+struct ref_fn {
+  template<class R> auto operator()(R r) const
+    noexcept(noexcept(ref_view{r}));
+};
+
+template<class R> struct indirect_view {
+  indirect_view(R);
+};
+
+struct indirect_fn {
+  template<class R> auto operator()(R r) const
+    noexcept(noexcept(indirect_view{r}));
+};
Index: gcc/testsuite/g++.dg/cpp1z/aggr-base9.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/aggr-base9.C b/gcc/testsuite/g++.dg/cpp1z/aggr-base9.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/aggr-base9.C	(revision 278653)
@@ -0,0 +1,33 @@
+// PR c++/89214
+// { dg-do compile { target c++17 } }
+
+struct B {
+  int c;
+};
+
+struct D : B { };
+
+void
+foo ()
+{
+  D d1 = {42};
+  D d2 = {{42}};
+  
+  D d4 = D{42};
+  D d5 = D{{42}};
+ 
+  D d7 = {D{42}};
+  D d8 = {D{{42}}};
+
+  D d10 = {{D{42}}}; // { dg-warning "initializing a base class of type .B. results in object slicing" }
+  D d11 = {{D{{42}}}}; // { dg-warning "initializing a base class of type .B. results in object slicing" }
+
+  D dd1{42};
+  D dd2{{42}};
+  
+  D dd7{D{42}};
+  D dd8{D{{42}}};
+
+  D dd10{{D{42}}}; // { dg-warning "initializing a base class of type .B. results in object slicing" }
+  D dd11{{D{{42}}}}; // { dg-warning "initializing a base class of type .B. results in object slicing" }
+}
Index: gcc/testsuite/g++.dg/cpp1z/class-deduction63.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction63.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction63.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction63.C	(revision 278653)
@@ -0,0 +1,11 @@
+// PR c++/88869
+// { dg-do compile { target c++17 } }
+
+template <typename> struct B;
+template <> struct B<int> {
+  template <typename T> struct C {
+    T e;
+    C (T f) : e(f) {}
+  };
+  void foo () { C c (42); }
+};
Index: gcc/testsuite/g++.dg/cpp1z/class-deduction64.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction64.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction64.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction64.C	(revision 278653)
@@ -0,0 +1,9 @@
+// PR c++/88820
+// { dg-do compile { target c++17 } }
+
+template <int> struct S;
+
+template <S> struct W {
+  template <typename> static int foo();
+  bool b = foo<int>();
+};
Index: gcc/testsuite/g++.dg/cpp1z/eval-order5.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/eval-order5.C b/gcc/testsuite/g++.dg/cpp1z/eval-order5.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/eval-order5.C	(revision 278653)
@@ -0,0 +1,31 @@
+// PR c++/91974
+// { dg-do run }
+// { dg-options "-fstrong-eval-order" }
+
+extern "C" void abort ();
+
+bool ok = false;
+
+void
+foo (int x)
+{
+  if (x != 0)
+    abort ();
+  ok = true;
+}
+
+void
+bar (int)
+{
+  abort ();
+}
+
+int
+main ()
+{
+  typedef void (*T) (int);
+  T fn = foo;
+  fn ((fn = bar, 0));
+  if (fn != bar || !ok)
+    abort ();
+}
Index: gcc/testsuite/g++.dg/cpp1z/class-deduction58.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction58.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction58.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction58.C	(revision 278653)
@@ -0,0 +1,16 @@
+// PR c++/86098
+// { dg-additional-options -std=c++17 }
+
+template <class _Res> class future;
+template <class T> T&& declval();
+
+template<template <class...> class T>
+struct construct_deduced {
+  template <class... AN>
+  using deduced_t = decltype(T{declval<AN>()...});
+  template<class... AN>
+  deduced_t<AN...> operator()(AN&&... an) const;
+};
+
+template<class T>
+future<T> future_from(T singleSender);
Index: gcc/testsuite/g++.dg/cpp1z/fold-lambda3.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/fold-lambda3.C b/gcc/testsuite/g++.dg/cpp1z/fold-lambda3.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/fold-lambda3.C	(revision 278653)
@@ -0,0 +1,19 @@
+// PR c++/88183
+// { dg-do compile { target c++17 } }
+
+struct A { int i; };
+
+template <class T> T& g(T);
+
+template <class U, class... Vs>
+void f(U u, Vs... vs)
+{ 
+  [vs...](auto x) {
+    (g(x) .* ... .* vs) = 42;
+  }(u);
+}
+
+int main()
+{
+  f(A(), &A::i);
+}
Index: gcc/testsuite/g++.dg/ext/flexary34.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/flexary34.C b/gcc/testsuite/g++.dg/ext/flexary34.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ext/flexary34.C	(revision 278653)
@@ -0,0 +1,10 @@
+// PR c++/87148
+// { dg-do compile }
+// { dg-options "-pedantic" }
+
+struct Tst { int i; char t[]; };	// { dg-warning "forbids flexible array member" }
+
+Tst t {};				// { dg-warning "extended initializer lists only available with" "" { target c++98_only } }
+Tst u = Tst();
+void foo () { Tst u = {}; }
+Tst *bar () { return new Tst (); }
Index: gcc/testsuite/g++.dg/ext/90532.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/90532.C b/gcc/testsuite/g++.dg/ext/90532.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ext/90532.C	(revision 278653)
@@ -0,0 +1,27 @@
+// { dg-do compile { target c++11 } }
+// PR c++/90532
+static_assert( !__is_constructible(int[]), "" );
+static_assert( !__is_constructible(int[], int), "" );
+static_assert( !__is_constructible(int[], int[]), "" );
+static_assert( !__is_trivially_constructible(int[]), "" );
+static_assert( !__is_trivially_constructible(int[], int), "" );
+static_assert( !__is_trivially_constructible(int[], int[]), "" );
+static_assert( !__is_trivially_constructible(int[], int(&)[]), "" );
+static_assert( !__is_trivially_constructible(int[], void), "" );
+struct A { };
+static_assert( !__is_constructible(A[]), "" );
+static_assert( !__is_constructible(A[], const A&), "" );
+static_assert( !__is_constructible(A[], const A[]), "" );
+static_assert( !__is_trivially_constructible(A[]), "" );
+static_assert( !__is_trivially_constructible(A[], const A&), "" );
+static_assert( !__is_trivially_constructible(A[], const A[]), "" );
+static_assert( !__is_trivially_constructible(A[], A(&)[]), "" );
+static_assert( !__is_trivially_constructible(A[], void), "" );
+struct B { B(); };
+static_assert( !__is_constructible(B[]), "" );
+static_assert( !__is_constructible(B[], const B&), "" );
+static_assert( !__is_trivially_constructible(B[]), "" );
+static_assert( !__is_trivially_constructible(B[], const B&), "" );
+static_assert( !__is_trivially_constructible(B[], const B[]), "" );
+static_assert( !__is_trivially_constructible(B[], B(&)[]), "" );
+static_assert( !__is_trivially_constructible(B[], void), "" );
Index: gcc/testsuite/g++.dg/ext/instantiate2.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/instantiate2.C b/gcc/testsuite/g++.dg/ext/instantiate2.C
--- a/gcc/testsuite/g++.dg/ext/instantiate2.C	(revision 278653)
+++ b/gcc/testsuite/g++.dg/ext/instantiate2.C	(revision 278653)
@@ -8,8 +8,7 @@
 template <class T> T A<T>::t = 0;
 static template struct A<int>;
 
-// { dg-final { scan-assembler "\n_?_ZN1AIiE1tE(:|\n|\t)" { target { ! *-*-darwin* } } } }
-// { dg-final { scan-assembler ".zerofill __DATA,__pu_bss2,__ZN1AIiE1tE" { target *-*-darwin* } } } 
+// { dg-final { scan-assembler "\n_?_ZN1AIiE1tE(:|\n|\t)" } }
 void test_int() { A<int>::t = 42; }
 
 // { dg-final { scan-assembler-not "\n_?_ZN1AIcE1tE(:|\n|\t)" } }
Index: gcc/testsuite/g++.dg/ext/alignof2.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/alignof2.C b/gcc/testsuite/g++.dg/ext/alignof2.C
--- a/gcc/testsuite/g++.dg/ext/alignof2.C	(revision 278653)
+++ b/gcc/testsuite/g++.dg/ext/alignof2.C	(revision 278653)
@@ -3,7 +3,7 @@
 // wrong for some fields.
 
 // { dg-do run }
-// { dg-xfail-run-if "AIX ABI increases struct alignment for first member double" { powerpc-ibm-aix* } }
+// { dg-xfail-run-if "AIX/Darwin ABI increases struct alignment for first member double" { powerpc-ibm-aix* || { ilp32 && powerpc-*-darwin* } } }
 
 extern "C" void abort();
 
Index: gcc/testsuite/g++.dg/ext/asm15.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/asm15.C b/gcc/testsuite/g++.dg/ext/asm15.C
--- a/gcc/testsuite/g++.dg/ext/asm15.C	(revision 278653)
+++ b/gcc/testsuite/g++.dg/ext/asm15.C	(revision 278653)
@@ -6,5 +6,6 @@
 void
 foo (S &s)
 {
-  __asm volatile ("" : "+r" (s) : : "memory");	// { dg-error "" }
+  __asm volatile ("" : "+r" (s) : : "memory");	// { dg-error "impossible constraint" }
+						// { dg-error "must stay in memory" "" { target *-*-* } .-1 }
 }
Index: gcc/testsuite/g++.dg/ext/asm16.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/asm16.C b/gcc/testsuite/g++.dg/ext/asm16.C
--- a/gcc/testsuite/g++.dg/ext/asm16.C	(revision 278653)
+++ b/gcc/testsuite/g++.dg/ext/asm16.C	(revision 278653)
@@ -6,5 +6,6 @@
 void
 foo ()
 {
-  __asm volatile ("" : "=r" (s) : : "memory");	// { dg-error "" }
+  __asm volatile ("" : "=r" (s) : : "memory");	// { dg-error "impossible constraint" }
+						// { dg-error "must stay in memory" "" { target *-*-* } .-1 }
 }
Index: gcc/testsuite/g++.dg/ext/asm17.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/asm17.C b/gcc/testsuite/g++.dg/ext/asm17.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ext/asm17.C	(revision 278653)
@@ -0,0 +1,11 @@
+// PR target/89752
+// { dg-do compile }
+
+struct A { A (); ~A (); short c; };
+
+void
+foo ()
+{
+  A a0, a1;
+  __asm volatile ("" : "+rm" (a0), "+rm" (a1));
+}
Index: gcc/testsuite/g++.dg/ext/vector37.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/vector37.C b/gcc/testsuite/g++.dg/ext/vector37.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ext/vector37.C	(revision 278653)
@@ -0,0 +1,29 @@
+// PR c++/90810
+// { dg-do run }
+
+void
+foo (float x, float y)
+{
+  typedef float __attribute__ ((__vector_size__ (4 * sizeof (float)), __may_alias__)) V;
+  const V a = { x, x, x, x }, b = { y, y, y, y };
+  const V c = a / b;
+  if (c[0] != 6.0f || c[1] != 6.0f || c[2] != 6.0f || c[3] != 6.0f)
+    __builtin_abort ();
+}
+
+void
+bar (float y)
+{
+  typedef float __attribute__ ((__vector_size__ (4 * sizeof (float)), __may_alias__)) V;
+  const V a = { 7.0f, 8.0f, 9.0f, 10.0f }, b = { 1.0f, 2.0f, 3.0f, y };
+  const V c = a / b;
+  if (c[0] != 7.0f || c[1] != 4.0f || c[2] != 3.0f || c[3] != 5.0f)
+    __builtin_abort ();
+}
+
+int
+main ()
+{
+  foo (12.0f, 2.0f);
+  bar (2.0f);
+}
Index: gcc/testsuite/g++.dg/pch/pr90326.Hs
===================================================================
diff --git a/gcc/testsuite/g++.dg/pch/pr90326.Hs b/gcc/testsuite/g++.dg/pch/pr90326.Hs
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/pch/pr90326.Hs	(revision 278653)
@@ -0,0 +1 @@
+// empty
Index: gcc/testsuite/g++.dg/pch/pr90326.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/pch/pr90326.C b/gcc/testsuite/g++.dg/pch/pr90326.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/pch/pr90326.C	(revision 278653)
@@ -0,0 +1,9 @@
+#include "pr90326.H"
+
+int main()
+{
+  float f = __FLT_MAX__;
+  if (f == 0.0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/g++.dg/gomp/lastprivate-1.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/gomp/lastprivate-1.C b/gcc/testsuite/g++.dg/gomp/lastprivate-1.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/gomp/lastprivate-1.C	(revision 278653)
@@ -0,0 +1,16 @@
+// PR c++/90950
+// { dg-do compile }
+
+template <typename T>
+T
+foo (void)
+{
+  T y = 0;
+  T &x = y;
+  #pragma omp parallel for lastprivate (x)
+  for (int i = 0; i < 8; ++i)
+    x = i;
+  return x;
+}
+
+int a = foo<int> ();
Index: gcc/testsuite/g++.dg/gomp/pr89796.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/gomp/pr89796.C b/gcc/testsuite/g++.dg/gomp/pr89796.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/gomp/pr89796.C	(revision 278653)
@@ -0,0 +1,53 @@
+// PR c++/89796
+// { dg-do compile }
+// { dg-additional-options "-Wunused-value" }
+
+int
+f1 (int &c)
+{
+  int r;
+  #pragma omp atomic capture	// { dg-bogus "value computed is not used" }
+  { r = c; c++; }
+  return r;
+}
+
+template <int N>
+int
+f2 (int &c)
+{
+  int r;
+  #pragma omp atomic capture	// { dg-bogus "value computed is not used" }
+  { r = c; c++; }
+  return r;
+}
+
+int
+f3 (int &c)
+{
+  return f2 <0> (c);
+}
+
+int
+f4 (int *p)
+{
+  int r;
+  #pragma omp atomic capture	// { dg-bogus "value computed is not used" }
+  { r = *p; (*p)++; }
+  return r;
+}
+
+template <int N>
+int
+f5 (int *p)
+{
+  int r;
+  #pragma omp atomic capture	// { dg-bogus "value computed is not used" }
+  { r = *p; (*p)++; }
+  return r;
+}
+
+int
+f6 (int *p)
+{
+  return f5 <0> (p);
+}
Index: gcc/testsuite/g++.dg/other/pr92201.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/other/pr92201.C b/gcc/testsuite/g++.dg/other/pr92201.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/other/pr92201.C	(revision 278653)
@@ -0,0 +1,7 @@
+// PR c++/92201
+
+int
+foo (void (*p) ())
+{
+  return (*reinterpret_cast<int (*)()> (p)) ();
+}
Index: gcc/testsuite/g++.dg/other/pr88568.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/other/pr88568.C b/gcc/testsuite/g++.dg/other/pr88568.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/other/pr88568.C	(revision 278653)
@@ -0,0 +1,13 @@
+// PR c/88568
+// { dg-do compile }
+// { dg-require-dll "" }
+
+struct S {
+  __attribute__((dllimport)) static const char foo[];
+};
+
+int
+foo (int x)
+{
+  return S::foo[x];
+}
Index: gcc/testsuite/g++.dg/tree-ssa/tail-call-1.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tree-ssa/tail-call-1.C b/gcc/testsuite/g++.dg/tree-ssa/tail-call-1.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tree-ssa/tail-call-1.C	(revision 278653)
@@ -0,0 +1,11 @@
+// PR c++/82081
+// { dg-do compile { target c++11 } }
+// { dg-additional-options "-O2 -fdump-tree-optimized" }
+// { dg-final { scan-tree-dump-not "tail call" "optimized" } }
+
+int g(int) ;
+
+int f() noexcept {
+    int i = 42, j = 43;
+    return g(i+j);
+}
Index: gcc/testsuite/g++.dg/tree-ssa/pr87008.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tree-ssa/pr87008.C b/gcc/testsuite/g++.dg/tree-ssa/pr87008.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tree-ssa/pr87008.C	(revision 278653)
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-optimized" } */
+
+extern void dontcallthis();
+
+struct A { long a, b; };
+struct B : A {};
+template<class T>void cp(T&a,T const&b){a=b;}
+long f(B x){
+  B y; cp<A>(y,x);
+  B z; cp<A>(z,x);
+  if (y.a - z.a)
+    dontcallthis ();
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-not "dontcallthis" "optimized" } } */
Index: gcc/testsuite/g++.dg/tls/thread_local11.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tls/thread_local11.C b/gcc/testsuite/g++.dg/tls/thread_local11.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tls/thread_local11.C	(revision 278653)
@@ -0,0 +1,36 @@
+// PR c++/60702
+// { dg-do compile { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+// { dg-additional-options "-fdump-tree-gimple" }
+// { dg-final { scan-tree-dump-times "_ZTW2s1" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTW2s2" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTW2s3" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTW2s4" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u1E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u2E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u3E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u4E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u5E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u6E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u7E" 2 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTWN1T2u8E" 2 "gimple" } }
+
+#include "thread_local11.h"
+
+void
+foo ()
+{
+  f1 ();
+  f2 ();
+  f3 ();
+  f4 ();
+  f5 ();
+  f6 ();
+  f7<0> ();
+  f8<0> ();
+  f9<0> ();
+  f10<0> ();
+  f11<0> ();
+  f12<0> ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12a.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tls/thread_local12a.C b/gcc/testsuite/g++.dg/tls/thread_local12a.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tls/thread_local12a.C	(revision 278653)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (f1 ()->i != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12b.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tls/thread_local12b.C b/gcc/testsuite/g++.dg/tls/thread_local12b.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tls/thread_local12b.C	(revision 278653)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (*f2 () != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12c.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tls/thread_local12c.C b/gcc/testsuite/g++.dg/tls/thread_local12c.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tls/thread_local12c.C	(revision 278653)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (f3 ()->i != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12d.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tls/thread_local12d.C b/gcc/testsuite/g++.dg/tls/thread_local12d.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tls/thread_local12d.C	(revision 278653)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (*f4 () != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12e.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tls/thread_local12e.C b/gcc/testsuite/g++.dg/tls/thread_local12e.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tls/thread_local12e.C	(revision 278653)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (f5 ()->i != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12f.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tls/thread_local12f.C b/gcc/testsuite/g++.dg/tls/thread_local12f.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tls/thread_local12f.C	(revision 278653)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (*f6 () != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12g.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tls/thread_local12g.C b/gcc/testsuite/g++.dg/tls/thread_local12g.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tls/thread_local12g.C	(revision 278653)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (f7<0> ()->i != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12h.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tls/thread_local12h.C b/gcc/testsuite/g++.dg/tls/thread_local12h.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tls/thread_local12h.C	(revision 278653)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (*f8<0> () != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12i.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tls/thread_local12i.C b/gcc/testsuite/g++.dg/tls/thread_local12i.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tls/thread_local12i.C	(revision 278653)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (f9<0> ()->i != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12j.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tls/thread_local12j.C b/gcc/testsuite/g++.dg/tls/thread_local12j.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tls/thread_local12j.C	(revision 278653)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (*f10<0> () != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12k.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tls/thread_local12k.C b/gcc/testsuite/g++.dg/tls/thread_local12k.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tls/thread_local12k.C	(revision 278653)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (f11<0> ()->i != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/thread_local12l.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tls/thread_local12l.C b/gcc/testsuite/g++.dg/tls/thread_local12l.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tls/thread_local12l.C	(revision 278653)
@@ -0,0 +1,12 @@
+// PR c++/60702
+// { dg-do run { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-effective-target tls_runtime }
+
+#include "thread_local11.h"
+
+int
+main ()
+{
+  if (*f12<0> () != 42) abort ();
+}
Index: gcc/testsuite/g++.dg/tls/pr85400.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tls/pr85400.C b/gcc/testsuite/g++.dg/tls/pr85400.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tls/pr85400.C	(revision 278653)
@@ -0,0 +1,24 @@
+// PR c++/85400
+// Testcase by Brian Vandenberg <phantall@gmail.com>
+
+// { dg-do link { target c++11 } }
+// { dg-require-effective-target fpic }
+// { dg-require-effective-target shared }
+// { dg-require-effective-target tls }
+// { dg-options "-shared -fPIC -O" }
+// { dg-add-options tls }
+
+struct Test
+{
+  int blah (int y)
+  {
+    thread_local int mything = 3;
+    mything = y > 0 ? y : mything;
+    return mything;
+  }
+};
+
+int stuff (Test& test, int y)
+{
+  return test.blah(y);
+}
Index: gcc/testsuite/g++.dg/tls/thread_local11a.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tls/thread_local11a.C b/gcc/testsuite/g++.dg/tls/thread_local11a.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tls/thread_local11a.C	(revision 278653)
@@ -0,0 +1,20 @@
+// PR c++/60702
+// { dg-do compile { target c++11 } }
+// { dg-add-options tls }
+// { dg-require-alias "" }
+// { dg-require-effective-target tls_runtime }
+// { dg-additional-options "-fdump-tree-gimple" }
+// { dg-final { scan-tree-dump-times "_ZTH2s1" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTH2s2" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTH2s3" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTH2s4" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u1E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u2E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u3E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u4E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u5E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u6E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u7E" 1 "gimple" } }
+// { dg-final { scan-tree-dump-times "_ZTHN1T2u8E" 1 "gimple" } }
+
+#include "thread_local11.C"
Index: gcc/testsuite/g++.dg/tls/thread_local11.h
===================================================================
diff --git a/gcc/testsuite/g++.dg/tls/thread_local11.h b/gcc/testsuite/g++.dg/tls/thread_local11.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tls/thread_local11.h	(revision 278653)
@@ -0,0 +1,26 @@
+// PR c++/60702
+
+extern "C" void abort ();
+struct S { S () { i = 42; }; int i; };
+thread_local S s1, s2, s3, s4;
+struct T { static thread_local S u1, u2, u3, u4, u5, u6, u7, u8; int i; } t;
+thread_local S T::u1, T::u2, T::u3, T::u4, T::u5, T::u6, T::u7, T::u8;
+
+S *f1 () { return &s1; }
+int *f2 () { return &s2.i; }
+S *f3 () { return &t.u1; }
+int *f4 () { return &t.u2.i; }
+S *f5 () { return &T::u3; }
+int *f6 () { return &T::u4.i; }
+template <int N>
+S *f7 () { return &s3; }
+template <int N>
+int *f8 () { return &s4.i; }
+template <int N>
+S *f9 () { return &t.u5; }
+template <int N>
+int *f10 () { return &t.u6.i; }
+template <int N>
+S *f11 () { return &T::u7; }
+template <int N>
+int *f12 () { return &T::u8.i; }
Index: gcc/testsuite/g++.dg/tls/pr77285-2.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tls/pr77285-2.C b/gcc/testsuite/g++.dg/tls/pr77285-2.C
--- a/gcc/testsuite/g++.dg/tls/pr77285-2.C	(revision 278653)
+++ b/gcc/testsuite/g++.dg/tls/pr77285-2.C	(revision 278653)
@@ -3,7 +3,7 @@
 // { dg-require-effective-target tls }
 // { dg-final { scan-assembler "_Z4var1B3tag" } }
 // { dg-final { scan-assembler "_Z4var2B3tag" } }
-// { dg-final { scan-assembler "_ZTH4var1B3tag" } }
+// { dg-final { scan-assembler "_ZTH4var1B3tag" { xfail *-*-darwin* } } }
 // { dg-final { scan-assembler "_ZTW4var1B3tag" } }
 
 struct __attribute__((abi_tag("tag"))) X { ~X () {} int i = 0; };
Index: gcc/testsuite/g++.dg/concepts/no-bool1.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/concepts/no-bool1.C b/gcc/testsuite/g++.dg/concepts/no-bool1.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/concepts/no-bool1.C	(revision 278653)
@@ -0,0 +1,4 @@
+// { dg-do compile { target c++14 } }
+// { dg-additional-options -fconcepts }
+
+template <class T> concept True = true;
Index: gcc/testsuite/objc.dg/no-extra-load.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/no-extra-load.m b/gcc/testsuite/objc.dg/no-extra-load.m
--- a/gcc/testsuite/objc.dg/no-extra-load.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/no-extra-load.m	(revision 278653)
@@ -1,7 +1,7 @@
 /* { dg-do compile { target *-*-darwin* } } */
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 
-#include <Foundation/NSObject.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
 main() { [NSObject new]; }
 
 /* { dg-final { scan-assembler-not "L_objc_msgSend\\\$non_lazy_ptr" } } */
Index: gcc/testsuite/objc.dg/method-6.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/method-6.m b/gcc/testsuite/objc.dg/method-6.m
--- a/gcc/testsuite/objc.dg/method-6.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/method-6.m	(revision 278653)
@@ -5,12 +5,12 @@
 /* { dg-options "-Wstrict-selector-match" } */
 
 #ifdef __NEXT_RUNTIME__
-#include <Foundation/NSObject.h>
-#define OBJECT NSObject
+# include "../objc-obj-c++-shared/F-NSObject.h"
+# define OBJECT NSObject
 #else
-#include <objc/Object.h>
-#include <objc/Protocol.h>
-#define OBJECT Object
+# include <objc/Object.h>
+# include <objc/Protocol.h>
+# define OBJECT Object
 #endif
 
 @interface Base
Index: gcc/testsuite/objc.dg/objc-gc-4.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/objc-gc-4.m b/gcc/testsuite/objc.dg/objc-gc-4.m
--- a/gcc/testsuite/objc.dg/objc-gc-4.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/objc-gc-4.m	(revision 278653)
@@ -3,6 +3,7 @@
 /* Contributed by Ziemowit Laski <zlaski@apple.com>  */
 
 /* { dg-do compile } */
+/* { dg-skip-if "GC API is an error from Darwin16." { *-*-darwin1[6-8]* } { "-fnext-runtime" } { "" } } */
 /* { dg-options "-fobjc-gc" } */
 /* { dg-prune-output "cc1obj: warning: '-fobjc-gc' is ignored for '-fgnu-runtime'" } */
 
Index: gcc/testsuite/objc.dg/strings/const-cfstring-5.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/strings/const-cfstring-5.m b/gcc/testsuite/objc.dg/strings/const-cfstring-5.m
--- a/gcc/testsuite/objc.dg/strings/const-cfstring-5.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/strings/const-cfstring-5.m	(revision 278653)
@@ -6,7 +6,7 @@
 /* { dg-skip-if "NeXT only" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-mconstant-cfstrings" } */
 
-#include <Foundation/NSObject.h>
+#include "../../objc-obj-c++-shared/F-NSObject.h"
 
 @interface Foo: NSObject {
   char *cString;
Index: gcc/testsuite/objc.dg/strings/const-str-12b.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/strings/const-str-12b.m b/gcc/testsuite/objc.dg/strings/const-str-12b.m
--- a/gcc/testsuite/objc.dg/strings/const-str-12b.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/strings/const-str-12b.m	(revision 278653)
@@ -6,11 +6,11 @@
 /* { dg-options "-mno-constant-cfstrings -fconstant-string-class=Foo" { target *-*-darwin* } } */
 
 #ifdef __NEXT_RUNTIME__
-#include <Foundation/NSObject.h>
-#define OBJECT NSObject
+# include "../../objc-obj-c++-shared/F-NSObject.h"
+# define OBJECT NSObject
 #else
-#include <objc/Object.h>
-#define OBJECT Object
+# include <objc/Object.h>
+# define OBJECT Object
 #endif
 #include "../../objc-obj-c++-shared/objc-test-suite-types.h"
 
Index: gcc/testsuite/objc.dg/strings/const-cfstring-2.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/strings/const-cfstring-2.m b/gcc/testsuite/objc.dg/strings/const-cfstring-2.m
--- a/gcc/testsuite/objc.dg/strings/const-cfstring-2.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/strings/const-cfstring-2.m	(revision 278653)
@@ -8,8 +8,8 @@
 /* { dg-skip-if "NeXT only" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-mconstant-cfstrings -Wnonportable-cfstrings" } */
 
-#import <Foundation/NSString.h>
-#import <CoreFoundation/CFString.h>
+#include "../../objc-obj-c++-shared/F-NSString.h"
+#include "../../objc-obj-c++-shared/CF-CFString.h"
 
 #ifndef __CONSTANT_CFSTRINGS__
 #error The -fconstant-cfstrings option is not functioning properly
Index: gcc/testsuite/objc.dg/encode-7-next-64bit.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/encode-7-next-64bit.m b/gcc/testsuite/objc.dg/encode-7-next-64bit.m
--- a/gcc/testsuite/objc.dg/encode-7-next-64bit.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/encode-7-next-64bit.m	(revision 278653)
@@ -9,10 +9,11 @@
 #include <stdbool.h>
 #include <string.h>
 #include <stdlib.h>
-#include <Foundation/NSObject.h>
+#include <stdio.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
+#include "../objc-obj-c++-shared/CF-CFString.h"
 #include "../objc-obj-c++-shared/runtime.h"
 
-extern int printf(char *,...);
 void CHECK_IF(const char *s1, const char *s2)
 {
  if (strcmp(s1,s2) != 0) {
Index: gcc/testsuite/objc.dg/proto-lossage-7.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/proto-lossage-7.m b/gcc/testsuite/objc.dg/proto-lossage-7.m
--- a/gcc/testsuite/objc.dg/proto-lossage-7.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/proto-lossage-7.m	(revision 278653)
@@ -3,7 +3,7 @@
 /* { dg-do compile } */
 
 #ifdef __NEXT_RUNTIME__
-#include <Foundation/NSObject.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
 #define OBJECT NSObject
 #else
 #include <objc/Object.h>
Index: gcc/testsuite/objc.dg/symtab-1.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/symtab-1.m b/gcc/testsuite/objc.dg/symtab-1.m
--- a/gcc/testsuite/objc.dg/symtab-1.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/symtab-1.m	(revision 278653)
@@ -4,7 +4,7 @@
 /* { dg-do compile { target { *-*-darwin* } } } */
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 
-#include <Foundation/NSObject.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
 
 @interface Base: NSObject 
 - (void)setValues;
Index: gcc/testsuite/objc.dg/headers.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/headers.m b/gcc/testsuite/objc.dg/headers.m
--- a/gcc/testsuite/objc.dg/headers.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/headers.m	(revision 278653)
@@ -2,6 +2,7 @@
 // test in libstdc++-v3).  Author: Loren J. Rittle <ljrittle@acm.org>.
 // { dg-options "-Wall -Wpointer-arith -Wcast-qual -Wstrict-prototypes -Wshadow" }
 // { dg-do compile }
+/* { dg-xfail-if "PR90709" { *-*-darwin1[4-9]* } { "-fnext-runtime" } { "" } } */
 
 #ifdef __NEXT_RUNTIME__
 #include <Foundation/NSString.h>
Index: gcc/testsuite/objc.dg/stubify-1.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/stubify-1.m b/gcc/testsuite/objc.dg/stubify-1.m
--- a/gcc/testsuite/objc.dg/stubify-1.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/stubify-1.m	(revision 278653)
@@ -4,7 +4,7 @@
 /* { dg-do compile { target *-*-darwin* } } */
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-require-effective-target ilp32 } */
-/* { dg-options "-Os -mdynamic-no-pic -mmacosx-version-min=10.4" } */
+/* { dg-options "-Os -mdynamic-no-pic -mmacosx-version-min=10.4 -msymbol-stubs" } */
 
 typedef struct objc_object { } *id ;
 int x = 41 ;
@@ -28,8 +28,8 @@
 }
 @end
 
-/* { dg-final { scan-assembler-not "\(bl|call\)\[ \t\]+_objc_msgSend\n" } } */
-/* { dg-final { scan-assembler     "\(bl|call\)\[ \t\]+L_objc_msgSend\\\$stub\n" } } */
-/* { dg-final { scan-assembler-not "\(bl|call\)\[ \t\]+_bogonic\n" } } */
-/* { dg-final { scan-assembler     "\(bl|call\)\[ \t\]+L_bogonic\\\$stub\n" } } */
-/* { dg-final { scan-assembler-not "\\\$non_lazy_ptr" } } */
+/* { dg-final { scan-assembler-not {(bl|call)[ \t]+_objc_msgSend\n} } } */
+/* { dg-final { scan-assembler     {(bl|call)[ \t]+L_objc_msgSend\$stub\n} } } */
+/* { dg-final { scan-assembler-not {(bl|call)[ \t]+_bogonic\n} } } */
+/* { dg-final { scan-assembler     {(bl|call)[ \t]+L_bogonic\$stub\n} } } */
+/* { dg-final { scan-assembler-not {\$non_lazy_ptr} } } */
Index: gcc/testsuite/objc.dg/objc-foreach-4.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/objc-foreach-4.m b/gcc/testsuite/objc.dg/objc-foreach-4.m
--- a/gcc/testsuite/objc.dg/objc-foreach-4.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/objc-foreach-4.m	(revision 278653)
@@ -5,9 +5,9 @@
 /* { dg-skip-if "No NeXT fast enum. pre-Darwin9" { *-*-darwin[5-8]* } { "-fnext-runtime" } { "" } } */
 /* { dg-additional-options "-framework Foundation" { target { *-*-darwin* } } } */
 
-#include <Foundation/NSString.h>
-#include <Foundation/NSAutoreleasePool.h>
-#include <Foundation/NSArray.h>
+#include "../objc-obj-c++-shared/F-NSString.h"
+#include "../objc-obj-c++-shared/F-NSAutoreleasePool.h"
+#include "../objc-obj-c++-shared/F-NSArray.h"
 
 // gcc -o foo foo.m -framework Foundation
 
Index: gcc/testsuite/objc.dg/instancetype-0.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/instancetype-0.m b/gcc/testsuite/objc.dg/instancetype-0.m
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/objc.dg/instancetype-0.m	(revision 278653)
@@ -0,0 +1,30 @@
+/* Contributed by Iain Sandoe <iain@sandoe.co.uk>, May 2019.  */
+/* { dg-do compile } */
+
+/* Basic check of parsing instancetype.  */
+
+extern id class_createInstance (id, int);
+extern id class_getSuperclass (id);
+
+@interface MyObject
+{
+  Class isa;
+}
++ (instancetype)alloc;
+- (instancetype)init;
++ (instancetype)initialize;
++ (instancetype)factoryMethodA;
++ (id)factoryMethodB;
++ (Class) class;
++ (Class) superclass;
+@end
+
+@implementation MyObject
++ (instancetype)alloc { return class_createInstance (self, 0); }
+- (instancetype)init  { return self; }
++ (instancetype)initialize { return self; }
++ (instancetype)factoryMethodA { return [[[self class] alloc] init]; }
++ (id)factoryMethodB { return [[[self class] alloc] init]; }
++ (Class) class { return self; }
++ (Class) superclass { return class_getSuperclass (self); }
+@end
Index: gcc/testsuite/objc.dg/objc-foreach-5.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/objc-foreach-5.m b/gcc/testsuite/objc.dg/objc-foreach-5.m
--- a/gcc/testsuite/objc.dg/objc-foreach-5.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/objc-foreach-5.m	(revision 278653)
@@ -4,8 +4,9 @@
 /* { dg-skip-if "No NeXT fast enum. pre-Darwin9" { *-*-darwin[5-8]* } { "-fnext-runtime" } { "" } } */
 /* { dg-additional-options "-framework Foundation" { target { *-*-darwin* } } } */
 
-#include <Foundation/NSArray.h>
-#include <Foundation/NSAutoreleasePool.h>
+#include "../objc-obj-c++-shared/F-NSArray.h"
+#include "../objc-obj-c++-shared/F-NSAutoreleasePool.h"
+#include "../objc-obj-c++-shared/F-NSValue.h"
 
 NSArray * createTestVictim(unsigned capacity) {
     NSMutableArray * arr = [[NSMutableArray alloc] initWithCapacity:capacity];
Index: gcc/testsuite/objc.dg/stubify-2.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/stubify-2.m b/gcc/testsuite/objc.dg/stubify-2.m
--- a/gcc/testsuite/objc.dg/stubify-2.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/stubify-2.m	(revision 278653)
@@ -1,10 +1,10 @@
 /* All calls must be properly stubified, m32 only.  */
 /* Testcase extracted from TextEdit:Document.m.  */
 
-/* { dg-do compile { target powerpc*-*-darwin* } } */
+/* { dg-do compile { target *-*-darwin* } } */
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-require-effective-target ilp32 } */
-/* { dg-options "-mdynamic-no-pic -fdump-rtl-jump -mmacosx-version-min=10.4" } */
+/* { dg-options "-mdynamic-no-pic -mmacosx-version-min=10.4 -msymbol-stubs" } */
 
 typedef struct objc_object { } *id ;
 int x = 41 ;
@@ -30,4 +30,9 @@
 
 /* Any symbol_ref of an un-stubified objc_msgSend is an error; look
    for "objc_msgSend" in quotes, without the $stub suffix.  */
-/* { dg-final { scan-rtl-dump-not "symbol_ref.*\"objc_msgSend\"" "jump" } } */
+
+/* { dg-final { scan-assembler-not {(bl|call)[ \t]+_objc_msgSend\n} } } */
+/* { dg-final { scan-assembler     {(bl|call)[ \t]+L_objc_msgSend\$stub\n} } } */
+/* { dg-final { scan-assembler-not {(bl|call)[ \t]+_bogonic\n} } } */
+/* { dg-final { scan-assembler     {(bl|call)[ \t]+L_bogonic\$stub\n} } } */
+/* { dg-final { scan-assembler-not {\$non_lazy_ptr} } } */
Index: gcc/testsuite/objc.dg/zero-link-1.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/zero-link-1.m b/gcc/testsuite/objc.dg/zero-link-1.m
--- a/gcc/testsuite/objc.dg/zero-link-1.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/zero-link-1.m	(revision 278653)
@@ -5,7 +5,7 @@
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-fzero-link" } */
 
-#include <Foundation/NSObject.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
 
 extern void abort(void);
 #define CHECK_IF(expr) if(!(expr)) abort();
Index: gcc/testsuite/objc.dg/zero-link-2.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/zero-link-2.m b/gcc/testsuite/objc.dg/zero-link-2.m
--- a/gcc/testsuite/objc.dg/zero-link-2.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/zero-link-2.m	(revision 278653)
@@ -5,7 +5,7 @@
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-fno-zero-link" } */
 
-#include <Foundation/NSObject.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
 
 extern void abort(void);
 #define CHECK_IF(expr) if(!(expr)) abort();
Index: gcc/testsuite/objc.dg/torture/strings/const-str-10.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/torture/strings/const-str-10.m b/gcc/testsuite/objc.dg/torture/strings/const-str-10.m
--- a/gcc/testsuite/objc.dg/torture/strings/const-str-10.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/torture/strings/const-str-10.m	(revision 278653)
@@ -6,7 +6,8 @@
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-mno-constant-cfstrings" { target *-*-darwin* } } */
 
-#include <Foundation/NSObject.h>
+#include "../../../objc-obj-c++-shared/F-NSObject.h"
+#include <stdlib.h>
 #include "../../../objc-obj-c++-shared/runtime.h" /* For NEXT_OBJC_USE_NEW_INTERFACE.  */
 
 @interface NSString: NSObject
Index: gcc/testsuite/objc.dg/torture/strings/const-str-11.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/torture/strings/const-str-11.m b/gcc/testsuite/objc.dg/torture/strings/const-str-11.m
--- a/gcc/testsuite/objc.dg/torture/strings/const-str-11.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/torture/strings/const-str-11.m	(revision 278653)
@@ -7,7 +7,7 @@
 /* { dg-options "-fconstant-string-class=XStr" } */
 /* { dg-options "-mno-constant-cfstrings -fconstant-string-class=XStr" { target *-*-darwin* } } */
 
-#include <Foundation/NSObject.h>
+#include "../../../objc-obj-c++-shared/F-NSObject.h"
 #include "../../../objc-obj-c++-shared/runtime.h" /* For NEXT_OBJC_USE_NEW_INTERFACE.  */
 
 @interface XString: NSObject {
Index: gcc/testsuite/objc.dg/torture/strings/const-cfstring-1.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/torture/strings/const-cfstring-1.m b/gcc/testsuite/objc.dg/torture/strings/const-cfstring-1.m
--- a/gcc/testsuite/objc.dg/torture/strings/const-cfstring-1.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/torture/strings/const-cfstring-1.m	(revision 278653)
@@ -13,8 +13,8 @@
    Well, we don't implement writable ones at this juncture.  */
 /* { dg-options "-mconstant-cfstrings -framework Cocoa -Wl,-w" { target *-*-darwin[123]* } } */
 
-#import <Foundation/NSString.h>
-#import <CoreFoundation/CFString.h>
+#include "../../../objc-obj-c++-shared/F-NSString.h"
+#include "../../../objc-obj-c++-shared/CF-CFString.h"
 #include <stdlib.h>
 
 void printOut(NSString *str) {
Index: gcc/testsuite/objc.dg/torture/strings/const-str-9.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/torture/strings/const-str-9.m b/gcc/testsuite/objc.dg/torture/strings/const-str-9.m
--- a/gcc/testsuite/objc.dg/torture/strings/const-str-9.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/torture/strings/const-str-9.m	(revision 278653)
@@ -5,7 +5,7 @@
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-mno-constant-cfstrings" { target *-*-darwin* } } */
 
-#include <Foundation/NSObject.h>
+#include "../../../objc-obj-c++-shared/F-NSObject.h"
 #include "../../../objc-obj-c++-shared/runtime.h" /* For NEXT_OBJC_USE_NEW_INTERFACE.  */
 
 @interface NSConstantString: NSObject {
Index: gcc/testsuite/objc.dg/zero-link-3.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/zero-link-3.m b/gcc/testsuite/objc.dg/zero-link-3.m
--- a/gcc/testsuite/objc.dg/zero-link-3.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/zero-link-3.m	(revision 278653)
@@ -7,12 +7,12 @@
 /* { dg-xfail-run-if "Needs OBJC2 ABI" { *-*-darwin* && { lp64 && { ! objc2 } } } { "-fnext-runtime" } { "" } } */
 
 #ifdef __NEXT_RUNTIME__
-#include <Foundation/NSObject.h>
-#define OBJECT NSObject
+# include "../objc-obj-c++-shared/F-NSObject.h"
+# define OBJECT NSObject
 #else
-#include <objc/Object.h>
-#include <objc/Protocol.h>
-#define OBJECT Object
+# include <objc/Object.h>
+# include <objc/Protocol.h>
+# define OBJECT Object
 #endif
 
 extern void abort(void);
Index: gcc/testsuite/objc.dg/image-info.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/image-info.m b/gcc/testsuite/objc.dg/image-info.m
--- a/gcc/testsuite/objc.dg/image-info.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/image-info.m	(revision 278653)
@@ -7,7 +7,7 @@
 /* { dg-skip-if "NeXT-only" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-freplace-objc-classes" } */
 
-#include <Foundation/NSObject.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
 
 extern void abort(void);
 #define CHECK_IF(expr) if(!(expr)) abort();
Index: gcc/testsuite/objc.dg/isa-field-1.m
===================================================================
diff --git a/gcc/testsuite/objc.dg/isa-field-1.m b/gcc/testsuite/objc.dg/isa-field-1.m
--- a/gcc/testsuite/objc.dg/isa-field-1.m	(revision 278653)
+++ b/gcc/testsuite/objc.dg/isa-field-1.m	(revision 278653)
@@ -1,5 +1,7 @@
 /* Ensure there are no bizarre difficulties with accessing the 'isa' field of objects.  */
 /* { dg-do compile } */
+/* The use of isa is deprecated, but we still want to test that it works. */
+/* { dg-additional-options "-Wno-deprecated-declarations" } */
 
 #include "../objc-obj-c++-shared/TestsuiteObject.h"
 #include "../objc-obj-c++-shared/runtime.h"
Index: gcc/testsuite/obj-c++.dg/stubify-1.mm
===================================================================
diff --git a/gcc/testsuite/obj-c++.dg/stubify-1.mm b/gcc/testsuite/obj-c++.dg/stubify-1.mm
--- a/gcc/testsuite/obj-c++.dg/stubify-1.mm	(revision 278653)
+++ b/gcc/testsuite/obj-c++.dg/stubify-1.mm	(revision 278653)
@@ -4,13 +4,13 @@
 /* { dg-do compile { target *-*-darwin* } } */
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-require-effective-target ilp32 } */
-/* { dg-options "-Os -mdynamic-no-pic -fno-exceptions -mmacosx-version-min=10.4" } */
+/* { dg-options "-mdynamic-no-pic -fno-exceptions -mmacosx-version-min=10.4 -msymbol-stubs" } */
 
 typedef struct objc_object { } *id ;
 int x = 41 ;
 
 extern "C" {
-  extern id objc_msgSend(id self, char * op, ...);
+  extern id objc_msgSend(id self, objc_selector* op, ...);
   extern int bogonic (int, int, int);
 }
 
@@ -20,9 +20,9 @@
 - (Document *) close;
 @end
 @implementation Document
-- (Document *) class { }
-- (Document *) close { }
-- (Document *) window { }
+- (Document *) class { return (Document *)0; }
+- (Document *) close { return (Document *)0; }
+- (Document *) window { return (Document *)0; }
 - (void)willEndCloseSheet:(void *)sheet returnCode:(int)returnCode contextInfo:(void *)contextInfo {
   [[self window] close];
   ((void (*)(id, char *, int))objc_msgSend)([self class], (char *)contextInfo, 1);
@@ -32,8 +32,8 @@
 }
 @end
 
-/* { dg-final { scan-assembler-not "\(bl|call\)\[ \t\]+_objc_msgSend\n" } } */
-/* { dg-final { scan-assembler     "\(bl|call\)\[ \t\]+L_objc_msgSend\\\$stub\n" } } */
-/* { dg-final { scan-assembler-not "\(bl|call\)\[ \t\]+_bogonic\n" } } */
-/* { dg-final { scan-assembler     "\(bl|call\)\[ \t\]+L_bogonic\\\$stub\n" } } */
-/* { dg-final { scan-assembler-not "\\\$non_lazy_ptr" } } */
+/* { dg-final { scan-assembler-not {(bl|call)[ \t]+_objc_msgSend\n} } } */
+/* { dg-final { scan-assembler     {(bl|call)[ \t]+L_objc_msgSend\$stub\n} } } */
+/* { dg-final { scan-assembler-not {(bl|call)[ \t]+_bogonic\n} } } */
+/* { dg-final { scan-assembler     {(bl|call)[ \t]+L_bogonic\$stub\n} } } */
+/* { dg-final { scan-assembler-not {\$non_lazy_ptr} } } */
Index: gcc/testsuite/obj-c++.dg/isa-field-1.mm
===================================================================
diff --git a/gcc/testsuite/obj-c++.dg/isa-field-1.mm b/gcc/testsuite/obj-c++.dg/isa-field-1.mm
--- a/gcc/testsuite/obj-c++.dg/isa-field-1.mm	(revision 278653)
+++ b/gcc/testsuite/obj-c++.dg/isa-field-1.mm	(revision 278653)
@@ -1,5 +1,7 @@
 /* Ensure there are no bizarre difficulties with accessing the 'isa' field of objects.  */
 /* { dg-do compile } */
+/* The use of isa is deprecated, but we still want to test that is works. */
+/* { dg-additional-options "-Wno-deprecated-declarations" } */
 
 #include "../objc-obj-c++-shared/TestsuiteObject.h"
 #include "../objc-obj-c++-shared/runtime.h"
Index: gcc/testsuite/obj-c++.dg/try-catch-1.mm
===================================================================
diff --git a/gcc/testsuite/obj-c++.dg/try-catch-1.mm b/gcc/testsuite/obj-c++.dg/try-catch-1.mm
--- a/gcc/testsuite/obj-c++.dg/try-catch-1.mm	(revision 278653)
+++ b/gcc/testsuite/obj-c++.dg/try-catch-1.mm	(revision 278653)
@@ -39,4 +39,5 @@
   @finally {
     printf("In @finally block (%d)... ", exc_control);
   }
+  return -1;
 }
Index: gcc/testsuite/obj-c++.dg/cxx-ivars-3.mm
===================================================================
diff --git a/gcc/testsuite/obj-c++.dg/cxx-ivars-3.mm b/gcc/testsuite/obj-c++.dg/cxx-ivars-3.mm
--- a/gcc/testsuite/obj-c++.dg/cxx-ivars-3.mm	(revision 278653)
+++ b/gcc/testsuite/obj-c++.dg/cxx-ivars-3.mm	(revision 278653)
@@ -2,13 +2,14 @@
 
 // { dg-do run { target *-*-darwin* } }
 // { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } }
+// { dg-skip-if "Headers incompatible with 10.4 APIs" { *-*-darwin1[3-8]* } { "-fnext-runtime" } { "" } }
 // { dg-additional-options "-fobjc-call-cxx-cdtors -mmacosx-version-min=10.4 -framework Foundation" }
 // This test has no equivalent or meaning for m64/ABI V2
-// { dg-xfail-run-if "No Test Avail" { *-*-darwin* && lp64 } { "-fnext-runtime" } { "" } }
+// { dg-xfail-run-if "No Test Avail" {  *-*-darwin* && lp64 } { "-fnext-runtime" } { "" } }
 
 #include <objc/objc-runtime.h>
 #include <stdlib.h>
-#include <Foundation/NSObject.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
 
 //extern "C" { int printf(const char *,...); }
 #define CHECK_IF(expr) if(!(expr)) abort()
Index: gcc/testsuite/obj-c++.dg/torture/strings/const-str-10.mm
===================================================================
diff --git a/gcc/testsuite/obj-c++.dg/torture/strings/const-str-10.mm b/gcc/testsuite/obj-c++.dg/torture/strings/const-str-10.mm
--- a/gcc/testsuite/obj-c++.dg/torture/strings/const-str-10.mm	(revision 278653)
+++ b/gcc/testsuite/obj-c++.dg/torture/strings/const-str-10.mm	(revision 278653)
@@ -6,7 +6,7 @@
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-mno-constant-cfstrings" { target *-*-darwin* } } */
 
-#include <Foundation/NSObject.h>
+#include "../../../objc-obj-c++-shared/F-NSObject.h"
 #include "../../../objc-obj-c++-shared/runtime.h" /* For NEXT_OBJC_USE_NEW_INTERFACE.  */
 
 @interface NSString: NSObject
Index: gcc/testsuite/obj-c++.dg/torture/strings/const-str-11.mm
===================================================================
diff --git a/gcc/testsuite/obj-c++.dg/torture/strings/const-str-11.mm b/gcc/testsuite/obj-c++.dg/torture/strings/const-str-11.mm
--- a/gcc/testsuite/obj-c++.dg/torture/strings/const-str-11.mm	(revision 278653)
+++ b/gcc/testsuite/obj-c++.dg/torture/strings/const-str-11.mm	(revision 278653)
@@ -7,7 +7,7 @@
 /* { dg-options "-fconstant-string-class=XStr" } */
 /* { dg-options "-mno-constant-cfstrings -fconstant-string-class=XStr" { target *-*-darwin* } } */
 
-#include <Foundation/NSObject.h>
+#include "../../../objc-obj-c++-shared/F-NSObject.h"
 #include "../../../objc-obj-c++-shared/runtime.h" /* For NEXT_OBJC_USE_NEW_INTERFACE.  */
 
 @interface XString: NSObject {
Index: gcc/testsuite/obj-c++.dg/torture/strings/const-cfstring-1.mm
===================================================================
diff --git a/gcc/testsuite/obj-c++.dg/torture/strings/const-cfstring-1.mm b/gcc/testsuite/obj-c++.dg/torture/strings/const-cfstring-1.mm
--- a/gcc/testsuite/obj-c++.dg/torture/strings/const-cfstring-1.mm	(revision 278653)
+++ b/gcc/testsuite/obj-c++.dg/torture/strings/const-cfstring-1.mm	(revision 278653)
@@ -13,8 +13,8 @@
    well, we don't implement writable ones at this juncture.  */
 /* { dg-options "-mconstant-cfstrings -framework Cocoa -Wl,-w" { target *-*-darwin[123]* } } */
 
-#import <Foundation/NSString.h>
-#import <CoreFoundation/CFString.h>
+#include "../../../objc-obj-c++-shared/F-NSString.h"
+#include "../../../objc-obj-c++-shared/CF-CFString.h"
 #include <stdlib.h>
 
 void printOut(NSString *str) {
@@ -47,10 +47,10 @@
   checkNSRange([@"Hello World" rangeOfString:(id)CFSTR("World")]);
   checkNSRange([(id)CFSTR("Hello World") rangeOfString:(id)CFSTR("World")]);
 
-  checkCFRange(CFStringFind((CFStringRef)@"Hello World", (CFStringRef)@"World", 0));
-  checkCFRange(CFStringFind(CFSTR("Hello World"), (CFStringRef)@"World", 0));
-  checkCFRange(CFStringFind((CFStringRef)@"Hello World", CFSTR("World"), 0));
-  checkCFRange(CFStringFind(CFSTR("Hello World"), CFSTR("World"), 0));
+  checkCFRange(CFStringFind((CFStringRef)@"Hello World", (CFStringRef)@"World", (CFStringCompareFlags)0));
+  checkCFRange(CFStringFind(CFSTR("Hello World"), (CFStringRef)@"World", (CFStringCompareFlags)0));
+  checkCFRange(CFStringFind((CFStringRef)@"Hello World", CFSTR("World"), (CFStringCompareFlags)0));
+  checkCFRange(CFStringFind(CFSTR("Hello World"), CFSTR("World"), (CFStringCompareFlags)0));
 
   /* Check for string uniquing.  */
   if (s0a != s0b || s0a != s2 || s1 != (id)s2) {
Index: gcc/testsuite/obj-c++.dg/torture/strings/const-str-9.mm
===================================================================
diff --git a/gcc/testsuite/obj-c++.dg/torture/strings/const-str-9.mm b/gcc/testsuite/obj-c++.dg/torture/strings/const-str-9.mm
--- a/gcc/testsuite/obj-c++.dg/torture/strings/const-str-9.mm	(revision 278653)
+++ b/gcc/testsuite/obj-c++.dg/torture/strings/const-str-9.mm	(revision 278653)
@@ -5,7 +5,7 @@
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-mno-constant-cfstrings" { target *-*-darwin* } } */
 
-#include <Foundation/NSObject.h>
+#include "../../../objc-obj-c++-shared/F-NSObject.h"
 #include "../../../objc-obj-c++-shared/runtime.h" /* For NEXT_OBJC_USE_NEW_INTERFACE.  */
 
 @interface NSConstantString: NSObject {
Index: gcc/testsuite/obj-c++.dg/strings/const-str-12.mm
===================================================================
diff --git a/gcc/testsuite/obj-c++.dg/strings/const-str-12.mm b/gcc/testsuite/obj-c++.dg/strings/const-str-12.mm
--- a/gcc/testsuite/obj-c++.dg/strings/const-str-12.mm	(revision 278653)
+++ b/gcc/testsuite/obj-c++.dg/strings/const-str-12.mm	(revision 278653)
@@ -6,7 +6,7 @@
 /* { dg-options "-mno-constant-cfstrings -fconstant-string-class=Foo" { target *-*-darwin* } } */
 
 #ifdef __NEXT_RUNTIME__
-#include <Foundation/NSObject.h>
+#include "../../objc-obj-c++-shared/F-NSObject.h"
 #define OBJECT NSObject
 #else
 #include <objc/Object.h>
Index: gcc/testsuite/obj-c++.dg/strings/const-cfstring-2.mm
===================================================================
diff --git a/gcc/testsuite/obj-c++.dg/strings/const-cfstring-2.mm b/gcc/testsuite/obj-c++.dg/strings/const-cfstring-2.mm
--- a/gcc/testsuite/obj-c++.dg/strings/const-cfstring-2.mm	(revision 278653)
+++ b/gcc/testsuite/obj-c++.dg/strings/const-cfstring-2.mm	(revision 278653)
@@ -8,8 +8,8 @@
 /* { dg-skip-if "NeXT only" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-ftrack-macro-expansion=0 -mconstant-cfstrings -Wnonportable-cfstrings" } */
 
-#import <Foundation/NSString.h>
-#import <CoreFoundation/CFString.h>
+#include "../../objc-obj-c++-shared/F-NSString.h"
+#include "../../objc-obj-c++-shared/CF-CFString.h"
 
 #ifndef __CONSTANT_CFSTRINGS__
 #error The -fconstant-cfstrings option is not functioning properly
Index: gcc/testsuite/obj-c++.dg/strings/const-cfstring-5.mm
===================================================================
diff --git a/gcc/testsuite/obj-c++.dg/strings/const-cfstring-5.mm b/gcc/testsuite/obj-c++.dg/strings/const-cfstring-5.mm
--- a/gcc/testsuite/obj-c++.dg/strings/const-cfstring-5.mm	(revision 278653)
+++ b/gcc/testsuite/obj-c++.dg/strings/const-cfstring-5.mm	(revision 278653)
@@ -6,7 +6,7 @@
 /* { dg-skip-if "NeXT only" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-options "-mconstant-cfstrings" } */
 
-#include <Foundation/NSObject.h>
+#include "../../objc-obj-c++-shared/F-NSObject.h"
 
 @interface Foo: NSObject {
   char *cString;
Index: gcc/testsuite/obj-c++.dg/stubify-2.mm
===================================================================
diff --git a/gcc/testsuite/obj-c++.dg/stubify-2.mm b/gcc/testsuite/obj-c++.dg/stubify-2.mm
--- a/gcc/testsuite/obj-c++.dg/stubify-2.mm	(revision 278653)
+++ b/gcc/testsuite/obj-c++.dg/stubify-2.mm	(revision 278653)
@@ -4,7 +4,7 @@
 /* { dg-do compile { target *-*-darwin* } } */
 /* { dg-skip-if "" { *-*-* } { "-fgnu-runtime" } { "" } } */
 /* { dg-require-effective-target ilp32 } */
-/* { dg-options "-mdynamic-no-pic -fdump-rtl-jump -mmacosx-version-min=10.4" } */
+/* { dg-options "-mdynamic-no-pic -mmacosx-version-min=10.4 -msymbol-stubs" } */
 
 typedef struct objc_object { } *id ;
 int x = 41 ;
@@ -16,9 +16,9 @@
 - (Document *) close;
 @end
 @implementation Document
-- (Document *) class { }
-- (Document *) close { }
-- (Document *) window { }
+- (Document *) class { return (Document *)0; }
+- (Document *) close { return (Document *)0; }
+- (Document *) window { return (Document *)0; }
 - (void)willEndCloseSheet:(void *)sheet returnCode:(int)returnCode contextInfo:(void *)contextInfo {
   [[self window] close];
   ((void (*)(id, char *, int))objc_msgSend)([self class], (char *)contextInfo, 1);
@@ -30,4 +30,9 @@
 
 /* Any symbol_ref of an un-stubified objc_msgSend is an error; look
    for "objc_msgSend" in quotes, without the $stub suffix. */
-/* { dg-final {  scan-rtl-dump-not "symbol_ref.*\"objc_msgSend\"" "jump" } } */
+
+/* { dg-final { scan-assembler-not {(bl|call)[ \t]+_objc_msgSend\n} } } */
+/* { dg-final { scan-assembler     {(bl|call)[ \t]+L_objc_msgSend\$stub\n} } } */
+/* { dg-final { scan-assembler-not {(bl|call)[ \t]+_Z7bogoniciii\n} } } */
+/* { dg-final { scan-assembler     {(bl|call)[ \t]+L__Z7bogoniciii\$stub\n} } } */
+/* { dg-final { scan-assembler-not {\$non_lazy_ptr} } } */
Index: gcc/testsuite/obj-c++.dg/objc-gc-3.mm
===================================================================
diff --git a/gcc/testsuite/obj-c++.dg/objc-gc-3.mm b/gcc/testsuite/obj-c++.dg/objc-gc-3.mm
--- a/gcc/testsuite/obj-c++.dg/objc-gc-3.mm	(revision 278653)
+++ b/gcc/testsuite/obj-c++.dg/objc-gc-3.mm	(revision 278653)
@@ -3,6 +3,7 @@
 /* Contributed by Ziemowit Laski <zlaski@apple.com>  */
 
 /* { dg-do compile } */
+/* { dg-skip-if "GC API is an error from Darwin16." { *-*-darwin1[6-8]* } { "-fnext-runtime" } { "" } } */
 /* { dg-options "-fobjc-gc" } */
 /* { dg-prune-output "cc1objplus: warning: '-fobjc-gc' is ignored for '-fgnu-runtime'" } */
 
Index: gcc/testsuite/obj-c++.dg/qual-types-1.mm
===================================================================
diff --git a/gcc/testsuite/obj-c++.dg/qual-types-1.mm b/gcc/testsuite/obj-c++.dg/qual-types-1.mm
--- a/gcc/testsuite/obj-c++.dg/qual-types-1.mm	(revision 278653)
+++ b/gcc/testsuite/obj-c++.dg/qual-types-1.mm	(revision 278653)
@@ -4,6 +4,8 @@
 
 /* { dg-do run } */
 /* { dg-xfail-run-if "Needs OBJC2 ABI" { *-*-darwin* && { lp64 && { ! objc2 } } } { "-fnext-runtime" } { "" } } */
+/* { dg-prune-output ".*ld: warning: direct access in.*" } */
+
 #include "../objc-obj-c++-shared/TestsuiteObject.m"
 #include <stdlib.h>
 
Index: gcc/testsuite/obj-c++.dg/proto-lossage-7.mm
===================================================================
diff --git a/gcc/testsuite/obj-c++.dg/proto-lossage-7.mm b/gcc/testsuite/obj-c++.dg/proto-lossage-7.mm
--- a/gcc/testsuite/obj-c++.dg/proto-lossage-7.mm	(revision 278653)
+++ b/gcc/testsuite/obj-c++.dg/proto-lossage-7.mm	(revision 278653)
@@ -1,9 +1,11 @@
 /* Check that typedefs of ObjC classes preserve 
    any @protocol qualifiers.  */
 /* { dg-do compile } */
+/* Suppress warnings that the GNUStep headers introduce.  */
+/* { dg-additional-options "-std=gnu++11 -Wno-expansion-to-defined -Wno-variadic-macros" { target *-*-darwin* } } */
 
 #ifdef __NEXT_RUNTIME__
-#include <Foundation/NSObject.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
 #define OBJECT NSObject
 #else
 #include <objc/Object.h>
Index: gcc/testsuite/obj-c++.dg/syntax-error-1.mm
===================================================================
diff --git a/gcc/testsuite/obj-c++.dg/syntax-error-1.mm b/gcc/testsuite/obj-c++.dg/syntax-error-1.mm
--- a/gcc/testsuite/obj-c++.dg/syntax-error-1.mm	(revision 278653)
+++ b/gcc/testsuite/obj-c++.dg/syntax-error-1.mm	(revision 278653)
@@ -1,8 +1,10 @@
 /* Graceful handling of a syntax error.  */
 /* { dg-do compile } */
+/* Suppress warnings that the GNUStep headers introduce.  */
+/* { dg-additional-options "-std=gnu++11 -Wno-expansion-to-defined -Wno-variadic-macros" { target *-*-darwin* } } */
 
 #ifdef __NEXT_RUNTIME__
-#include <Foundation/NSObject.h>
+#include "../objc-obj-c++-shared/F-NSObject.h"
 #define OBJECT NSObject
 #else
 #include <objc/Object.h>
Index: gcc/testsuite/obj-c++.dg/try-catch-3.mm
===================================================================
diff --git a/gcc/testsuite/obj-c++.dg/try-catch-3.mm b/gcc/testsuite/obj-c++.dg/try-catch-3.mm
--- a/gcc/testsuite/obj-c++.dg/try-catch-3.mm	(revision 278653)
+++ b/gcc/testsuite/obj-c++.dg/try-catch-3.mm	(revision 278653)
@@ -15,4 +15,5 @@
   @catch (TestsuiteObject* theException) {
     return [theException name];
   }
+  return (const char *)0;
 }
Index: gcc/testsuite/c-c++-common/cpp/pr92296-1.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/cpp/pr92296-1.c b/gcc/testsuite/c-c++-common/cpp/pr92296-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/cpp/pr92296-1.c	(revision 278653)
@@ -0,0 +1,32 @@
+/* PR preprocessor/92296 */
+/* { dg-do preprocess } */
+
+#pragma push_macro("__TIMESTAMP__")
+#pragma pop_macro("__TIMESTAMP__")
+
+#pragma push_macro("__TIME__")
+#pragma pop_macro("__TIME__")
+
+#pragma push_macro("__DATE__")
+#pragma pop_macro("__DATE__")
+
+#pragma push_macro("__FILE__")
+#pragma pop_macro("__FILE__")
+
+#pragma push_macro("__BASE_FILE__")
+#pragma pop_macro("__BASE_FILE__")
+
+#pragma push_macro("__LINE__")
+#pragma pop_macro("__LINE__")
+
+#pragma push_macro("__INCLUDE_LEVEL__")
+#pragma pop_macro("__INCLUDE_LEVEL__")
+
+#pragma push_macro("__COUNTER__")
+#pragma pop_macro("__COUNTER__")
+
+#pragma push_macro("__has_attribute")
+#pragma pop_macro("__has_attribute")
+
+#pragma push_macro("__has_cpp_attribute")
+#pragma pop_macro("__has_cpp_attribute")
Index: gcc/testsuite/c-c++-common/cpp/pr92296-2.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/cpp/pr92296-2.c b/gcc/testsuite/c-c++-common/cpp/pr92296-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/cpp/pr92296-2.c	(revision 278653)
@@ -0,0 +1,73 @@
+/* PR preprocessor/92296 */
+/* { dg-do preprocess } */
+/* { dg-options "-Wno-builtin-macro-redefined" } */
+
+#pragma push_macro("__TIMESTAMP__")
+#undef __TIMESTAMP__
+#define __TIMESTAMP__ "Thu Oct 31 12:00:00 2019"
+timestamp1 = __TIMESTAMP__
+#pragma pop_macro("__TIMESTAMP__")
+timestamp2 = __TIMESTAMP__
+
+#pragma push_macro("__TIME__")
+#undef __TIME__
+#define __TIME__ "12:00:00"
+time1 = __TIME__
+#pragma pop_macro("__TIME__")
+time2 = __TIME__
+
+#pragma push_macro("__DATE__")
+#undef __DATE__
+#define __DATE__ "Oct 31 2019"
+date1 = __DATE__
+#pragma pop_macro("__DATE__")
+date2 = __DATE__
+
+#pragma push_macro("__FILE__")
+#undef __FILE__
+#define __FILE__ "pr92296-3.c"
+file1 = __FILE__	/* { dg-final { scan-file pr92296-2.i "file1 = \"pr92296-3.c\"" } } */
+#pragma pop_macro("__FILE__")
+file2 = __FILE__	/* { dg-final { scan-file-not pr92296-2.i "file2 = \"pr92296-3.c\"" } } */
+
+#pragma push_macro("__BASE_FILE__")
+#undef __BASE_FILE__
+#define __BASE_FILE__ "pr92296-4.c"
+filebase1 = __BASE_FILE__	/* { dg-final { scan-file pr92296-2.i "filebase1 = \"pr92296-4.c\"" } } */
+#pragma pop_macro("__BASE_FILE__")
+filebase2 = __BASE_FILE__	/* { dg-final { scan-file-not pr92296-2.i "filebase2 = \"pr92296-4.c\"" } } */
+
+#pragma push_macro("__LINE__")
+#undef __LINE__		/* { dg-warning "undefining" } */
+#define __LINE__ 142
+line1 = __LINE__	/* { dg-final { scan-file pr92296-2.i "line1 = 142" } } */
+#pragma pop_macro("__LINE__")
+line2 = __LINE__	/* { dg-final { scan-file pr92296-2.i "line2 = 45" } } */
+
+#pragma push_macro("__INCLUDE_LEVEL__")
+#undef __INCLUDE_LEVEL__	/* { dg-warning "undefining" } */
+#define __INCLUDE_LEVEL__ 42
+includelevel1 = __INCLUDE_LEVEL__	/* { dg-final { scan-file pr92296-2.i "includelevel1 = 42" } } */
+#pragma pop_macro("__INCLUDE_LEVEL__")
+includelevel2 = __INCLUDE_LEVEL__	/* { dg-final { scan-file pr92296-2.i "includelevel2 = 0" } } */
+
+#pragma push_macro("__COUNTER__")
+#undef __COUNTER__	/* { dg-warning "undefining" } */
+#define __COUNTER__ 172
+counter1 = __COUNTER__	/* { dg-final { scan-file pr92296-2.i "counter1 = 172" } } */
+#pragma pop_macro("__COUNTER__")
+counter2 = __COUNTER__	/* { dg-final { scan-file-not pr92296-2.i "counter2 = 172" } } */
+
+#pragma push_macro("__has_attribute")
+#undef __has_attribute	/* { dg-warning "undefining" } */
+#define __has_attribute(x) 0
+hasattr1 = __has_attribute(noreturn)	/* { dg-final { scan-file pr92296-2.i "hasattr1 = 0" } } */
+#pragma pop_macro("__has_attribute")
+hasattr2 = __has_attribute(noreturn)	/* { dg-final { scan-file-not pr92296-2.i "hasattr2 = 0" } } */
+
+#pragma push_macro("__has_cpp_attribute")
+#undef __has_cpp_attribute	/* { dg-warning "undefining" } */
+#define __has_cpp_attribute(x) 0
+hasattrcpp1 = __has_cpp_attribute(noreturn)	/* { dg-final { scan-file pr92296-2.i "hasattrcpp1 = 0" } } */
+#pragma pop_macro("__has_cpp_attribute")
+hasattrcpp2 = __has_cpp_attribute(noreturn)	/* { dg-final { scan-file-not pr92296-2.i "hasattrcpp2 = 0" } } */
Index: gcc/testsuite/c-c++-common/pr90108.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/pr90108.c b/gcc/testsuite/c-c++-common/pr90108.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/pr90108.c	(revision 278653)
@@ -0,0 +1,6 @@
+/* PR c++/90108 */
+/* { dg-do compile } */
+/* { dg-options "--param ggc-min-heapsize=0" } */
+
+typedef unsigned int a __attribute__ ((__aligned__(8), __may_alias__));
+typedef unsigned int a __attribute__ ((__aligned__(8), __may_alias__));
Index: gcc/testsuite/c-c++-common/gomp/pr88588.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/gomp/pr88588.c b/gcc/testsuite/c-c++-common/gomp/pr88588.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/gomp/pr88588.c	(revision 278653)
@@ -0,0 +1,18 @@
+/* PR middle-end/88588 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp -O1" } */
+
+int *v;
+
+#pragma omp declare simd
+void
+foo (int x)
+{
+  int *a = &x;
+
+  for (;;)
+    {
+      *v = *a;
+      a = v;
+    }
+}
Index: gcc/testsuite/c-c++-common/gomp/pr91401-2.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/gomp/pr91401-2.c b/gcc/testsuite/c-c++-common/gomp/pr91401-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/gomp/pr91401-2.c	(revision 278653)
@@ -0,0 +1,15 @@
+#pragma omp declare target
+void f0 (void);
+
+void
+f1 (void)
+{
+  int i;
+  #pragma omp distribute dist_schedule(static) dist_schedule(static)	/* { dg-warning "too many 'dist_schedule' clauses" } */
+  for (i = 0; i < 8; ++i)
+    f0 ();
+  #pragma omp distribute dist_schedule(static,2) dist_schedule(static,4) /* { dg-warning "too many 'dist_schedule' clauses" } */
+  for (i = 0; i < 8; ++i)
+    f0 ();
+}
+#pragma omp end declare target
Index: gcc/testsuite/c-c++-common/gomp/pr90954.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/gomp/pr90954.c b/gcc/testsuite/c-c++-common/gomp/pr90954.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/gomp/pr90954.c	(revision 278653)
@@ -0,0 +1,27 @@
+/* PR sanitizer/90954 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp -fsanitize=undefined" } */
+
+float v;
+int i;
+
+void
+foo (float x, float y)
+{
+  #pragma omp atomic
+  v += x / y;
+}
+
+void
+bar (int x, int y)
+{
+  #pragma omp atomic
+  i += x / y;
+}
+
+void
+baz (int x, int y)
+{
+  #pragma omp atomic
+  i *= (x << y);
+}
Index: gcc/testsuite/c-c++-common/gomp/pr91401-1.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/gomp/pr91401-1.c b/gcc/testsuite/c-c++-common/gomp/pr91401-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/gomp/pr91401-1.c	(revision 278653)
@@ -0,0 +1,10 @@
+/* PR c/91401 */
+
+void
+foo (void)
+{
+  int i;
+  #pragma omp distribute parallel for schedule (static) dist_schedule (static)
+  for (i = 0; i < 64; i++)
+    ;
+}
Index: gcc/testsuite/c-c++-common/pr53633-2.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/pr53633-2.c b/gcc/testsuite/c-c++-common/pr53633-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/pr53633-2.c	(revision 278653)
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target naked_functions } */
+/* { dg-options "-O2 -Wall" } */
+/* Check that we do not get warnings about missing return statements
+   or bogus looking noreturn functions.  */
+static int __attribute__((naked))
+foo (void)
+{
+  __asm__ ("");
+}
+
+static int __attribute__((naked,noreturn))
+bar (void)
+{
+  __asm__ ("");
+}
+
+int foo_caller (void) { return foo (); }
+int bar_caller (void) { return bar (); }
Index: gcc/testsuite/c-c++-common/unroll-6.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/unroll-6.c b/gcc/testsuite/c-c++-common/unroll-6.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/unroll-6.c	(revision 278653)
@@ -0,0 +1,9 @@
+/* { dg-do compile } */
+/* { dg-options "-O -fno-tree-loop-optimize" } */
+
+void test (void)
+{
+  #pragma GCC unroll 2
+  for (int nv = 0; nv <= 2; nv += 2)
+    {}
+}
Index: gcc/testsuite/c-c++-common/pr89933.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/pr89933.c b/gcc/testsuite/c-c++-common/pr89933.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/pr89933.c	(revision 278653)
@@ -0,0 +1,5 @@
+/* PR c/89933 */
+/* { dg-do compile } */
+
+typedef unsigned int a __attribute__ ((__aligned__(8), __may_alias__));
+typedef unsigned int a __attribute__ ((__aligned__(8), __may_alias__));
Index: gcc/testsuite/c-c++-common/unroll-7.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/unroll-7.c b/gcc/testsuite/c-c++-common/unroll-7.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/unroll-7.c	(revision 278653)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-options "-O -fno-tree-dominator-opts" } */
+
+int nv;
+
+void test (void)
+{
+  #pragma GCC unroll 2
+  for (nv = 0; nv < 1; ++nv)
+    {}
+}
Index: gcc/testsuite/c-c++-common/pr89946.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/pr89946.c b/gcc/testsuite/c-c++-common/pr89946.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/pr89946.c	(revision 278653)
@@ -0,0 +1,7 @@
+/* PR c/89946 */
+
+__attribute__((patchable_function_entry (-1))) void foo (void) {}	/* { dg-warning "'patchable_function_entry' attribute argument '-1' is not an integer constant" } */
+__attribute__((patchable_function_entry (5, -5))) void bar (void) {}	/* { dg-warning "'patchable_function_entry' attribute argument '-5' is not an integer constant" } */
+int i, j;
+__attribute__((patchable_function_entry (i))) void baz (void) {}	/* { dg-warning "'patchable_function_entry' attribute argument 'i' is not an integer constant" } */
+__attribute__((patchable_function_entry (2, j))) void qux (void) {}	/* { dg-warning "'patchable_function_entry' attribute argument 'j' is not an integer constant" } */
Index: gcc/objcp/ChangeLog
===================================================================
diff --git a/gcc/objcp/ChangeLog b/gcc/objcp/ChangeLog
--- a/gcc/objcp/ChangeLog	(revision 278653)
+++ b/gcc/objcp/ChangeLog	(revision 278653)
@@ -1,3 +1,11 @@
+2019-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR pch/90326
+	* config-lang.in (gtfiles): Don't add c-family/c-cppbuiltin.c.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: gcc/objcp/config-lang.in
===================================================================
diff --git a/gcc/objcp/config-lang.in b/gcc/objcp/config-lang.in
--- a/gcc/objcp/config-lang.in	(revision 278653)
+++ b/gcc/objcp/config-lang.in	(revision 278653)
@@ -52,7 +52,6 @@
 gtfiles="$gtfiles \
 \$(srcdir)/objc/objc-act.h \
 \$(srcdir)/objc/objc-map.h \
-\$(srcdir)/c-family/c-cppbuiltin.c \
 \$(srcdir)/objc/objc-act.c \
 \$(srcdir)/objc/objc-gnu-runtime-abi-01.c \
 \$(srcdir)/objc/objc-next-runtime-abi-01.c \
Index: gcc/cp/typeck.c
===================================================================
diff --git a/gcc/cp/typeck.c b/gcc/cp/typeck.c
--- a/gcc/cp/typeck.c	(revision 278653)
+++ b/gcc/cp/typeck.c	(revision 278653)
@@ -40,6 +40,7 @@
 #include "stringpool.h"
 #include "attribs.h"
 #include "asan.h"
+#include "gimplify.h"
 
 static tree cp_build_addr_expr_strict (tree, tsubst_flags_t);
 static tree cp_build_function_call (tree, tree, tsubst_flags_t);
@@ -1383,6 +1384,11 @@
 	 template parameters set, they can't be equal.  */
       if (!comp_template_parms_position (t1, t2))
 	return false;
+      /* If T1 and T2 don't represent the same class template deduction,
+         they aren't equal.  */
+      if (CLASS_PLACEHOLDER_TEMPLATE (t1)
+	  != CLASS_PLACEHOLDER_TEMPLATE (t2))
+	return false;
       /* Constrained 'auto's are distinct from parms that don't have the same
 	 constraints.  */
       if (!equivalent_placeholder_constraints (t1, t2))
@@ -2437,6 +2443,12 @@
       /* A static data member.  */
       result = member;
       mark_exp_read (object);
+
+      if (tree wrap = maybe_get_tls_wrapper_call (result))
+	/* Replace an evaluated use of the thread_local variable with
+	   a call to its wrapper.  */
+	result = wrap;
+
       /* If OBJECT has side-effects, they are supposed to occur.  */
       if (TREE_SIDE_EFFECTS (object))
 	result = build2 (COMPOUND_EXPR, TREE_TYPE (result), object, result);
@@ -5747,18 +5759,17 @@
     return c_common_truthvalue_conversion (input_location, expr);
 }
 
-/* Just like cp_truthvalue_conversion, but we want a CLEANUP_POINT_EXPR.  */
+/* Just like cp_truthvalue_conversion, but we want a CLEANUP_POINT_EXPR.  This
+   is a low-level function; most callers should use maybe_convert_cond.  */
 
 tree
 condition_conversion (tree expr)
 {
   tree t;
-  /* Anything that might happen in a template should go through
-     maybe_convert_cond.  */
-  gcc_assert (!processing_template_decl);
   t = perform_implicit_conversion_flags (boolean_type_node, expr,
 					 tf_warning_or_error, LOOKUP_NORMAL);
-  t = fold_build_cleanup_point_expr (boolean_type_node, t);
+  if (!processing_template_decl)
+    t = fold_build_cleanup_point_expr (boolean_type_node, t);
   return t;
 }
 
@@ -7983,8 +7994,6 @@
 	/* Produce (a ? (b = rhs) : (c = rhs))
 	   except that the RHS goes through a save-expr
 	   so the code to compute it is only emitted once.  */
-	tree cond;
-
 	if (VOID_TYPE_P (TREE_TYPE (rhs)))
 	  {
 	    if (complain & tf_error)
@@ -7999,13 +8008,21 @@
 	if (!lvalue_or_else (lhs, lv_assign, complain))
 	  return error_mark_node;
 
-	cond = build_conditional_expr
-	  (input_location, TREE_OPERAND (lhs, 0),
-	   cp_build_modify_expr (loc, TREE_OPERAND (lhs, 1),
-				 modifycode, rhs, complain),
-	   cp_build_modify_expr (loc, TREE_OPERAND (lhs, 2),
-				 modifycode, rhs, complain),
-           complain);
+	tree op1 = cp_build_modify_expr (loc, TREE_OPERAND (lhs, 1),
+					 modifycode, rhs, complain);
+	/* When sanitizing undefined behavior, even when rhs doesn't need
+	   stabilization at this point, the sanitization might add extra
+	   SAVE_EXPRs in there and so make sure there is no tree sharing
+	   in the rhs, otherwise those SAVE_EXPRs will have initialization
+	   only in one of the two branches.  */
+	if (sanitize_flags_p (SANITIZE_UNDEFINED
+			      | SANITIZE_UNDEFINED_NONDEFAULT))
+	  rhs = unshare_expr (rhs);
+	tree op2 = cp_build_modify_expr (loc, TREE_OPERAND (lhs, 2),
+					 modifycode, rhs, complain);
+	tree cond = build_conditional_expr (input_location,
+					    TREE_OPERAND (lhs, 0), op1, op2,
+					    complain);
 
 	if (cond == error_mark_node)
 	  return cond;
@@ -9092,8 +9109,10 @@
 	  tree base = DECL_DECOMP_BASE (whats_returned);
 	  if (TREE_CODE (TREE_TYPE (base)) == REFERENCE_TYPE)
 	    {
-	      tree init = DECL_INITIAL (base);
-	      return maybe_warn_about_returning_address_of_local (init);
+	      if (tree init = DECL_INITIAL (base))
+		return maybe_warn_about_returning_address_of_local (init);
+	      else
+		return false;
 	    }
 	}
       if (TREE_CODE (valtype) == REFERENCE_TYPE)
Index: gcc/cp/init.c
===================================================================
diff --git a/gcc/cp/init.c b/gcc/cp/init.c
--- a/gcc/cp/init.c	(revision 278653)
+++ b/gcc/cp/init.c	(revision 278653)
@@ -419,6 +419,15 @@
 	      if (ftype == error_mark_node)
 		continue;
 
+	      /* Ignore flexible array members for value initialization.  */
+	      if (TREE_CODE (ftype) == ARRAY_TYPE
+		  && !COMPLETE_TYPE_P (ftype)
+		  && !TYPE_DOMAIN (ftype)
+		  && COMPLETE_TYPE_P (TREE_TYPE (ftype))
+		  && (next_initializable_field (DECL_CHAIN (field))
+		      == NULL_TREE))
+		continue;
+
 	      /* We could skip vfields and fields of types with
 		 user-defined constructors, but I think that won't improve
 		 performance at all; it should be simpler in general just
@@ -2269,8 +2278,11 @@
 		  || TREE_CODE (init) == STRING_CST)))
 	break;
       /* Don't return a CONSTRUCTOR for a variable with partial run-time
-	 initialization, since it doesn't represent the entire value.  */
-      if (TREE_CODE (init) == CONSTRUCTOR
+	 initialization, since it doesn't represent the entire value.
+	 Similarly for VECTOR_CSTs created by cp_folding those
+	 CONSTRUCTORs.  */
+      if ((TREE_CODE (init) == CONSTRUCTOR
+	   || TREE_CODE (init) == VECTOR_CST)
 	  && !DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl))
 	break;
       /* If the variable has a dynamic initializer, don't use its
Index: gcc/cp/class.c
===================================================================
diff --git a/gcc/cp/class.c b/gcc/cp/class.c
--- a/gcc/cp/class.c	(revision 278653)
+++ b/gcc/cp/class.c	(revision 278653)
@@ -5171,7 +5171,9 @@
     for (ovl_iterator iter (get_class_binding_direct
 			    (t, assign_op_identifier));
 	 iter; ++iter)
-      if ((!user_p || !DECL_ARTIFICIAL (*iter)) && move_fn_p (*iter))
+      if ((!user_p || !DECL_ARTIFICIAL (*iter))
+	  && DECL_CONTEXT (*iter) == t
+	  && move_fn_p (*iter))
 	return true;
   
   return false;
Index: gcc/cp/decl.c
===================================================================
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
--- a/gcc/cp/decl.c	(revision 278653)
+++ b/gcc/cp/decl.c	(revision 278653)
@@ -2163,13 +2163,33 @@
 	  if (TYPE_NAME (TREE_TYPE (newdecl)) == newdecl)
 	    {
 	      tree remove = TREE_TYPE (newdecl);
-	      for (tree t = TYPE_MAIN_VARIANT (remove); ;
-		   t = TYPE_NEXT_VARIANT (t))
-		if (TYPE_NEXT_VARIANT (t) == remove)
-		  {
-		    TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (remove);
-		    break;
-		  }
+	      if (TYPE_MAIN_VARIANT (remove) == remove)
+		{
+		  gcc_assert (TYPE_NEXT_VARIANT (remove) == NULL_TREE);
+		  /* If remove is the main variant, no need to remove that
+		     from the list.  One of the DECL_ORIGINAL_TYPE
+		     variants, e.g. created for aligned attribute, might still
+		     refer to the newdecl TYPE_DECL though, so remove that one
+		     in that case.  */
+		  if (tree orig = DECL_ORIGINAL_TYPE (newdecl))
+		    if (orig != remove)
+		      for (tree t = TYPE_MAIN_VARIANT (orig); t;
+			   t = TYPE_MAIN_VARIANT (t))
+			if (TYPE_NAME (TYPE_NEXT_VARIANT (t)) == newdecl)
+			  {
+			    TYPE_NEXT_VARIANT (t)
+			      = TYPE_NEXT_VARIANT (TYPE_NEXT_VARIANT (t));
+			    break;
+			  }
+		}	    
+	      else
+		for (tree t = TYPE_MAIN_VARIANT (remove); ;
+		     t = TYPE_NEXT_VARIANT (t))
+		  if (TYPE_NEXT_VARIANT (t) == remove)
+		    {
+		      TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (remove);
+		      break;
+		    }
 	    }
 	}
       else if (merge_attr)
@@ -5616,6 +5636,7 @@
 		 be merged.  */
 	      TREE_PUBLIC (decl) = 0;
 	      DECL_COMMON (decl) = 0;
+	      DECL_INTERFACE_KNOWN (decl) = 1;
 	      const char *msg;
 	      if (DECL_INLINE_VAR_P (decl))
 		msg = G_("sorry: semantics of inline variable "
@@ -8326,7 +8347,7 @@
 	      (acquire_name, build_function_type_list (integer_type_node,
 						       TREE_TYPE (guard_addr),
 						       NULL_TREE),
-	       NULL_TREE, ECF_NOTHROW | ECF_LEAF);
+	       NULL_TREE, ECF_NOTHROW);
 	  if (!release_fn || !abort_fn)
 	    vfntype = build_function_type_list (void_type_node,
 						TREE_TYPE (guard_addr),
@@ -8333,7 +8354,7 @@
 						NULL_TREE);
 	  if (!release_fn)
 	    release_fn = push_library_fn (release_name, vfntype, NULL_TREE,
-					   ECF_NOTHROW | ECF_LEAF);
+					  ECF_NOTHROW);
 	  if (!abort_fn)
 	    abort_fn = push_library_fn (abort_name, vfntype, NULL_TREE,
 					ECF_NOTHROW | ECF_LEAF);
Index: gcc/cp/method.c
===================================================================
diff --git a/gcc/cp/method.c b/gcc/cp/method.c
--- a/gcc/cp/method.c	(revision 278653)
+++ b/gcc/cp/method.c	(revision 278653)
@@ -1201,6 +1201,8 @@
     expr = assignable_expr (to, from);
   else if (trivial && from && TREE_CHAIN (from))
     return error_mark_node; // only 0- and 1-argument ctors can be trivial
+  else if (TREE_CODE (to) == ARRAY_TYPE && !TYPE_DOMAIN (to))
+    return error_mark_node; // can't construct an array of unknown bound
   else
     expr = constructible_expr (to, from);
   return expr;
Index: gcc/cp/ChangeLog
===================================================================
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
--- a/gcc/cp/ChangeLog	(revision 278653)
+++ b/gcc/cp/ChangeLog	(revision 278653)
@@ -1,3 +1,293 @@
+2019-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-10-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/85887
+	* decl.c (expand_static_init): Drop ECF_LEAF from __cxa_guard_acquire
+	and __cxa_guard_release.
+
+	2019-10-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/92201
+	* cp-gimplify.c (cp_gimplify_expr): If gimplify_to_rvalue changes the
+	function pointer type, re-add cast to the original one.
+
+	2019-10-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/91974
+	* cp-gimplify.c (cp_gimplify_expr) <case CALL_EXPR>: For
+	-fstrong-eval-order ensure CALL_EXPR_FN side-effects are evaluated
+	before any arguments.  Additionally, ensure CALL_EXPR_FN that isn't
+	invariant nor OBJ_TYPE_REF nor SSA_NAME is forced into a temporary.
+
+	2019-08-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/91401
+	* parser.c (cp_parser_omp_clause_dist_schedule): Comment out the
+	check_no_duplicate_clause call, instead emit a warning for duplicate
+	dist_schedule clauses.
+
+2019-11-05  Jason Merrill  <jason@redhat.com>
+
+	PR c++/88075
+	* parser.c (cp_parser_decl_specifier_seq): Support C++20
+	concept-definition syntax without 'bool'.
+
+2019-10-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-10-21  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/92106 - ICE with structured bindings and -Wreturn-local-addr.
+	* typeck.c (maybe_warn_about_returning_address_of_local): Avoid
+	recursing on null initializer and return false instead.
+
+2019-09-03  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backported from mainline
+	2019-08-23  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR pch/61250
+	* parser.c (cp_parser_initial_pragma): Call c_common_no_more_pch ()
+	after determining that the first token is not
+	PRAGMA_GCC_PCH_PREPROCESS.
+
+2019-08-30  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2019-02-21  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/89392
+	* vtable-class-hierarchy.c (vtv_generate_init_routine): Do not
+	make symtab process new functions here.
+
+2019-08-29  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-06-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90950
+	* semantics.c (finish_omp_clauses): Don't reject references to
+	incomplete types if processing_template_decl.
+
+	2019-05-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/90197
+	* cp-gimplify.c (genericize_cp_loop): Emit a DEBUG_BEGIN_STMT
+	before the condition (or if missing or constant non-zero at the end
+	of the loop.  Emit a DEBUG_BEGIN_STMT before the increment expression
+	if any.  Don't call protected_set_expr_location on incr if it already
+	has a location.
+
+	2019-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR pch/90326
+	* config-lang.in (gtfiles): Remove c-family/c-lex.c, add
+	c-family/c-cppbuiltin.c.
+
+2019-08-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline.
+	2019-08-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/91436
+	* name-lookup.c (get_std_name_hint): Fix min_dialect field for
+	complex_literals and make_unique entries.
+
+2019-08-01  Marek Polacek  <polacek@redhat.com>	
+
+	Backported from mainline
+	2018-06-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/86098 - ICE with template placeholder for TTP.
+	* typeck.c (structural_comptypes) [TEMPLATE_TYPE_PARM]: Check
+	CLASS_PLACEHOLDER_TEMPLATE.
+
+2019-06-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90810
+	* init.c (constant_value_1): Handle VECTOR_CST DECL_INITIAL for
+	!DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P decls like CONSTRUCTOR.
+
+2019-05-22  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2018-05-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR c++/85400
+	* decl2.c (adjust_var_decl_tls_model): New static function.
+	(comdat_linkage): Call it on a variable.
+	(maybe_make_one_only): Likewise.
+
+2019-05-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backported from mainline
+	2019-05-20  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/90532 Ensure __is_constructible(T[]) is false
+	* method.c (is_xible_helper): Return error_mark_node for construction
+	of an array of unknown bound.
+
+2019-05-07  Marek Polacek  <polacek@redhat.com>	
+
+	Backported from mainline
+	2019-02-27  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/88857 - ICE with value-initialization of argument in template.
+	* call.c (convert_like_real): Don't call build_value_init in template.
+
+	2019-03-25  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/89214 - ICE when initializing aggregates with bases.
+	* typeck2.c (digest_init_r): Warn about object slicing instead of
+	crashing.
+
+	2019-02-27  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/89511 - ICE with using-declaration and unscoped enumerator.
+	* parser.c (cp_parser_using_declaration): For an unscoped enum
+	only use its context if it's not a function declaration.
+
+	2019-03-25  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/89705 - ICE with reference binding with conversion function.
+	* call.c (reference_binding): If the result of the conversion function
+	is a prvalue of non-class type, use the cv-unqualified type.
+
+	2019-03-29  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/89876 - ICE with deprecated conversion.
+	* call.c (convert_like_real): Only give warnings with tf_warning.
+
+2019-04-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/90108
+	* decl.c (duplicate_decls): If remove is main variant and
+	DECL_ORIGINAL_TYPE is some other type, remove a DECL_ORIGINAL_TYPE
+	variant that has newdecl as TYPE_NAME if any.
+
+	2019-04-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/89933
+	* decl.c (duplicate_decls): When newdecl's type is its main variant,
+	don't try to remove it from the variant list, but instead assert
+	it has no variants.
+
+	2019-03-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/89869
+	* typeck.c: Include gimplify.h.
+	(cp_build_modify_expr) <case COND_EXPR>: Unshare rhs before using it
+	for second time.  Formatting fixes.
+
+	2019-03-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89796
+	* semantics.c (finish_omp_atomic): Add warning_sentinel for
+	-Wunused-value around finish_expr_stmt call.
+
+	2019-03-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/60702
+	* cp-tree.h (get_tls_wrapper_fn): Remove declaration.
+	(maybe_get_tls_wrapper_call): Declare.
+	* decl2.c (get_tls_wrapper_fn): Make static.
+	(maybe_get_tls_wrapper_call): New function.
+	* typeck.c (build_class_member_access_expr): Handle accesses to TLS
+	variables.
+	* semantics.c (finish_qualified_id_expr): Likewise.
+	(finish_id_expression_1): Use maybe_get_tls_wrapper_call.
+	* pt.c (tsubst_copy_and_build): Likewise.
+
+	2019-03-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89767
+	* parser.c (cp_parser_lambda_introducer): Add ids and first_capture_id
+	variables, check for duplicates in this function.
+	* lambda.c (add_capture): Don't check for duplicates nor use
+	IDENTIFIER_MARKED.
+	(register_capture_members): Don't clear IDENTIFIER_MARKED here.
+
+	2019-03-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89512
+	* semantics.c (finish_qualified_id_expr): Reject variable templates.
+
+	2019-03-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/87148
+	* init.c (build_value_init_noctor): Ignore flexible array members.
+
+	2019-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89403
+	* decl2.c (c_parse_final_cleanups): Move TREE_ASM_WRITTEN setting
+	for flag_syntax_only from here...
+	* semantics.c (expand_or_defer_fn_1): ... here.
+
+	PR c++/89405
+	* decl.c (maybe_commonize_var): When clearing TREE_PUBLIC and
+	DECL_COMMON, set DECL_INTERFACE_KNOWN.
+
+2019-03-08  Jason Merrill  <jason@redhat.com>
+
+	PR c++/88820 - ICE with CTAD and member template used in DMI.
+	* pt.c (do_class_deduction): Handle parm used as its own arg.
+
+	PR c++/88869 - C++17 ICE with CTAD and explicit specialization.
+	* pt.c (do_class_deduction): Don't include explicit specialization
+	args in outer_args.
+
+	PR c++/88419 - C++17 ICE with class template arg deduction.
+	* pt.c (make_template_placeholder): Set TYPE_CANONICAL after
+	CLASS_PLACEHOLDER_TEMPLATE.
+
+	PR c++/88690 - C++17 ICE with empty base in aggregate.
+	* typeck2.c (process_init_constructor_record): Skip trivial
+	initialization of an empty base.
+
+	PR c++/87921 - wrong error with inline static data member.
+	* decl2.c (c_parse_final_cleanups): Don't force out uninstantiated
+	inline static data members.
+
+	PR c++/89381 - implicit copy and using-declaration.
+	* class.c (classtype_has_move_assign_or_move_ctor_p): Don't consider
+	op= brought in by a using-declaration.
+
+	PR c++/89576 - if constexpr of lambda capture.
+	* semantics.c (maybe_convert_cond): Do convert a non-dependent
+	condition in a template.
+	* typeck.c (condition_conversion): Handle being called in a
+	template.
+
+	PR c++/89422 - ICE with -g and lambda in default arg in template.
+	* pt.c (tsubst_function_decl): SET_DECL_FRIEND_CONTEXT sooner.
+
+	PR c++/87513 - 'sorry' mangling PMF template-id.
+	* mangle.c (write_expression): Handle SCOPE_REF to BASELINK.
+
+	PR c++/88183 - ICE with .* fold-expression.
+	* pt.c (fold_expression) [DOTSTAR_EXPR]: Remove special handling.
+
+2019-03-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/89585
+	* parser.c (cp_parser_asm_definition): Parse asm qualifiers even
+	at toplevel, but diagnose them.
+
+2019-02-26  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2019-02-11  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/89212 - ICE converting nullptr to pointer-to-member-function.
+	* pt.c (tsubst_copy_and_build) <case CONSTRUCTOR>: Return early for
+	null member pointer value.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: gcc/cp/cp-gimplify.c
===================================================================
diff --git a/gcc/cp/cp-gimplify.c b/gcc/cp/cp-gimplify.c
--- a/gcc/cp/cp-gimplify.c	(revision 278653)
+++ b/gcc/cp/cp-gimplify.c	(revision 278653)
@@ -202,11 +202,13 @@
   tree blab, clab;
   tree exit = NULL;
   tree stmt_list = NULL;
+  tree debug_begin = NULL;
 
   blab = begin_bc_block (bc_break, start_locus);
   clab = begin_bc_block (bc_continue, start_locus);
 
-  protected_set_expr_location (incr, start_locus);
+  if (EXPR_LOCATION (incr) == UNKNOWN_LOCATION)
+    protected_set_expr_location (incr, start_locus);
 
   cp_walk_tree (&cond, cp_genericize_r, data, NULL);
   cp_walk_tree (&body, cp_genericize_r, data, NULL);
@@ -213,6 +215,13 @@
   cp_walk_tree (&incr, cp_genericize_r, data, NULL);
   *walk_subtrees = 0;
 
+  if (MAY_HAVE_DEBUG_MARKER_STMTS
+      && (!cond || !integer_zerop (cond)))
+    {
+      debug_begin = build0 (DEBUG_BEGIN_STMT, void_type_node);
+      SET_EXPR_LOCATION (debug_begin, EXPR_LOC_OR_LOC (cond, start_locus));
+    }
+
   if (cond && TREE_CODE (cond) != INTEGER_CST)
     {
       /* If COND is constant, don't bother building an exit.  If it's false,
@@ -225,10 +234,24 @@
     }
 
   if (exit && cond_is_first)
-    append_to_statement_list (exit, &stmt_list);
+    {
+      append_to_statement_list (debug_begin, &stmt_list);
+      debug_begin = NULL_TREE;
+      append_to_statement_list (exit, &stmt_list);
+    }
   append_to_statement_list (body, &stmt_list);
   finish_bc_block (&stmt_list, bc_continue, clab);
-  append_to_statement_list (incr, &stmt_list);
+  if (incr)
+    {
+      if (MAY_HAVE_DEBUG_MARKER_STMTS)
+	{
+	  tree d = build0 (DEBUG_BEGIN_STMT, void_type_node);
+	  SET_EXPR_LOCATION (d, EXPR_LOC_OR_LOC (incr, start_locus));
+	  append_to_statement_list (d, &stmt_list);
+	}
+      append_to_statement_list (incr, &stmt_list);
+    }
+  append_to_statement_list (debug_begin, &stmt_list);
   if (exit && !cond_is_first)
     append_to_statement_list (exit, &stmt_list);
 
@@ -752,6 +775,27 @@
 
     case CALL_EXPR:
       ret = GS_OK;
+      if (flag_strong_eval_order == 2
+	  && CALL_EXPR_FN (*expr_p)
+	  && cp_get_callee_fndecl_nofold (*expr_p) == NULL_TREE)
+	{
+	  tree fnptrtype = TREE_TYPE (CALL_EXPR_FN (*expr_p));
+	  enum gimplify_status t
+	    = gimplify_expr (&CALL_EXPR_FN (*expr_p), pre_p, NULL,
+			     is_gimple_call_addr, fb_rvalue);
+	  if (t == GS_ERROR)
+	    ret = GS_ERROR;
+	  else if (is_gimple_variable (CALL_EXPR_FN (*expr_p))
+		   && TREE_CODE (CALL_EXPR_FN (*expr_p)) != SSA_NAME)
+	    CALL_EXPR_FN (*expr_p)
+	      = get_initialized_tmp_var (CALL_EXPR_FN (*expr_p), pre_p,
+					 NULL);
+	  /* GIMPLE considers most pointer conversion useless, but for
+	     calls we actually care about the exact function pointer type.  */
+	  if (t != GS_ERROR && TREE_TYPE (CALL_EXPR_FN (*expr_p)) != fnptrtype)
+	    CALL_EXPR_FN (*expr_p)
+	      = build1 (NOP_EXPR, fnptrtype, CALL_EXPR_FN (*expr_p));
+	}
       if (!CALL_EXPR_FN (*expr_p))
 	/* Internal function call.  */;
       else if (CALL_EXPR_REVERSE_ARGS (*expr_p))
Index: gcc/cp/typeck2.c
===================================================================
diff --git a/gcc/cp/typeck2.c b/gcc/cp/typeck2.c
--- a/gcc/cp/typeck2.c	(revision 278653)
+++ b/gcc/cp/typeck2.c	(revision 278653)
@@ -1142,8 +1142,29 @@
     {
       tree elt = CONSTRUCTOR_ELT (init, 0)->value;
       if (reference_related_p (type, TREE_TYPE (elt)))
-	/* We should have fixed this in reshape_init.  */
-	gcc_unreachable ();
+	{
+	  /* In C++17, aggregates can have bases, thus participate in
+	     aggregate initialization.  In the following case:
+
+	       struct B { int c; };
+	       struct D : B { };
+	       D d{{D{{42}}}};
+
+	    there's an extra set of braces, so the D temporary initializes
+	    the first element of d, which is the B base subobject.  The base
+	    of type B is copy-initialized from the D temporary, causing
+	    object slicing.  */
+	  tree field = next_initializable_field (TYPE_FIELDS (type));
+	  if (field && DECL_FIELD_IS_BASE (field))
+	    {
+	      if (warning_at (loc, 0, "initializing a base class of type %qT "
+			      "results in object slicing", TREE_TYPE (field)))
+		inform (loc, "remove %<{ }%> around initializer");
+	    }
+	  else
+	    /* We should have fixed this in reshape_init.  */
+	    gcc_unreachable ();
+	}
     }
 
   if (BRACE_ENCLOSED_INITIALIZER_P (init)
@@ -1538,6 +1559,13 @@
 	    }
 	}
 
+      if (DECL_SIZE (field) && integer_zerop (DECL_SIZE (field))
+	  && !TREE_SIDE_EFFECTS (next))
+	/* Don't add trivial initialization of an empty base/field to the
+	   constructor, as they might not be ordered the way the back-end
+	   expects.  */
+	continue;
+
       /* If this is a bitfield, now convert to the lowered type.  */
       if (type != TREE_TYPE (field))
 	next = cp_convert_and_check (TREE_TYPE (field), next, complain);
Index: gcc/cp/pt.c
===================================================================
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
--- a/gcc/cp/pt.c	(revision 278653)
+++ b/gcc/cp/pt.c	(revision 278653)
@@ -11732,8 +11732,6 @@
     {
     case COMPOUND_EXPR:
       return build_x_compound_expr (input_location, left, right, complain);
-    case DOTSTAR_EXPR:
-      return build_m_component_ref (left, right, complain);
     default:
       return build_x_binary_op (input_location, code,
                                 left, TREE_CODE (left),
@@ -13023,6 +13021,11 @@
 	set_constraints (r, ci);
       }
 
+  if (DECL_FRIEND_P (t) && DECL_FRIEND_CONTEXT (t))
+    SET_DECL_FRIEND_CONTEXT (r,
+			     tsubst (DECL_FRIEND_CONTEXT (t),
+				     args, complain, in_decl));
+
   /* Set up the DECL_TEMPLATE_INFO for R.  There's no need to do
      this in the special friend case mentioned above where
      GEN_TMPL is NULL.  */
@@ -13084,11 +13087,6 @@
 	   && !grok_op_properties (r, /*complain=*/true))
     return error_mark_node;
 
-  if (DECL_FRIEND_P (t) && DECL_FRIEND_CONTEXT (t))
-    SET_DECL_FRIEND_CONTEXT (r,
-			     tsubst (DECL_FRIEND_CONTEXT (t),
-				     args, complain, in_decl));
-
   /* Possibly limit visibility based on template args.  */
   DECL_VISIBILITY (r) = VISIBILITY_DEFAULT;
   if (DECL_VISIBILITY_SPECIFIED (t))
@@ -18797,6 +18795,12 @@
 	   looked up by digest_init.  */
 	process_index_p = !(type && MAYBE_CLASS_TYPE_P (type));
 
+	if (null_member_pointer_value_p (t))
+	  {
+	    gcc_assert (same_type_p (type, TREE_TYPE (t)));
+	    RETURN (t);
+	  }
+
 	n = vec_safe_copy (CONSTRUCTOR_ELTS (t));
         newlen = vec_safe_length (n);
 	FOR_EACH_VEC_SAFE_ELT (n, idx, ce)
@@ -18890,17 +18894,10 @@
       {
 	tree r = tsubst_copy (t, args, complain, in_decl);
 	/* ??? We're doing a subset of finish_id_expression here.  */
-	if (VAR_P (r)
-	    && !processing_template_decl
-	    && !cp_unevaluated_operand
-	    && (TREE_STATIC (r) || DECL_EXTERNAL (r))
-	    && CP_DECL_THREAD_LOCAL_P (r))
-	  {
-	    if (tree wrap = get_tls_wrapper_fn (r))
-	      /* Replace an evaluated use of the thread_local variable with
-		 a call to its wrapper.  */
-	      r = build_cxx_call (wrap, 0, NULL, tf_warning_or_error);
-	  }
+	if (tree wrap = maybe_get_tls_wrapper_call (r))
+	  /* Replace an evaluated use of the thread_local variable with
+	     a call to its wrapper.  */
+	  r = wrap;
 	else if (outer_automatic_var_p (r))
 	  r = process_outer_var_ref (r, complain);
 
@@ -25998,8 +25995,10 @@
 tree
 make_template_placeholder (tree tmpl)
 {
-  tree t = make_auto_1 (DECL_NAME (tmpl), true);
+  tree t = make_auto_1 (DECL_NAME (tmpl), false);
   CLASS_PLACEHOLDER_TEMPLATE (t) = tmpl;
+  /* Our canonical type depends on the placeholder.  */
+  TYPE_CANONICAL (t) = canonical_type_parameter (t);
   return t;
 }
 
@@ -26534,6 +26533,9 @@
 	error ("non-class template %qT used without template arguments", tmpl);
       return error_mark_node;
     }
+  if (init && TREE_TYPE (init) == ptype)
+    /* Using the template parm as its own argument.  */
+    return ptype;
 
   tree type = TREE_TYPE (tmpl);
 
@@ -26601,7 +26603,7 @@
 
   tree outer_args = NULL_TREE;
   if (DECL_CLASS_SCOPE_P (tmpl)
-      && CLASSTYPE_TEMPLATE_INFO (DECL_CONTEXT (tmpl)))
+      && CLASSTYPE_TEMPLATE_INSTANTIATION (DECL_CONTEXT (tmpl)))
     {
       outer_args = CLASSTYPE_TI_ARGS (DECL_CONTEXT (tmpl));
       type = TREE_TYPE (most_general_template (tmpl));
Index: gcc/cp/semantics.c
===================================================================
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
--- a/gcc/cp/semantics.c	(revision 278653)
+++ b/gcc/cp/semantics.c	(revision 278653)
@@ -645,10 +645,13 @@
     return NULL_TREE;
 
   /* Wait until we instantiate templates before doing conversion.  */
-  if (processing_template_decl)
+  if (processing_template_decl
+      && (type_dependent_expression_p (cond)
+	  /* For GCC 8 only convert non-dependent condition in a lambda.  */
+	  || !current_lambda_expr ()))
     return cond;
 
-  if (warn_sequence_point)
+  if (warn_sequence_point && !processing_template_decl)
     verify_sequence_points (cond);
 
   /* Do the conversion.  */
@@ -2099,6 +2102,14 @@
 	expr = build_offset_ref (qualifying_class, expr, /*address_p=*/false,
 				 complain);
     }
+  else if (!template_p
+	   && TREE_CODE (expr) == TEMPLATE_DECL
+	   && !DECL_FUNCTION_TEMPLATE_P (expr))
+    {
+      if (complain & tf_error)
+	error ("%qE missing template arguments", expr);
+      return error_mark_node;
+    }
   else
     {
       /* In a template, return a SCOPE_REF for most qualified-ids
@@ -2114,6 +2125,8 @@
 	expr = build_qualified_name (TREE_TYPE (expr),
 				     qualifying_class, expr,
 				     template_p);
+      else if (tree wrap = maybe_get_tls_wrapper_call (expr))
+	expr = wrap;
 
       expr = convert_from_reference (expr);
     }
@@ -3709,18 +3722,10 @@
 	  *non_integral_constant_expression_p = true;
 	}
 
-      tree wrap;
-      if (VAR_P (decl)
-	  && !cp_unevaluated_operand
-	  && !processing_template_decl
-	  && (TREE_STATIC (decl) || DECL_EXTERNAL (decl))
-	  && CP_DECL_THREAD_LOCAL_P (decl)
-	  && (wrap = get_tls_wrapper_fn (decl)))
-	{
-	  /* Replace an evaluated use of the thread_local variable with
-	     a call to its wrapper.  */
-	  decl = build_cxx_call (wrap, 0, NULL, tf_warning_or_error);
-	}
+      if (tree wrap = maybe_get_tls_wrapper_call (decl))
+	/* Replace an evaluated use of the thread_local variable with
+	   a call to its wrapper.  */
+	decl = wrap;
       else if (TREE_CODE (decl) == TEMPLATE_ID_EXPR
 	       && !dependent_p
 	       && variable_template_p (TREE_OPERAND (decl, 0)))
@@ -4265,7 +4270,12 @@
   /* There's no reason to do any of the work here if we're only doing
      semantic analysis; this code just generates RTL.  */
   if (flag_syntax_only)
-    return false;
+    {
+      /* Pretend that this function has been written out so that we don't try
+	 to expand it again.  */
+      TREE_ASM_WRITTEN (fn) = 1;
+      return false;
+    }
 
   return true;
 }
@@ -7305,7 +7315,8 @@
 	  t = require_complete_type (t);
 	  if (t == error_mark_node)
 	    remove = true;
-	  else if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE
+	  else if (!processing_template_decl
+		   && TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE
 		   && !complete_type_or_else (TREE_TYPE (TREE_TYPE (t)), t))
 	    remove = true;
 	}
@@ -8452,6 +8463,11 @@
       stmt = build2 (OMP_ATOMIC, void_type_node, integer_zero_node, stmt);
       OMP_ATOMIC_SEQ_CST (stmt) = seq_cst;
     }
+
+  /* Avoid -Wunused-value warnings here, the whole construct has side-effects
+     and even if it might be wrapped from fold-const.c or c-omp.c wrapped
+     in some tree that appears to be unused, the value is not unused.  */
+  warning_sentinel w (warn_unused_value);
   finish_expr_stmt (stmt);
 }
 
Index: gcc/cp/decl2.c
===================================================================
diff --git a/gcc/cp/decl2.c b/gcc/cp/decl2.c
--- a/gcc/cp/decl2.c	(revision 278653)
+++ b/gcc/cp/decl2.c	(revision 278653)
@@ -1838,6 +1838,17 @@
     }
 }
 
+/* Adjust the TLS model on variable DECL if need be, typically after
+   the linkage of DECL has been modified.  */
+
+static void
+adjust_var_decl_tls_model (tree decl)
+{
+  if (CP_DECL_THREAD_LOCAL_P (decl)
+      && !lookup_attribute ("tls_model", DECL_ATTRIBUTES (decl)))
+    set_decl_tls_model (decl, decl_default_tls_model (decl));
+}
+
 /* Set DECL up to have the closest approximation of "initialized common"
    linkage available.  */
 
@@ -1888,6 +1899,9 @@
 
   if (TREE_PUBLIC (decl))
     DECL_COMDAT (decl) = 1;
+
+  if (VAR_P (decl))
+    adjust_var_decl_tls_model (decl);
 }
 
 /* For win32 we also want to put explicit instantiations in
@@ -1926,6 +1940,8 @@
 	  /* Mark it needed so we don't forget to emit it.  */
           node->forced_by_abi = true;
 	  TREE_USED (decl) = 1;
+
+	  adjust_var_decl_tls_model (decl);
 	}
     }
 }
@@ -3357,7 +3373,7 @@
    VAR and then returns a reference to VAR.  The wrapper function is used
    in place of VAR everywhere VAR is mentioned.  */
 
-tree
+static tree
 get_tls_wrapper_fn (tree var)
 {
   /* Only C++11 TLS vars need this wrapper fn.  */
@@ -3409,6 +3425,22 @@
   return fn;
 }
 
+/* If EXPR is a thread_local variable that should be wrapped by init
+   wrapper function, return a call to that function, otherwise return
+   NULL.  */
+
+tree
+maybe_get_tls_wrapper_call (tree expr)
+{
+  if (VAR_P (expr)
+      && !processing_template_decl
+      && !cp_unevaluated_operand
+      && CP_DECL_THREAD_LOCAL_P (expr))
+    if (tree wrap = get_tls_wrapper_fn (expr))
+      return build_cxx_call (wrap, 0, NULL, tf_warning_or_error);
+  return NULL;
+}
+
 /* At EOF, generate the definition for the TLS wrapper function FN:
 
    T& var_wrapper() {
@@ -4888,11 +4920,6 @@
 	      /* Generate RTL for this function now that we know we
 		 need it.  */
 	      expand_or_defer_fn (decl);
-	      /* If we're compiling -fsyntax-only pretend that this
-		 function has been written out so that we don't try to
-		 expand it again.  */
-	      if (flag_syntax_only)
-		TREE_ASM_WRITTEN (decl) = 1;
 	      reconsider = true;
 	    }
 	}
@@ -4905,7 +4932,10 @@
 	{
 	  if (var_finalized_p (decl) || DECL_REALLY_EXTERN (decl)
 	      /* Don't write it out if we haven't seen a definition.  */
-	      || (DECL_IN_AGGR_P (decl) && !DECL_INLINE_VAR_P (decl)))
+	      || (DECL_IN_AGGR_P (decl) && !DECL_INLINE_VAR_P (decl))
+	      /* Or haven't instantiated it.  */
+	      || (DECL_TEMPLATE_INSTANTIATION (decl)
+		  && !DECL_TEMPLATE_INSTANTIATED (decl)))
 	    continue;
 	  import_export_decl (decl);
 	  /* If this static data member is needed, provide it to the
Index: gcc/cp/parser.c
===================================================================
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
--- a/gcc/cp/parser.c	(revision 278653)
+++ b/gcc/cp/parser.c	(revision 278653)
@@ -10266,6 +10266,11 @@
       first = false;
     }
 
+  hash_set<tree> *ids = NULL;
+#if GCC_VERSION >= 8000
+  char ids_buf[sizeof (hash_set<tree>) + __alignof__ (hash_set<tree>) - 1];
+#endif
+  tree first_capture_id = NULL_TREE;
   while (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_SQUARE))
     {
       cp_token* capture_token;
@@ -10301,11 +10306,14 @@
 	    pedwarn (loc, 0, "explicit by-copy capture of %<this%> redundant "
 		     "with by-copy capture default");
 	  cp_lexer_consume_token (parser->lexer);
-	  add_capture (lambda_expr,
-		       /*id=*/this_identifier,
-		       /*initializer=*/finish_this_expr (),
-		       /*by_reference_p=*/true,
-		       explicit_init_p);
+	  if (LAMBDA_EXPR_THIS_CAPTURE (lambda_expr))
+	    pedwarn (input_location, 0,
+		     "already captured %qD in lambda expression",
+		     this_identifier);
+	  else
+	    add_capture (lambda_expr, /*id=*/this_identifier,
+			 /*initializer=*/finish_this_expr (),
+			 /*by_reference_p=*/true, explicit_init_p);
 	  continue;
 	}
 
@@ -10319,11 +10327,14 @@
 			     "-std=c++17 or -std=gnu++17");
 	  cp_lexer_consume_token (parser->lexer);
 	  cp_lexer_consume_token (parser->lexer);
-	  add_capture (lambda_expr,
-		       /*id=*/this_identifier,
-		       /*initializer=*/finish_this_expr (),
-		       /*by_reference_p=*/false,
-		       explicit_init_p);
+	  if (LAMBDA_EXPR_THIS_CAPTURE (lambda_expr))
+	    pedwarn (input_location, 0,
+		     "already captured %qD in lambda expression",
+		     this_identifier);
+	  else
+	    add_capture (lambda_expr, /*id=*/this_identifier,
+			 /*initializer=*/finish_this_expr (),
+			 /*by_reference_p=*/false, explicit_init_p);
 	  continue;
 	}
 
@@ -10445,11 +10456,35 @@
 		     "default", capture_id);
 	}
 
-      add_capture (lambda_expr,
-		   capture_id,
-		   capture_init_expr,
-		   /*by_reference_p=*/capture_kind == BY_REFERENCE,
-		   explicit_init_p);
+      /* Check for duplicates.
+	 Optimize for the zero or one explicit captures cases and only create
+	 the hash_set after adding second capture.  */
+      bool found = false;
+      if (ids && ids->elements ())
+	found = ids->add (capture_id);
+      else if (first_capture_id == NULL_TREE)
+	first_capture_id = capture_id;
+      else if (capture_id == first_capture_id)
+	found = true;
+      else
+	{
+#if GCC_VERSION >= 8000
+	  ids = new (ids_buf
+		     + (-(uintptr_t) ids_buf
+			& (__alignof__ (hash_set <tree>) - 1))) hash_set <tree>;
+#else
+	  ids = new hash_set <tree>;
+#endif
+	  ids->add (first_capture_id);
+	  ids->add (capture_id);
+	}
+      if (found)
+	pedwarn (input_location, 0,
+		 "already captured %qD in lambda expression", capture_id);
+      else
+	add_capture (lambda_expr, capture_id, capture_init_expr,
+		     /*by_reference_p=*/capture_kind == BY_REFERENCE,
+		     explicit_init_p);
 
       /* If there is any qualification still in effect, clear it
 	 now; we will be starting fresh with the next capture.  */
@@ -10458,6 +10493,13 @@
       parser->object_scope = NULL_TREE;
     }
 
+  if (ids)
+#if GCC_VERSION >= 8000
+    ids->~hash_set <tree> ();
+#else
+    delete ids;
+#endif
+
   cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);
 }
 
@@ -13510,6 +13552,15 @@
         case RID_CONCEPT:
           ds = ds_concept;
           cp_lexer_consume_token (parser->lexer);
+	  /* In C++20 a concept definition is just 'concept name = expr;'
+	     Support that syntax by pretending we've seen 'bool'.  */
+	  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME)
+	      && cp_lexer_nth_token_is (parser->lexer, 2, CPP_EQ))
+	    {
+	      cp_parser_set_decl_spec_type (decl_specs, boolean_type_node,
+					    token, /*type_definition*/false);
+	      decl_specs->any_type_specifiers_p = true;
+	    }
           break;
 
 	  /* function-specifier:
@@ -18773,7 +18824,8 @@
 						  /*is_declaration=*/true);
   if (!qscope)
     qscope = global_namespace;
-  else if (UNSCOPED_ENUM_P (qscope))
+  else if (UNSCOPED_ENUM_P (qscope)
+	   && !TYPE_FUNCTION_SCOPE_P (qscope))
     qscope = CP_TYPE_CONTEXT (qscope);
 
   if (access_declaration_p && cp_parser_error_occurred (parser))
@@ -19125,8 +19177,9 @@
   location_t volatile_loc = UNKNOWN_LOCATION;
   location_t inline_loc = UNKNOWN_LOCATION;
   location_t goto_loc = UNKNOWN_LOCATION;
+  location_t first_loc = UNKNOWN_LOCATION;
 
-  if (cp_parser_allow_gnu_extensions_p (parser) && parser->in_function_body)
+  if (cp_parser_allow_gnu_extensions_p (parser))
     for (;;)
       {
 	cp_token *token = cp_lexer_peek_token (parser->lexer);
@@ -19152,6 +19205,8 @@
 	      }
 	    else
 	      inline_loc = loc;
+	    if (!first_loc)
+	      first_loc = loc;
 	    cp_lexer_consume_token (parser->lexer);
 	    continue;
 
@@ -19163,6 +19218,8 @@
 	      }
 	    else
 	      goto_loc = loc;
+	    if (!first_loc)
+	      first_loc = loc;
 	    cp_lexer_consume_token (parser->lexer);
 	    continue;
 
@@ -19182,6 +19239,12 @@
   bool inline_p = (inline_loc != UNKNOWN_LOCATION);
   bool goto_p = (goto_loc != UNKNOWN_LOCATION);
 
+  if (!parser->in_function_body && (inline_p || goto_p))
+    {
+      error_at (first_loc, "asm qualifier outside of function body");
+      inline_p = goto_p = false;
+    }
+
   /* Look for the opening `('.  */
   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))
     return;
@@ -33599,8 +33662,10 @@
   else if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_COMMA_CLOSE_PAREN))
     goto resync_fail;
 
-  check_no_duplicate_clause (list, OMP_CLAUSE_DIST_SCHEDULE, "dist_schedule",
-			     location);
+  /* check_no_duplicate_clause (list, OMP_CLAUSE_DIST_SCHEDULE,
+				"dist_schedule", location); */
+  if (omp_find_clause (list, OMP_CLAUSE_DIST_SCHEDULE))
+    warning_at (location, 0, "too many %qs clauses", "dist_schedule");
   OMP_CLAUSE_CHAIN (c) = list;
   return c;
 
@@ -38680,7 +38745,10 @@
 
   cp_lexer_get_preprocessor_token (NULL, first_token);
   if (cp_parser_pragma_kind (first_token) != PRAGMA_GCC_PCH_PREPROCESS)
-    return;
+    {
+      c_common_no_more_pch ();
+      return;
+    }
 
   cp_lexer_get_preprocessor_token (NULL, first_token);
   if (first_token->type == CPP_STRING)
Index: gcc/cp/config-lang.in
===================================================================
diff --git a/gcc/cp/config-lang.in b/gcc/cp/config-lang.in
--- a/gcc/cp/config-lang.in	(revision 278653)
+++ b/gcc/cp/config-lang.in	(revision 278653)
@@ -37,7 +37,7 @@
 \$(srcdir)/c-family/c-pragma.h \$(srcdir)/cp/decl.h \
 \$(srcdir)/cp/parser.h \
 \$(srcdir)/c-family/c-common.c \$(srcdir)/c-family/c-format.c \
-\$(srcdir)/c-family/c-lex.c \$(srcdir)/c-family/c-pragma.c \
+\$(srcdir)/c-family/c-cppbuiltin.c \$(srcdir)/c-family/c-pragma.c \
 \$(srcdir)/cp/call.c \$(srcdir)/cp/class.c \$(srcdir)/cp/constexpr.c \
 \$(srcdir)/cp/cp-gimplify.c \
 \$(srcdir)/cp/cp-lang.c \$(srcdir)/cp/cp-objcp-common.c \
Index: gcc/cp/call.c
===================================================================
diff --git a/gcc/cp/call.c b/gcc/cp/call.c
--- a/gcc/cp/call.c	(revision 278653)
+++ b/gcc/cp/call.c	(revision 278653)
@@ -1767,6 +1767,9 @@
 	    && DECL_CONV_FN_P (t->cand->fn))
 	  {
 	    tree ftype = TREE_TYPE (TREE_TYPE (t->cand->fn));
+	    /* A prvalue of non-class type is cv-unqualified.  */
+	    if (TREE_CODE (ftype) != REFERENCE_TYPE && !CLASS_TYPE_P (ftype))
+	      ftype = cv_unqualified (ftype);
 	    int sflags = (flags|LOOKUP_NO_CONVERSION)&~LOOKUP_NO_TEMP_BIND;
 	    conversion *new_second
 	      = reference_binding (rto, ftype, NULL_TREE, c_cast_p,
@@ -6775,7 +6778,8 @@
 	/* If we're initializing from {}, it's value-initialization.  */
 	if (BRACE_ENCLOSED_INITIALIZER_P (expr)
 	    && CONSTRUCTOR_NELTS (expr) == 0
-	    && TYPE_HAS_DEFAULT_CONSTRUCTOR (totype))
+	    && TYPE_HAS_DEFAULT_CONSTRUCTOR (totype)
+	    && !processing_template_decl)
 	  {
 	    bool direct = CONSTRUCTOR_IS_DIRECT_INIT (expr);
 	    if (abstract_virtuals_error_sfinae (NULL_TREE, totype, complain))
@@ -7110,7 +7114,8 @@
 
     case ck_qual:
       /* Warn about deprecated conversion if appropriate.  */
-      string_conv_p (totype, expr, 1);
+      if (complain & tf_warning)
+	string_conv_p (totype, expr, 1);
       break;
 
     case ck_ptr:
Index: gcc/cp/lambda.c
===================================================================
diff --git a/gcc/cp/lambda.c b/gcc/cp/lambda.c
--- a/gcc/cp/lambda.c	(revision 278653)
+++ b/gcc/cp/lambda.c	(revision 278653)
@@ -612,19 +612,6 @@
 	  IDENTIFIER_LENGTH (id) + 1);
   name = get_identifier (buf);
 
-  /* If TREE_TYPE isn't set, we're still in the introducer, so check
-     for duplicates.  */
-  if (!LAMBDA_EXPR_CLOSURE (lambda))
-    {
-      if (IDENTIFIER_MARKED (name))
-	{
-	  pedwarn (input_location, 0,
-		   "already captured %qD in lambda expression", id);
-	  return NULL_TREE;
-	}
-      IDENTIFIER_MARKED (name) = true;
-    }
-
   if (variadic)
     type = make_pack_expansion (type);
 
@@ -685,8 +672,6 @@
   if (PACK_EXPANSION_P (field))
     field = PACK_EXPANSION_PATTERN (field);
 
-  /* We set this in add_capture to avoid duplicates.  */
-  IDENTIFIER_MARKED (DECL_NAME (field)) = false;
   finish_member_declaration (field);
 }
 
Index: gcc/cp/vtable-class-hierarchy.c
===================================================================
diff --git a/gcc/cp/vtable-class-hierarchy.c b/gcc/cp/vtable-class-hierarchy.c
--- a/gcc/cp/vtable-class-hierarchy.c	(revision 278653)
+++ b/gcc/cp/vtable-class-hierarchy.c	(revision 278653)
@@ -1191,8 +1191,6 @@
       gimplify_function_tree (vtv_fndecl);
       cgraph_node::add_new_function (vtv_fndecl, false);
 
-      symtab->process_new_functions ();
-
       if (flag_vtable_verify == VTV_PREINIT_PRIORITY && !TARGET_PECOFF)
         assemble_vtv_preinit_initializer (vtv_fndecl);
 
Index: gcc/cp/mangle.c
===================================================================
diff --git a/gcc/cp/mangle.c b/gcc/cp/mangle.c
--- a/gcc/cp/mangle.c	(revision 278653)
+++ b/gcc/cp/mangle.c	(revision 278653)
@@ -3047,7 +3047,8 @@
 	{
 	  scope = TREE_OPERAND (expr, 0);
 	  member = TREE_OPERAND (expr, 1);
-	  gcc_assert (!BASELINK_P (member));
+	  if (BASELINK_P (member))
+	    member = BASELINK_FUNCTIONS (member);
 	}
       else
 	{
Index: gcc/cp/cp-tree.h
===================================================================
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
--- a/gcc/cp/cp-tree.h	(revision 278653)
+++ b/gcc/cp/cp-tree.h	(revision 278653)
@@ -6390,7 +6390,7 @@
 extern tree get_guard				(tree);
 extern tree get_guard_cond			(tree, bool);
 extern tree set_guard				(tree);
-extern tree get_tls_wrapper_fn			(tree);
+extern tree maybe_get_tls_wrapper_call		(tree);
 extern void mark_needed				(tree);
 extern bool decl_needed_p			(tree);
 extern void note_vague_linkage_fn		(tree);
Index: gcc/cp/name-lookup.c
===================================================================
diff --git a/gcc/cp/name-lookup.c b/gcc/cp/name-lookup.c
--- a/gcc/cp/name-lookup.c	(revision 278653)
+++ b/gcc/cp/name-lookup.c	(revision 278653)
@@ -5509,7 +5509,7 @@
     {"bitset", "<bitset>", cxx11},
     /* <complex>.  */
     {"complex", "<complex>", cxx98},
-    {"complex_literals", "<complex>", cxx98},
+    {"complex_literals", "<complex>", cxx14},
     /* <condition_variable>. */
     {"condition_variable", "<condition_variable>", cxx11},
     {"condition_variable_any", "<condition_variable>", cxx11},
@@ -5571,7 +5571,7 @@
     {"multimap", "<map>", cxx98},
     /* <memory>.  */
     {"make_shared", "<memory>", cxx11},
-    {"make_unique", "<memory>", cxx11},
+    {"make_unique", "<memory>", cxx14},
     {"shared_ptr", "<memory>", cxx11},
     {"unique_ptr", "<memory>", cxx11},
     {"weak_ptr", "<memory>", cxx11},
Index: gcc/tree-ssa-ccp.c
===================================================================
diff --git a/gcc/tree-ssa-ccp.c b/gcc/tree-ssa-ccp.c
--- a/gcc/tree-ssa-ccp.c	(revision 278653)
+++ b/gcc/tree-ssa-ccp.c	(revision 278653)
@@ -2082,8 +2082,6 @@
 					   visited);
     else if (chkp_gimple_call_builtin_p (stmt, BUILT_IN_CHKP_BNDRET))
       continue;
-    else
-      gcc_assert (is_gimple_debug (stmt));
 }
 
 /* Advance the iterator to the previous non-debug gimple statement in the same
@@ -2108,9 +2106,9 @@
 /* Find a BUILT_IN_STACK_SAVE dominating gsi_stmt (I), and insert
    a clobber of VAR before each matching BUILT_IN_STACK_RESTORE.
 
-   It is possible that BUILT_IN_STACK_SAVE cannot be find in a dominator when a
-   previous pass (such as DOM) duplicated it along multiple paths to a BB.  In
-   that case the function gives up without inserting the clobbers.  */
+   It is possible that BUILT_IN_STACK_SAVE cannot be found in a dominator when
+   a previous pass (such as DOM) duplicated it along multiple paths to a BB.
+   In that case the function gives up without inserting the clobbers.  */
 
 static void
 insert_clobbers_for_var (gimple_stmt_iterator i, tree var)
Index: gcc/cgraphclones.c
===================================================================
diff --git a/gcc/cgraphclones.c b/gcc/cgraphclones.c
--- a/gcc/cgraphclones.c	(revision 278653)
+++ b/gcc/cgraphclones.c	(revision 278653)
@@ -938,6 +938,11 @@
    If non-NULL BLOCK_TO_COPY determine what basic blocks to copy.
    If non_NULL NEW_ENTRY determine new entry BB of the clone.
 
+   If TARGET_ATTRIBUTES is non-null, when creating a new declaration,
+   add the attributes to DECL_ATTRIBUTES.  And call valid_attribute_p
+   that will promote value of the attribute DECL_FUNCTION_SPECIFIC_TARGET
+   of the declaration.
+
    Return the new version's cgraph node.  */
 
 cgraph_node *
@@ -945,7 +950,7 @@
   (vec<cgraph_edge *> redirect_callers,
    vec<ipa_replace_map *, va_gc> *tree_map, bitmap args_to_skip,
    bool skip_return, bitmap bbs_to_copy, basic_block new_entry_block,
-   const char *suffix)
+   const char *suffix, tree target_attributes)
 {
   tree old_decl = decl;
   cgraph_node *new_version_node = NULL;
@@ -968,6 +973,19 @@
   SET_DECL_ASSEMBLER_NAME (new_decl, DECL_NAME (new_decl));
   SET_DECL_RTL (new_decl, NULL);
 
+  if (target_attributes)
+    {
+      DECL_ATTRIBUTES (new_decl) = target_attributes;
+
+      location_t saved_loc = input_location;
+      tree v = TREE_VALUE (target_attributes);
+      input_location = DECL_SOURCE_LOCATION (new_decl);
+      bool r = targetm.target_option.valid_attribute_p (new_decl, NULL, v, 0);
+      input_location = saved_loc;
+      if (!r)
+	return NULL;
+    }
+
   /* When the old decl was a con-/destructor make sure the clone isn't.  */
   DECL_STATIC_CONSTRUCTOR (new_decl) = 0;
   DECL_STATIC_DESTRUCTOR (new_decl) = 0;
Index: gcc/tree-ssa-loop-ivopts.c
===================================================================
diff --git a/gcc/tree-ssa-loop-ivopts.c b/gcc/tree-ssa-loop-ivopts.c
--- a/gcc/tree-ssa-loop-ivopts.c	(revision 278653)
+++ b/gcc/tree-ssa-loop-ivopts.c	(revision 278653)
@@ -582,6 +582,9 @@
   /* The common candidates.  */
   vec<iv_common_cand *> iv_common_cands;
 
+  /* Hash map recording base object information of tree exp.  */
+  hash_map<tree, tree> *base_object_map;
+
   /* The maximum invariant variable id.  */
   unsigned max_inv_var_id;
 
@@ -1093,6 +1096,7 @@
   data->vcands.create (20);
   data->inv_expr_tab = new hash_table<iv_inv_expr_hasher> (10);
   data->name_expansion_cache = NULL;
+  data->base_object_map = NULL;
   data->iv_common_cand_tab = new hash_table<iv_common_cand_hasher> (10);
   data->iv_common_cands.create (20);
   decl_rtl_to_reset.create (20);
@@ -1099,55 +1103,61 @@
   gcc_obstack_init (&data->iv_obstack);
 }
 
-/* Returns a memory object to that EXPR points.  In case we are able to
-   determine that it does not point to any such object, NULL is returned.  */
+/* walk_tree callback for determine_base_object.  */
 
 static tree
-determine_base_object (tree expr)
+determine_base_object_1 (tree *tp, int *walk_subtrees, void *wdata)
 {
-  enum tree_code code = TREE_CODE (expr);
-  tree base, obj;
-
-  /* If this is a pointer casted to any type, we need to determine
-     the base object for the pointer; so handle conversions before
-     throwing away non-pointer expressions.  */
-  if (CONVERT_EXPR_P (expr))
-    return determine_base_object (TREE_OPERAND (expr, 0));
-
-  if (!POINTER_TYPE_P (TREE_TYPE (expr)))
-    return NULL_TREE;
-
-  switch (code)
+  tree_code code = TREE_CODE (*tp);
+  tree obj = NULL_TREE;
+  if (code == ADDR_EXPR)
     {
-    case INTEGER_CST:
-      return NULL_TREE;
-
-    case ADDR_EXPR:
-      obj = TREE_OPERAND (expr, 0);
-      base = get_base_address (obj);
-
+      tree base = get_base_address (TREE_OPERAND (*tp, 0));
       if (!base)
-	return expr;
+	obj = *tp;
+      else if (TREE_CODE (base) != MEM_REF)
+	obj = fold_convert (ptr_type_node, build_fold_addr_expr (base));
+    }
+  else if (code == SSA_NAME && POINTER_TYPE_P (TREE_TYPE (*tp)))
+	obj = fold_convert (ptr_type_node, *tp);
 
-      if (TREE_CODE (base) == MEM_REF)
-	return determine_base_object (TREE_OPERAND (base, 0));
+  if (!obj)
+    {
+      if (!EXPR_P (*tp))
+	*walk_subtrees = 0;
 
-      return fold_convert (ptr_type_node,
-			   build_fold_addr_expr (base));
+      return NULL_TREE;
+    }
+  /* Record special node for multiple base objects and stop.  */
+  if (*static_cast<tree *> (wdata))
+    {
+      *static_cast<tree *> (wdata) = integer_zero_node;
+      return integer_zero_node;
+    }
+  /* Record the base object and continue looking.  */
+  *static_cast<tree *> (wdata) = obj;
+  return NULL_TREE;
+}
 
-    case POINTER_PLUS_EXPR:
-      return determine_base_object (TREE_OPERAND (expr, 0));
+/* Returns a memory object to that EXPR points with caching.  Return NULL if we
+   are able to determine that it does not point to any such object; specially
+   return integer_zero_node if EXPR contains multiple base objects.  */
 
-    case PLUS_EXPR:
-    case MINUS_EXPR:
-      /* Pointer addition is done solely using POINTER_PLUS_EXPR.  */
-      gcc_unreachable ();
+static tree
+determine_base_object (struct ivopts_data *data, tree expr)
+{
+  tree *slot, obj = NULL_TREE;
+  if (data->base_object_map)
+    {
+      if ((slot = data->base_object_map->get(expr)) != NULL)
+	return *slot;
+    }
+  else
+    data->base_object_map = new hash_map<tree, tree>;
 
-    default:
-      if (POLY_INT_CST_P (expr))
-	return NULL_TREE;
-      return fold_convert (ptr_type_node, expr);
-    }
+  (void) walk_tree_without_duplicates (&expr, determine_base_object_1, &obj);
+  data->base_object_map->put (expr, obj);
+  return obj;
 }
 
 /* Return true if address expression with non-DECL_P operand appears
@@ -1205,7 +1215,7 @@
     }
 
   iv->base = base;
-  iv->base_object = determine_base_object (base);
+  iv->base_object = determine_base_object (data, base);
   iv->step = step;
   iv->biv_p = false;
   iv->nonlin_use = NULL;
@@ -7487,6 +7497,8 @@
   delete data->inv_expr_tab;
   data->inv_expr_tab = NULL;
   free_affine_expand_cache (&data->name_expansion_cache);
+  if (data->base_object_map)
+    delete data->base_object_map;
   delete data->iv_common_cand_tab;
   data->iv_common_cand_tab = NULL;
   data->iv_common_cands.release ();
Index: gcc/df-core.c
===================================================================
diff --git a/gcc/df-core.c b/gcc/df-core.c
--- a/gcc/df-core.c	(revision 278653)
+++ b/gcc/df-core.c	(revision 278653)
@@ -298,12 +298,12 @@
 
    Artificial defs and uses occur both at the beginning and ends of blocks.
 
-     For blocks that area at the destination of eh edges, the
+     For blocks that are at the destination of eh edges, the
      artificial uses and defs occur at the beginning.  The defs relate
      to the registers specified in EH_RETURN_DATA_REGNO and the uses
-     relate to the registers specified in ED_USES.  Logically these
+     relate to the registers specified in EH_USES.  Logically these
      defs and uses should really occur along the eh edge, but there is
-     no convenient way to do this.  Artificial edges that occur at the
+     no convenient way to do this.  Artificial defs that occur at the
      beginning of the block have the DF_REF_AT_TOP flag set.
 
      Artificial uses occur at the end of all blocks.  These arise from
Index: gcc/modulo-sched.c
===================================================================
diff --git a/gcc/modulo-sched.c b/gcc/modulo-sched.c
--- a/gcc/modulo-sched.c	(revision 278653)
+++ b/gcc/modulo-sched.c	(revision 278653)
@@ -1605,6 +1605,7 @@
       mii = 1; /* Need to pass some estimate of mii.  */
       rec_mii = sms_order_nodes (g, mii, node_order, &max_asap);
       mii = MAX (res_MII (g), rec_mii);
+      mii = MAX (mii, 1);
       maxii = MAX (max_asap, MAXII_FACTOR * mii);
 
       if (dump_file)
@@ -3004,9 +3005,7 @@
             last_must_precede = next_ps_i;
         }
       /* The closing branch must be the last in the row.  */
-      if (must_precede 
-	  && bitmap_bit_p (must_precede, next_ps_i->id)
-	  && JUMP_P (ps_rtl_insn (ps, next_ps_i->id)))
+      if (JUMP_P (ps_rtl_insn (ps, next_ps_i->id)))
 	return false;
              
        last_in_row = next_ps_i;
Index: gcc/lto-streamer-out.c
===================================================================
diff --git a/gcc/lto-streamer-out.c b/gcc/lto-streamer-out.c
--- a/gcc/lto-streamer-out.c	(revision 278653)
+++ b/gcc/lto-streamer-out.c	(revision 278653)
@@ -1945,6 +1945,7 @@
       /* Write OMP SIMD related info.  */
       streamer_write_hwi (ob, loop->safelen);
       streamer_write_hwi (ob, loop->unroll);
+      streamer_write_hwi (ob, loop->owned_clique);
       streamer_write_hwi (ob, loop->dont_vectorize);
       streamer_write_hwi (ob, loop->force_vectorize);
       stream_write_tree (ob, loop->simduid, true);
Index: gcc/xcoffout.c
===================================================================
diff --git a/gcc/xcoffout.c b/gcc/xcoffout.c
--- a/gcc/xcoffout.c	(revision 278653)
+++ b/gcc/xcoffout.c	(revision 278653)
@@ -64,6 +64,7 @@
 
 char *xcoff_bss_section_name;
 char *xcoff_private_data_section_name;
+char *xcoff_private_rodata_section_name;
 char *xcoff_tls_data_section_name;
 char *xcoff_tbss_section_name;
 char *xcoff_read_only_section_name;
Index: gcc/tree-ssa-math-opts.c
===================================================================
diff --git a/gcc/tree-ssa-math-opts.c b/gcc/tree-ssa-math-opts.c
--- a/gcc/tree-ssa-math-opts.c	(revision 278653)
+++ b/gcc/tree-ssa-math-opts.c	(revision 278653)
@@ -334,7 +334,8 @@
 	 /* Do not recognize x / x as valid division, as we are getting
 	    confused later by replacing all immediate uses x in such
 	    a stmt.  */
-	 && gimple_assign_rhs1 (use_stmt) != def;
+	 && gimple_assign_rhs1 (use_stmt) != def
+	 && !stmt_can_throw_internal (use_stmt);
 }
 
 /* Return whether USE_STMT is DEF * DEF.  */
@@ -359,13 +360,12 @@
 {
   if (gimple_code (use_stmt) == GIMPLE_ASSIGN
       && gimple_assign_rhs_code (use_stmt) == RDIV_EXPR
-      && gimple_assign_rhs1 (use_stmt) != gimple_assign_rhs2 (use_stmt))
+      && gimple_assign_rhs1 (use_stmt) != gimple_assign_rhs2 (use_stmt)
+      && !stmt_can_throw_internal (use_stmt))
     {
       tree denominator = gimple_assign_rhs2 (use_stmt);
       if (TREE_CODE (denominator) == SSA_NAME)
-	{
-	  return is_square_of (SSA_NAME_DEF_STMT (denominator), def);
-	}
+	return is_square_of (SSA_NAME_DEF_STMT (denominator), def);
     }
   return 0;
 }
@@ -603,7 +603,7 @@
 
   /* If it is more profitable to optimize 1 / x, don't optimize 1 / (x * x).  */
   if (sqrt_recip_count > square_recip_count)
-    return;
+    goto out;
 
   /* Do the expensive part only if we can hope to optimize something.  */
   if (count + square_recip_count >= threshold && count >= 1)
@@ -646,6 +646,7 @@
 	}
     }
 
+out:
   for (occ = occ_head; occ; )
     occ = free_bb (occ);
 
Index: gcc/tree-ssa-dom.c
===================================================================
diff --git a/gcc/tree-ssa-dom.c b/gcc/tree-ssa-dom.c
--- a/gcc/tree-ssa-dom.c	(revision 278653)
+++ b/gcc/tree-ssa-dom.c	(revision 278653)
@@ -170,11 +170,10 @@
   gimple *def_stmt = SSA_NAME_DEF_STMT (name);
   if (is_gimple_assign (def_stmt))
     {
-      /* We know the result of DEF_STMT was zero.  See if that allows
-	 us to deduce anything about the SSA_NAMEs used on the RHS.  */
       enum tree_code code = gimple_assign_rhs_code (def_stmt);
       switch (code)
 	{
+	/* If the result of an OR is zero, then its operands are, too.  */
 	case BIT_IOR_EXPR:
 	  if (integer_zerop (value))
 	    {
@@ -188,8 +187,7 @@
 	    }
 	  break;
 
-      /* We know the result of DEF_STMT was one.  See if that allows
-	 us to deduce anything about the SSA_NAMEs used on the RHS.  */
+	/* If the result of an AND is nonzero, then its operands are, too.  */
 	case BIT_AND_EXPR:
 	  if (!integer_zerop (value))
 	    {
@@ -296,7 +294,6 @@
 	    break;
 	  }
 
-
 	case EQ_EXPR:
 	case NE_EXPR:
 	  {
@@ -336,7 +333,28 @@
 	case NEGATE_EXPR:
 	  {
 	    tree rhs = gimple_assign_rhs1 (def_stmt);
-	    tree res = fold_build1 (code, TREE_TYPE (rhs), value);
+	    tree res;
+	    /* If this is a NOT and the operand has a boolean range, then we
+	       know its value must be zero or one.  We are not supposed to
+	       have a BIT_NOT_EXPR for boolean types with precision > 1 in
+	       the general case, see e.g. the handling of TRUTH_NOT_EXPR in
+	       the gimplifier, but it can be generated by match.pd out of
+	       a BIT_XOR_EXPR wrapped in a BIT_AND_EXPR.  Now the handling
+	       of BIT_AND_EXPR above already forces a specific semantics for
+	       boolean types with precision > 1 so we must do the same here,
+	       otherwise we could change the semantics of TRUTH_NOT_EXPR for
+	       boolean types with precision > 1.  */
+	    if (code == BIT_NOT_EXPR
+		&& TREE_CODE (rhs) == SSA_NAME
+		&& ssa_name_has_boolean_range (rhs))
+	      {
+		if ((TREE_INT_CST_LOW (value) & 1) == 0)
+		  res = build_one_cst (TREE_TYPE (rhs));
+		else
+		  res = build_zero_cst (TREE_TYPE (rhs));
+	      }
+	    else
+	      res = fold_build1 (code, TREE_TYPE (rhs), value);
 	    derive_equivalences (rhs, res, recursion_limit - 1);
 	    break;
 	  }
@@ -598,7 +616,7 @@
      various tables mantained by DOM.  Returns the taken edge if
      the statement is a conditional with a statically determined
      value.  */
-  edge optimize_stmt (basic_block, gimple_stmt_iterator);
+  edge optimize_stmt (basic_block, gimple_stmt_iterator *, bool *);
 };
 
 /* Jump threading, redundancy elimination and const/copy propagation.
@@ -1437,10 +1455,48 @@
   m_avail_exprs_stack->pop_to_marker ();
 
   edge taken_edge = NULL;
+  /* Initialize visited flag ahead of us, it has undefined state on
+     pass entry.  */
   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+    gimple_set_visited (gsi_stmt (gsi), false);
+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi);)
     {
+      /* Do not optimize a stmt twice, substitution might end up with
+         _3 = _3 which is not valid.  */
+      if (gimple_visited_p (gsi_stmt (gsi)))
+	{
+	  gsi_next (&gsi);
+	  continue;
+	}
+
+      /* Compute range information and optimize the stmt.  */
       evrp_range_analyzer.record_ranges_from_stmt (gsi_stmt (gsi), false);
-      taken_edge = this->optimize_stmt (bb, gsi);
+      bool removed_p = false;
+      taken_edge = this->optimize_stmt (bb, &gsi, &removed_p);
+      if (!removed_p)
+	gimple_set_visited (gsi_stmt (gsi), true);
+
+      /* Go back and visit stmts inserted by folding after substituting
+	 into the stmt at gsi.  */
+      if (gsi_end_p (gsi))
+	{
+	  gcc_checking_assert (removed_p);
+	  gsi = gsi_last_bb (bb);
+	  while (!gsi_end_p (gsi) && !gimple_visited_p (gsi_stmt (gsi)))
+	    gsi_prev (&gsi);
+	}
+      else
+	{
+	  do
+	    {
+	      gsi_prev (&gsi);
+	    }
+	  while (!gsi_end_p (gsi) && !gimple_visited_p (gsi_stmt (gsi)));
+	}
+      if (gsi_end_p (gsi))
+	gsi = gsi_start_bb (bb);
+      else
+	gsi_next (&gsi);
     }
 
   /* Now prepare to process dominated blocks.  */
@@ -1905,7 +1961,8 @@
       condition to an equality condition.  */
 
 edge
-dom_opt_dom_walker::optimize_stmt (basic_block bb, gimple_stmt_iterator si)
+dom_opt_dom_walker::optimize_stmt (basic_block bb, gimple_stmt_iterator *si,
+				   bool *removed_p)
 {
   gimple *stmt, *old_stmt;
   bool may_optimize_p;
@@ -1913,7 +1970,7 @@
   bool was_noreturn;
   edge retval = NULL;
 
-  old_stmt = stmt = gsi_stmt (si);
+  old_stmt = stmt = gsi_stmt (*si);
   was_noreturn = is_gimple_call (stmt) && gimple_call_noreturn_p (stmt);
 
   if (dump_file && (dump_flags & TDF_DETAILS))
@@ -1936,9 +1993,9 @@
 
       /* Try to fold the statement making sure that STMT is kept
 	 up to date.  */
-      if (fold_stmt (&si))
+      if (fold_stmt (si))
 	{
-	  stmt = gsi_stmt (si);
+	  stmt = gsi_stmt (*si);
 	  gimple_set_modified (stmt, true);
 
 	  if (dump_file && (dump_flags & TDF_DETAILS))
@@ -1987,8 +2044,8 @@
 	      && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL
 	      && DECL_FUNCTION_CODE (callee) == BUILT_IN_CONSTANT_P)
 	    {
-	      propagate_tree_value_into_stmt (&si, integer_zero_node);
-	      stmt = gsi_stmt (si);
+	      propagate_tree_value_into_stmt (si, integer_zero_node);
+	      stmt = gsi_stmt (*si);
 	    }
 	}
 
@@ -2044,9 +2101,9 @@
 	}
 
       update_stmt_if_modified (stmt);
-      eliminate_redundant_computations (&si, m_const_and_copies,
+      eliminate_redundant_computations (si, m_const_and_copies,
 					m_avail_exprs_stack);
-      stmt = gsi_stmt (si);
+      stmt = gsi_stmt (*si);
 
       /* Perform simple redundant store elimination.  */
       if (gimple_assign_single_p (stmt)
@@ -2073,7 +2130,7 @@
 	    {
 	      basic_block bb = gimple_bb (stmt);
 	      unlink_stmt_vdef (stmt);
-	      if (gsi_remove (&si, true))
+	      if (gsi_remove (si, true))
 		{
 		  bitmap_set_bit (need_eh_cleanup, bb->index);
 		  if (dump_file && (dump_flags & TDF_DETAILS))
@@ -2080,6 +2137,7 @@
 		    fprintf (dump_file, "  Flagged to clear EH edges.\n");
 		}
 	      release_defs (stmt);
+	      *removed_p = true;
 	      return retval;
 	    }
 	}
Index: gcc/xcoffout.h
===================================================================
diff --git a/gcc/xcoffout.h b/gcc/xcoffout.h
--- a/gcc/xcoffout.h	(revision 278653)
+++ b/gcc/xcoffout.h	(revision 278653)
@@ -127,6 +127,7 @@
 
 extern char *xcoff_bss_section_name;
 extern char *xcoff_private_data_section_name;
+extern char *xcoff_private_rodata_section_name;
 extern char *xcoff_tls_data_section_name;
 extern char *xcoff_tbss_section_name;
 extern char *xcoff_read_only_section_name;
Index: gcc/gimple-ssa-warn-restrict.c
===================================================================
diff --git a/gcc/gimple-ssa-warn-restrict.c b/gcc/gimple-ssa-warn-restrict.c
--- a/gcc/gimple-ssa-warn-restrict.c	(revision 278653)
+++ b/gcc/gimple-ssa-warn-restrict.c	(revision 278653)
@@ -314,13 +314,9 @@
 	  offrange[0] += offset_int::from (min, SIGNED);
 	  offrange[1] += offset_int::from (max, SIGNED);
 	}
-      else if (rng == VR_ANTI_RANGE)
-	{
-	  offrange[0] += offset_int::from (max + 1, SIGNED);
-	  offrange[1] += offset_int::from (min - 1, SIGNED);
-	}
       else
 	{
+	  /* Handle an anti-range the same as no range at all.  */
 	  gimple *stmt = SSA_NAME_DEF_STMT (offset);
 	  tree type;
 	  if (is_gimple_assign (stmt)
@@ -702,6 +698,10 @@
   offset_int bounds[2] = { maxobjsize, maxobjsize };
   if (dstref->strbounded_p)
     {
+      unsigned nargs = gimple_call_num_args (call);
+      if (nargs <= sizeargno)
+	return;
+
       tree size = gimple_call_arg (call, sizeargno);
       tree range[2];
       if (get_size_range (size, range, true))
Index: gcc/lto-wrapper.c
===================================================================
diff --git a/gcc/lto-wrapper.c b/gcc/lto-wrapper.c
--- a/gcc/lto-wrapper.c	(revision 278653)
+++ b/gcc/lto-wrapper.c	(revision 278653)
@@ -1669,7 +1669,9 @@
 	  struct pex_obj *pex;
 	  char jobs[32];
 
-	  fprintf (mstream, "all:");
+	  fprintf (mstream,
+		   ".PHONY: all\n"
+		   "all:");
 	  for (i = 0; i < nr; ++i)
 	    {
 	      int j = ltrans_priorities[i*2 + 1];
Index: gcc/tree-ssa-sink.c
===================================================================
diff --git a/gcc/tree-ssa-sink.c b/gcc/tree-ssa-sink.c
--- a/gcc/tree-ssa-sink.c	(revision 278653)
+++ b/gcc/tree-ssa-sink.c	(revision 278653)
@@ -229,7 +229,7 @@
       /* If result of comparsion is unknown, preffer EARLY_BB.
 	 Thus use !(...>=..) rather than (...<...)  */
       && !(best_bb->count.apply_scale (100, 1)
-	   > (early_bb->count.apply_scale (threshold, 1))))
+	   >= early_bb->count.apply_scale (threshold, 1)))
     return best_bb;
 
   /* No better block found, so return EARLY_BB, which happens to be the
@@ -439,7 +439,10 @@
 	  if (sinkbb == frombb)
 	    return false;
 
-	  *togsi = gsi_for_stmt (use);
+	  if (sinkbb == gimple_bb (use))
+	    *togsi = gsi_for_stmt (use);
+	  else
+	    *togsi = gsi_after_labels (sinkbb);
 
 	  return true;
 	}
Index: gcc/dwarf2out.c
===================================================================
diff --git a/gcc/dwarf2out.c b/gcc/dwarf2out.c
--- a/gcc/dwarf2out.c	(revision 278653)
+++ b/gcc/dwarf2out.c	(revision 278653)
@@ -2875,9 +2875,13 @@
    separate comdat sections since the linker will then be able to
    remove duplicates.  But not all tools support .debug_types sections
    yet.  For Dwarf V5 or higher .debug_types doesn't exist any more,
-   it is DW_UT_type unit type in .debug_info section.  */
+   it is DW_UT_type unit type in .debug_info section.  For late LTO
+   debug there should be almost no types emitted so avoid enabling
+   -fdebug-types-section there.  */
 
-#define use_debug_types (dwarf_version >= 4 && flag_debug_types_section)
+#define use_debug_types (dwarf_version >= 4 \
+			 && flag_debug_types_section \
+			 && !in_lto_p)
 
 /* Various DIE's use offsets relative to the beginning of the
    .debug_info section to refer to each other.  */
@@ -3713,7 +3717,7 @@
 static void output_die (dw_die_ref);
 static void output_compilation_unit_header (enum dwarf_unit_type);
 static void output_comp_unit (dw_die_ref, int, const unsigned char *);
-static void output_comdat_type_unit (comdat_type_node *);
+static void output_comdat_type_unit (comdat_type_node *, bool);
 static const char *dwarf2_name (tree, int);
 static void add_pubname (tree, dw_die_ref);
 static void add_enumerator_pubname (const char *, dw_die_ref);
@@ -9339,7 +9343,6 @@
 	  }
 	  break;
 	case dw_val_class_loc_list:
-	case dw_val_class_view_list:
 	  if (dwarf_split_debug_info && dwarf_version >= 5)
 	    {
 	      gcc_assert (AT_loc_list (a)->num_assigned);
@@ -9348,6 +9351,9 @@
           else
             size += DWARF_OFFSET_SIZE;
 	  break;
+	case dw_val_class_view_list:
+	  size += DWARF_OFFSET_SIZE;
+	  break;
 	case dw_val_class_range_list:
 	  if (value_format (a) == DW_FORM_rnglistx)
 	    {
@@ -9425,7 +9431,7 @@
 		 we use DW_FORM_ref_addr.  In DWARF2, DW_FORM_ref_addr
 		 is sized by target address length, whereas in DWARF3
 		 it's always sized as an offset.  */
-	      if (use_debug_types)
+	      if (AT_ref (a)->comdat_type_p)
 		size += DWARF_TYPE_SIGNATURE_SIZE;
 	      else if (dwarf_version == 2)
 		size += DWARF2_ADDR_SIZE;
@@ -9721,12 +9727,12 @@
 	  gcc_unreachable ();
 	}
     case dw_val_class_loc_list:
-    case dw_val_class_view_list:
       if (dwarf_split_debug_info
 	  && dwarf_version >= 5
 	  && AT_loc_list (a)->num_assigned)
 	return DW_FORM_loclistx;
       /* FALLTHRU */
+    case dw_val_class_view_list:
     case dw_val_class_range_list:
       /* For range lists in DWARF 5, use DW_FORM_rnglistx from .debug_info.dwo
 	 but in .debug_info use DW_FORM_sec_offset, which is shorter if we
@@ -9869,7 +9875,12 @@
       return DW_FORM_flag;
     case dw_val_class_die_ref:
       if (AT_ref_external (a))
-	return use_debug_types ? DW_FORM_ref_sig8 : DW_FORM_ref_addr;
+	{
+	  if (AT_ref (a)->comdat_type_p)
+	    return DW_FORM_ref_sig8;
+	  else
+	    return DW_FORM_ref_addr;
+	}
       else
 	return DW_FORM_ref;
     case dw_val_class_fde_ref:
@@ -11217,7 +11228,8 @@
 /* Output a comdat type unit DIE and its children.  */
 
 static void
-output_comdat_type_unit (comdat_type_node *node)
+output_comdat_type_unit (comdat_type_node *node,
+			 bool early_lto_debug ATTRIBUTE_UNUSED)
 {
   const char *secname;
   char *tmp;
@@ -11244,14 +11256,16 @@
   if (dwarf_version >= 5)
     {
       if (!dwarf_split_debug_info)
-	secname = ".debug_info";
+	secname = early_lto_debug ? DEBUG_LTO_INFO_SECTION : DEBUG_INFO_SECTION;
       else
-	secname = ".debug_info.dwo";
+	secname = (early_lto_debug
+		   ? DEBUG_LTO_DWO_INFO_SECTION : DEBUG_DWO_INFO_SECTION);
     }
   else if (!dwarf_split_debug_info)
-    secname = ".debug_types";
+    secname = early_lto_debug ? ".gnu.debuglto_.debug_types" : ".debug_types";
   else
-    secname = ".debug_types.dwo";
+    secname = (early_lto_debug
+	       ? ".gnu.debuglto_.debug_types.dwo" : ".debug_types.dwo");
 
   tmp = XALLOCAVEC (char, 4 + DWARF_TYPE_SIGNATURE_SIZE * 2);
   sprintf (tmp, dwarf_version >= 5 ? "wi." : "wt.");
@@ -17879,6 +17893,8 @@
 	case DW_OP_push_object_address:
 	case DW_OP_call_frame_cfa:
 	case DW_OP_GNU_variable_value:
+	case DW_OP_GNU_addr_index:
+	case DW_OP_GNU_const_index:
 	  ++frame_offset_;
 	  break;
 
@@ -19661,6 +19677,9 @@
 
     case HIGH:
     case CONST_FIXED:
+    case MINUS:
+    case SIGN_EXTEND:
+    case ZERO_EXTEND:
       return false;
 
     case MEM:
@@ -22202,19 +22221,18 @@
       /* If the contexts differ, we may not be talking about the same
 	 thing.
 	 ???  When in LTO the DIE parent is the "abstract" copy and the
-	 context_die is the specification "copy".  But this whole block
-	 should eventually be no longer needed.  */
-      if (parm_die && parm_die->die_parent != context_die && !in_lto_p)
+	 context_die is the specification "copy".  */
+      if (parm_die
+	  && parm_die->die_parent != context_die
+	  && (parm_die->die_parent->die_tag != DW_TAG_GNU_formal_parameter_pack
+	      || parm_die->die_parent->die_parent != context_die)
+	  && !in_lto_p)
 	{
-	  if (!DECL_ABSTRACT_P (node))
-	    {
-	      /* This can happen when creating an inlined instance, in
-		 which case we need to create a new DIE that will get
-		 annotated with DW_AT_abstract_origin.  */
-	      parm_die = NULL;
-	    }
-	  else
-	    gcc_unreachable ();
+	  gcc_assert (!DECL_ABSTRACT_P (node));
+	  /* This can happen when creating a concrete instance, in
+	     which case we need to create a new DIE that will get
+	     annotated with DW_AT_abstract_origin.  */
+	  parm_die = NULL;
 	}
 
       if (parm_die && parm_die->die_parent == NULL)
@@ -26573,17 +26591,13 @@
     {
       dw_die_ref die = lookup_decl_die (decl);
 
-      /* We may have to generate early debug late for LTO in case debug
+      /* We may have to generate full debug late for LTO in case debug
          was not enabled at compile-time or the target doesn't support
 	 the LTO early debug scheme.  */
       if (! die && in_lto_p)
+	dwarf2out_decl (decl);
+      else if (die)
 	{
-	  dwarf2out_decl (decl);
-	  die = lookup_decl_die (decl);
-	}
-
-      if (die)
-	{
 	  /* We get called via the symtab code invoking late_global_decl
 	     for symbols that are optimized out.
 
@@ -31398,7 +31412,7 @@
                          ? dl_section_ref
                          : debug_skeleton_line_section_label));
 
-      output_comdat_type_unit (ctnode);
+      output_comdat_type_unit (ctnode, false);
       *slot = ctnode;
     }
 
@@ -32039,7 +32053,7 @@
                          ? debug_line_section_label
                          : debug_skeleton_line_section_label));
 
-      output_comdat_type_unit (ctnode);
+      output_comdat_type_unit (ctnode, true);
       *slot = ctnode;
     }
 
Index: gcc/match.pd
===================================================================
diff --git a/gcc/match.pd b/gcc/match.pd
--- a/gcc/match.pd	(revision 278653)
+++ b/gcc/match.pd	(revision 278653)
@@ -2406,6 +2406,13 @@
 	       && TYPE_UNSIGNED (TREE_TYPE (@1)))))
    (view_convert @1)))
 
+/* Simplify a view-converted empty constructor.  */
+(simplify
+  (view_convert CONSTRUCTOR@0)
+  (if (TREE_CODE (@0) != SSA_NAME
+       && CONSTRUCTOR_NELTS (@0) == 0)
+   { build_zero_cst (type); }))
+
 /* Re-association barriers around constants and other re-association
    barriers can be removed.  */
 (simplify
Index: gcc/expr.c
===================================================================
diff --git a/gcc/expr.c b/gcc/expr.c
--- a/gcc/expr.c	(revision 278653)
+++ b/gcc/expr.c	(revision 278653)
@@ -5187,9 +5187,13 @@
 		}
 	      else
 		{
-		  rtx from_rtx
-		    = simplify_gen_subreg (to_mode, result,
-					   TYPE_MODE (TREE_TYPE (from)), 0);
+		  rtx from_rtx;
+		  if (MEM_P (result))
+		    from_rtx = change_address (result, to_mode, NULL_RTX);
+		  else
+		    from_rtx
+		      = simplify_gen_subreg (to_mode, result,
+					     TYPE_MODE (TREE_TYPE (from)), 0);
 		  if (from_rtx)
 		    {
 		      emit_move_insn (XEXP (to_rtx, 0),
@@ -5258,6 +5262,7 @@
 		MEM_VOLATILE_P (to_rtx) = 1;
 	    }
 
+	  gcc_checking_assert (known_ge (bitpos, 0));
 	  if (optimize_bitfield_assignment_op (bitsize, bitpos,
 					       bitregion_start, bitregion_end,
 					       mode1, to_rtx, to, from,
@@ -7115,6 +7120,7 @@
 	}
 
       /* Store the value in the bitfield.  */
+      gcc_assert (known_ge (bitpos, 0));
       store_bit_field (target, bitsize, bitpos,
 		       bitregion_start, bitregion_end,
 		       mode, temp, reverse);
@@ -10658,6 +10664,14 @@
 	mode2
 	  = CONSTANT_P (op0) ? TYPE_MODE (TREE_TYPE (tem)) : GET_MODE (op0);
 
+	/* Make sure bitpos is not negative, it can wreak havoc later.  */
+	if (maybe_lt (bitpos, 0))
+	  {
+	    gcc_checking_assert (offset == NULL_TREE);
+	    offset = size_int (bits_to_bytes_round_down (bitpos));
+	    bitpos = num_trailing_bits (bitpos);
+	  }
+
 	/* If we have either an offset, a BLKmode result, or a reference
 	   outside the underlying object, we must force it to memory.
 	   Such a case can occur in Ada if we have unchecked conversion
@@ -10906,6 +10920,7 @@
 		&& GET_MODE_CLASS (ext_mode) == MODE_INT)
 	      reversep = TYPE_REVERSE_STORAGE_ORDER (type);
 
+	    gcc_checking_assert (known_ge (bitpos, 0));
 	    op0 = extract_bit_field (op0, bitsize, bitpos, unsignedp,
 				     (modifier == EXPAND_STACK_PARM
 				      ? NULL_RTX : target),
Index: gcc/opts.c
===================================================================
diff --git a/gcc/opts.c b/gcc/opts.c
--- a/gcc/opts.c	(revision 278653)
+++ b/gcc/opts.c	(revision 278653)
@@ -922,6 +922,14 @@
 		      "linker plugin");
 	  opts->x_flag_fat_lto_objects = 1;
 	}
+
+      /* -gsplit-dwarf isn't compatible with LTO, see PR88389.  */
+      if (opts->x_dwarf_split_debug_info)
+	{
+	  inform (loc, "%<-gsplit-dwarf%> is not supported with LTO,"
+		  " disabling");
+	  opts->x_dwarf_split_debug_info = 0;
+	}
     }
 
   /* We initialize opts->x_flag_split_stack to -1 so that targets can set a
Index: gcc/tree-ssa-loop-ivcanon.c
===================================================================
diff --git a/gcc/tree-ssa-loop-ivcanon.c b/gcc/tree-ssa-loop-ivcanon.c
--- a/gcc/tree-ssa-loop-ivcanon.c	(revision 278653)
+++ b/gcc/tree-ssa-loop-ivcanon.c	(revision 278653)
@@ -1177,7 +1177,7 @@
 	= niter_desc.may_be_zero && !integer_zerop (niter_desc.may_be_zero);
     }
   if (TREE_CODE (niter) == INTEGER_CST)
-    locus = gimple_location (last_stmt (exit->src));
+    locus = gimple_location_safe (last_stmt (exit->src));
   else
     {
       /* For non-constant niter fold may_be_zero into niter again.  */
@@ -1204,7 +1204,7 @@
 	niter = find_loop_niter_by_eval (loop, &exit);
 
       if (exit)
-        locus = gimple_location (last_stmt (exit->src));
+        locus = gimple_location_safe (last_stmt (exit->src));
 
       if (TREE_CODE (niter) != INTEGER_CST)
 	exit = NULL;
Index: gcc/recog.c
===================================================================
diff --git a/gcc/recog.c b/gcc/recog.c
--- a/gcc/recog.c	(revision 278653)
+++ b/gcc/recog.c	(revision 278653)
@@ -1070,6 +1070,11 @@
 int
 address_operand (rtx op, machine_mode mode)
 {
+  /* Wrong mode for an address expr.  */
+  if (GET_MODE (op) != VOIDmode
+      && ! SCALAR_INT_MODE_P (GET_MODE (op)))
+    return false;
+
   return memory_address_p (mode, op);
 }
 
@@ -2695,10 +2700,13 @@
 		/* p is used for address_operands.  When we are called by
 		   gen_reload, no one will have checked that the address is
 		   strictly valid, i.e., that all pseudos requiring hard regs
-		   have gotten them.  */
-		if (strict <= 0
-		    || (strict_memory_address_p (recog_data.operand_mode[opno],
-						 op)))
+		   have gotten them.  We also want to make sure we have a
+		   valid mode.  */
+		if ((GET_MODE (op) == VOIDmode
+		     || SCALAR_INT_MODE_P (GET_MODE (op)))
+		    && (strict <= 0
+			|| (strict_memory_address_p
+			     (recog_data.operand_mode[opno], op))))
 		  win = 1;
 		break;
 
Index: gcc/ada/sem_spark.adb
===================================================================
diff --git a/gcc/ada/sem_spark.adb b/gcc/ada/sem_spark.adb
--- a/gcc/ada/sem_spark.adb	(revision 278653)
+++ b/gcc/ada/sem_spark.adb	(revision 278653)
@@ -971,7 +971,7 @@
 
       if Present (SPARK_Pragma (Defining_Entity (Body_N))) then
          if Get_SPARK_Mode_From_Annotation
-           (SPARK_Pragma (Defining_Entity (Body_N, False))) /= Opt.On
+           (SPARK_Pragma (Defining_Entity (Body_N))) /= Opt.On
          then
             return;
          end if;
@@ -2379,7 +2379,7 @@
       CorSp : Node_Id;
 
    begin
-      if Present (SPARK_Pragma (Defining_Entity (Pack, False))) then
+      if Present (SPARK_Pragma (Defining_Entity (Pack))) then
          if Get_SPARK_Mode_From_Annotation
            (SPARK_Pragma (Defining_Entity (Pack))) /= Opt.On
          then
Index: gcc/ada/libgnat/system-darwin-ppc.ads
===================================================================
diff --git a/gcc/ada/libgnat/system-darwin-ppc.ads b/gcc/ada/libgnat/system-darwin-ppc.ads
--- a/gcc/ada/libgnat/system-darwin-ppc.ads	(revision 278653)
+++ b/gcc/ada/libgnat/system-darwin-ppc.ads	(revision 278653)
@@ -158,7 +158,7 @@
    Preallocated_Stacks       : constant Boolean := False;
    Signed_Zeros              : constant Boolean := True;
    Stack_Check_Default       : constant Boolean := False;
-   Stack_Check_Probes        : constant Boolean := False;
+   Stack_Check_Probes        : constant Boolean := True;
    Stack_Check_Limits        : constant Boolean := False;
    Support_Aggregates        : constant Boolean := True;
    Support_Atomic_Primitives : constant Boolean := Word_Size = 64;
Index: gcc/ada/ChangeLog
===================================================================
diff --git a/gcc/ada/ChangeLog b/gcc/ada/ChangeLog
--- a/gcc/ada/ChangeLog	(revision 278653)
+++ b/gcc/ada/ChangeLog	(revision 278653)
@@ -1,3 +1,106 @@
+2019-10-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/91995
+	* sem_ch8.adb (Chain_Use_Clause): Remove second argument in calls
+	to Defining_Entity.
+	* sem_elab.adb (Find_Unit_Entity): Likewise.  Deal with N_Subunit
+	here in lieu of in Defining_Entity.
+	* sem_spark.adb (Check_Callable_Body): Likewise.
+	(Check_Package_Body): Likewise.
+	* sem_util.ads (Defining_Entity): Remove 2nd and 3th parameters.
+	* sem_util.adb (Defining_Entity): Remove 2nd and 3th parameters,
+	and adjust accordingly.  Deal with N_Compilation_Unit.
+
+2019-10-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (annotate_value) <INTEGER_CST>: Really test the
+	sign of the value when deciding to build a NEGATE_EXPR.
+	<PLUS_EXPR>: Remove redundant line.
+	<BIT_AND_EXPR>: Do the negation here.
+
+2019-09-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (Attribute_to_gnu): Test Can_Use_Internal_Rep
+	on the underlying type of the node.
+	(Call_to_gnu): Likewise with the type of the prefix.
+
+2019-09-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-07-02  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* libgnat/system-darwin-ppc.ads: Set Stack_Check_Probes True for
+	PPC Darwin.
+
+2019-08-05  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-30  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* gnatlink.adb (Link_Step): Push -shared-libgcc explicitly, when it
+	is the target default (unless overidden by the static flag).
+	When the user has put an instance of shared/static-libgcc do not push
+	a duplicate of this.
+
+2019-06-29  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity): Beep up comment on SAVED,
+	and tweak comment on the assertion about the scopes of Itypes.  Do not
+	skip the regular processing for Itypes that are E_Record_Subtype with
+	a Cloned_Subtype.  Get the Cloned_Subtype for every E_Record_Subtype
+	if the type is dummy and hasn't got its own freeze node.
+	<E_Record_Subtype>: Save again the DECL of the Cloned_Subtype, if any.
+	<E_Access_Subtype>: Save again the DECL of the equivalent type.
+	(Gigi_Equivalent_Type) <E_Access_Subtype>: New case.
+
+2019-06-29  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (mark_visited_r): Set TYPE_SIZES_GIMPLIFIED on
+	the main variant of a type, if any.
+
+2019-06-29  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (set_nonaliased_component_on_array_type): Add
+	missing guard for the presence of TYPE_CANONICAL.
+	(set_reverse_storage_order_on_array_type): Likewise.
+
+2019-06-17  Arnaud Charlet  <charlet@adacore.com>
+
+	PR ada/80590
+	* exp_ch9.adb (Expand_N_Delay_Relative_Statement): Swap the two
+	conditions to avoid a unnecessary exception propagation in the default
+	case.
+
+2019-05-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (walk_nesting_tree): New static function.
+	(finalize_nrv): Use it to walk the entire nesting tree.
+
+2019-05-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/utils.c (maybe_pad_type): Issue the warning for the
+	specific case of component types preferably.
+
+2019-05-27  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (Call_to_gnu): Use the unpadded type when
+	putting back an intermediate conversion the type of the actuals.
+
+2019-05-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gcc-interface/Makefile.in (install-gcc-specs): Use foreach.
+	Honor DESTDIR.
+
+2019-02-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/89349
+	Backport from mainline
+	2018-05-25  Arnaud Charlet  <charlet@adacore.com>
+
+	* osint.ads (Unknown_Attributes): No longer pretend this is a constant.
+	(No_File_Info_Cache): Initialize separately.
+	* osint.adb (No_File_Info_Cache): Update initializer.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: gcc/ada/gcc-interface/utils.c
===================================================================
diff --git a/gcc/ada/gcc-interface/utils.c b/gcc/ada/gcc-interface/utils.c
--- a/gcc/ada/gcc-interface/utils.c	(revision 278653)
+++ b/gcc/ada/gcc-interface/utils.c	(revision 278653)
@@ -1519,14 +1519,14 @@
 	 generated for some other corresponding source entity.  */
       if (Comes_From_Source (gnat_entity))
 	{
-	  if (Present (gnat_error_node))
+	  if (is_component_type)
+	    post_error_ne_tree ("component of& padded{ by ^ bits}?",
+				gnat_entity, gnat_entity,
+				size_diffop (size, orig_size));
+	  else if (Present (gnat_error_node))
 	    post_error_ne_tree ("{^ }bits of & unused?",
 				gnat_error_node, gnat_entity,
 				size_diffop (size, orig_size));
-	  else if (is_component_type)
-	    post_error_ne_tree ("component of& padded{ by ^ bits}?",
-				gnat_entity, gnat_entity,
-				size_diffop (size, orig_size));
 	}
     }
 
Index: gcc/ada/gcc-interface/Makefile.in
===================================================================
diff --git a/gcc/ada/gcc-interface/Makefile.in b/gcc/ada/gcc-interface/Makefile.in
--- a/gcc/ada/gcc-interface/Makefile.in	(revision 278653)
+++ b/gcc/ada/gcc-interface/Makefile.in	(revision 278653)
@@ -2285,9 +2285,8 @@
 install-gcc-specs:
 #	Install all the requested GCC spec files.
 
-	for f in $(GCC_SPEC_FILES); do \
-	    $(INSTALL_DATA_DATE) $(srcdir)/ada/$$f $(libsubdir)/; \
-	done
+	$(foreach f,$(GCC_SPEC_FILES), \
+	    $(INSTALL_DATA_DATE) $(srcdir)/ada/$(f) $(DESTDIR)$(libsubdir)/;)
 
 install-gnatlib: ../stamp-gnatlib-$(RTSDIR) install-gcc-specs
 	$(RMDIR) $(DESTDIR)$(ADA_RTL_OBJ_DIR)
Index: gcc/ada/gcc-interface/decl.c
===================================================================
diff --git a/gcc/ada/gcc-interface/decl.c b/gcc/ada/gcc-interface/decl.c
--- a/gcc/ada/gcc-interface/decl.c	(revision 278653)
+++ b/gcc/ada/gcc-interface/decl.c	(revision 278653)
@@ -295,7 +295,10 @@
   tree gnu_size = NULL_TREE;
   /* Contains the GCC name to be used for the GCC node.  */
   tree gnu_entity_name;
-  /* True if we have already saved gnu_decl as a GNAT association.  */
+  /* True if we have already saved gnu_decl as a GNAT association.  This can
+     also be used to purposely avoid making such an association but this use
+     case ought not to be applied to types because it can break the deferral
+     mechanism implemented for access types.  */
   bool saved = false;
   /* True if we incremented defer_incomplete_level.  */
   bool this_deferred = false;
@@ -312,14 +315,11 @@
 
   /* Since a use of an Itype is a definition, process it as such if it is in
      the main unit, except for E_Access_Subtype because it's actually a use
-     of its base type, and for E_Record_Subtype with cloned subtype because
-     it's actually a use of the cloned subtype, see below.  */
+     of its base type, see below.  */
   if (!definition
       && is_type
       && Is_Itype (gnat_entity)
-      && !(kind == E_Access_Subtype
-	   || (kind == E_Record_Subtype
-	       && Present (Cloned_Subtype (gnat_entity))))
+      && Ekind (gnat_entity) != E_Access_Subtype
       && !present_gnu_tree (gnat_entity)
       && In_Extended_Main_Code_Unit (gnat_entity))
     {
@@ -362,7 +362,7 @@
 	}
 
       /* This abort means the Itype has an incorrect scope, i.e. that its
-	 scope does not correspond to the subprogram it is declared in.  */
+	 scope does not correspond to the subprogram it is first used in.  */
       gcc_unreachable ();
     }
 
@@ -371,7 +371,9 @@
      In that case, we will abort below when we try to save a new GCC tree
      for this object.  We also need to handle the case of getting a dummy
      type when a Full_View exists but be careful so as not to trigger its
-     premature elaboration.  */
+     premature elaboration.  Likewise for a cloned subtype without its own
+     freeze node, which typically happens when a generic gets instantiated
+     on an incomplete or private type.  */
   if ((!definition || (is_type && imported_p))
       && present_gnu_tree (gnat_entity))
     {
@@ -385,11 +387,27 @@
 	      || No (Freeze_Node (Full_View (gnat_entity)))))
 	{
 	  gnu_decl
-	    = gnat_to_gnu_entity (Full_View (gnat_entity), NULL_TREE, false);
+	    = gnat_to_gnu_entity (Full_View (gnat_entity), NULL_TREE,
+				  false);
 	  save_gnu_tree (gnat_entity, NULL_TREE, false);
 	  save_gnu_tree (gnat_entity, gnu_decl, false);
 	}
 
+      if (TREE_CODE (gnu_decl) == TYPE_DECL
+	  && TYPE_IS_DUMMY_P (TREE_TYPE (gnu_decl))
+	  && Ekind (gnat_entity) == E_Record_Subtype
+	  && No (Freeze_Node (gnat_entity))
+	  && Present (Cloned_Subtype (gnat_entity))
+	  && (present_gnu_tree (Cloned_Subtype (gnat_entity))
+	      || No (Freeze_Node (Cloned_Subtype (gnat_entity)))))
+	{
+	  gnu_decl
+	    = gnat_to_gnu_entity (Cloned_Subtype (gnat_entity), NULL_TREE,
+				  false);
+	  save_gnu_tree (gnat_entity, NULL_TREE, false);
+	  save_gnu_tree (gnat_entity, gnu_decl, false);
+	}
+
       return gnu_decl;
     }
 
@@ -3367,13 +3385,13 @@
     case E_Record_Subtype:
       /* If Cloned_Subtype is Present it means this record subtype has
 	 identical layout to that type or subtype and we should use
-	 that GCC type for this one.  The front end guarantees that
+	 that GCC type for this one.  The front-end guarantees that
 	 the component list is shared.  */
       if (Present (Cloned_Subtype (gnat_entity)))
 	{
 	  gnu_decl = gnat_to_gnu_entity (Cloned_Subtype (gnat_entity),
 					 NULL_TREE, false);
-	  saved = true;
+	  maybe_present = true;
 	  break;
 	}
 
@@ -3787,8 +3805,8 @@
     case E_Access_Subtype:
       /* We treat this as identical to its base type; any constraint is
 	 meaningful only to the front-end.  */
-      gnu_decl = gnat_to_gnu_entity (Etype (gnat_entity), NULL_TREE, false);
-      saved = true;
+      gnu_decl = gnat_to_gnu_entity (gnat_equiv_type, NULL_TREE, false);
+      maybe_present = true;
 
       /* The designated subtype must be elaborated as well, if it does
 	 not have its own freeze node.  But designated subtypes created
@@ -4974,6 +4992,10 @@
 	gnat_equiv = Equivalent_Type (gnat_entity);
       break;
 
+    case E_Access_Subtype:
+      gnat_equiv = Etype (gnat_entity);
+      break;
+
     case E_Class_Wide_Type:
       gnat_equiv = Root_Type (gnat_entity);
       break;
@@ -6065,7 +6087,8 @@
 set_nonaliased_component_on_array_type (tree type)
 {
   TYPE_NONALIASED_COMPONENT (type) = 1;
-  TYPE_NONALIASED_COMPONENT (TYPE_CANONICAL (type)) = 1;
+  if (TYPE_CANONICAL (type))
+    TYPE_NONALIASED_COMPONENT (TYPE_CANONICAL (type)) = 1;
 }
 
 /* Set TYPE_REVERSE_STORAGE_ORDER on an array type built by means of
@@ -6075,7 +6098,8 @@
 set_reverse_storage_order_on_array_type (tree type)
 {
   TYPE_REVERSE_STORAGE_ORDER (type) = 1;
-  TYPE_REVERSE_STORAGE_ORDER (TYPE_CANONICAL (type)) = 1;
+  if (TYPE_CANONICAL (type))
+    TYPE_REVERSE_STORAGE_ORDER (TYPE_CANONICAL (type)) = 1;
 }
 
 /* Return true if DISCR1 and DISCR2 represent the same discriminant.  */
@@ -8083,9 +8107,8 @@
     {
     case INTEGER_CST:
       /* For negative values, build NEGATE_EXPR of the opposite.  Such values
-	 can appear for discriminants in expressions for variants.  Note that,
-	 sizetype being unsigned, we don't directly use tree_int_cst_sgn.  */
-      if (tree_int_cst_sign_bit (gnu_size))
+	 can appear for discriminants in expressions for variants.  */
+      if (tree_int_cst_sgn (gnu_size) < 0)
 	{
 	  tree t = wide_int_to_tree (sizetype, -wi::to_wide (gnu_size));
 	  tcode = Negate_Expr;
@@ -8163,9 +8186,8 @@
 	  && tree_int_cst_sign_bit (TREE_OPERAND (gnu_size, 1)))
 	{
 	  tcode = Minus_Expr;
-	  ops[0] = annotate_value (TREE_OPERAND (gnu_size, 0));
-	  wide_int op1 = -wi::to_wide (TREE_OPERAND (gnu_size, 1));
-	  ops[1] = annotate_value (wide_int_to_tree (sizetype, op1));
+	  wide_int wop1 = -wi::to_wide (TREE_OPERAND (gnu_size, 1));
+	  ops[1] = annotate_value (wide_int_to_tree (sizetype, wop1));
 	  break;
 	}
 
@@ -8206,9 +8228,9 @@
 	 Such values can appear in expressions with aligning patterns.  */
       if (TREE_CODE (TREE_OPERAND (gnu_size, 1)) == INTEGER_CST)
 	{
-	  wide_int op1 = wi::sext (wi::to_wide (TREE_OPERAND (gnu_size, 1)),
-				   TYPE_PRECISION (sizetype));
-	  ops[1] = annotate_value (wide_int_to_tree (sizetype, op1));
+	  wide_int wop1 = -wi::to_wide (TREE_OPERAND (gnu_size, 1));
+	  tree op1 = wide_int_to_tree (sizetype, wop1);
+	  ops[1] = annotate_value (build1 (NEGATE_EXPR, sizetype, op1));
 	}
       break;
 
Index: gcc/ada/gcc-interface/trans.c
===================================================================
diff --git a/gcc/ada/gcc-interface/trans.c b/gcc/ada/gcc-interface/trans.c
--- a/gcc/ada/gcc-interface/trans.c	(revision 278653)
+++ b/gcc/ada/gcc-interface/trans.c	(revision 278653)
@@ -1720,32 +1720,29 @@
       /* For other address attributes applied to a nested function,
 	 find an inner ADDR_EXPR and annotate it so that we can issue
 	 a useful warning with -Wtrampolines.  */
-      else if (TREE_CODE (TREE_TYPE (gnu_prefix)) == FUNCTION_TYPE)
+      else if (TREE_CODE (TREE_TYPE (gnu_prefix)) == FUNCTION_TYPE
+	       && (gnu_expr = remove_conversions (gnu_result, false))
+	       && TREE_CODE (gnu_expr) == ADDR_EXPR
+	       && decl_function_context (TREE_OPERAND (gnu_expr, 0)))
 	{
-	  gnu_expr = remove_conversions (gnu_result, false);
+	  set_expr_location_from_node (gnu_expr, gnat_node);
 
-	  if (TREE_CODE (gnu_expr) == ADDR_EXPR
-	      && decl_function_context (TREE_OPERAND (gnu_expr, 0)))
-	    {
-	      set_expr_location_from_node (gnu_expr, gnat_node);
+	  /* Also check the inlining status.  */
+	  check_inlining_for_nested_subprog (TREE_OPERAND (gnu_expr, 0));
 
-	      /* Also check the inlining status.  */
-	      check_inlining_for_nested_subprog (TREE_OPERAND (gnu_expr, 0));
+	  /* Moreover, for 'Access or 'Unrestricted_Access with non-
+	     foreign-compatible representation, mark the ADDR_EXPR so
+	     that we can build a descriptor instead of a trampoline.  */
+	  if ((attribute == Attr_Access
+	       || attribute == Attr_Unrestricted_Access)
+	      && targetm.calls.custom_function_descriptors > 0
+	      && Can_Use_Internal_Rep (Underlying_Type (Etype (gnat_node))))
+	    FUNC_ADDR_BY_DESCRIPTOR (gnu_expr) = 1;
 
-	      /* Moreover, for 'Access or 'Unrestricted_Access with non-
-		 foreign-compatible representation, mark the ADDR_EXPR so
-		 that we can build a descriptor instead of a trampoline.  */
-	      if ((attribute == Attr_Access
-		   || attribute == Attr_Unrestricted_Access)
-		  && targetm.calls.custom_function_descriptors > 0
-		  && Can_Use_Internal_Rep (Etype (gnat_node)))
-		FUNC_ADDR_BY_DESCRIPTOR (gnu_expr) = 1;
-
-	      /* Otherwise, we need to check that we are not violating the
-		 No_Implicit_Dynamic_Code restriction.  */
-	      else if (targetm.calls.custom_function_descriptors != 0)
-	        Check_Implicit_Dynamic_Code_Allowed (gnat_node);
-	    }
+	  /* Otherwise, we need to check that we are not violating the
+	     No_Implicit_Dynamic_Code restriction.  */
+	  else if (targetm.calls.custom_function_descriptors != 0)
+	    Check_Implicit_Dynamic_Code_Allowed (gnat_node);
 	}
       break;
 
@@ -3534,6 +3531,20 @@
   return NULL_TREE;
 }
 
+/* Apply FUNC to all the sub-trees of nested functions in NODE.  FUNC is called
+   with the DATA and the address of each sub-tree.  If FUNC returns a non-NULL
+   value, the traversal is stopped.  */
+
+static void
+walk_nesting_tree (struct cgraph_node *node, walk_tree_fn func, void *data)
+{
+  for (node = node->nested; node; node = node->next_nested)
+    {
+      walk_tree_without_duplicates (&DECL_SAVED_TREE (node->decl), func, data);
+      walk_nesting_tree (node, func, data);
+    }
+}
+
 /* Finalize the Named Return Value optimization for FNDECL.  The NRV bitmap
    contains the candidates for Named Return Value and OTHER is a list of
    the other return values.  GNAT_RET is a representative return node.  */
@@ -3541,7 +3552,6 @@
 static void
 finalize_nrv (tree fndecl, bitmap nrv, vec<tree, va_gc> *other, Node_Id gnat_ret)
 {
-  struct cgraph_node *node;
   struct nrv_data data;
   walk_tree_fn func;
   unsigned int i;
@@ -3562,10 +3572,7 @@
     return;
 
   /* Prune also the candidates that are referenced by nested functions.  */
-  node = cgraph_node::get_create (fndecl);
-  for (node = node->nested; node; node = node->next_nested)
-    walk_tree_without_duplicates (&DECL_SAVED_TREE (node->decl), prune_nrv_r,
-				  &data);
+  walk_nesting_tree (cgraph_node::get_create (fndecl), prune_nrv_r, &data);
   if (bitmap_empty_p (nrv))
     return;
 
@@ -4308,7 +4315,8 @@
       /* If the access type doesn't require foreign-compatible representation,
 	 be prepared for descriptors.  */
       if (targetm.calls.custom_function_descriptors > 0
-	  && Can_Use_Internal_Rep (Etype (Prefix (Name (gnat_node)))))
+	  && Can_Use_Internal_Rep
+	     (Underlying_Type (Etype (Prefix (Name (gnat_node))))))
 	by_descriptor = true;
     }
   else if (Nkind (Name (gnat_node)) == N_Attribute_Reference)
@@ -4575,7 +4583,7 @@
 	 since the parent is a procedure call, so put it back here.  Note that
 	 we might have a dummy type here if the actual is the dereference of a
 	 pointer to it, but that's OK if the formal is passed by reference.  */
-      tree gnu_actual_type = gnat_to_gnu_type (Etype (gnat_actual));
+      tree gnu_actual_type = get_unpadded_type (Etype (gnat_actual));
       if (TYPE_IS_DUMMY_P (gnu_actual_type))
 	gcc_assert (is_true_formal_parm && DECL_BY_REF_P (gnu_formal));
       else if (suppress_type_conversion
@@ -8167,8 +8175,9 @@
   else if (!TYPE_IS_DUMMY_P (t))
     TREE_VISITED (t) = 1;
 
+  /* The test in gimplify_type_sizes is on the main variant.  */
   if (TYPE_P (t))
-    TYPE_SIZES_GIMPLIFIED (t) = 1;
+    TYPE_SIZES_GIMPLIFIED (TYPE_MAIN_VARIANT (t)) = 1;
 
   return NULL_TREE;
 }
Index: gcc/ada/sem_util.adb
===================================================================
diff --git a/gcc/ada/sem_util.adb b/gcc/ada/sem_util.adb
--- a/gcc/ada/sem_util.adb	(revision 278653)
+++ b/gcc/ada/sem_util.adb	(revision 278653)
@@ -5714,11 +5714,7 @@
    -- Defining_Entity --
    ---------------------
 
-   function Defining_Entity
-     (N                  : Node_Id;
-      Empty_On_Errors    : Boolean := False;
-      Concurrent_Subunit : Boolean := False) return Entity_Id
-   is
+   function Defining_Entity (N : Node_Id) return Entity_Id is
    begin
       case Nkind (N) is
          when N_Abstract_Subprogram_Declaration
@@ -5769,25 +5765,12 @@
          =>
             return Defining_Identifier (N);
 
+         when N_Compilation_Unit =>
+            return Defining_Entity (Unit (N));
+
          when N_Subunit =>
-            declare
-               Bod      : constant Node_Id := Proper_Body (N);
-               Orig_Bod : constant Node_Id := Original_Node (Bod);
+            return Defining_Entity (Proper_Body (N));
 
-            begin
-               --  Retrieve the entity of the original protected or task body
-               --  if requested by the caller.
-
-               if Concurrent_Subunit
-                 and then Nkind (Bod) = N_Null_Statement
-                 and then Nkind_In (Orig_Bod, N_Protected_Body, N_Task_Body)
-               then
-                  return Defining_Entity (Orig_Bod);
-               else
-                  return Defining_Entity (Bod);
-               end if;
-            end;
-
          when N_Function_Instantiation
             | N_Function_Specification
             | N_Generic_Function_Renaming_Declaration
@@ -5812,14 +5795,10 @@
                --  can continue semantic analysis.
 
                elsif Nam = Error then
-                  if Empty_On_Errors then
-                     return Empty;
-                  else
-                     Err := Make_Temporary (Sloc (N), 'T');
-                     Set_Defining_Unit_Name (N, Err);
+                  Err := Make_Temporary (Sloc (N), 'T');
+                  Set_Defining_Unit_Name (N, Err);
 
-                     return Err;
-                  end if;
+                  return Err;
 
                --  If not an entity, get defining identifier
 
@@ -5834,11 +5813,7 @@
             return Entity (Identifier (N));
 
          when others =>
-            if Empty_On_Errors then
-               return Empty;
-            else
-               raise Program_Error;
-            end if;
+            raise Program_Error;
       end case;
    end Defining_Entity;
 
Index: gcc/ada/sem_util.ads
===================================================================
diff --git a/gcc/ada/sem_util.ads b/gcc/ada/sem_util.ads
--- a/gcc/ada/sem_util.ads	(revision 278653)
+++ b/gcc/ada/sem_util.ads	(revision 278653)
@@ -543,10 +543,7 @@
    --  in the case of a descendant of a generic formal type (returns Int'Last
    --  instead of 0).
 
-   function Defining_Entity
-     (N                  : Node_Id;
-      Empty_On_Errors    : Boolean := False;
-      Concurrent_Subunit : Boolean := False) return Entity_Id;
+   function Defining_Entity (N : Node_Id) return Entity_Id;
    --  Given a declaration N, returns the associated defining entity. If the
    --  declaration has a specification, the entity is obtained from the
    --  specification. If the declaration has a defining unit name, then the
@@ -557,22 +554,6 @@
    --  local entities declared during loop expansion. These entities need
    --  debugging information, generated through Qualify_Entity_Names, and
    --  the loop declaration must be placed in the table Name_Qualify_Units.
-   --
-   --  Set flag Empty_On_Error to change the behavior of this routine as
-   --  follows:
-   --
-   --    * True  - A declaration that lacks a defining entity returns Empty.
-   --      A node that does not allow for a defining entity returns Empty.
-   --
-   --    * False - A declaration that lacks a defining entity is given a new
-   --      internally generated entity which is subsequently returned. A node
-   --      that does not allow for a defining entity raises Program_Error.
-   --
-   --  The former semantics is appropriate for the back end; the latter
-   --  semantics is appropriate for the front end.
-   --
-   --  Set flag Concurrent_Subunit to handle rewritings of concurrent bodies
-   --  which act as subunits. Such bodies are generally rewritten as null.
 
    function Denotes_Discriminant
      (N                : Node_Id;
Index: gcc/ada/exp_ch9.adb
===================================================================
diff --git a/gcc/ada/exp_ch9.adb b/gcc/ada/exp_ch9.adb
--- a/gcc/ada/exp_ch9.adb	(revision 278653)
+++ b/gcc/ada/exp_ch9.adb	(revision 278653)
@@ -8144,18 +8144,17 @@
       Proc : Entity_Id;
 
    begin
-      --  Try to use System.Relative_Delays.Delay_For only if available. This
-      --  is the implementation used on restricted platforms when Ada.Calendar
-      --  is not available.
+      --  Try to use Ada.Calendar.Delays.Delay_For if available.
 
-      if RTE_Available (RO_RD_Delay_For) then
-         Proc := RTE (RO_RD_Delay_For);
+      if RTE_Available (RO_CA_Delay_For) then
+         Proc := RTE (RO_CA_Delay_For);
 
-      --  Otherwise, use Ada.Calendar.Delays.Delay_For and emit an error
-      --  message if not available.
+      --  Otherwise, use System.Relative_Delays.Delay_For and emit an error
+      --  message if not available. This is the implementation used on
+      --  restricted platforms when Ada.Calendar is not available.
 
       else
-         Proc := RTE (RO_CA_Delay_For);
+         Proc := RTE (RO_RD_Delay_For);
       end if;
 
       Rewrite (N,
Index: gcc/ada/gnatlink.adb
===================================================================
diff --git a/gcc/ada/gnatlink.adb b/gcc/ada/gnatlink.adb
--- a/gcc/ada/gnatlink.adb	(revision 278653)
+++ b/gcc/ada/gnatlink.adb	(revision 278653)
@@ -1882,6 +1882,7 @@
       Clean_Link_Option_Set : declare
          J                  : Natural;
          Shared_Libgcc_Seen : Boolean := False;
+         Static_Libgcc_Seen : Boolean := False;
 
       begin
          J := Linker_Options.First;
@@ -1903,7 +1904,7 @@
                end if;
             end if;
 
-            --  Remove duplicate -shared-libgcc switch
+            --  Remove duplicate -shared-libgcc switches
 
             if Linker_Options.Table (J).all = Shared_Libgcc_String then
                if Shared_Libgcc_Seen then
@@ -1917,6 +1918,20 @@
                end if;
             end if;
 
+            --  Remove duplicate -static-libgcc switches
+
+            if Linker_Options.Table (J).all = Static_Libgcc_String then
+               if Static_Libgcc_Seen then
+                  Linker_Options.Table (J .. Linker_Options.Last - 1) :=
+                    Linker_Options.Table (J + 1 .. Linker_Options.Last);
+                  Linker_Options.Decrement_Last;
+                  Num_Args := Num_Args - 1;
+
+               else
+                  Static_Libgcc_Seen := True;
+               end if;
+            end if;
+
             --  Here we just check for a canonical form that matches the
             --  pragma Linker_Options set in the NT runtime.
 
@@ -1948,14 +1963,27 @@
             --  libgcc, if gcc is not called with -shared-libgcc, call it
             --  with -static-libgcc, as there are some platforms where one
             --  of these two switches is compulsory to link.
+            --  Don't push extra switches if we already saw one.
 
             if Shared_Libgcc_Default = 'T'
               and then not Shared_Libgcc_Seen
+              and then not Static_Libgcc_Seen
             then
                Linker_Options.Increment_Last;
                Linker_Options.Table (Linker_Options.Last) := Static_Libgcc;
                Num_Args := Num_Args + 1;
             end if;
+
+            --  Likewise, the reverse.
+
+            if Shared_Libgcc_Default = 'H'
+              and then not Static_Libgcc_Seen
+              and then not Shared_Libgcc_Seen
+            then
+               Linker_Options.Increment_Last;
+               Linker_Options.Table (Linker_Options.Last) := Shared_Libgcc;
+               Num_Args := Num_Args + 1;
+            end if;
          end if;
       end Clean_Link_Option_Set;
 
Index: gcc/ada/osint.adb
===================================================================
diff --git a/gcc/ada/osint.adb b/gcc/ada/osint.adb
--- a/gcc/ada/osint.adb	(revision 278653)
+++ b/gcc/ada/osint.adb	(revision 278653)
@@ -250,8 +250,7 @@
       Attr : aliased File_Attributes;
    end record;
 
-   No_File_Info_Cache : constant File_Info_Cache :=
-                          (No_File, Unknown_Attributes);
+   No_File_Info_Cache : constant File_Info_Cache := (No_File, (others => 0));
 
    package File_Name_Hash_Table is new GNAT.HTable.Simple_HTable (
      Header_Num => File_Hash_Num,
Index: gcc/ada/osint.ads
===================================================================
diff --git a/gcc/ada/osint.ads b/gcc/ada/osint.ads
--- a/gcc/ada/osint.ads	(revision 278653)
+++ b/gcc/ada/osint.ads	(revision 278653)
@@ -255,10 +255,26 @@
    --  from the disk and then cached in the File_Attributes parameter (possibly
    --  along with other values).
 
-   type File_Attributes is private;
-   Unknown_Attributes : constant File_Attributes;
+   File_Attributes_Size : constant Natural := 32;
+   --  This should be big enough to fit a "struct file_attributes" on any
+   --  system. It doesn't cause any malfunction if it is too big (which avoids
+   --  the need for either mapping the struct exactly or importing the sizeof
+   --  from C, which would result in dynamic code). However, it does waste
+   --  space (e.g. when a component of this type appears in a record, if it is
+   --  unnecessarily large). Note: for runtime units, use System.OS_Constants.
+   --  SIZEOF_struct_file_attributes instead, which has the exact value.
+
+   type File_Attributes is
+     array (1 .. File_Attributes_Size)
+       of System.Storage_Elements.Storage_Element;
+   for File_Attributes'Alignment use Standard'Maximum_Alignment;
+
+   Unknown_Attributes : File_Attributes;
    --  A cache for various attributes for a file (length, accessibility,...)
-   --  This must be initialized to Unknown_Attributes prior to the first call.
+   --  Will be initialized properly at elaboration (for efficiency later on,
+   --  avoid function calls every time we want to reset the attributes) prior
+   --  to the first usage. We cannot make it constant since the compiler may
+   --  put it in a read-only section.
 
    function Is_Directory
      (Name : C_File_Name;
@@ -754,22 +770,4 @@
    --  detected, the file being written is deleted, and a fatal error is
    --  signalled.
 
-   File_Attributes_Size : constant Natural := 32;
-   --  This should be big enough to fit a "struct file_attributes" on any
-   --  system. It doesn't cause any malfunction if it is too big (which avoids
-   --  the need for either mapping the struct exactly or importing the sizeof
-   --  from C, which would result in dynamic code). However, it does waste
-   --  space (e.g. when a component of this type appears in a record, if it is
-   --  unnecessarily large). Note: for runtime units, use System.OS_Constants.
-   --  SIZEOF_struct_file_attributes instead, which has the exact value.
-
-   type File_Attributes is
-     array (1 .. File_Attributes_Size)
-       of System.Storage_Elements.Storage_Element;
-   for File_Attributes'Alignment use Standard'Maximum_Alignment;
-
-   Unknown_Attributes : constant File_Attributes := (others => 0);
-   --  Will be initialized properly at elaboration (for efficiency later on,
-   --  avoid function calls every time we want to reset the attributes).
-
 end Osint;
Index: gcc/ada/sem_ch8.adb
===================================================================
diff --git a/gcc/ada/sem_ch8.adb b/gcc/ada/sem_ch8.adb
--- a/gcc/ada/sem_ch8.adb	(revision 278653)
+++ b/gcc/ada/sem_ch8.adb	(revision 278653)
@@ -4259,9 +4259,7 @@
 
       --  Common case for compilation unit
 
-      elsif Defining_Entity (N               => Parent (N),
-                             Empty_On_Errors => True) = Current_Scope
-      then
+      elsif Defining_Entity (Parent (N)) = Current_Scope then
          null;
 
       else
@@ -4268,7 +4266,7 @@
          --  If declaration appears in some other scope, it must be in some
          --  parent unit when compiling a child.
 
-         Pack := Defining_Entity (Parent (N), Empty_On_Errors => True);
+         Pack := Defining_Entity (Parent (N));
 
          if not In_Open_Scopes (Pack) then
             null;
Index: gcc/ada/sem_elab.adb
===================================================================
diff --git a/gcc/ada/sem_elab.adb b/gcc/ada/sem_elab.adb
--- a/gcc/ada/sem_elab.adb	(revision 278653)
+++ b/gcc/ada/sem_elab.adb	(revision 278653)
@@ -5544,13 +5544,23 @@
                                    N_Procedure_Instantiation)
         and then Nkind (Context) = N_Compilation_Unit
       then
-         return
-           Related_Instance (Defining_Entity (N, Concurrent_Subunit => True));
+         return Related_Instance (Defining_Entity (N));
 
+      --  The unit denotes a concurrent body acting as a subunit. Such bodies
+      --  are generally rewritten into null statements. The proper entity is
+      --  that of the "original node".
+
+      elsif Nkind (N) = N_Subunit
+        and then Nkind (Proper_Body (N)) = N_Null_Statement
+        and then Nkind_In (Original_Node (Proper_Body (N)), N_Protected_Body,
+                                                            N_Task_Body)
+      then
+         return Defining_Entity (Original_Node (Proper_Body (N)));
+
       --  Otherwise the proper entity is the defining entity
 
       else
-         return Defining_Entity (N, Concurrent_Subunit => True);
+         return Defining_Entity (N);
       end if;
    end Find_Unit_Entity;
 
Index: gcc/tree-ssa-address.c
===================================================================
diff --git a/gcc/tree-ssa-address.c b/gcc/tree-ssa-address.c
--- a/gcc/tree-ssa-address.c	(revision 278653)
+++ b/gcc/tree-ssa-address.c	(revision 278653)
@@ -259,6 +259,20 @@
 	 ? expand_expr (addr->index, NULL_RTX, pointer_mode, EXPAND_NORMAL)
 	 : NULL_RTX);
 
+  /* addr->base could be an SSA_NAME that was set to a constant value.  The
+     call to expand_expr may expose that constant.  If so, fold the value
+     into OFF and clear BSE.  Otherwise we may later try to pull a mode from
+     BSE to generate a REG, which won't work with constants because they
+     are modeless.  */
+  if (bse && GET_CODE (bse) == CONST_INT)
+    {
+      if (off)
+	off = simplify_gen_binary (PLUS, pointer_mode, bse, off);
+      else
+	off = bse;
+      gcc_assert (GET_CODE (off) == CONST_INT);
+      bse = NULL_RTX;
+    }
   gen_addr_rtx (pointer_mode, sym, bse, idx, st, off, &address, NULL, NULL);
   if (pointer_mode != address_mode)
     address = convert_memory_address (address_mode, address);
Index: gcc/common/config/aarch64/aarch64-common.c
===================================================================
diff --git a/gcc/common/config/aarch64/aarch64-common.c b/gcc/common/config/aarch64/aarch64-common.c
--- a/gcc/common/config/aarch64/aarch64-common.c	(revision 278653)
+++ b/gcc/common/config/aarch64/aarch64-common.c	(revision 278653)
@@ -41,6 +41,8 @@
 
 #undef	TARGET_OPTION_OPTIMIZATION_TABLE
 #define TARGET_OPTION_OPTIMIZATION_TABLE aarch_option_optimization_table
+#undef TARGET_OPTION_INIT_STRUCT
+#define TARGET_OPTION_INIT_STRUCT aarch64_option_init_struct
 
 /* Set default optimization options.  */
 static const struct default_options aarch_option_optimization_table[] =
@@ -113,8 +115,6 @@
     }
 }
 
-struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;
-
 /* An ISA extension in the co-processor and main instruction set space.  */
 struct aarch64_option_extension
 {
@@ -122,17 +122,30 @@
   const unsigned long flag_canonical;
   const unsigned long flags_on;
   const unsigned long flags_off;
+  const bool is_synthetic;
 };
 
 /* ISA extensions in AArch64.  */
 static const struct aarch64_option_extension all_extensions[] =
 {
-#define AARCH64_OPT_EXTENSION(NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, Z) \
-  {NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF},
+#define AARCH64_OPT_EXTENSION(NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, \
+			      SYNTHETIC, Z) \
+  {NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, SYNTHETIC},
 #include "config/aarch64/aarch64-option-extensions.def"
-  {NULL, 0, 0, 0}
+  {NULL, 0, 0, 0, false}
 };
 
+/* A copy of the ISA extensions list for AArch64 sorted by the popcount of
+   bits and extension turned on.  Cached for efficiency.  */
+static struct aarch64_option_extension all_extensions_by_on[] =
+{
+#define AARCH64_OPT_EXTENSION(NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, \
+			      SYNTHETIC, Z) \
+  {NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, SYNTHETIC},
+#include "config/aarch64/aarch64-option-extensions.def"
+  {NULL, 0, 0, 0, false}
+};
+
 struct processor_name_to_arch
 {
   const std::string processor_name;
@@ -232,6 +245,76 @@
   return AARCH64_PARSE_OK;
 }
 
+/* Comparer to sort aarch64's feature extensions by population count. Largest
+   first.  */
+
+typedef const struct aarch64_option_extension opt_ext;
+
+int opt_ext_cmp (const void* a, const void* b)
+{
+  opt_ext *opt_a = (opt_ext *)a;
+  opt_ext *opt_b = (opt_ext *)b;
+
+  /* We consider the total set of bits an options turns on to be the union of
+     the singleton set containing the option itself and the set of options it
+     turns on as a dependency.  As an example +dotprod turns on FL_DOTPROD and
+     FL_SIMD.  As such the set of bits represented by this option is
+     {FL_DOTPROD, FL_SIMD}. */
+  unsigned long total_flags_a = opt_a->flag_canonical & opt_a->flags_on;
+  unsigned long total_flags_b = opt_b->flag_canonical & opt_b->flags_on;
+  int popcnt_a = popcount_hwi ((HOST_WIDE_INT)total_flags_a);
+  int popcnt_b = popcount_hwi ((HOST_WIDE_INT)total_flags_b);
+  int order = popcnt_b - popcnt_a;
+
+  /* If they have the same amount of bits set, give it a more
+     deterministic ordering by using the value of the bits themselves.  */
+  if (order == 0)
+    return total_flags_b - total_flags_a;
+
+  return order;
+}
+
+/* Implement TARGET_OPTION_INIT_STRUCT.  */
+
+static void
+aarch64_option_init_struct (struct gcc_options *opts ATTRIBUTE_UNUSED)
+{
+    /* Sort the extensions based on how many bits they set, order the larger
+       counts first.  We sort the list because this makes processing the
+       feature bits O(n) instead of O(n^2).  While n is small, the function
+       to calculate the feature strings is called on every options push,
+       pop and attribute change (arm_neon headers, lto etc all cause this to
+       happen quite frequently).  It is a trade-off between time and space and
+       so time won.  */
+    int n_extensions
+      = sizeof (all_extensions) / sizeof (struct aarch64_option_extension);
+    qsort (&all_extensions_by_on, n_extensions,
+	   sizeof (struct aarch64_option_extension), opt_ext_cmp);
+}
+
+/* Checks to see if enough bits from the option OPT are enabled in
+   ISA_FLAG_BITS to be able to replace the individual options with the
+   canonicalized version of the option.  This is done based on two rules:
+
+   1) Synthetic groups, such as +crypto we only care about the bits that are
+      turned on. e.g. +aes+sha2 can be replaced with +crypto.
+
+   2) Options that themselves have a bit, such as +rdma, in this case, all the
+      feature bits they turn on must be available and the bit for the option
+      itself must be.  In this case it's effectively a reduction rather than a
+      grouping. e.g. +fp+simd is not enough to turn on +rdma, for that you would
+      need +rdma+fp+simd which is reduced down to +rdma.
+*/
+
+static bool
+aarch64_contains_opt (unsigned long isa_flag_bits, opt_ext *opt)
+{
+  unsigned long flags_check
+    = opt->is_synthetic ? opt->flags_on : opt->flag_canonical;
+
+  return (isa_flag_bits & flags_check) == flags_check;
+}
+
 /* Return a string representation of ISA_FLAGS.  DEFAULT_ARCH_FLAGS
    gives the default set of flags which are implied by whatever -march
    we'd put out.  Our job is to figure out the minimal set of "+" and
@@ -245,27 +328,98 @@
   const struct aarch64_option_extension *opt = NULL;
   std::string outstr = "";
 
-  /* Pass one: Find all the things we need to turn on.  As a special case,
-     we always want to put out +crc if it is enabled.  */
-  for (opt = all_extensions; opt->name != NULL; opt++)
-    if ((isa_flags & opt->flag_canonical
-	 && !(default_arch_flags & opt->flag_canonical))
-	|| (default_arch_flags & opt->flag_canonical
-            && opt->flag_canonical == AARCH64_ISA_CRC))
-      {
-	outstr += "+";
-	outstr += opt->name;
-      }
+  unsigned long isa_flag_bits = isa_flags;
 
-  /* Pass two: Find all the things we need to turn off.  */
-  for (opt = all_extensions; opt->name != NULL; opt++)
-    if ((~isa_flags) & opt->flag_canonical
-	&& !((~default_arch_flags) & opt->flag_canonical))
+  /* Pass one: Minimize the search space by reducing the set of options
+     to the smallest set that still turns on the same features as before in
+     conjunction with the bits that are turned on by default for the selected
+     architecture.  */
+  for (opt = all_extensions_by_on; opt->name != NULL; opt++)
+    {
+      /* If the bit is on by default, then all the options it turns on are also
+	 on by default due to the transitive dependencies.
+
+         If the option is enabled explicitly in the set then we need to emit
+	 an option for it.  Since this list is sorted by extensions setting the
+	 largest number of featers first, we can be sure that nothing else will
+	 ever need to set the bits we already set.  Consider the following
+	 situation:
+
+	  Feat1 = A + B + C
+	  Feat2 = A + B
+	  Feat3 = A + D
+	  Feat4 = B + C
+	  Feat5 = C
+
+	The following results are expected:
+
+	  A + C = A + Feat5
+	  B + C = Feat4
+	  Feat4 + A = Feat1
+	  Feat2 + Feat5 = Feat1
+	  Feat1 + C = Feat1
+          Feat3 + Feat4 = Feat1 + D
+
+	This search assumes that all invidual feature bits are use visible,
+	in other words the user must be able to do +A, +B, +C and +D.  */
+      if (aarch64_contains_opt (isa_flag_bits | default_arch_flags, opt))
       {
-	outstr += "+no";
-	outstr += opt->name;
+	/* We remove all the dependent bits, to prevent them from being turned
+	   on twice.  This only works because we assume that all there are
+	   individual options to set all bits standalone.  */
+	isa_flag_bits &= ~opt->flags_on;
+	isa_flag_bits |= opt->flag_canonical;
       }
+    }
 
+   /* By toggling bits on and off, we may have set bits on that are already
+      enabled by default.  So we mask the default set out so we don't emit an
+      option for them.  Instead of checking for this each time during Pass One
+      we just mask all default bits away at the end.  */
+   isa_flag_bits &= ~default_arch_flags;
+
+   /* We now have the smallest set of features we need to process.  A subsequent
+      linear scan of the bits in isa_flag_bits will allow us to print the ext
+      names.  However as a special case if CRC was enabled before, always print
+      it.  This is required because some CPUs have an incorrect specification
+      in older assemblers.  Even though CRC should be the default for these
+      cases the -mcpu values won't turn it on.  */
+  if (isa_flags & AARCH64_ISA_CRC)
+    isa_flag_bits |= AARCH64_ISA_CRC;
+
+  /* Pass Two:
+     Print the option names that we're sure we must turn on.  These are only
+     optional extension names.  Mandatory ones have already been removed and
+     ones we explicitly want off have been too.  */
+  for (opt = all_extensions_by_on; opt->name != NULL; opt++)
+    {
+      if (isa_flag_bits & opt->flag_canonical)
+	{
+	  outstr += "+";
+	  outstr += opt->name;
+	}
+    }
+
+  /* Pass Three:
+     Print out a +no for any mandatory extension that we are
+     turning off.  By this point aarch64_parse_extension would have ensured
+     that any optional extensions are turned off.  The only things left are
+     things that can't be turned off usually, e.g. something that is on by
+     default because it's mandatory and we want it off.  For turning off bits
+     we don't guarantee the smallest set of flags, but instead just emit all
+     options the user has specified.
+
+     The assembler requires all +<opts> to be printed before +no<opts>.  */
+  for (opt = all_extensions_by_on; opt->name != NULL; opt++)
+    {
+      if ((~isa_flags) & opt->flag_canonical
+		&& !((~default_arch_flags) & opt->flag_canonical))
+	{
+	  outstr += "+no";
+	  outstr += opt->name;
+	}
+    }
+
   return outstr;
 }
 
@@ -345,5 +499,7 @@
   return aarch64_rewrite_selected_cpu (argv[argc - 1]);
 }
 
+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;
+
 #undef AARCH64_CPU_NAME_LENGTH
 
Index: gcc/dse.c
===================================================================
diff --git a/gcc/dse.c b/gcc/dse.c
--- a/gcc/dse.c	(revision 278653)
+++ b/gcc/dse.c	(revision 278653)
@@ -2515,10 +2515,13 @@
 		clear_rhs_from_active_local_stores ();
 	    }
 	}
-      else if (SIBLING_CALL_P (insn) && reload_completed)
+      else if (SIBLING_CALL_P (insn)
+	       && (reload_completed || HARD_FRAME_POINTER_IS_ARG_POINTER))
 	/* Arguments for a sibling call that are pushed to memory are passed
 	   using the incoming argument pointer of the current function.  After
-	   reload that might be (and likely is) frame pointer based.  */
+	   reload that might be (and likely is) frame pointer based.  And, if
+	   it is a frame pointer on the target, even before reload we need to
+	   kill frame pointer based stores.  */
 	add_wild_read (bb_info);
       else
 	/* Every other call, including pure functions, may read any memory
Index: gcc/tree-ssa-ifcombine.c
===================================================================
diff --git a/gcc/tree-ssa-ifcombine.c b/gcc/tree-ssa-ifcombine.c
--- a/gcc/tree-ssa-ifcombine.c	(revision 278653)
+++ b/gcc/tree-ssa-ifcombine.c	(revision 278653)
@@ -40,6 +40,7 @@
 #include "gimplify-me.h"
 #include "tree-cfg.h"
 #include "tree-ssa.h"
+#include "params.h"
 
 #ifndef LOGICAL_OP_NON_SHORT_CIRCUIT
 #define LOGICAL_OP_NON_SHORT_CIRCUIT \
@@ -556,7 +557,11 @@
 	{
 	  tree t1, t2;
 	  gimple_stmt_iterator gsi;
-	  if (!LOGICAL_OP_NON_SHORT_CIRCUIT || flag_sanitize_coverage)
+	  bool logical_op_non_short_circuit = LOGICAL_OP_NON_SHORT_CIRCUIT;
+	  if (PARAM_VALUE (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT) != -1)
+	    logical_op_non_short_circuit
+	      = PARAM_VALUE (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT);
+	  if (!logical_op_non_short_circuit || flag_sanitize_coverage)
 	    return false;
 	  /* Only do this optimization if the inner bb contains only the conditional. */
 	  if (!gsi_one_before_end_p (gsi_start_nondebug_after_labels_bb (inner_cond_bb)))
Index: gcc/lto-streamer-in.c
===================================================================
diff --git a/gcc/lto-streamer-in.c b/gcc/lto-streamer-in.c
--- a/gcc/lto-streamer-in.c	(revision 278653)
+++ b/gcc/lto-streamer-in.c	(revision 278653)
@@ -826,6 +826,7 @@
       /* Read OMP SIMD related info.  */
       loop->safelen = streamer_read_hwi (ib);
       loop->unroll = streamer_read_hwi (ib);
+      loop->owned_clique = streamer_read_hwi (ib);
       loop->dont_vectorize = streamer_read_hwi (ib);
       loop->force_vectorize = streamer_read_hwi (ib);
       loop->simduid = stream_read_tree (ib, data_in);
@@ -1131,6 +1132,14 @@
 		      ? !MAY_HAVE_DEBUG_MARKER_STMTS
 		      : !MAY_HAVE_DEBUG_BIND_STMTS))
 		remove = true;
+	      /* In case the linemap overflows locations can be dropped
+		 to zero.  Thus do not keep nonsensical inline entry markers
+		 we'd later ICE on.  */
+	      tree block;
+	      if (gimple_debug_inline_entry_p (stmt)
+		  && (block = gimple_block (stmt))
+		  && !inlined_function_outer_scope_p (block))
+		remove = true;
 	      if (is_gimple_call (stmt)
 		  && gimple_call_internal_p (stmt))
 		{
Index: gcc/fortran/interface.c
===================================================================
diff --git a/gcc/fortran/interface.c b/gcc/fortran/interface.c
--- a/gcc/fortran/interface.c	(revision 278653)
+++ b/gcc/fortran/interface.c	(revision 278653)
@@ -2941,9 +2941,11 @@
 
       if (f->sym == NULL)
 	{
+	  /* These errors have to be issued, otherwise an ICE can occur.
+	     See PR 78865.  */
 	  if (where)
-	    gfc_error ("Missing alternate return spec in subroutine call "
-		       "at %L", where);
+	    gfc_error_now ("Missing alternate return specifier in subroutine "
+			   "call at %L", where);
 	  return false;
 	}
 
@@ -2950,8 +2952,8 @@
       if (a->expr == NULL)
 	{
 	  if (where)
-	    gfc_error ("Unexpected alternate return spec in subroutine "
-		       "call at %L", where);
+	    gfc_error_now ("Unexpected alternate return specifier in "
+			   "subroutine call at %L", where);
 	  return false;
 	}
 
@@ -3655,6 +3657,7 @@
 	gfc_warning (OPT_Wimplicit_procedure,
 		     "Procedure %qs called at %L is not explicitly declared",
 		     sym->name, where);
+      gfc_find_proc_namespace (sym->ns)->implicit_interface_calls = 1;
     }
 
   if (sym->attr.if_source == IFSRC_UNKNOWN)
Index: gcc/fortran/trans-expr.c
===================================================================
diff --git a/gcc/fortran/trans-expr.c b/gcc/fortran/trans-expr.c
--- a/gcc/fortran/trans-expr.c	(revision 278653)
+++ b/gcc/fortran/trans-expr.c	(revision 278653)
@@ -352,7 +352,7 @@
    of refs following.  */
 
 gfc_expr *
-gfc_find_and_cut_at_last_class_ref (gfc_expr *e)
+gfc_find_and_cut_at_last_class_ref (gfc_expr *e, bool is_mold)
 {
   gfc_expr *base_expr;
   gfc_ref *ref, *class_ref, *tail = NULL, *array_ref;
@@ -394,7 +394,10 @@
       e->ref = NULL;
     }
 
-  base_expr = gfc_copy_expr (e);
+  if (is_mold)
+    base_expr = gfc_expr_to_initialize (e);
+  else
+    base_expr = gfc_copy_expr (e);
 
   /* Restore the original tail expression.  */
   if (class_ref)
@@ -3834,7 +3837,8 @@
 
 
 static void
-conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr)
+conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr,
+		   gfc_actual_arglist *actual_args)
 {
   tree tmp;
 
@@ -3852,7 +3856,7 @@
   else
     {
       if (!sym->backend_decl)
-	sym->backend_decl = gfc_get_extern_function_decl (sym);
+	sym->backend_decl = gfc_get_extern_function_decl (sym, actual_args);
 
       TREE_USED (sym->backend_decl) = 1;
 
@@ -6276,7 +6280,7 @@
 
   /* Generate the actual call.  */
   if (base_object == NULL_TREE)
-    conv_function_val (se, sym, expr);
+    conv_function_val (se, sym, expr, args);
   else
     conv_base_obj_fcn_val (se, base_object, expr);
 
@@ -8385,24 +8389,7 @@
     }
 }
 
-/* Indentify class valued proc_pointer assignments.  */
 
-static bool
-pointer_assignment_is_proc_pointer (gfc_expr * expr1, gfc_expr * expr2)
-{
-  gfc_ref * ref;
-
-  ref = expr1->ref;
-  while (ref && ref->next)
-     ref = ref->next;
-
-  return ref && ref->type == REF_COMPONENT
-      && ref->u.c.component->attr.proc_pointer
-      && expr2->expr_type == EXPR_VARIABLE
-      && expr2->symtree->n.sym->attr.flavor == FL_PROCEDURE;
-}
-
-
 /* Do everything that is needed for a CLASS function expr2.  */
 
 static tree
@@ -8454,7 +8441,7 @@
   tree desc;
   tree tmp;
   tree expr1_vptr = NULL_TREE;
-  bool scalar, non_proc_pointer_assign;
+  bool scalar, non_proc_ptr_assign;
   gfc_ss *ss;
 
   gfc_start_block (&block);
@@ -8462,7 +8449,9 @@
   gfc_init_se (&lse, NULL);
 
   /* Usually testing whether this is not a proc pointer assignment.  */
-  non_proc_pointer_assign = !pointer_assignment_is_proc_pointer (expr1, expr2);
+  non_proc_ptr_assign = !(gfc_expr_attr (expr1).proc_pointer
+			&& expr2->expr_type == EXPR_VARIABLE
+			&& expr2->symtree->n.sym->attr.flavor == FL_PROCEDURE);
 
   /* Check whether the expression is a scalar or not; we cannot use
      expr1->rank as it can be nonzero for proc pointers.  */
@@ -8472,7 +8461,7 @@
     gfc_free_ss_chain (ss);
 
   if (expr1->ts.type == BT_DERIVED && expr2->ts.type == BT_CLASS
-      && expr2->expr_type != EXPR_FUNCTION && non_proc_pointer_assign)
+      && expr2->expr_type != EXPR_FUNCTION && non_proc_ptr_assign)
     {
       gfc_add_data_component (expr2);
       /* The following is required as gfc_add_data_component doesn't
@@ -8492,7 +8481,7 @@
       else
 	gfc_conv_expr (&rse, expr2);
 
-      if (non_proc_pointer_assign && expr1->ts.type == BT_CLASS)
+      if (non_proc_ptr_assign && expr1->ts.type == BT_CLASS)
 	{
 	  trans_class_vptr_len_assignment (&block, expr1, expr2, &rse, NULL,
 					   NULL);
Index: gcc/fortran/trans-array.c
===================================================================
diff --git a/gcc/fortran/trans-array.c b/gcc/fortran/trans-array.c
--- a/gcc/fortran/trans-array.c	(revision 278653)
+++ b/gcc/fortran/trans-array.c	(revision 278653)
@@ -1164,6 +1164,7 @@
   tree nelem;
   tree cond;
   tree or_expr;
+  tree elemsize;
   tree class_expr = NULL_TREE;
   int n, dim, tmp_dim;
   int total_dim = 0;
@@ -1329,10 +1330,15 @@
 	}
     }
 
+  if (class_expr == NULL_TREE)
+    elemsize = fold_convert (gfc_array_index_type,
+			     TYPE_SIZE_UNIT (gfc_get_element_type (type)));
+  else
+    elemsize = gfc_class_vtab_size_get (class_expr);
+
   /* Get the size of the array.  */
   if (size && !callee_alloc)
     {
-      tree elemsize;
       /* If or_expr is true, then the extent in at least one
 	 dimension is zero and the size is set to zero.  */
       size = fold_build3_loc (input_location, COND_EXPR, gfc_array_index_type,
@@ -1339,11 +1345,6 @@
 			      or_expr, gfc_index_zero_node, size);
 
       nelem = size;
-      if (class_expr == NULL_TREE)
-	elemsize = fold_convert (gfc_array_index_type,
-			TYPE_SIZE_UNIT (gfc_get_element_type (type)));
-      else
-	elemsize = gfc_class_vtab_size_get (class_expr);
 
       size = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,
 			      size, elemsize);
@@ -1354,6 +1355,10 @@
       size = NULL_TREE;
     }
 
+  /* Set the span.  */
+  tmp = fold_convert (gfc_array_index_type, elemsize);
+  gfc_conv_descriptor_span_set (pre, desc, tmp);
+
   gfc_trans_allocate_array_storage (pre, post, info, size, nelem, initial,
 				    dynamic, dealloc);
 
@@ -2652,6 +2657,9 @@
   if (ss_info->type != GFC_SS_REFERENCE)
     return false;
 
+  if (ss_info->data.scalar.needs_temporary)
+    return false;
+
   /* If the actual argument can be absent (in other words, it can
      be a NULL reference), don't try to evaluate it; pass instead
      the reference directly.  */
@@ -3414,10 +3422,8 @@
   if (build_class_array_ref (se, base, index))
     return;
 
-  if (expr && ((is_subref_array (expr)
-		&& GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (info->descriptor)))
-	       || (expr->ts.deferred && (expr->expr_type == EXPR_VARIABLE
-					 || expr->expr_type == EXPR_FUNCTION))))
+  if (expr && (expr->ts.deferred && (expr->expr_type == EXPR_VARIABLE
+				     || expr->expr_type == EXPR_FUNCTION)))
     decl = expr->symtree->n.sym->backend_decl;
 
   /* A pointer array component can be detected from its field decl. Fix
@@ -9527,9 +9533,15 @@
   if (sym->ts.type == BT_CLASS
       && !sym->attr.associate_var
       && CLASS_DATA (sym)->attr.allocatable
-      && expr->ref && expr->ref->type == REF_COMPONENT
-      && strcmp (expr->ref->u.c.component->name, "_data") == 0
-      && expr->ref->next == NULL)
+      && expr->ref
+      && ((expr->ref->type == REF_ARRAY && expr->ref->u.ar.type == AR_FULL
+	   && expr->ref->next == NULL)
+	  || (expr->ref->type == REF_COMPONENT
+	      && strcmp (expr->ref->u.c.component->name, "_data") == 0
+	      && (expr->ref->next == NULL
+		  || (expr->ref->next->type == REF_ARRAY
+		      && expr->ref->next->u.ar.type == AR_FULL
+		      && expr->ref->next->next == NULL)))))
     return true;
 
   /* An allocatable variable.  */
@@ -10350,6 +10362,8 @@
 {
   gfc_ref *ref;
 
+  gfc_fix_class_refs (expr);
+
   for (ref = expr->ref; ref; ref = ref->next)
     if (ref->type == REF_ARRAY && ref->u.ar.type != AR_ELEMENT)
       break;
Index: gcc/fortran/symbol.c
===================================================================
diff --git a/gcc/fortran/symbol.c b/gcc/fortran/symbol.c
--- a/gcc/fortran/symbol.c	(revision 278653)
+++ b/gcc/fortran/symbol.c	(revision 278653)
@@ -522,7 +522,7 @@
   /* The copying of procedure dummy arguments for module procedures in
      a submodule occur whilst the current state is COMP_CONTAINS. It
      is necessary, therefore, to let this through.  */
-  if (attr->dummy
+  if (name && attr->dummy
       && (attr->function || attr->subroutine)
       && gfc_current_state () == COMP_CONTAINS
       && !(gfc_new_block && gfc_new_block->abr_modproc_decl))
@@ -554,6 +554,7 @@
 
   conf (external, intrinsic);
   conf (entry, intrinsic);
+  conf (abstract, intrinsic);
 
   if ((attr->if_source == IFSRC_DECL && !attr->procedure) || attr->contained)
     conf (external, subroutine);
@@ -1685,7 +1686,15 @@
     return false;
 
   attr->subroutine = 1;
-  return check_conflict (attr, name, where);
+
+  /* If we are looking at a BLOCK DATA statement and we encounter a
+     name with a leading underscore (which must be
+     compiler-generated), do not check. See PR 84394.  */
+
+  if (name && *name != '_' && gfc_current_state () != COMP_BLOCK_DATA)
+    return check_conflict (attr, name, where);
+  else
+    return true;
 }
 
 
@@ -1801,7 +1810,8 @@
   if (where == NULL)
     where = &gfc_current_locus;
 
-  if (attr->proc != PROC_UNKNOWN && !attr->module_procedure)
+  if (attr->proc != PROC_UNKNOWN && !attr->module_procedure
+      && attr->access == ACCESS_UNKNOWN)
     {
       if (attr->proc == PROC_ST_FUNCTION && t == PROC_INTERNAL
 	  && !gfc_notification_std (GFC_STD_F2008))
@@ -4352,7 +4362,7 @@
 /* Get a global symbol, creating it if it doesn't exist.  */
 
 gfc_gsymbol *
-gfc_get_gsymbol (const char *name)
+gfc_get_gsymbol (const char *name, bool bind_c)
 {
   gfc_gsymbol *s;
 
@@ -4363,6 +4373,7 @@
   s = XCNEW (gfc_gsymbol);
   s->type = GSYM_UNKNOWN;
   s->name = gfc_get_string ("%s", name);
+  s->bind_c = bind_c;
 
   gfc_insert_bbt (&gfc_gsym_root, s, gsym_compare);
 
Index: gcc/fortran/class.c
===================================================================
diff --git a/gcc/fortran/class.c b/gcc/fortran/class.c
--- a/gcc/fortran/class.c	(revision 278653)
+++ b/gcc/fortran/class.c	(revision 278653)
@@ -561,7 +561,7 @@
    ref to the _len component.  */
 
 gfc_expr *
-gfc_get_len_component (gfc_expr *e)
+gfc_get_len_component (gfc_expr *e, int k)
 {
   gfc_expr *ptr;
   gfc_ref *ref, **last;
@@ -586,6 +586,14 @@
     }
   /* And replace if with a ref to the _len component.  */
   gfc_add_len_component (ptr);
+  if (k != ptr->ts.kind)
+    {
+      gfc_typespec ts;
+      gfc_clear_ts (&ts);
+      ts.type = BT_INTEGER;
+      ts.kind = k;
+      gfc_convert_type_warn (ptr, &ts, 2, 0);
+    }
   return ptr;
 }
 
@@ -899,6 +907,9 @@
   if (!comp_is_finalizable (comp))
     return;
 
+  if (comp->finalized)
+    return;
+
   e = gfc_copy_expr (expr);
   if (!e->ref)
     e->ref = ref = gfc_get_ref ();
@@ -1026,6 +1037,7 @@
 			    sub_ns);
       gfc_free_expr (e);
     }
+  comp->finalized = true;
 }
 
 
@@ -2661,6 +2673,7 @@
 	      gfc_namespace *sub_ns;
 	      gfc_namespace *contained;
 	      gfc_expr *e;
+	      size_t e_size;
 
 	      gfc_get_symbol (name, ns, &vtype);
 	      if (!gfc_add_flavor (&vtype->attr, FL_DERIVED, NULL,
@@ -2695,11 +2708,13 @@
 	      e = gfc_get_expr ();
 	      e->ts = *ts;
 	      e->expr_type = EXPR_VARIABLE;
+	      if (ts->type == BT_CHARACTER)
+		e_size = ts->kind;
+	      else
+		gfc_element_size (e, &e_size);
 	      c->initializer = gfc_get_int_expr (gfc_size_kind,
 						 NULL,
-						 ts->type == BT_CHARACTER
-						 ? ts->kind
-						 : gfc_element_size (e));
+						 e_size);
 	      gfc_free_expr (e);
 
 	      /* Add component _extends.  */
Index: gcc/fortran/decl.c
===================================================================
diff --git a/gcc/fortran/decl.c b/gcc/fortran/decl.c
--- a/gcc/fortran/decl.c	(revision 278653)
+++ b/gcc/fortran/decl.c	(revision 278653)
@@ -1678,6 +1678,14 @@
       free (expr->value.character.string);
       expr->value.character.string = s;
       expr->value.character.length = len;
+      /* If explicit representation was given, clear it
+	 as it is no longer needed after padding.  */
+      if (expr->representation.length)
+	{
+	  expr->representation.length = 0;
+	  free (expr->representation.string);
+	  expr->representation.string = NULL;
+	}
     }
 }
 
@@ -3891,7 +3899,6 @@
       return MATCH_YES;
     }
 
-
   m = gfc_match (" type (");
   matched_type = (m == MATCH_YES);
   if (matched_type)
@@ -3940,7 +3947,10 @@
 	m = MATCH_YES;
 
       if (matched_type && m == MATCH_YES && gfc_match_char (')') != MATCH_YES)
-	m = MATCH_ERROR;
+	{
+	  gfc_error ("Malformed type-spec at %C");
+	  return MATCH_ERROR;
+	}
 
       return m;
     }
@@ -3963,8 +3973,12 @@
 	  && !gfc_notify_std (GFC_STD_F2008, "TYPE with "
 			      "intrinsic-type-spec at %C"))
 	return MATCH_ERROR;
+
       if (matched_type && gfc_match_char (')') != MATCH_YES)
-	return MATCH_ERROR;
+	{
+	  gfc_error ("Malformed type-spec at %C");
+	  return MATCH_ERROR;
+	}
 
       ts->type = BT_REAL;
       ts->kind = gfc_default_double_kind;
@@ -3994,7 +4008,10 @@
 	return MATCH_ERROR;
 
       if (matched_type && gfc_match_char (')') != MATCH_YES)
-	return MATCH_ERROR;
+	{
+	  gfc_error ("Malformed type-spec at %C");
+	  return MATCH_ERROR;
+	}
 
       ts->type = BT_COMPLEX;
       ts->kind = gfc_default_double_kind;
@@ -4015,7 +4032,13 @@
       if (m == MATCH_ERROR)
 	return m;
 
-    m = gfc_match_char (')');
+      gfc_gobble_whitespace ();
+      if (gfc_peek_ascii_char () != ')')
+	{
+	  gfc_error ("Malformed type-spec at %C");
+	  return MATCH_ERROR;
+	}
+      m = gfc_match_char (')'); /* Burn closing ')'.  */
     }
 
   if (m != MATCH_YES)
@@ -7156,7 +7179,7 @@
      name is a global identifier.  */
   if (!binding_label || gfc_notification_std (GFC_STD_F2008))
     {
-      s = gfc_get_gsymbol (name);
+      s = gfc_get_gsymbol (name, false);
 
       if (s->defined || (s->type != GSYM_UNKNOWN && s->type != type))
 	{
@@ -7178,7 +7201,7 @@
       && (!gfc_notification_std (GFC_STD_F2008)
 	  || strcmp (name, binding_label) != 0))
     {
-      s = gfc_get_gsymbol (binding_label);
+      s = gfc_get_gsymbol (binding_label, true);
 
       if (s->defined || (s->type != GSYM_UNKNOWN && s->type != type))
 	{
Index: gcc/fortran/trans-openmp.c
===================================================================
diff --git a/gcc/fortran/trans-openmp.c b/gcc/fortran/trans-openmp.c
--- a/gcc/fortran/trans-openmp.c	(revision 278653)
+++ b/gcc/fortran/trans-openmp.c	(revision 278653)
@@ -548,6 +548,9 @@
 			     build3_loc (input_location, COND_EXPR,
 					 void_type_node, cond, then_b,
 					 else_b));
+      /* Avoid -W*uninitialized warnings.  */
+      if (DECL_P (decl))
+	TREE_NO_WARNING (decl) = 1;
     }
   else
     gfc_add_expr_to_block (&block, then_b);
@@ -654,6 +657,9 @@
   gfc_add_expr_to_block (&block,
 			 build3_loc (input_location, COND_EXPR,
 				     void_type_node, cond, then_b, else_b));
+  /* Avoid -W*uninitialized warnings.  */
+  if (DECL_P (dest))
+    TREE_NO_WARNING (dest) = 1;
 
   return gfc_finish_block (&block);
 }
Index: gcc/fortran/gfortran.h
===================================================================
diff --git a/gcc/fortran/gfortran.h b/gcc/fortran/gfortran.h
--- a/gcc/fortran/gfortran.h	(revision 278653)
+++ b/gcc/fortran/gfortran.h	(revision 278653)
@@ -1080,6 +1080,7 @@
   struct gfc_typebound_proc *tb;
   /* When allocatable/pointer and in a coarray the associated token.  */
   tree caf_token;
+  bool finalized;
 }
 gfc_component;
 
@@ -1856,6 +1857,9 @@
 
   /* Set to 1 for !$ACC ROUTINE namespaces.  */
   unsigned oacc_routine:1;
+
+  /* Set to 1 if there are any calls to procedures with implicit interface.  */
+  unsigned implicit_interface_calls:1;
 }
 gfc_namespace;
 
@@ -1883,6 +1887,7 @@
   enum gfc_symbol_type type;
 
   int defined, used;
+  bool bind_c;
   locus where;
   gfc_namespace *ns;
 }
@@ -3059,7 +3064,7 @@
 void gfc_free_dt_list (void);
 
 
-gfc_gsymbol *gfc_get_gsymbol (const char *);
+gfc_gsymbol *gfc_get_gsymbol (const char *, bool bind_c);
 gfc_gsymbol *gfc_find_gsymbol (gfc_gsymbol *, const char *);
 gfc_gsymbol *gfc_find_case_gsymbol (gfc_gsymbol *, const char *);
 
@@ -3426,7 +3431,7 @@
 bool gfc_is_class_container_ref (gfc_expr *e);
 gfc_expr *gfc_class_initializer (gfc_typespec *, gfc_expr *);
 unsigned int gfc_hash_value (gfc_symbol *);
-gfc_expr *gfc_get_len_component (gfc_expr *e);
+gfc_expr *gfc_get_len_component (gfc_expr *e, int);
 bool gfc_build_class_symbol (gfc_typespec *, symbol_attribute *,
 			     gfc_array_spec **);
 gfc_symbol *gfc_find_derived_vtab (gfc_symbol *);
Index: gcc/fortran/lang.opt
===================================================================
diff --git a/gcc/fortran/lang.opt b/gcc/fortran/lang.opt
--- a/gcc/fortran/lang.opt	(revision 278653)
+++ b/gcc/fortran/lang.opt	(revision 278653)
@@ -742,6 +742,13 @@
 Fortran Var(flag_sign_zero) Init(1)
 Apply negative sign to zero values.
 
+ftail-call-workaround
+Fortran Alias(ftail-call-workaround=,1,0)
+
+ftail-call-workaround=
+Fortran RejectNegative Joined UInteger IntegerRange(0, 2) Var(flag_tail_call_workaround) Init(1)
+Disallow tail call optimization when a calling routine may have omitted character lengths.
+
 funderscoring
 Fortran Var(flag_underscoring) Init(1)
 Append underscores to externally visible names.
Index: gcc/fortran/ChangeLog
===================================================================
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
--- a/gcc/fortran/ChangeLog	(revision 278653)
+++ b/gcc/fortran/ChangeLog	(revision 278653)
@@ -1,3 +1,426 @@
+2019-11-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/92113
+	* trans-decl.c (gfc_get_symbol_decl): If __def_init actually
+	contains a value, put it into  the read-only section.
+
+2019-10-27  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/86248
+	* resolve.c (flag_fn_result_spec): Correct a typo before the
+	function declaration.
+	* trans-decl.c (gfc_sym_identifier): Boost the length of 'name'
+	to allow for all variants. Simplify the code by using a pointer
+	to the symbol's proc_name and taking the return out of each of
+	the conditional branches. Allow symbols with fn_result_spec set
+	that do not come from a procedure namespace and have a module
+	name to go through the non-fn_result_spec branch.
+
+2019-10-18  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/69455
+	* trans-decl.c (generate_local_decl): Avoid misconstructed
+	intrinsic modules in a BLOCK construct.
+
+2019-10-07  Thomas Koenig <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84487
+	* trans-decl.c (gfc_get_symbol_decl): For __def_init, set
+	DECL_ARTIFICAL and do not set TREE_READONLY.
+
+2019-09-28  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/91588
+	* expr.c (check_inquiry): Remove extended component refs by
+	using symbol pointers. If a function argument is an associate
+	variable with a constant target, copy the target expression in
+	place of the argument expression. Check that the charlen is not
+	NULL before using the string length.
+
+2019-09-18  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91550
+	* frontend-passes.c (do_subscript): If step equals
+	zero, a previuos error has been reported; do nothing
+	in this case.
+	* resolve.c (gfc_resolve_iterator): Move error checking
+	after type conversion.
+
+2019-09-15  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91557
+	* trans-decl.c (generate_local_decl): Do not warn if the symbol
+	is artificial.
+	* trans-types.c (get_formal_from_actual_arglist): Set artificial
+	attribute on dummy arguments.
+
+2013-08-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90563
+	* frontend-passes.c (insert_index): Suppress errors while
+	simplifying the resulting expression.
+
+2019-08-02  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Paul Thomas <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90786
+	PR fortran/90813
+	* trans-expr.c (pointer_assignment_is_proc_pointer) Remove as
+	it is very simple and only called from one place.
+	(gfc_trans_pointer_assignment): Rename non_proc_pointer_assign
+	as non_proc_ptr_assign. Assign to it directly, rather than call
+	to above, deleted function and use gfc_expr_attr instead of
+	only checking the reference chain.
+	* trans-decl.c (sym_identifier): New function.
+	(mangled_identifier): New function, doing most of the work
+	of gfc_sym_mangled_identifier.
+	(gfc_sym_mangled_identifier): Use mangled_identifier.  Add mangled
+	identifier to global symbol table.
+	(get_proc_pointer_decl): Use backend decl from global identifier
+	if present.
+
+2019-07-07  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/91077
+	* trans-array.c (gfc_conv_scalarized_array_ref) Delete code
+	that gave symbol backend decl for subref arrays.
+
+2019-06-21  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90937
+	* trans-types.c (get_formal_from_actual_arglist): Get symbol from
+	current namespace so it will be freed later.  If symbol is of type
+	character, get an empty character length.
+
+2019-06-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Tomáš Trnka  <trnka@scm.com>
+
+	Backport from trunk
+	PR fortran/90744
+	* trans-types.c (get_formal_from_actual_arglist): Unset typespec
+	flags which make no sense for procedures without explicit
+	interface.
+
+2019-06-10  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/90498
+	* trans-stmt.c (trans_associate_var) Do not use the saved
+	descriptor if the expression is a COMPONENT_REF.
+
+2019-06-09  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/57284
+	* resolve.c (find_array_spec): If this is a class expression
+	and the symbol and component array specs are the same, this is
+	not an error.
+	*trans-intrinsic.c (gfc_conv_intrinsic_size): If a class symbol
+	argument, has no namespace, it has come from the interface
+	mapping and the _data component must be accessed directly.
+
+2019-05-30  Marek Polacek  <polacek@redhat.com>
+
+	* lang.opt (ftail-call-workaround): Fix a typo.
+
+2019-05-30  Jakub Jelinek  <jakub@redhat.com>
+
+	* lang.opt (ftail-call-workaround=): Fix a typo - lenghts to lengths.
+
+2019-05-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/90329
+	Backported from mainline
+	2019-05-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/90329
+	* lang.opt (fbroken-callers): Remove.
+	(ftail-call-workaround, ftail-call-workaround=): New options.
+	* gfortran.h (struct gfc_namespace): Add implicit_interface_calls.
+	* interface.c (gfc_procedure_use): Set implicit_interface_calls
+	for calls to implicit interface procedures.
+	* trans-decl.c (create_function_arglist): Use flag_tail_call_workaround
+	instead of flag_broken_callers.  If it is not 2, also require
+	sym->ns->implicit_interface_calls.
+	* invoke.texi (fbroken-callers): Remove documentation.
+	(ftail-call-workaround, ftail-call-workaround=): Document.
+
+	2019-05-19  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/90329
+	* invoke.texi: Document -fbroken-callers.
+	* lang.opt: Add -fbroken-callers.
+	* trans-decl.c (create_function_arglist): Only set
+	DECL_HIDDEN_STRING_LENGTH if flag_broken_callers is set.
+
+	2019-05-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/90329
+	* trans-decl.c (create_function_arglist): Set
+	DECL_HIDDEN_STRING_LENGTH on hidden string length PARM_DECLs if
+	len is constant.
+
+2019-04-30  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-03-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/89651
+	* trans-openmp.c (gfc_omp_clause_default_ctor): Set TREE_NO_WARNING
+	on decl if adding COND_EXPR for allocatable.
+	(gfc_omp_clause_copy_ctor): Set TREE_NO_WARNING on dest.
+
+2019-04-24  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from mainline
+	PR fortran/87127
+	* resolve.c (check_host_association): If an external function
+	is typed but not declared explicitly to be external, change the
+	old symbol from a variable to an external function.
+
+2019-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/87352
+	* gfortran.h (gfc_component): Add finalized field.
+	* class.c (finalize_component): If the component is already
+	finalized, return early.  Set component->finalized on exit.
+
+2019-04-14  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/89981
+	* resolve.c (resolve_global_procedure): If the global symbol is an
+	ENTRY, also look up its name among the entries.
+
+2019-04-10  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89904
+	* check.c (gfc_check_transfer): Reject procedures as actual
+	arguments for SOURCE and MOLD of TRANSFER intrinsic.
+
+2019-03-31  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/83515
+	PR fortran/85797
+	* trans-types.c (gfc_typenode_for_spec): Handle conversion for
+	procedure pointers.
+	* target-memory.c (gfc_element_size): Handle size determination
+	for procedure pointers.
+
+2019-03-30  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/78865
+	Backport from trunk
+	* interface.c (compare_actual_formal): Change errors about
+	missing or extra to gfc_error_now to make sure they are issued.
+	Change "spec" to "specifier" in message.
+	* resolve.c (resolve_global_procedure): Also check for mismatching
+	interface with global symbols if the namespace has already been
+	resolved.
+
+2019-03-24  Janus Weil  <janus@gcc.gnu.org>
+
+	PR fortran/71861
+	Backport from trunk
+	* symbol.c (check_conflict): ABSTRACT attribute conflicts with
+	INTRINSIC attribute.
+
+2019-03-23  Thomas Koenig  <tkoeng@gcc.gnu.org>
+
+	PR fortran/68009
+	Backport from trunk
+	* iresolve.c: Include trans.h.
+	(gfc_resolve_fe_runtine_error): Set backend_decl on
+	resolved_sym.
+
+2019-03-17  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/84394
+	Backport from trunk
+	* symbol.c (gfc_add_subroutine): If we are encountering a
+	subrtoutine within a BLOCK DATA and the name starts with an
+	underscore, do not check.
+
+2019-03-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66089
+	Backport from trunk
+	* trans-array.c (gfc_scalar_elemental_arg_saved_as_reference):
+	Return false if a scalar tempoary is needed.
+	(gfc_walk_variable_expr): Fix up class refs.
+
+2019-03-16  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/66695
+	PR fortran/77746
+	PR fortran/79485
+	Backport from trunk
+	* gfortran.h (gfc_symbol): Add bind_c component.
+	(gfc_get_gsymbol): Add argument bind_c.
+	* decl.c (add_global_entry): Add bind_c argument to
+	gfc_get_symbol.
+	* parse.c (parse_block_data): Likewise.
+	(parse_module): Likewise.
+	(add_global_procedure): Likewise.
+	(add_global_program): Likewise.
+	* resolve.c (resolve_common_blocks): Likewise.
+	(resolve_global_procedure): Likewise.
+	(gfc_verify_binding_labels): Likewise.
+	* symbol.c (gfc_get_gsymbol): Add argument bind_c. Set bind_c
+	in gsym.
+	* trans-decl.c (gfc_get_module_backend_decl): Add bind_c argument
+	to gfc_get_symbol.
+	(gfc_get_extern_function_decl): If the sym has a binding label
+	and it cannot be found in the global symbol tabel, it is the wrong
+	one and vice versa.
+
+2019-03-13  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87673
+	Backport from trunk
+	* match.c (gfc_match_type_spec): Remove call to
+	gfc_resolve_expr for character length.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71544
+	Backport from trunk
+	* trans-types.c (gfc_typenode_for_spec) Set ts->is_c_interop of
+	C_PTR and C_FUNPTR.
+	(create_fn_spec): Mark argument as escaping if ts->is_c_interop is set.
+
+2019-03-10  Thomas Koenig  <tkoenig@gcc.gnu.org>
+	Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/87734
+	Backort from trunk
+	* symbol.c (gfc_add_procedure): Only throw an error if the
+	procedure has not been declared either PUBLIC or PRIVATE.
+	* resolve.c (is_illegal_recursion): Remove an assert().
+
+2019-03-06  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/71203
+	* expr.c (simplify_const_ref): Avoid null pointer dereference.
+
+2019-03-06  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/72714
+	Backport from trunk
+	* resolve.c (resolve_allocate_expr): Add some tests for coarrays.
+
+2019-03-03  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89077
+	* decl.c (gfc_set_constant_character_len): Clear original string
+	representation after padding has been performed to target length.
+	* resolve.c (gfc_resolve_substring_charlen): Check substring
+	length for constantness prior to general calculation of length.
+
+2019-03-03  Harald Anlauf  <anlauf@gmx.de>
+	    Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/77583
+	* symbol.c (check_conflict): Check for valid procedure name
+	passed to error reporting routine.
+
+2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/89174
+	Backport from trunk
+	* trans-expr.c (gfc_find_and_cut_at_last_class_ref): Add is_mold
+	to garguments. If we are dealing with a MOLD, call
+	gfc_expr_to_initialize().
+	* trans-stmt.c (gfc_trans_allocate): For MOLD, pass is_mold=true
+	to gfc_find_and_cut_at_last_class_ref.
+	* trans.h (gfc_find_and_cut_at_last_class_ref): Add optional
+	argument is_mold with default false.
+
+2019-03-03  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/87689
+	Backport from trunk
+	* gfortran.dg/lto/20091028-1_0.f90: Add -Wno-lto-type-mismatch to
+	options.
+	* gfortran.dg/lto/20091028-2_0.f90: Likewise.
+	* gfortran.dg/lto/pr87689_0.f: New file.
+	* gfortran.dg/lto/pr87689_1.f: New file.
+	* gfortran.dg/altreturn_9_0.f90: New file.
+	* gfortran.dg/altreturn_9_1.f90: New file.
+
+2019-03-02  Jerry DeLisle <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84387
+	* trans-io.c (transfer_expr): Do not return if there are no
+	components to the derived type or class.
+
+2019-03-02  Harald Anlauf  <anlauf@gmx.de>
+
+	Backport from trunk
+	PR fortran/89516
+	* check.c (gfc_calculate_transfer_sizes): Correct checks for cases
+	where storage size of elements of MOLD is 0.
+
+	PR fortran/89492
+	* check.c (gfc_calculate_transfer_sizes): Handle cases where
+	storage size of elements of MOLD is 0.
+
+	PR fortran/89266
+	PR fortran/88326
+	* target-memory.c (gfc_element_size): Return false if element size
+	cannot be determined; element size is returned separately.
+	(gfc_target_expr_size): Return false if expression size cannot be
+	determined; expression size is returned separately.
+	* target-memory.h: Adjust prototypes.
+	* check.c (gfc_calculate_transfer_sizes): Adjust references to
+	gfc_target_expr_size, gfc_element_size.
+	* arith.c (hollerith2representation): Likewise.
+	* class.c (find_intrinsic_vtab): Likewise.
+	* simplify.c (gfc_simplify_sizeof): Likewise.
+
+2019-02-23  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/86119
+	Backport from trunk
+	* class.c (gfc_get_len_component): Add argument k for kind.
+	If the kind of the resulting expression is not equal to k,
+	convert it.
+	* gfortran.h (gfc_len_component): Adjust prototype.
+	* simplify.c (gfc_simplify_len): Pass kind to
+	gfc_get_len_component.
+
+2019-02-23  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/88117
+	* resolve.c (deferred_op_assign): Return if the lhs expression
+	has the pointer attribute.
+
+2019-02-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/71066
+	Backport from trunk
+	* trans-decl.c (generate_coarray_sym_init):  For an array
+	constructor in a DATA statement of a coarray variable, set the
+	rank to 1 to avoid confusion later on.  If the constructor
+	contains only one value, use that for initiailizig.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: gcc/fortran/trans-stmt.c
===================================================================
diff --git a/gcc/fortran/trans-stmt.c b/gcc/fortran/trans-stmt.c
--- a/gcc/fortran/trans-stmt.c	(revision 278653)
+++ b/gcc/fortran/trans-stmt.c	(revision 278653)
@@ -1842,7 +1842,8 @@
 	    {
 	      if (e->symtree
 		  && DECL_LANG_SPECIFIC (e->symtree->n.sym->backend_decl)
-		 && GFC_DECL_SAVED_DESCRIPTOR (e->symtree->n.sym->backend_decl))
+		  && GFC_DECL_SAVED_DESCRIPTOR (e->symtree->n.sym->backend_decl)
+		  && TREE_CODE (target_expr) != COMPONENT_REF)
 		/* Use the original class descriptor stored in the saved
 		   descriptor to get the target_expr.  */
 		target_expr =
@@ -6606,7 +6607,7 @@
 	  /* Use class_init_assign to initialize expr.  */
 	  gfc_code *ini;
 	  ini = gfc_get_code (EXEC_INIT_ASSIGN);
-	  ini->expr1 = gfc_find_and_cut_at_last_class_ref (expr);
+	  ini->expr1 = gfc_find_and_cut_at_last_class_ref (expr, true);
 	  tmp = gfc_trans_class_init_assign (ini);
 	  gfc_free_statements (ini);
 	  gfc_add_expr_to_block (&block, tmp);
Index: gcc/fortran/expr.c
===================================================================
diff --git a/gcc/fortran/expr.c b/gcc/fortran/expr.c
--- a/gcc/fortran/expr.c	(revision 278653)
+++ b/gcc/fortran/expr.c	(revision 278653)
@@ -1784,8 +1784,14 @@
 			string_len = 0;
 
 		      if (!p->ts.u.cl)
-			p->ts.u.cl = gfc_new_charlen (p->symtree->n.sym->ns,
-						      NULL);
+			{
+			  if (p->symtree)
+			    p->ts.u.cl = gfc_new_charlen (p->symtree->n.sym->ns,
+							  NULL);
+			  else
+			    p->ts.u.cl = gfc_new_charlen (gfc_current_ns,
+							  NULL);
+			}
 		      else
 			gfc_free_expr (p->ts.u.cl->length);
 
@@ -2390,6 +2396,8 @@
 
   int i = 0;
   gfc_actual_arglist *ap;
+  gfc_symbol *sym;
+  gfc_symbol *asym;
 
   if (!e->value.function.isym
       || !e->value.function.isym->inquiry)
@@ -2399,20 +2407,22 @@
   if (e->symtree == NULL)
     return MATCH_NO;
 
-  if (e->symtree->n.sym->from_intmod)
+  sym = e->symtree->n.sym;
+
+  if (sym->from_intmod)
     {
-      if (e->symtree->n.sym->from_intmod == INTMOD_ISO_FORTRAN_ENV
-	  && e->symtree->n.sym->intmod_sym_id != ISOFORTRAN_COMPILER_OPTIONS
-	  && e->symtree->n.sym->intmod_sym_id != ISOFORTRAN_COMPILER_VERSION)
+      if (sym->from_intmod == INTMOD_ISO_FORTRAN_ENV
+	  && sym->intmod_sym_id != ISOFORTRAN_COMPILER_OPTIONS
+	  && sym->intmod_sym_id != ISOFORTRAN_COMPILER_VERSION)
 	return MATCH_NO;
 
-      if (e->symtree->n.sym->from_intmod == INTMOD_ISO_C_BINDING
-	  && e->symtree->n.sym->intmod_sym_id != ISOCBINDING_C_SIZEOF)
+      if (sym->from_intmod == INTMOD_ISO_C_BINDING
+	  && sym->intmod_sym_id != ISOCBINDING_C_SIZEOF)
 	return MATCH_NO;
     }
   else
     {
-      name = e->symtree->n.sym->name;
+      name = sym->name;
 
       functions = (gfc_option.warn_std & GFC_STD_F2003)
 		? inquiry_func_f2003 : inquiry_func_f95;
@@ -2434,41 +2444,48 @@
       if (!ap->expr)
 	continue;
 
+      asym = ap->expr->symtree ? ap->expr->symtree->n.sym : NULL;
+
       if (ap->expr->ts.type == BT_UNKNOWN)
 	{
-	  if (ap->expr->symtree->n.sym->ts.type == BT_UNKNOWN
-	      && !gfc_set_default_type (ap->expr->symtree->n.sym, 0, gfc_current_ns))
+	  if (asym && asym->ts.type == BT_UNKNOWN
+	      && !gfc_set_default_type (asym, 0, gfc_current_ns))
 	    return MATCH_NO;
 
-	  ap->expr->ts = ap->expr->symtree->n.sym->ts;
+	  ap->expr->ts = asym->ts;
 	}
 
-	/* Assumed character length will not reduce to a constant expression
-	   with LEN, as required by the standard.  */
-	if (i == 5 && not_restricted && ap->expr->symtree
-	    && ap->expr->symtree->n.sym->ts.type == BT_CHARACTER
-	    && (ap->expr->symtree->n.sym->ts.u.cl->length == NULL
-		|| ap->expr->symtree->n.sym->ts.deferred))
-	  {
-	    gfc_error ("Assumed or deferred character length variable %qs "
-			"in constant expression at %L",
-			ap->expr->symtree->n.sym->name,
-			&ap->expr->where);
-	      return MATCH_ERROR;
-	  }
-	else if (not_restricted && !gfc_check_init_expr (ap->expr))
-	  return MATCH_ERROR;
+      if (asym && asym->assoc && asym->assoc->target
+	  && asym->assoc->target->expr_type == EXPR_CONSTANT)
+	{
+	  gfc_free_expr (ap->expr);
+	  ap->expr = gfc_copy_expr (asym->assoc->target);
+	}
 
-	if (not_restricted == 0
-	      && ap->expr->expr_type != EXPR_VARIABLE
-	      && !check_restricted (ap->expr))
+      /* Assumed character length will not reduce to a constant expression
+	 with LEN, as required by the standard.  */
+      if (i == 5 && not_restricted && asym
+	  && asym->ts.type == BT_CHARACTER
+	  && ((asym->ts.u.cl && asym->ts.u.cl->length == NULL)
+	      || asym->ts.deferred))
+	{
+	  gfc_error ("Assumed or deferred character length variable %qs "
+		     "in constant expression at %L",
+		      asym->name, &ap->expr->where);
 	  return MATCH_ERROR;
+	}
+      else if (not_restricted && !gfc_check_init_expr (ap->expr))
+	return MATCH_ERROR;
 
-	if (not_restricted == 0
-	    && ap->expr->expr_type == EXPR_VARIABLE
-	    && ap->expr->symtree->n.sym->attr.dummy
-	    && ap->expr->symtree->n.sym->attr.optional)
-	  return MATCH_NO;
+      if (not_restricted == 0
+	  && ap->expr->expr_type != EXPR_VARIABLE
+	  && !check_restricted (ap->expr))
+	return MATCH_ERROR;
+
+      if (not_restricted == 0
+	  && ap->expr->expr_type == EXPR_VARIABLE
+	  && asym->attr.dummy && asym->attr.optional)
+	return MATCH_NO;
     }
 
   return MATCH_YES;
Index: gcc/fortran/invoke.texi
===================================================================
diff --git a/gcc/fortran/invoke.texi b/gcc/fortran/invoke.texi
--- a/gcc/fortran/invoke.texi	(revision 278653)
+++ b/gcc/fortran/invoke.texi	(revision 278653)
@@ -181,7 +181,8 @@
 @item Code Generation Options
 @xref{Code Gen Options,,Options for code generation conventions}.
 @gccoptlist{-faggressive-function-elimination -fblas-matmul-limit=@var{n} @gol
--fbounds-check -fcheck-array-temporaries @gol
+-fbounds-check -ftail-call-workaround -ftail-call-workaround=@var{n} @gol
+-fcheck-array-temporaries @gol
 -fcheck=@var{<all|array-temps|bounds|do|mem|pointer|recursion>} @gol
 -fcoarray=@var{<none|single|lib>} -fexternal-blas -ff2c
 -ffrontend-loop-interchange @gol
@@ -1580,6 +1581,39 @@
 @c Note: This option is also referred in gcc's manpage
 Deprecated alias for @option{-fcheck=bounds}.
 
+@item -ftail-call-workaround
+@itemx -ftail-call-workaround=@var{n}
+@opindex @code{tail-call-workaround}
+Some C interfaces to Fortran codes violate the gfortran ABI by
+omitting the hidden character length arguments as described in
+@xref{Argument passing conventions}.  This can lead to crashes
+because pushing arguments for tail calls can overflow the stack.
+
+To provide a workaround for existing binary packages, this option
+disables tail call optimization for gfortran procedures with character
+arguments.  With @option{-ftail-call-workaround=2} tail call optimization
+is disabled in all gfortran procedures with character arguments,
+with @option{-ftail-call-workaround=1} or equivalent
+@option{-ftail-call-workaround} only in gfortran procedures with character
+arguments that call implicitly prototyped procedures.
+
+Using this option can lead to problems including crashes due to
+insufficient stack space.
+
+It is @emph{very strongly} recommended to fix the code in question.
+The @option{-fc-prototypes-external} option can be used to generate
+prototypes which conform to gfortran's ABI, for inclusion in the
+source code.
+
+Support for this option will likely be withdrawn in a future release
+of gfortran.
+
+The negative form, @option{-fno-tail-call-workaround} or equivalent
+@option{-ftail-call-workaround=0}, can be used to disable this option.
+
+Default is currently @option{-ftail-call-workaround}, this will change
+in future releases.
+
 @item -fcheck-array-temporaries
 @opindex @code{fcheck-array-temporaries}
 Deprecated alias for @option{-fcheck=array-temps}.
Index: gcc/fortran/trans-types.c
===================================================================
diff --git a/gcc/fortran/trans-types.c b/gcc/fortran/trans-types.c
--- a/gcc/fortran/trans-types.c	(revision 278653)
+++ b/gcc/fortran/trans-types.c	(revision 278653)
@@ -1213,7 +1213,8 @@
         {
           spec->type = BT_INTEGER;
           spec->kind = gfc_index_integer_kind;
-          spec->f90_type = BT_VOID;
+	  spec->f90_type = BT_VOID;
+	  spec->is_c_interop = 1;  /* Mark as escaping later.  */
         }
       break;
     case BT_VOID:
@@ -1230,6 +1231,9 @@
 	    basetype = pfunc_type_node;
 	}
        break;
+    case BT_PROCEDURE:
+      basetype = pfunc_type_node;
+      break;
     default:
       gcc_unreachable ();
     }
@@ -2978,7 +2982,8 @@
 		    || f->sym->ts.u.derived->attr.pointer_comp))
 	    || (f->sym->ts.type == BT_CLASS
 		&& (CLASS_DATA (f->sym)->ts.u.derived->attr.proc_pointer_comp
-		    || CLASS_DATA (f->sym)->ts.u.derived->attr.pointer_comp)))
+		    || CLASS_DATA (f->sym)->ts.u.derived->attr.pointer_comp))
+	    || (f->sym->ts.type == BT_INTEGER && f->sym->ts.is_c_interop))
 	  spec[spec_len++] = '.';
 	else if (f->sym->attr.intent == INTENT_IN)
 	  spec[spec_len++] = 'r';
@@ -2991,9 +2996,65 @@
   return build_type_attribute_variant (fntype, tmp);
 }
 
+/* Helper function - if we do not find an interface for a procedure,
+   construct it from the actual arglist.  Luckily, this can only
+   happen for call by reference, so the information we actually need
+   to provide (and which would be impossible to guess from the call
+   itself) is not actually needed.  */
 
+static void
+get_formal_from_actual_arglist (gfc_symbol *sym, gfc_actual_arglist *actual_args)
+{
+  gfc_actual_arglist *a;
+  gfc_formal_arglist **f;
+  gfc_symbol *s;
+  char name[GFC_MAX_SYMBOL_LEN + 1];
+  static int var_num;
+
+  f = &sym->formal;
+  for (a = actual_args; a != NULL; a = a->next)
+    {
+      (*f) = gfc_get_formal_arglist ();
+      if (a->expr)
+	{
+	  snprintf (name, GFC_MAX_SYMBOL_LEN, "_formal_%d", var_num ++);
+	  gfc_get_symbol (name, gfc_current_ns, &s);
+	  if (a->expr->ts.type == BT_PROCEDURE)
+	    {
+	      s->attr.flavor = FL_PROCEDURE;
+	    }
+	  else
+	    {
+	      s->ts = a->expr->ts;
+
+	      if (s->ts.type == BT_CHARACTER)
+		  s->ts.u.cl = gfc_get_charlen ();
+
+	      s->ts.deferred = 0;
+	      s->ts.is_iso_c = 0;
+	      s->ts.is_c_interop = 0;
+	      s->attr.flavor = FL_VARIABLE;
+	      if (a->expr->rank > 0)
+		{
+		  s->attr.dimension = 1;
+		  s->as = gfc_get_array_spec ();
+		  s->as->type = AS_ASSUMED_SIZE;
+		}
+	    }
+	  s->attr.dummy = 1;
+	  s->attr.artificial = 1;
+	  s->attr.intent = INTENT_UNKNOWN;
+	  (*f)->sym = s;
+	}
+      else  /* If a->expr is NULL, this is an alternate rerturn.  */
+	(*f)->sym = NULL;
+
+      f = &((*f)->next);
+    }
+}
+
 tree
-gfc_get_function_type (gfc_symbol * sym)
+gfc_get_function_type (gfc_symbol * sym, gfc_actual_arglist *actual_args)
 {
   tree type;
   vec<tree, va_gc> *typelist = NULL;
@@ -3051,6 +3112,10 @@
 	    vec_safe_push (typelist, build_pointer_type(gfc_charlen_type_node));
 	}
     }
+  if (sym->backend_decl == error_mark_node && actual_args != NULL
+      && sym->formal == NULL && (sym->attr.proc == PROC_EXTERNAL
+				 || sym->attr.proc == PROC_UNKNOWN))
+    get_formal_from_actual_arglist (sym, actual_args);
 
   /* Build the argument types for the function.  */
   for (f = gfc_sym_get_dummy_args (sym); f; f = f->next)
Index: gcc/fortran/trans.h
===================================================================
diff --git a/gcc/fortran/trans.h b/gcc/fortran/trans.h
--- a/gcc/fortran/trans.h	(revision 278653)
+++ b/gcc/fortran/trans.h	(revision 278653)
@@ -412,7 +412,7 @@
 tree gfc_class_vptr_get (tree);
 tree gfc_class_len_get (tree);
 tree gfc_class_len_or_zero_get (tree);
-gfc_expr * gfc_find_and_cut_at_last_class_ref (gfc_expr *);
+gfc_expr * gfc_find_and_cut_at_last_class_ref (gfc_expr *, bool is_mold = false);
 /* Get an accessor to the class' vtab's * field, when a class handle is
    available.  */
 tree gfc_class_vtab_hash_get (tree);
@@ -579,7 +579,8 @@
 tree gfc_get_label_decl (gfc_st_label *);
 
 /* Return the decl for an external function.  */
-tree gfc_get_extern_function_decl (gfc_symbol *);
+tree gfc_get_extern_function_decl (gfc_symbol *,
+				   gfc_actual_arglist *args = NULL);
 
 /* Return the decl for a function.  */
 tree gfc_get_function_decl (gfc_symbol *);
Index: gcc/fortran/trans-types.h
===================================================================
diff --git a/gcc/fortran/trans-types.h b/gcc/fortran/trans-types.h
--- a/gcc/fortran/trans-types.h	(revision 278653)
+++ b/gcc/fortran/trans-types.h	(revision 278653)
@@ -88,7 +88,7 @@
 tree gfc_typenode_for_spec (gfc_typespec *, int c = 0);
 int gfc_copy_dt_decls_ifequal (gfc_symbol *, gfc_symbol *, bool);
 
-tree gfc_get_function_type (gfc_symbol *);
+tree gfc_get_function_type (gfc_symbol *, gfc_actual_arglist *args = NULL);
 
 tree gfc_type_for_size (unsigned, int);
 tree gfc_type_for_mode (machine_mode, int);
Index: gcc/fortran/frontend-passes.c
===================================================================
diff --git a/gcc/fortran/frontend-passes.c b/gcc/fortran/frontend-passes.c
--- a/gcc/fortran/frontend-passes.c	(revision 278653)
+++ b/gcc/fortran/frontend-passes.c	(revision 278653)
@@ -2461,7 +2461,12 @@
   data.sym = sym;
   mpz_init_set (data.val, val);
   gfc_expr_walker (&n, callback_insert_index, (void *) &data);
+
+  /* Suppress errors here - we could get errors here such as an
+     out of bounds access for arrays, see PR 90563.  */
+  gfc_push_suppress_errors ();
   gfc_simplify_expr (n, 0);
+  gfc_pop_suppress_errors ();
 
   if (n->expr_type == EXPR_CONSTANT)
     {
@@ -2511,6 +2516,7 @@
 	      bool have_do_start, have_do_end;
 	      bool error_not_proven;
 	      int warn;
+	      int sgn;
 
 	      dl = lp->c;
 	      if (dl == NULL)
@@ -2539,7 +2545,16 @@
 		 Do not warn in this case.  */
 	  
 	      if (dl->ext.iterator->step->expr_type == EXPR_CONSTANT)
-		mpz_init_set (do_step, dl->ext.iterator->step->value.integer);
+		{
+		  sgn = mpz_cmp_ui (dl->ext.iterator->step->value.integer, 0);
+		  /* This can happen, but then the error has been
+		     reported previusly.  */
+		  if (sgn == 0)
+		    continue;
+
+		  mpz_init_set (do_step, dl->ext.iterator->step->value.integer);
+		}
+
 	      else
 		continue;
 
@@ -2563,6 +2578,16 @@
 	      if (!have_do_start && !have_do_end)
 		return 0;
 
+	      /* No warning inside a zero-trip loop.  */
+	      if (have_do_start && have_do_end)
+		{
+		  int cmp;
+
+		  cmp = mpz_cmp (do_end, do_start);
+		  if ((sgn > 0 && cmp < 0) || (sgn < 0 && cmp > 0))
+		    break;
+		}
+
 	      /* May have to correct the end value if the step does not equal
 		 one.  */
 	      if (have_do_start && have_do_end && mpz_cmp_ui (do_step, 1) != 0)
Index: gcc/fortran/resolve.c
===================================================================
diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
--- a/gcc/fortran/resolve.c	(revision 278653)
+++ b/gcc/fortran/resolve.c	(revision 278653)
@@ -1045,7 +1045,7 @@
 	}
       if (!gsym)
 	{
-	  gsym = gfc_get_gsymbol (common_root->n.common->name);
+	  gsym = gfc_get_gsymbol (common_root->n.common->name, false);
 	  gsym->type = GSYM_COMMON;
 	  gsym->where = common_root->n.common->where;
 	  gsym->defined = 1;
@@ -1067,7 +1067,7 @@
 	}
       if (!gsym)
 	{
-	  gsym = gfc_get_gsymbol (common_root->n.common->binding_label);
+	  gsym = gfc_get_gsymbol (common_root->n.common->binding_label, true);
 	  gsym->type = GSYM_COMMON;
 	  gsym->where = common_root->n.common->where;
 	  gsym->defined = 1;
@@ -1681,8 +1681,6 @@
       || gfc_fl_struct (sym->attr.flavor))
     return false;
 
-  gcc_assert (sym->attr.flavor == FL_PROCEDURE);
-
   /* If we've got an ENTRY, find real procedure.  */
   if (sym->attr.entry && sym->ns->entries)
     proc_sym = sym->ns->entries->sym;
@@ -2484,7 +2482,8 @@
 
   type = sub ? GSYM_SUBROUTINE : GSYM_FUNCTION;
 
-  gsym = gfc_get_gsymbol (sym->binding_label ? sym->binding_label : sym->name);
+  gsym = gfc_get_gsymbol (sym->binding_label ? sym->binding_label : sym->name,
+			  sym->binding_label != NULL);
 
   if ((gsym->type != GSYM_UNKNOWN && gsym->type != type))
     gfc_global_used (gsym, where);
@@ -2494,64 +2493,64 @@
       && gsym->type != GSYM_UNKNOWN
       && !gsym->binding_label
       && gsym->ns
-      && gsym->ns->resolved != -1
       && gsym->ns->proc_name
       && not_in_recursive (sym, gsym->ns)
       && not_entry_self_reference (sym, gsym->ns))
     {
       gfc_symbol *def_sym;
+      def_sym = gsym->ns->proc_name;
 
       /* Resolve the gsymbol namespace if needed.  */
-      if (!gsym->ns->resolved)
+      if (gsym->ns->resolved != -1)
 	{
-	  gfc_dt_list *old_dt_list;
+	  if (!gsym->ns->resolved)
+	    {
+	      gfc_dt_list *old_dt_list;
 
-	  /* Stash away derived types so that the backend_decls do not
-	     get mixed up.  */
-	  old_dt_list = gfc_derived_types;
-	  gfc_derived_types = NULL;
+	      /* Stash away derived types so that the backend_decls
+	     do not get mixed up.  */
+	      old_dt_list = gfc_derived_types;
+	      gfc_derived_types = NULL;
 
-	  gfc_resolve (gsym->ns);
+	      gfc_resolve (gsym->ns);
 
-	  /* Store the new derived types with the global namespace.  */
-	  if (gfc_derived_types)
-	    gsym->ns->derived_types = gfc_derived_types;
+	      /* Store the new derived types with the global namespace.  */
+	      if (gfc_derived_types)
+		gsym->ns->derived_types = gfc_derived_types;
 
-	  /* Restore the derived types of this namespace.  */
-	  gfc_derived_types = old_dt_list;
-	}
+	      /* Restore the derived types of this namespace.  */
+	      gfc_derived_types = old_dt_list;
+	    }
 
-      /* Make sure that translation for the gsymbol occurs before
-	 the procedure currently being resolved.  */
-      ns = gfc_global_ns_list;
-      for (; ns && ns != gsym->ns; ns = ns->sibling)
-	{
-	  if (ns->sibling == gsym->ns)
+	  /* Make sure that translation for the gsymbol occurs before
+	     the procedure currently being resolved.  */
+	  ns = gfc_global_ns_list;
+	  for (; ns && ns != gsym->ns; ns = ns->sibling)
 	    {
-	      ns->sibling = gsym->ns->sibling;
-	      gsym->ns->sibling = gfc_global_ns_list;
-	      gfc_global_ns_list = gsym->ns;
-	      break;
+	      if (ns->sibling == gsym->ns)
+		{
+		  ns->sibling = gsym->ns->sibling;
+		  gsym->ns->sibling = gfc_global_ns_list;
+		  gfc_global_ns_list = gsym->ns;
+		  break;
+		}
 	    }
-	}
 
-      def_sym = gsym->ns->proc_name;
+	  /* This can happen if a binding name has been specified.  */
+	  if (gsym->binding_label && gsym->sym_name != def_sym->name)
+	    gfc_find_symbol (gsym->sym_name, gsym->ns, 0, &def_sym);
 
-      /* This can happen if a binding name has been specified.  */
-      if (gsym->binding_label && gsym->sym_name != def_sym->name)
-	gfc_find_symbol (gsym->sym_name, gsym->ns, 0, &def_sym);
-
-      if (def_sym->attr.entry_master)
-	{
-	  gfc_entry_list *entry;
-	  for (entry = gsym->ns->entries; entry; entry = entry->next)
-	    if (strcmp (entry->sym->name, sym->name) == 0)
-	      {
-		def_sym = entry->sym;
-		break;
-	      }
+	  if (def_sym->attr.entry_master || def_sym->attr.entry)
+	    {
+	      gfc_entry_list *entry;
+	      for (entry = gsym->ns->entries; entry; entry = entry->next)
+		if (strcmp (entry->sym->name, sym->name) == 0)
+		  {
+		    def_sym = entry->sym;
+		    break;
+		  }
+	    }
 	}
-
       if (sym->attr.function && !gfc_compare_types (&sym->ts, &def_sym->ts))
 	{
 	  gfc_error ("Return type mismatch of function %qs at %L (%s/%s)",
@@ -4633,9 +4632,13 @@
   gfc_array_spec *as;
   gfc_component *c;
   gfc_ref *ref;
+  bool class_as = false;
 
   if (e->symtree->n.sym->ts.type == BT_CLASS)
-    as = CLASS_DATA (e->symtree->n.sym)->as;
+    {
+      as = CLASS_DATA (e->symtree->n.sym)->as;
+      class_as = true;
+    }
   else
     as = e->symtree->n.sym->as;
 
@@ -4654,7 +4657,7 @@
 	c = ref->u.c.component;
 	if (c->attr.dimension)
 	  {
-	    if (as != NULL)
+	    if (as != NULL && !(class_as && as == c->as))
 	      gfc_internal_error ("find_array_spec(): unused as(1)");
 	    as = c->as;
 	  }
@@ -4881,6 +4884,7 @@
   gfc_ref *char_ref;
   gfc_expr *start, *end;
   gfc_typespec *ts = NULL;
+  mpz_t diff;
 
   for (char_ref = e->ref; char_ref; char_ref = char_ref->next)
     {
@@ -4932,12 +4936,26 @@
       return;
     }
 
-  /* Length = (end - start + 1).  */
-  e->ts.u.cl->length = gfc_subtract (end, start);
-  e->ts.u.cl->length = gfc_add (e->ts.u.cl->length,
-				gfc_get_int_expr (gfc_charlen_int_kind,
-						  NULL, 1));
+  /* Length = (end - start + 1).
+     Check first whether it has a constant length.  */
+  if (gfc_dep_difference (end, start, &diff))
+    {
+      gfc_expr *len = gfc_get_constant_expr (BT_INTEGER, gfc_charlen_int_kind,
+					     &e->where);
 
+      mpz_add_ui (len->value.integer, diff, 1);
+      mpz_clear (diff);
+      e->ts.u.cl->length = len;
+      /* The check for length < 0 is handled below */
+    }
+  else
+    {
+      e->ts.u.cl->length = gfc_subtract (end, start);
+      e->ts.u.cl->length = gfc_add (e->ts.u.cl->length,
+				    gfc_get_int_expr (gfc_charlen_int_kind,
+						      NULL, 1));
+    }
+
   /* F2008, 6.4.1:  Both the starting point and the ending point shall
      be within the range 1, 2, ..., n unless the starting point exceeds
      the ending point, in which case the substring has length zero.  */
@@ -5615,11 +5633,14 @@
 
 
 /* Checks to see that the correct symbol has been host associated.
-   The only situation where this arises is that in which a twice
-   contained function is parsed after the host association is made.
-   Therefore, on detecting this, change the symbol in the expression
-   and convert the array reference into an actual arglist if the old
-   symbol is a variable.  */
+   The only situations where this arises are:
+	(i)  That in which a twice contained function is parsed after
+	     the host association is made. On detecting this, change
+	     the symbol in the expression and convert the array reference
+	     into an actual arglist if the old symbol is a variable; or
+	(ii) That in which an external function is typed but not declared
+	     explcitly to be external. Here, the old symbol is changed
+	     from a variable to an external function.  */
 static bool
 check_host_association (gfc_expr *e)
 {
@@ -5709,6 +5730,26 @@
 	  gfc_resolve_expr (e);
 	  sym->refs++;
 	}
+      /* This case corresponds to a call, from a block or a contained
+	 procedure, to an external function, which has not been declared
+	 as being external in the main program but has been typed.  */
+      else if (sym && old_sym != sym
+	       && !e->ref
+	       && sym->ts.type == BT_UNKNOWN
+	       && old_sym->ts.type != BT_UNKNOWN
+	       && sym->attr.flavor == FL_PROCEDURE
+	       && old_sym->attr.flavor == FL_VARIABLE
+	       && sym->ns->parent == old_sym->ns
+	       && sym->ns->proc_name
+	       && (sym->ns->proc_name->attr.flavor == FL_LABEL
+		   || sym->ns->proc_name->attr.flavor == FL_PROCEDURE))
+	{
+	  old_sym->attr.flavor = FL_PROCEDURE;
+	  old_sym->attr.external = 1;
+	  old_sym->attr.function = 1;
+	  old_sym->result = old_sym;
+	  gfc_resolve_expr (e);
+	}
     }
   /* This might have changed!  */
   return e->expr_type == EXPR_FUNCTION;
@@ -6888,6 +6929,19 @@
 				  "Step expression in DO loop"))
     return false;
 
+  /* Convert start, end, and step to the same type as var.  */
+  if (iter->start->ts.kind != iter->var->ts.kind
+      || iter->start->ts.type != iter->var->ts.type)
+    gfc_convert_type (iter->start, &iter->var->ts, 1);
+
+  if (iter->end->ts.kind != iter->var->ts.kind
+      || iter->end->ts.type != iter->var->ts.type)
+    gfc_convert_type (iter->end, &iter->var->ts, 1);
+
+  if (iter->step->ts.kind != iter->var->ts.kind
+      || iter->step->ts.type != iter->var->ts.type)
+    gfc_convert_type (iter->step, &iter->var->ts, 1);
+
   if (iter->step->expr_type == EXPR_CONSTANT)
     {
       if ((iter->step->ts.type == BT_INTEGER
@@ -6901,19 +6955,6 @@
 	}
     }
 
-  /* Convert start, end, and step to the same type as var.  */
-  if (iter->start->ts.kind != iter->var->ts.kind
-      || iter->start->ts.type != iter->var->ts.type)
-    gfc_convert_type (iter->start, &iter->var->ts, 1);
-
-  if (iter->end->ts.kind != iter->var->ts.kind
-      || iter->end->ts.type != iter->var->ts.type)
-    gfc_convert_type (iter->end, &iter->var->ts, 1);
-
-  if (iter->step->ts.kind != iter->var->ts.kind
-      || iter->step->ts.type != iter->var->ts.type)
-    gfc_convert_type (iter->step, &iter->var->ts, 1);
-
   if (iter->start->expr_type == EXPR_CONSTANT
       && iter->end->expr_type == EXPR_CONSTANT
       && iter->step->expr_type == EXPR_CONSTANT)
@@ -7215,6 +7256,10 @@
   for (ref = result->ref; ref; ref = ref->next)
     if (ref->type == REF_ARRAY && ref->next == NULL)
       {
+	if (ref->u.ar.dimen == 0
+	    && ref->u.ar.as && ref->u.ar.as->corank)
+	  return result;
+
 	ref->u.ar.type = AR_FULL;
 
 	for (i = 0; i < ref->u.ar.dimen; i++)
@@ -7640,13 +7685,54 @@
 
   if (codimension)
     for (i = ar->dimen; i < ar->dimen + ar->codimen; i++)
-      if (ar->dimen_type[i] == DIMEN_THIS_IMAGE)
-	{
-	  gfc_error ("Coarray specification required in ALLOCATE statement "
-		     "at %L", &e->where);
-	  goto failure;
-	}
+      {
+	switch (ar->dimen_type[i])
+	  {
+	  case DIMEN_THIS_IMAGE:
+	    gfc_error ("Coarray specification required in ALLOCATE statement "
+		       "at %L", &e->where);
+	    goto failure;
 
+	  case  DIMEN_RANGE:
+	    if (ar->start[i] == 0 || ar->end[i] == 0)
+	      {
+		/* If ar->stride[i] is NULL, we issued a previous error.  */
+		if (ar->stride[i] == NULL)
+		  gfc_error ("Bad array specification in ALLOCATE statement "
+			     "at %L", &e->where);
+		goto failure;
+	      }
+	    else if (gfc_dep_compare_expr (ar->start[i], ar->end[i]) == 1)
+	      {
+		gfc_error ("Upper cobound is less than lower cobound at %L",
+			   &ar->start[i]->where);
+		goto failure;
+	      }
+	    break;
+
+	  case DIMEN_ELEMENT:
+	    if (ar->start[i]->expr_type == EXPR_CONSTANT)
+	      {
+		gcc_assert (ar->start[i]->ts.type == BT_INTEGER);
+		if (mpz_cmp_si (ar->start[i]->value.integer, 1) < 0)
+		  {
+		    gfc_error ("Upper cobound is less than lower cobound "
+			       " of 1 at %L", &ar->start[i]->where);
+		    goto failure;
+		  }
+	      }
+	    break;
+
+	  case DIMEN_STAR:
+	    break;
+
+	  default:
+	    gfc_error ("Bad array specification in ALLOCATE statement at %L",
+		       &e->where);
+	    goto failure;
+
+	  }
+      }
   for (i = 0; i < ar->dimen; i++)
     {
       if (ar->type == AR_ELEMENT || ar->type == AR_FULL)
@@ -11011,6 +11097,9 @@
   if (!gfc_check_dependency ((*code)->expr1, (*code)->expr2, 1))
     return false;
 
+  if (gfc_expr_attr ((*code)->expr1).pointer)
+    return false;
+
   tmp_expr = get_temp_from_expr ((*code)->expr1, ns);
   tmp_expr->where = (*code)->loc;
 
@@ -11647,7 +11736,7 @@
 	  && (gsym->type == GSYM_FUNCTION || gsym->type == GSYM_SUBROUTINE)))
     {
       if (!gsym)
-	gsym = gfc_get_gsymbol (sym->binding_label);
+	gsym = gfc_get_gsymbol (sym->binding_label, true);
       gsym->where = sym->declared_at;
       gsym->sym_name = sym->name;
       gsym->binding_label = sym->binding_label;
@@ -16266,8 +16355,8 @@
 }
 
 
-/* Function called by resolve_fntype to flag other symbol used in the
-   length type parameter specification of function resuls.  */
+/* Function called by resolve_fntype to flag other symbols used in the
+   length type parameter specification of function results.  */
 
 static bool
 flag_fn_result_spec (gfc_expr *expr,
Index: gcc/fortran/iresolve.c
===================================================================
diff --git a/gcc/fortran/iresolve.c b/gcc/fortran/iresolve.c
--- a/gcc/fortran/iresolve.c	(revision 278653)
+++ b/gcc/fortran/iresolve.c	(revision 278653)
@@ -35,6 +35,7 @@
 #include "intrinsic.h"
 #include "constructor.h"
 #include "arith.h"
+#include "trans.h"
 
 /* Given printf-like arguments, return a stable version of the result string.
 
@@ -2377,6 +2378,10 @@
     a->name = "%VAL";
 
   c->resolved_sym = gfc_get_intrinsic_sub_symbol (name);
+  /* We set the backend_decl here because runtime_error is a
+     variadic function and we would use the wrong calling
+     convention otherwise.  */
+  c->resolved_sym->backend_decl = gfor_fndecl_runtime_error;
 }
 
 void
Index: gcc/fortran/trans-decl.c
===================================================================
diff --git a/gcc/fortran/trans-decl.c b/gcc/fortran/trans-decl.c
--- a/gcc/fortran/trans-decl.c	(revision 278653)
+++ b/gcc/fortran/trans-decl.c	(revision 278653)
@@ -342,40 +342,45 @@
     }
 }
 
+/* Return the name of an identifier.  */
 
+static const char *
+sym_identifier (gfc_symbol *sym)
+{
+  if (sym->attr.is_main_program && strcmp (sym->name, "main") == 0)
+    return "MAIN__";
+  else
+    return sym->name;
+}
+
 /* Convert a gfc_symbol to an identifier of the same name.  */
 
 static tree
 gfc_sym_identifier (gfc_symbol * sym)
 {
-  if (sym->attr.is_main_program && strcmp (sym->name, "main") == 0)
-    return (get_identifier ("MAIN__"));
-  else
-    return (get_identifier (sym->name));
+  return get_identifier (sym_identifier (sym));
 }
 
+/* Construct mangled name from symbol name.   */
 
-/* Construct mangled name from symbol name.  */
-
-static tree
-gfc_sym_mangled_identifier (gfc_symbol * sym)
+static const char *
+mangled_identifier (gfc_symbol *sym)
 {
-  char name[GFC_MAX_MANGLED_SYMBOL_LEN + 1];
-
+  gfc_symbol *proc = sym->ns->proc_name;
+  static char name[3*GFC_MAX_MANGLED_SYMBOL_LEN + 14];
   /* Prevent the mangling of identifiers that have an assigned
      binding label (mainly those that are bind(c)).  */
+
   if (sym->attr.is_bind_c == 1 && sym->binding_label)
-    return get_identifier (sym->binding_label);
+    return sym->binding_label;
 
-  if (!sym->fn_result_spec)
+  if (!sym->fn_result_spec
+      || (sym->module && !(proc && proc->attr.flavor == FL_PROCEDURE)))
     {
       if (sym->module == NULL)
-	return gfc_sym_identifier (sym);
+	return sym_identifier (sym);
       else
-	{
-	  snprintf (name, sizeof name, "__%s_MOD_%s", sym->module, sym->name);
-	  return get_identifier (name);
-	}
+	snprintf (name, sizeof name, "__%s_MOD_%s", sym->module, sym->name);
     }
   else
     {
@@ -382,25 +387,42 @@
       /* This is an entity that is actually local to a module procedure
 	 that appears in the result specification expression.  Since
 	 sym->module will be a zero length string, we use ns->proc_name
-	 instead. */
-      if (sym->ns->proc_name && sym->ns->proc_name->module)
-	{
-	  snprintf (name, sizeof name, "__%s_MOD__%s_PROC_%s",
-		    sym->ns->proc_name->module,
-		    sym->ns->proc_name->name,
-		    sym->name);
-	  return get_identifier (name);
-	}
+	 to provide the module name instead. */
+      if (proc && proc->module)
+	snprintf (name, sizeof name, "__%s_MOD__%s_PROC_%s",
+		  proc->module, proc->name, sym->name);
       else
-	{
-	  snprintf (name, sizeof name, "__%s_PROC_%s",
-		    sym->ns->proc_name->name, sym->name);
-	  return get_identifier (name);
-	}
+	snprintf (name, sizeof name, "__%s_PROC_%s",
+		  proc->name, sym->name);
     }
+
+  return name;
 }
 
+/* Get mangled identifier, adding the symbol to the global table if
+   it is not yet already there.  */
 
+static tree
+gfc_sym_mangled_identifier (gfc_symbol * sym)
+{
+  tree result;
+  gfc_gsymbol *gsym;
+  const char *name;
+
+  name = mangled_identifier (sym);
+  result = get_identifier (name);
+
+  gsym = gfc_find_gsymbol (gfc_gsym_root, name);
+  if (gsym == NULL)
+    {
+      gsym = gfc_get_gsymbol (name, false);
+      gsym->ns = sym->ns;
+      gsym->sym_name = sym->name;
+    }
+
+  return result;
+}
+
 /* Construct mangled function name from symbol name.  */
 
 static tree
@@ -839,7 +861,7 @@
 	{
 	  if (!gsym)
 	    {
-	      gsym = gfc_get_gsymbol (sym->module);
+	      gsym = gfc_get_gsymbol (sym->module, false);
 	      gsym->type = GSYM_MODULE;
 	      gsym->ns = gfc_get_namespace (NULL, 0);
 	    }
@@ -1863,10 +1885,19 @@
   if (sym->attr.associate_var)
     GFC_DECL_ASSOCIATE_VAR_P (decl) = 1;
 
-  if (sym->attr.vtab
-      || (sym->name[0] == '_' && strncmp ("__def_init", sym->name, 10) == 0))
-    TREE_READONLY (decl) = 1;
+  /* We only mark __def_init as read-only if it actually has an
+     initializer so it does not needlessly take up space in the
+     read-only section and can go into the BSS instead, see PR 84487.
+     Marking this as artificial means that OpenMP will treat this as
+     predetermined shared.  */
 
+  if (sym->attr.vtab || strncmp ("__def_init", sym->name, 10) == 0)
+    {
+      DECL_ARTIFICIAL (decl) = 1;
+      if (sym->attr.vtab || sym->value)
+	TREE_READONLY (decl) = 1;
+    }
+
   return decl;
 }
 
@@ -1905,6 +1936,22 @@
   tree decl;
   tree attributes;
 
+  if (sym->module || sym->fn_result_spec)
+    {
+      const char *name;
+      gfc_gsymbol *gsym;
+
+      name = mangled_identifier (sym);
+      gsym = gfc_find_gsymbol (gfc_gsym_root, name);
+      if (gsym != NULL)
+	{
+	  gfc_symbol *s;
+	  gfc_find_symbol (sym->name, gsym->ns, 0, &s);
+	  if (s && s->backend_decl)
+	    return s->backend_decl;
+	}
+    }
+
   decl = sym->backend_decl;
   if (decl)
     return decl;
@@ -1977,7 +2024,7 @@
 /* Get a basic decl for an external function.  */
 
 tree
-gfc_get_extern_function_decl (gfc_symbol * sym)
+gfc_get_extern_function_decl (gfc_symbol * sym, gfc_actual_arglist *actual_args)
 {
   tree type;
   tree fndecl;
@@ -2002,10 +2049,23 @@
     return get_proc_pointer_decl (sym);
 
   /* See if this is an external procedure from the same file.  If so,
-     return the backend_decl.  */
-  gsym =  gfc_find_gsymbol (gfc_gsym_root, sym->binding_label
-					   ? sym->binding_label : sym->name);
+     return the backend_decl.  If we are looking at a BIND(C)
+     procedure and the symbol is not BIND(C), or vice versa, we
+     haven't found the right procedure.  */
 
+  if (sym->binding_label)
+    {
+      gsym = gfc_find_gsymbol (gfc_gsym_root, sym->binding_label);
+      if (gsym && !gsym->bind_c)
+	gsym = NULL;
+    }
+  else
+    {
+      gsym = gfc_find_gsymbol (gfc_gsym_root, sym->name);
+      if (gsym && gsym->bind_c)
+	gsym = NULL;
+    }
+
   if (gsym && !gsym->defined)
     gsym = NULL;
 
@@ -2150,7 +2210,7 @@
       mangled_name = gfc_sym_mangled_function_id (sym);
     }
 
-  type = gfc_get_function_type (sym);
+  type = gfc_get_function_type (sym, actual_args);
   fndecl = build_decl (input_location,
 		       FUNCTION_DECL, name, type);
 
@@ -2500,6 +2560,17 @@
 	  TREE_READONLY (length) = 1;
 	  gfc_finish_decl (length);
 
+	  /* Marking the length DECL_HIDDEN_STRING_LENGTH will lead
+	     to tail calls being disabled.  Only do that if we
+	     potentially have broken callers.  */
+	  if (flag_tail_call_workaround
+	      && f->sym->ts.u.cl
+	      && f->sym->ts.u.cl->length
+	      && f->sym->ts.u.cl->length->expr_type == EXPR_CONSTANT
+	      && (flag_tail_call_workaround == 2
+		  || f->sym->ns->implicit_interface_calls))
+	    DECL_HIDDEN_STRING_LENGTH (length) = 1;
+
 	  /* Remember the passed value.  */
           if (!f->sym->ts.u.cl ||  f->sym->ts.u.cl->passed_length)
             {
@@ -5384,6 +5455,33 @@
   /* Handle "static" initializer.  */
   if (sym->value)
     {
+      if (sym->value->expr_type == EXPR_ARRAY)
+	{
+	  gfc_constructor *c, *cnext;
+
+	  /* Test if the array has more than one element.  */
+	  c = gfc_constructor_first (sym->value->value.constructor);
+	  gcc_assert (c);  /* Empty constructor should not happen here.  */
+	  cnext = gfc_constructor_next (c);
+
+	  if (cnext)
+	    {
+	      /* An EXPR_ARRAY with a rank > 1 here has to come from a
+		 DATA statement.  Set its rank here as not to confuse
+		 the following steps.   */
+	      sym->value->rank = 1;
+	    }
+	  else
+	    {
+	      /* There is only a single value in the constructor, use
+		 it directly for the assignment.  */
+	      gfc_expr *new_expr;
+	      new_expr = gfc_copy_expr (c->expr);
+	      gfc_free_expr (sym->value);
+	      sym->value = new_expr;
+	    }
+	}
+
       sym->attr.pointer = 1;
       tmp = gfc_trans_assignment (gfc_lval_expr_from_sym (sym), sym->value,
 				  true, false);
@@ -5628,9 +5726,11 @@
 	    }
 	  else if (warn_unused_dummy_argument)
 	    {
-	      gfc_warning (OPT_Wunused_dummy_argument,
-			   "Unused dummy argument %qs at %L", sym->name,
-			   &sym->declared_at);
+	      if (!sym->attr.artificial)
+		gfc_warning (OPT_Wunused_dummy_argument,
+			     "Unused dummy argument %qs at %L", sym->name,
+			     &sym->declared_at);
+
 	      if (sym->backend_decl != NULL_TREE)
 		TREE_NO_WARNING(sym->backend_decl) = 1;
 	    }
@@ -5722,7 +5822,14 @@
 
       if (sym->ns && sym->ns->construct_entities)
 	{
-	  if (sym->attr.referenced)
+	  /* Construction of the intrinsic modules within a BLOCK
+	     construct, where ONLY and RENAMED entities are included,
+	     seems to be bogus.  This is a workaround that can be removed
+	     if someone ever takes on the task to creating full-fledge
+	     modules.  See PR 69455.  */
+	  if (sym->attr.referenced
+	      && sym->from_intmod != INTMOD_ISO_C_BINDING
+	      && sym->from_intmod != INTMOD_ISO_FORTRAN_ENV)
 	    gfc_get_symbol_decl (sym);
 	  sym->mark = 1;
 	}
Index: gcc/fortran/target-memory.c
===================================================================
diff --git a/gcc/fortran/target-memory.c b/gcc/fortran/target-memory.c
--- a/gcc/fortran/target-memory.c	(revision 278653)
+++ b/gcc/fortran/target-memory.c	(revision 278653)
@@ -73,10 +73,10 @@
 
 
 /* Return the size of a single element of the given expression.
-   Identical to gfc_target_expr_size for scalars.  */
+   Equivalent to gfc_target_expr_size for scalars.  */
 
-size_t
-gfc_element_size (gfc_expr *e)
+bool
+gfc_element_size (gfc_expr *e, size_t *siz)
 {
   tree type;
 
@@ -83,16 +83,20 @@
   switch (e->ts.type)
     {
     case BT_INTEGER:
-      return size_integer (e->ts.kind);
+      *siz = size_integer (e->ts.kind);
+      return true;
     case BT_REAL:
-      return size_float (e->ts.kind);
+      *siz = size_float (e->ts.kind);
+      return true;
     case BT_COMPLEX:
-      return size_complex (e->ts.kind);
+      *siz = size_complex (e->ts.kind);
+      return true;
     case BT_LOGICAL:
-      return size_logical (e->ts.kind);
+      *siz = size_logical (e->ts.kind);
+      return true;
     case BT_CHARACTER:
       if (e->expr_type == EXPR_CONSTANT)
-	return size_character (e->value.character.length, e->ts.kind);
+	*siz = size_character (e->value.character.length, e->ts.kind);
       else if (e->ts.u.cl != NULL && e->ts.u.cl->length != NULL
 	       && e->ts.u.cl->length->expr_type == EXPR_CONSTANT
 	       && e->ts.u.cl->length->ts.type == BT_INTEGER)
@@ -100,17 +104,23 @@
 	  HOST_WIDE_INT length;
 
 	  gfc_extract_hwi (e->ts.u.cl->length, &length);
-	  return size_character (length, e->ts.kind);
+	  *siz = size_character (length, e->ts.kind);
 	}
       else
-	return 0;
+	{
+	  *siz = 0;
+	  return false;
+	}
+      return true;
 
     case BT_HOLLERITH:
-      return e->representation.length;
+      *siz = e->representation.length;
+      return true;
     case BT_DERIVED:
     case BT_CLASS:
     case BT_VOID:
     case BT_ASSUMED:
+    case BT_PROCEDURE:
       {
 	/* Determine type size without clobbering the typespec for ISO C
 	   binding types.  */
@@ -120,36 +130,43 @@
 	type = gfc_typenode_for_spec (&ts);
 	size = int_size_in_bytes (type);
 	gcc_assert (size >= 0);
-	return size;
+	*siz = size;
       }
+      return true;
     default:
       gfc_internal_error ("Invalid expression in gfc_element_size.");
-      return 0;
+      *siz = 0;
+      return false;
     }
+  return true;
 }
 
 
 /* Return the size of an expression in its target representation.  */
 
-size_t
-gfc_target_expr_size (gfc_expr *e)
+bool
+gfc_target_expr_size (gfc_expr *e, size_t *size)
 {
   mpz_t tmp;
-  size_t asz;
+  size_t asz, el_size;
 
   gcc_assert (e != NULL);
 
+  *size = 0;
   if (e->rank)
     {
       if (gfc_array_size (e, &tmp))
 	asz = mpz_get_ui (tmp);
       else
-	asz = 0;
+	return false;
     }
   else
     asz = 1;
 
-  return asz * gfc_element_size (e);
+  if (!gfc_element_size (e, &el_size))
+    return false;
+  *size = asz * el_size;
+  return true;
 }
 
 
@@ -675,7 +692,7 @@
 
   /* Otherwise, use the target-memory machinery to write a bitwise image, appropriate
      to the target, in a buffer and check off the initialized part of the buffer.  */
-  len = gfc_target_expr_size (e);
+  gfc_target_expr_size (e, &len);
   buffer = (unsigned char*)alloca (len);
   len = gfc_target_encode_expr (e, buffer, len);
 
@@ -722,8 +739,10 @@
       for (c = gfc_constructor_first (e->value.constructor);
 	   c; c = gfc_constructor_next (c))
 	{
-	  size_t elt_size = gfc_target_expr_size (c->expr);
+	  size_t elt_size;
 
+	  gfc_target_expr_size (c->expr, &elt_size);
+
 	  if (mpz_cmp_si (c->offset, 0) != 0)
 	    len = elt_size * (size_t)mpz_get_si (c->offset);
 
Index: gcc/fortran/match.c
===================================================================
diff --git a/gcc/fortran/match.c b/gcc/fortran/match.c
--- a/gcc/fortran/match.c	(revision 278653)
+++ b/gcc/fortran/match.c	(revision 278653)
@@ -2105,8 +2105,6 @@
       ts->type = BT_CHARACTER;
 
       m = gfc_match_char_spec (ts);
-      if (ts->u.cl && ts->u.cl->length)
-	gfc_resolve_expr (ts->u.cl->length);
 
       if (m == MATCH_NO)
 	m = MATCH_YES;
Index: gcc/fortran/trans-io.c
===================================================================
diff --git a/gcc/fortran/trans-io.c b/gcc/fortran/trans-io.c
--- a/gcc/fortran/trans-io.c	(revision 278653)
+++ b/gcc/fortran/trans-io.c	(revision 278653)
@@ -2408,8 +2408,6 @@
 
     case_bt_struct:
     case BT_CLASS:
-      if (ts->u.derived->components == NULL)
-	return;
       if (gfc_bt_struct (ts->type) || ts->type == BT_CLASS)
 	{
 	  gfc_symbol *derived;
Index: gcc/fortran/target-memory.h
===================================================================
diff --git a/gcc/fortran/target-memory.h b/gcc/fortran/target-memory.h
--- a/gcc/fortran/target-memory.h	(revision 278653)
+++ b/gcc/fortran/target-memory.h	(revision 278653)
@@ -24,8 +24,8 @@
 /* Convert a BOZ to REAL or COMPLEX.  */
 bool gfc_convert_boz (gfc_expr *, gfc_typespec *);
 
-size_t gfc_element_size (gfc_expr *);
-size_t gfc_target_expr_size (gfc_expr *);
+bool gfc_element_size (gfc_expr *, size_t *);
+bool gfc_target_expr_size (gfc_expr *, size_t *);
 
 /* Write a constant expression in binary form to a target buffer.  */
 size_t gfc_encode_character (int, size_t, const gfc_char_t *, unsigned char *,
Index: gcc/fortran/arith.c
===================================================================
diff --git a/gcc/fortran/arith.c b/gcc/fortran/arith.c
--- a/gcc/fortran/arith.c	(revision 278653)
+++ b/gcc/fortran/arith.c	(revision 278653)
@@ -2548,10 +2548,10 @@
 static void
 hollerith2representation (gfc_expr *result, gfc_expr *src)
 {
-  int src_len, result_len;
+  size_t src_len, result_len;
 
   src_len = src->representation.length - src->ts.u.pad;
-  result_len = gfc_target_expr_size (result);
+  gfc_target_expr_size (result, &result_len);
 
   if (src_len > result_len)
     {
Index: gcc/fortran/parse.c
===================================================================
diff --git a/gcc/fortran/parse.c b/gcc/fortran/parse.c
--- a/gcc/fortran/parse.c	(revision 278653)
+++ b/gcc/fortran/parse.c	(revision 278653)
@@ -5830,7 +5830,7 @@
     }
   else
     {
-      s = gfc_get_gsymbol (gfc_new_block->name);
+      s = gfc_get_gsymbol (gfc_new_block->name, false);
       if (s->defined
 	  || (s->type != GSYM_UNKNOWN && s->type != GSYM_BLOCK_DATA))
        gfc_global_used (s, &gfc_new_block->declared_at);
@@ -5912,7 +5912,7 @@
   gfc_gsymbol *s;
   bool error;
 
-  s = gfc_get_gsymbol (gfc_new_block->name);
+  s = gfc_get_gsymbol (gfc_new_block->name, false);
   if (s->defined || (s->type != GSYM_UNKNOWN && s->type != GSYM_MODULE))
     gfc_global_used (s, &gfc_new_block->declared_at);
   else
@@ -5976,7 +5976,7 @@
      name is a global identifier.  */
   if (!gfc_new_block->binding_label || gfc_notification_std (GFC_STD_F2008))
     {
-      s = gfc_get_gsymbol (gfc_new_block->name);
+      s = gfc_get_gsymbol (gfc_new_block->name, false);
 
       if (s->defined
 	  || (s->type != GSYM_UNKNOWN
@@ -6001,7 +6001,7 @@
       && (!gfc_notification_std (GFC_STD_F2008)
           || strcmp (gfc_new_block->name, gfc_new_block->binding_label) != 0))
     {
-      s = gfc_get_gsymbol (gfc_new_block->binding_label);
+      s = gfc_get_gsymbol (gfc_new_block->binding_label, true);
 
       if (s->defined
 	  || (s->type != GSYM_UNKNOWN
@@ -6033,7 +6033,7 @@
 
   if (gfc_new_block == NULL)
     return;
-  s = gfc_get_gsymbol (gfc_new_block->name);
+  s = gfc_get_gsymbol (gfc_new_block->name, false);
 
   if (s->defined || (s->type != GSYM_UNKNOWN && s->type != GSYM_PROGRAM))
     gfc_global_used (s, &gfc_new_block->declared_at);
Index: gcc/fortran/check.c
===================================================================
diff --git a/gcc/fortran/check.c b/gcc/fortran/check.c
--- a/gcc/fortran/check.c	(revision 278653)
+++ b/gcc/fortran/check.c	(revision 278653)
@@ -5413,17 +5413,42 @@
     return false;
 
   /* Calculate the size of the source.  */
-  *source_size = gfc_target_expr_size (source);
-  if (*source_size == 0)
+  if (!gfc_target_expr_size (source, source_size))
     return false;
 
   /* Determine the size of the element.  */
-  result_elt_size = gfc_element_size (mold);
-  if (result_elt_size == 0)
+  if (!gfc_element_size (mold, &result_elt_size))
     return false;
 
-  if (mold->expr_type == EXPR_ARRAY || mold->rank || size)
+  /* If the storage size of SOURCE is greater than zero and MOLD is an array,
+   * a scalar with the type and type parameters of MOLD shall not have a
+   * storage size equal to zero.
+   * If MOLD is a scalar and SIZE is absent, the result is a scalar.
+   * If MOLD is an array and SIZE is absent, the result is an array and of
+   * rank one. Its size is as small as possible such that its physical
+   * representation is not shorter than that of SOURCE.
+   * If SIZE is present, the result is an array of rank one and size SIZE.
+   */
+  if (result_elt_size == 0 && *source_size > 0 && !size
+      && mold->expr_type == EXPR_ARRAY)
     {
+      gfc_error ("%<MOLD%> argument of %<TRANSFER%> intrinsic at %L is an "
+		 "array and shall not have storage size 0 when %<SOURCE%> "
+		 "argument has size greater than 0", &mold->where);
+      return false;
+    }
+
+  if (result_elt_size == 0 && *source_size == 0 && !size)
+    {
+      *result_size = 0;
+      if (result_length_p)
+	*result_length_p = 0;
+      return true;
+    }
+
+  if ((result_elt_size > 0 && (mold->expr_type == EXPR_ARRAY || mold->rank))
+      || size)
+    {
       int result_length;
 
       if (size)
@@ -5452,6 +5477,26 @@
   size_t source_size;
   size_t result_size;
 
+  /* SOURCE shall be a scalar or array of any type.  */
+  if (source->ts.type == BT_PROCEDURE
+      && source->symtree->n.sym->attr.subroutine == 1)
+    {
+      gfc_error ("%<SOURCE%> argument of %<TRANSFER%> intrinsic at %L "
+                 "must not be a %s", &source->where,
+		 gfc_basic_typename (source->ts.type));
+      return false;
+    }
+
+  /* MOLD shall be a scalar or array of any type.  */
+  if (mold->ts.type == BT_PROCEDURE
+      && mold->symtree->n.sym->attr.subroutine == 1)
+    {
+      gfc_error ("%<MOLD%> argument of %<TRANSFER%> intrinsic at %L "
+                 "must not be a %s", &mold->where,
+		 gfc_basic_typename (mold->ts.type));
+      return false;
+    }
+
   if (mold->ts.type == BT_HOLLERITH)
     {
       gfc_error ("%<MOLD%> argument of %<TRANSFER%> intrinsic at %L must not be"
@@ -5459,6 +5504,8 @@
       return false;
     }
 
+  /* SIZE (optional) shall be an integer scalar.  The corresponding actual
+     argument shall not be an optional dummy argument.  */
   if (size != NULL)
     {
       if (!type_check (size, 2, BT_INTEGER))
Index: gcc/fortran/trans-intrinsic.c
===================================================================
diff --git a/gcc/fortran/trans-intrinsic.c b/gcc/fortran/trans-intrinsic.c
--- a/gcc/fortran/trans-intrinsic.c	(revision 278653)
+++ b/gcc/fortran/trans-intrinsic.c	(revision 278653)
@@ -6820,6 +6820,8 @@
   tree fncall0;
   tree fncall1;
   gfc_se argse;
+  gfc_expr *e;
+  gfc_symbol *sym = NULL;
 
   gfc_init_se (&argse, NULL);
   actual = expr->value.function.actual;
@@ -6827,15 +6829,34 @@
   if (actual->expr->ts.type == BT_CLASS)
     gfc_add_class_array_ref (actual->expr);
 
+  e = actual->expr;
+
+  /* These are emerging from the interface mapping, when a class valued
+     function appears as the rhs in a realloc on assign statement, where
+     the size of the result is that of one of the actual arguments.  */
+  if (e->expr_type == EXPR_VARIABLE
+      && e->symtree->n.sym->ns == NULL /* This is distinctive!  */
+      && e->symtree->n.sym->ts.type == BT_CLASS
+      && e->ref && e->ref->type == REF_COMPONENT
+      && strcmp (e->ref->u.c.component->name, "_data") == 0)
+    sym = e->symtree->n.sym;
+
   argse.data_not_needed = 1;
-  if (gfc_is_class_array_function (actual->expr))
+  if (gfc_is_class_array_function (e))
     {
       /* For functions that return a class array conv_expr_descriptor is not
 	 able to get the descriptor right.  Therefore this special case.  */
-      gfc_conv_expr_reference (&argse, actual->expr);
+      gfc_conv_expr_reference (&argse, e);
       argse.expr = gfc_build_addr_expr (NULL_TREE,
 					gfc_class_data_get (argse.expr));
     }
+  else if (sym && sym->backend_decl)
+    {
+      gcc_assert (GFC_CLASS_TYPE_P (TREE_TYPE (sym->backend_decl)));
+      argse.expr = sym->backend_decl;
+      argse.expr = gfc_build_addr_expr (NULL_TREE,
+					gfc_class_data_get (argse.expr));
+    }
   else
     {
       argse.want_pointer = 1;
Index: gcc/fortran/simplify.c
===================================================================
diff --git a/gcc/fortran/simplify.c b/gcc/fortran/simplify.c
--- a/gcc/fortran/simplify.c	(revision 278653)
+++ b/gcc/fortran/simplify.c	(revision 278653)
@@ -4469,7 +4469,7 @@
     /* The expression in assoc->target points to a ref to the _data component
        of the unlimited polymorphic entity.  To get the _len component the last
        _data ref needs to be stripped and a ref to the _len component added.  */
-    return gfc_get_len_component (e->symtree->n.sym->assoc->target);
+    return gfc_get_len_component (e->symtree->n.sym->assoc->target, k);
   else
     return NULL;
 }
@@ -6921,6 +6921,7 @@
 {
   gfc_expr *result = NULL;
   mpz_t array_size;
+  size_t res_size;
 
   if (x->ts.type == BT_CLASS || x->ts.deferred)
     return NULL;
@@ -6936,7 +6937,8 @@
 
   result = gfc_get_constant_expr (BT_INTEGER, gfc_index_integer_kind,
 				  &x->where);
-  mpz_set_si (result->value.integer, gfc_target_expr_size (x));
+  gfc_target_expr_size (x, &res_size);
+  mpz_set_si (result->value.integer, res_size);
 
   return result;
 }
@@ -6950,6 +6952,7 @@
 {
   gfc_expr *result = NULL;
   int k;
+  size_t siz;
 
   if (x->ts.type == BT_CLASS || x->ts.deferred)
     return NULL;
@@ -6965,7 +6968,8 @@
 
   result = gfc_get_constant_expr (BT_INTEGER, k, &x->where);
 
-  mpz_set_si (result->value.integer, gfc_element_size (x));
+  gfc_element_size (x, &siz);
+  mpz_set_si (result->value.integer, siz);
   mpz_mul_ui (result->value.integer, result->value.integer, BITS_PER_UNIT);
 
   return range_check (result, "STORAGE_SIZE");
Index: gcc/configure.ac
===================================================================
diff --git a/gcc/configure.ac b/gcc/configure.ac
--- a/gcc/configure.ac	(revision 278653)
+++ b/gcc/configure.ac	(revision 278653)
@@ -2595,17 +2595,13 @@
 	#
 	# ld: Software Generation Utilities - Solaris Link Editors: 5.11-1.1701:onnv-ab196087-6931056-03/25/10
 	#
-	# In Solaris 11.4, this was changed to
-	#
-	# ld: Solaris ELF Utilities: 11.4-1.3123
-	#
 	# ld and ld.so.1 are guaranteed to be updated in lockstep, so ld version
 	# numbers can be used in ld.so.1 feature checks even if a different
 	# linker is configured.
 	ld_ver=`$gcc_cv_ld -V 2>&1`
-	if echo "$ld_ver" | $EGREP 'Solaris Link Editors|Solaris ELF Utilities' > /dev/null; then
+	if echo "$ld_ver" | grep 'Solaris Link Editors' > /dev/null; then
 	  ld_vers=`echo $ld_ver | sed -n \
-	    -e 's,^.*: \(5\|1[0-9]\)\.[0-9][0-9]*-\([0-9]\.[0-9][0-9]*\).*$,\2,p'`
+	    -e 's,^.*: 5\.[0-9][0-9]*-\([0-9]\.[0-9][0-9]*\).*$,\1,p'`
 	  ld_vers_major=`expr "$ld_vers" : '\([0-9]*\)'`
 	  ld_vers_minor=`expr "$ld_vers" : '[0-9]*\.\([0-9]*\)'`
 	fi
@@ -6143,7 +6139,8 @@
 all_languages=
 all_compilers=
 all_outputs='Makefile'
-# List of language makefile fragments.
+# List of language configure and makefile fragments.
+all_lang_configurefrags=
 all_lang_makefrags=
 # Additional files for gengtype
 all_gtfiles="$target_gtfiles"
@@ -6231,6 +6228,7 @@
 	esac
 	$ok || continue
 
+	all_lang_configurefrags="$all_lang_configurefrags \$(srcdir)/$gcc_subdir/config-lang.in"
 	all_lang_makefrags="$all_lang_makefrags \$(srcdir)/$gcc_subdir/Make-lang.in"
 	if test -f $srcdir/$gcc_subdir/lang.opt; then
 	    lang_opt_files="$lang_opt_files $srcdir/$gcc_subdir/lang.opt"
@@ -6332,6 +6330,7 @@
 AC_SUBST(srcdir)
 AC_SUBST(all_compilers)
 AC_SUBST(all_gtfiles)
+AC_SUBST(all_lang_configurefrags)
 AC_SUBST(all_lang_makefrags)
 AC_SUBST(all_languages)
 AC_SUBST(all_selected_languages)
Index: gcc/BASE-VER
===================================================================
diff --git a/gcc/BASE-VER b/gcc/BASE-VER
--- a/gcc/BASE-VER	(revision 278653)
+++ b/gcc/BASE-VER	(revision 278653)
@@ -1 +1 @@
-8.3.0
+8.3.1
Index: gcc/function.c
===================================================================
diff --git a/gcc/function.c b/gcc/function.c
--- a/gcc/function.c	(revision 278653)
+++ b/gcc/function.c	(revision 278653)
@@ -2477,8 +2477,7 @@
   /* If the parm is to be passed as a transparent union or record, use the
      type of the first field for the tests below.  We have already verified
      that the modes are the same.  */
-  if ((TREE_CODE (passed_type) == UNION_TYPE
-       || TREE_CODE (passed_type) == RECORD_TYPE)
+  if (RECORD_OR_UNION_TYPE_P (passed_type)
       && TYPE_TRANSPARENT_AGGR (passed_type))
     passed_type = TREE_TYPE (first_field (passed_type));
 
@@ -3098,7 +3097,7 @@
 	move_block_from_reg (REGNO (entry_parm), mem,
 			     size_stored / UNITS_PER_WORD);
     }
-  else if (data->stack_parm == 0)
+  else if (data->stack_parm == 0 && !TYPE_EMPTY_P (data->passed_type))
     {
       push_to_sequence2 (all->first_conversion_insn, all->last_conversion_insn);
       emit_block_move (stack_parm, data->entry_parm, GEN_INT (size),
@@ -3474,7 +3473,9 @@
       dest = validize_mem (copy_rtx (data->stack_parm));
       src = validize_mem (copy_rtx (data->entry_parm));
 
-      if (MEM_P (src))
+      if (TYPE_EMPTY_P (data->passed_type))
+	/* Empty types don't really need to be copied.  */;
+      else if (MEM_P (src))
 	{
 	  /* Use a block move to handle potentially misaligned entry_parm.  */
 	  if (!to_conversion)
@@ -3749,6 +3750,16 @@
 	{
 	  assign_parm_find_stack_rtl (parm, &data);
 	  assign_parm_adjust_entry_rtl (&data);
+	  /* For arguments that occupy no space in the parameter
+	     passing area, have non-zero size and have address taken,
+	     force creation of a stack slot so that they have distinct
+	     address from other parameters.  */
+	  if (TYPE_EMPTY_P (data.passed_type)
+	      && TREE_ADDRESSABLE (parm)
+	      && data.entry_parm == data.stack_parm
+	      && MEM_P (data.entry_parm)
+	      && int_size_in_bytes (data.passed_type))
+	    data.stack_parm = NULL_RTX;
 	}
       if (!POINTER_BOUNDS_TYPE_P (data.passed_type))
 	{
Index: gcc/gcse.c
===================================================================
diff --git a/gcc/gcse.c b/gcc/gcse.c
--- a/gcc/gcse.c	(revision 278653)
+++ b/gcc/gcse.c	(revision 278653)
@@ -1532,7 +1532,8 @@
 					      0, regno, hrsi)
 		record_last_reg_set_info (insn, regno);
 
-	      if (! RTL_CONST_OR_PURE_CALL_P (insn))
+	      if (! RTL_CONST_OR_PURE_CALL_P (insn)
+		  || RTL_LOOPING_CONST_OR_PURE_CALL_P (insn))
 		record_last_mem_set_info (insn);
 	    }
 
Index: gcc/tree-vect-loop.c
===================================================================
diff --git a/gcc/tree-vect-loop.c b/gcc/tree-vect-loop.c
--- a/gcc/tree-vect-loop.c	(revision 278653)
+++ b/gcc/tree-vect-loop.c	(revision 278653)
@@ -4551,14 +4551,9 @@
   unsigned HOST_WIDE_INT nunits;
   unsigned j, number_of_places_left_in_vector;
   tree vector_type;
-  tree vop;
-  int group_size = stmts.length ();
-  unsigned int vec_num, i;
-  unsigned number_of_copies = 1;
-  vec<tree> voprnds;
-  voprnds.create (number_of_vectors);
+  unsigned int group_size = stmts.length ();
+  unsigned int i;
   struct loop *loop;
-  auto_vec<tree, 16> permute_results;
 
   vector_type = STMT_VINFO_VECTYPE (stmt_vinfo);
 
@@ -4589,119 +4584,79 @@
   if (!TYPE_VECTOR_SUBPARTS (vector_type).is_constant (&nunits))
     nunits = group_size;
 
-  number_of_copies = nunits * number_of_vectors / group_size;
-
   number_of_places_left_in_vector = nunits;
   bool constant_p = true;
   tree_vector_builder elts (vector_type, nunits, 1);
   elts.quick_grow (nunits);
-  for (j = 0; j < number_of_copies; j++)
+  gimple_seq ctor_seq = NULL;
+  for (j = 0; j < nunits * number_of_vectors; ++j)
     {
-      for (i = group_size - 1; stmts.iterate (i, &stmt); i--)
-        {
-	  tree op;
-	  /* Get the def before the loop.  In reduction chain we have only
-	     one initial value.  */
-	  if ((j != (number_of_copies - 1)
-	       || (reduc_chain && i != 0))
-	      && neutral_op)
-	    op = neutral_op;
-	  else
-	    op = PHI_ARG_DEF_FROM_EDGE (stmt, pe);
+      tree op;
+      i = j % group_size;
+      stmt_vinfo = vinfo_for_stmt (stmts[i]);
 
-          /* Create 'vect_ = {op0,op1,...,opn}'.  */
-          number_of_places_left_in_vector--;
-	  elts[number_of_places_left_in_vector] = op;
-	  if (!CONSTANT_CLASS_P (op))
-	    constant_p = false;
+      /* Get the def before the loop.  In reduction chain we have only
+	 one initial value.  Else we have as many as PHIs in the group.  */
+      if (reduc_chain)
+	op = j != 0 ? neutral_op : PHI_ARG_DEF_FROM_EDGE (stmt_vinfo->stmt, pe);
+      else if (((vec_oprnds->length () + 1) * nunits
+		- number_of_places_left_in_vector >= group_size)
+	       && neutral_op)
+	op = neutral_op;
+      else
+	op = PHI_ARG_DEF_FROM_EDGE (stmt_vinfo->stmt, pe);
 
-          if (number_of_places_left_in_vector == 0)
-            {
-	      gimple_seq ctor_seq = NULL;
-	      tree init;
-	      if (constant_p && !neutral_op
-		  ? multiple_p (TYPE_VECTOR_SUBPARTS (vector_type), nunits)
-		  : known_eq (TYPE_VECTOR_SUBPARTS (vector_type), nunits))
-		/* Build the vector directly from ELTS.  */
-		init = gimple_build_vector (&ctor_seq, &elts);
-	      else if (neutral_op)
+      /* Create 'vect_ = {op0,op1,...,opn}'.  */
+      number_of_places_left_in_vector--;
+      elts[nunits - number_of_places_left_in_vector - 1] = op;
+      if (!CONSTANT_CLASS_P (op))
+	constant_p = false;
+
+      if (number_of_places_left_in_vector == 0)
+	{
+	  tree init;
+	  if (constant_p && !neutral_op
+	      ? multiple_p (TYPE_VECTOR_SUBPARTS (vector_type), nunits)
+	      : known_eq (TYPE_VECTOR_SUBPARTS (vector_type), nunits))
+	    /* Build the vector directly from ELTS.  */
+	    init = gimple_build_vector (&ctor_seq, &elts);
+	  else if (neutral_op)
+	    {
+	      /* Build a vector of the neutral value and shift the
+		 other elements into place.  */
+	      init = gimple_build_vector_from_val (&ctor_seq, vector_type,
+						   neutral_op);
+	      int k = nunits;
+	      while (k > 0 && elts[k - 1] == neutral_op)
+		k -= 1;
+	      while (k > 0)
 		{
-		  /* Build a vector of the neutral value and shift the
-		     other elements into place.  */
-		  init = gimple_build_vector_from_val (&ctor_seq, vector_type,
-						       neutral_op);
-		  int k = nunits;
-		  while (k > 0 && elts[k - 1] == neutral_op)
-		    k -= 1;
-		  while (k > 0)
-		    {
-		      k -= 1;
-		      gcall *call = gimple_build_call_internal
-			(IFN_VEC_SHL_INSERT, 2, init, elts[k]);
-		      init = make_ssa_name (vector_type);
-		      gimple_call_set_lhs (call, init);
-		      gimple_seq_add_stmt (&ctor_seq, call);
-		    }
+		  k -= 1;
+		  gcall *call = gimple_build_call_internal
+		      (IFN_VEC_SHL_INSERT, 2, init, elts[k]);
+		  init = make_ssa_name (vector_type);
+		  gimple_call_set_lhs (call, init);
+		  gimple_seq_add_stmt (&ctor_seq, call);
 		}
-	      else
-		{
-		  /* First time round, duplicate ELTS to fill the
-		     required number of vectors, then cherry pick the
-		     appropriate result for each iteration.  */
-		  if (vec_oprnds->is_empty ())
-		    duplicate_and_interleave (&ctor_seq, vector_type, elts,
-					      number_of_vectors,
-					      permute_results);
-		  init = permute_results[number_of_vectors - j - 1];
-		}
-	      if (ctor_seq != NULL)
-		gsi_insert_seq_on_edge_immediate (pe, ctor_seq);
-	      voprnds.quick_push (init);
-
-              number_of_places_left_in_vector = nunits;
-	      elts.new_vector (vector_type, nunits, 1);
-	      elts.quick_grow (nunits);
-	      constant_p = true;
-            }
-        }
-    }
-
-  /* Since the vectors are created in the reverse order, we should invert
-     them.  */
-  vec_num = voprnds.length ();
-  for (j = vec_num; j != 0; j--)
-    {
-      vop = voprnds[j - 1];
-      vec_oprnds->quick_push (vop);
-    }
-
-  voprnds.release ();
-
-  /* In case that VF is greater than the unrolling factor needed for the SLP
-     group of stmts, NUMBER_OF_VECTORS to be created is greater than
-     NUMBER_OF_SCALARS/NUNITS or NUNITS/NUMBER_OF_SCALARS, and hence we have
-     to replicate the vectors.  */
-  tree neutral_vec = NULL;
-  while (number_of_vectors > vec_oprnds->length ())
-    {
-      if (neutral_op)
-        {
-          if (!neutral_vec)
+	    }
+	  else
 	    {
-	      gimple_seq ctor_seq = NULL;
-	      neutral_vec = gimple_build_vector_from_val
-		(&ctor_seq, vector_type, neutral_op);
-	      if (ctor_seq != NULL)
-		gsi_insert_seq_on_edge_immediate (pe, ctor_seq);
+	      /* First time round, duplicate ELTS to fill the
+		 required number of vectors.  */
+	      duplicate_and_interleave (&ctor_seq, vector_type, elts,
+					number_of_vectors, *vec_oprnds);
+	      break;
 	    }
-          vec_oprnds->quick_push (neutral_vec);
-        }
-      else
-        {
-          for (i = 0; vec_oprnds->iterate (i, &vop) && i < vec_num; i++)
-            vec_oprnds->quick_push (vop);
-        }
+	  vec_oprnds->quick_push (init);
+
+	  number_of_places_left_in_vector = nunits;
+	  elts.new_vector (vector_type, nunits, 1);
+	  elts.quick_grow (nunits);
+	  constant_p = true;
+	}
     }
+  if (ctor_seq != NULL)
+    gsi_insert_seq_on_edge_immediate (pe, ctor_seq);
 }
 
 
@@ -6853,10 +6808,13 @@
 	  gcc_assert (TREE_CODE (base) == INTEGER_CST
 		      && TREE_CODE (step) == INTEGER_CST);
 	  cond_reduc_val = NULL_TREE;
+	  tree res = PHI_RESULT (STMT_VINFO_STMT (cond_stmt_vinfo));
+	  if (!types_compatible_p (TREE_TYPE (res), TREE_TYPE (base)))
+	    ;
 	  /* Find a suitable value, for MAX_EXPR below base, for MIN_EXPR
 	     above base; punt if base is the minimum value of the type for
 	     MAX_EXPR or maximum value of the type for MIN_EXPR for now.  */
-	  if (tree_int_cst_sgn (step) == -1)
+	  else if (tree_int_cst_sgn (step) == -1)
 	    {
 	      cond_reduc_op_code = MIN_EXPR;
 	      if (tree_int_cst_sgn (base) == -1)
Index: gcc/tree-data-ref.c
===================================================================
diff --git a/gcc/tree-data-ref.c b/gcc/tree-data-ref.c
--- a/gcc/tree-data-ref.c	(revision 278653)
+++ b/gcc/tree-data-ref.c	(revision 278653)
@@ -2230,7 +2230,7 @@
 
 bool
 dr_may_alias_p (const struct data_reference *a, const struct data_reference *b,
-		bool loop_nest)
+		struct loop *loop_nest)
 {
   tree addr_a = DR_BASE_OBJECT (a);
   tree addr_b = DR_BASE_OBJECT (b);
@@ -2254,6 +2254,11 @@
 
   if ((TREE_CODE (addr_a) == MEM_REF || TREE_CODE (addr_a) == TARGET_MEM_REF)
       && (TREE_CODE (addr_b) == MEM_REF || TREE_CODE (addr_b) == TARGET_MEM_REF)
+      /* For cross-iteration dependences the cliques must be valid for the
+	 whole loop, not just individual iterations.  */
+      && (!loop_nest
+	  || MR_DEPENDENCE_CLIQUE (addr_a) == 1
+	  || MR_DEPENDENCE_CLIQUE (addr_a) == loop_nest->owned_clique)
       && MR_DEPENDENCE_CLIQUE (addr_a) == MR_DEPENDENCE_CLIQUE (addr_b)
       && MR_DEPENDENCE_BASE (addr_a) != MR_DEPENDENCE_BASE (addr_b))
     return false;
@@ -2365,7 +2370,7 @@
     }
 
   /* If the data references do not alias, then they are independent.  */
-  if (!dr_may_alias_p (a, b, loop_nest.exists ()))
+  if (!dr_may_alias_p (a, b, loop_nest.exists () ? loop_nest[0] : NULL))
     {
       DDR_ARE_DEPENDENT (res) = chrec_known;
       return res;
@@ -4048,9 +4053,9 @@
     }
 
   else if (evolution_function_is_affine_multivariate_p (chrec_a, loop_nest->num)
-	   && !chrec_contains_symbols (chrec_a)
+	   && !chrec_contains_symbols (chrec_a, loop_nest)
 	   && evolution_function_is_affine_multivariate_p (chrec_b, loop_nest->num)
-	   && !chrec_contains_symbols (chrec_b))
+	   && !chrec_contains_symbols (chrec_b, loop_nest))
     {
       /* testsuite/.../ssa-chrec-35.c
 	 {0, +, 1}_2  vs.  {0, +, 1}_3
@@ -4260,6 +4265,7 @@
 {
   unsigned i;
   lambda_vector init_v = lambda_vector_new (DDR_NB_LOOPS (ddr));
+  struct loop *loop = DDR_LOOP_NEST (ddr)[0];
 
   for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)
     {
@@ -4290,6 +4296,15 @@
 	      return false;
 	    }
 
+	  /* When data references are collected in a loop while data
+	     dependences are analyzed in loop nest nested in the loop, we
+	     would have more number of access functions than number of
+	     loops.  Skip access functions of loops not in the loop nest.
+
+	     See PR89725 for more information.  */
+	  if (flow_loop_nested_p (get_loop (cfun, var_a), loop))
+	    continue;
+
 	  dist = int_cst_value (SUB_DISTANCE (subscript));
 	  index = index_in_loop_nest (var_a, DDR_LOOP_NEST (ddr));
 	  *index_carry = MIN (index, *index_carry);
@@ -4401,6 +4416,7 @@
   unsigned i;
   int index_carry = DDR_NB_LOOPS (ddr);
   subscript *sub;
+  struct loop *loop = DDR_LOOP_NEST (ddr)[0];
 
   FOR_EACH_VEC_ELT (DDR_SUBSCRIPTS (ddr), i, sub)
     {
@@ -4430,6 +4446,16 @@
 	      return;
 	    }
 
+	  /* When data references are collected in a loop while data
+	     dependences are analyzed in loop nest nested in the loop, we
+	     would have more number of access functions than number of
+	     loops.  Skip access functions of loops not in the loop nest.
+
+	     See PR89725 for more information.  */
+	  if (flow_loop_nested_p (get_loop (cfun, CHREC_VARIABLE (access_fun)),
+				  loop))
+	    continue;
+
 	  index_carry = MIN (index_carry,
 			     index_in_loop_nest (CHREC_VARIABLE (access_fun),
 						 DDR_LOOP_NEST (ddr)));
Index: gcc/loop-unroll.c
===================================================================
diff --git a/gcc/loop-unroll.c b/gcc/loop-unroll.c
--- a/gcc/loop-unroll.c	(revision 278653)
+++ b/gcc/loop-unroll.c	(revision 278653)
@@ -399,7 +399,7 @@
     {
       /* However we cannot unroll completely at the RTL level a loop with
 	 constant number of iterations; it should have been peeled instead.  */
-      if ((unsigned) loop->unroll - 1 > desc->niter - 2)
+      if (desc->niter == 0 || (unsigned) loop->unroll > desc->niter - 1)
 	{
 	  if (dump_file)
 	    fprintf (dump_file, ";; Loop should have been peeled\n");
@@ -651,7 +651,7 @@
   if (loop->any_likely_upper_bound)
     loop->nb_iterations_likely_upper_bound
       = wi::udiv_trunc (loop->nb_iterations_likely_upper_bound, max_unroll + 1);
-  desc->niter_expr = GEN_INT (desc->niter);
+  desc->niter_expr = gen_int_mode (desc->niter, desc->mode);
 
   /* Remove the edges.  */
   FOR_EACH_VEC_ELT (remove_edges, i, e)
@@ -1019,9 +1019,9 @@
       preheader = split_edge (loop_preheader_edge (loop));
       /* Add in count of edge from switch block.  */
       preheader->count += iter_count;
-      branch_code = compare_and_jump_seq (copy_rtx (niter), GEN_INT (j), EQ,
-					  block_label (preheader), p,
-					  NULL);
+      branch_code = compare_and_jump_seq (copy_rtx (niter),
+					  gen_int_mode (j, desc->mode), EQ,
+					  block_label (preheader), p, NULL);
 
       /* We rely on the fact that the compare and jump cannot be optimized out,
 	 and hence the cfg we create is correct.  */
Index: gcc/tree-data-ref.h
===================================================================
diff --git a/gcc/tree-data-ref.h b/gcc/tree-data-ref.h
--- a/gcc/tree-data-ref.h	(revision 278653)
+++ b/gcc/tree-data-ref.h	(revision 278653)
@@ -475,7 +475,7 @@
 }
 
 extern bool dr_may_alias_p (const struct data_reference *,
-			    const struct data_reference *, bool);
+			    const struct data_reference *, struct loop *);
 extern bool dr_equal_offsets_p (struct data_reference *,
                                 struct data_reference *);
 
Index: gcc/tree-vect-data-refs.c
===================================================================
diff --git a/gcc/tree-vect-data-refs.c b/gcc/tree-vect-data-refs.c
--- a/gcc/tree-vect-data-refs.c	(revision 278653)
+++ b/gcc/tree-vect-data-refs.c	(revision 278653)
@@ -144,6 +144,30 @@
       if (rhs < lhs)
         scalar_type = rhs_type;
     }
+  else if (gcall *call = dyn_cast <gcall *> (stmt))
+    {
+      unsigned int i = 0;
+      if (gimple_call_internal_p (call))
+	{
+	  internal_fn ifn = gimple_call_internal_fn (call);
+	  if (internal_load_fn_p (ifn) || internal_store_fn_p (ifn))
+	    /* gimple_expr_type already picked the type of the loaded
+	       or stored data.  */
+	    i = ~0U;
+	  else if (internal_fn_mask_index (ifn) == 0)
+	    i = 1;
+	}
+      if (i < gimple_call_num_args (call))
+	{
+	  tree rhs_type = TREE_TYPE (gimple_call_arg (call, i));
+	  if (tree_fits_uhwi_p (TYPE_SIZE_UNIT (rhs_type)))
+	    {
+	      rhs = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (rhs_type));
+	      if (rhs < lhs)
+		scalar_type = rhs_type;
+	    }
+	}
+    }
 
   *lhs_size_unit = lhs;
   *rhs_size_unit = rhs;
@@ -206,26 +230,60 @@
     return true;
 
   /* STMT_A and STMT_B belong to overlapping groups.  All loads in a
-     group are emitted at the position of the last scalar load and all
-     stores in a group are emitted at the position of the last scalar store.
+     SLP group are emitted at the position of the last scalar load and
+     all loads in an interleaving group are emitted at the position
+     of the first scalar load.
+     Stores in a group are emitted at the position of the last scalar store.
      Compute that position and check whether the resulting order matches
-     the current one.  */
-  gimple *last_a = GROUP_FIRST_ELEMENT (stmtinfo_a);
+     the current one.
+     We have not yet decided between SLP and interleaving so we have
+     to conservatively assume both.  */
+  gimple *il_a;
+  gimple *last_a = il_a = GROUP_FIRST_ELEMENT (stmtinfo_a);
   if (last_a)
-    for (gimple *s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (last_a)); s;
-	 s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (s)))
-      last_a = get_later_stmt (last_a, s);
+    {
+      for (gimple *s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (last_a)); s;
+	   s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (s)))
+	last_a = get_later_stmt (last_a, s);
+      if (!DR_IS_WRITE (STMT_VINFO_DATA_REF (stmtinfo_a)))
+	{
+	  for (gimple *s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (il_a)); s;
+	       s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (s)))
+	    if (get_later_stmt (il_a, s) == il_a)
+	      il_a = s;
+	}
+      else
+	il_a = last_a;
+    }
   else
-    last_a = stmt_a;
-  gimple *last_b = GROUP_FIRST_ELEMENT (stmtinfo_b);
+    last_a = il_a = stmt_a;
+  gimple *il_b;
+  gimple *last_b = il_b = GROUP_FIRST_ELEMENT (stmtinfo_b);
   if (last_b)
-    for (gimple *s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (last_b)); s;
-	 s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (s)))
-      last_b = get_later_stmt (last_b, s);
+    {
+      for (gimple *s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (last_b)); s;
+	   s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (s)))
+	last_b = get_later_stmt (last_b, s);
+      if (!DR_IS_WRITE (STMT_VINFO_DATA_REF (stmtinfo_b)))
+	{
+	  for (gimple *s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (il_b)); s;
+	       s = GROUP_NEXT_ELEMENT (vinfo_for_stmt (s)))
+	    if (get_later_stmt (il_b, s) == il_b)
+	      il_b = s;
+	}
+      else
+	il_b = last_b;
+    }
   else
-    last_b = stmt_b;
-  return ((get_later_stmt (last_a, last_b) == last_a)
-	  == (get_later_stmt (stmt_a, stmt_b) == stmt_a));
+    last_b = il_b = stmt_b;
+  bool a_after_b = (get_later_stmt (stmt_a, stmt_b) == stmt_a);
+  return (/* SLP */
+	  (get_later_stmt (last_a, last_b) == last_a) == a_after_b
+	  /* Interleaving */
+	  && (get_later_stmt (il_a, il_b) == il_a) == a_after_b
+	  /* Mixed */
+	  && (get_later_stmt (il_a, last_b) == il_a) == a_after_b
+	  && (get_later_stmt (last_a, il_b) == last_a) == a_after_b);
 }
 
 /* A subroutine of vect_analyze_data_ref_dependence.  Handle
@@ -504,8 +562,19 @@
 	     reversed (to make distance vector positive), and the actual
 	     distance is negative.  */
 	  if (dump_enabled_p ())
-	    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+	    dump_printf_loc (MSG_NOTE, vect_location,
 	                     "dependence distance negative.\n");
+	  /* When doing outer loop vectorization, we need to check if there is
+	     a backward dependence at the inner loop level if the dependence
+	     at the outer loop is reversed.  See PR81740.  */
+	  if (nested_in_vect_loop_p (loop, DR_STMT (dra))
+	      || nested_in_vect_loop_p (loop, DR_STMT (drb)))
+	    {
+	      unsigned inner_depth = index_in_loop_nest (loop->inner->num,
+							 DDR_LOOP_NEST (ddr));
+	      if (dist_v[inner_depth] < 0)
+		return true;
+	    }
 	  /* Record a negative dependence distance to later limit the
 	     amount of stmt copying / unrolling we can perform.
 	     Only need to handle read-after-write dependence.  */
@@ -521,7 +590,7 @@
 	{
 	  /* The dependence distance requires reduction of the maximal
 	     vectorization factor.  */
-	  *max_vf = abs (dist);
+	  *max_vf = abs_dist;
 	  if (dump_enabled_p ())
 	    dump_printf_loc (MSG_NOTE, vect_location,
 	                     "adjusting maximal vectorization factor to %i\n",
Index: gcc/gimplify.c
===================================================================
diff --git a/gcc/gimplify.c b/gcc/gimplify.c
--- a/gcc/gimplify.c	(revision 278653)
+++ b/gcc/gimplify.c	(revision 278653)
@@ -191,6 +191,7 @@
   bool target_map_scalars_firstprivate;
   bool target_map_pointers_as_0len_arrays;
   bool target_firstprivatize_array_bases;
+  bool add_safelen1;
 };
 
 static struct gimplify_ctx *gimplify_ctxp;
@@ -1294,12 +1295,17 @@
 		  || splay_tree_lookup (ctx->variables,
 					(splay_tree_key) t) == NULL))
 	    {
+	      int flag = GOVD_LOCAL;
 	      if (ctx->region_type == ORT_SIMD
 		  && TREE_ADDRESSABLE (t)
 		  && !TREE_STATIC (t))
-		omp_add_variable (ctx, t, GOVD_PRIVATE | GOVD_SEEN);
-	      else
-		omp_add_variable (ctx, t, GOVD_LOCAL | GOVD_SEEN);
+		{
+		  if (TREE_CODE (DECL_SIZE_UNIT (t)) != INTEGER_CST)
+		    ctx->add_safelen1 = true;
+		  else
+		    flag = GOVD_PRIVATE;
+		}
+	      omp_add_variable (ctx, t, flag | GOVD_SEEN);
 	    }
 
 	  DECL_SEEN_IN_BIND_EXPR_P (t) = 1;
@@ -4650,6 +4656,7 @@
      otherwise we'd generate a new temporary, and we can as well just
      use the decl we already have.  */
   else if (!TREE_ADDRESSABLE (decl)
+	   && !TREE_THIS_VOLATILE (decl)
 	   && init
 	   && (fallback & fb_lvalue) == 0
 	   && gimple_test_f (init))
@@ -4946,7 +4953,7 @@
 	   one field to assign, initialize the target from a temporary.  */
 	if (TREE_THIS_VOLATILE (object)
 	    && !TREE_ADDRESSABLE (type)
-	    && num_nonzero_elements > 0
+	    && (num_nonzero_elements > 0 || !cleared)
 	    && vec_safe_length (elts) > 1)
 	  {
 	    tree temp = create_tmp_var (TYPE_MAIN_VARIANT (type));
@@ -6144,6 +6151,19 @@
 	  is_inout = false;
 	}
 
+      /* If we can't make copies, we can only accept memory.  */
+      if (TREE_ADDRESSABLE (TREE_TYPE (TREE_VALUE (link))))
+	{
+	  if (allows_mem)
+	    allows_reg = 0;
+	  else
+	    {
+	      error ("impossible constraint in %<asm%>");
+	      error ("non-memory output %d must stay in memory", i);
+	      return GS_ERROR;
+	    }
+	}
+
       if (!allows_reg && allows_mem)
 	mark_addressable (TREE_VALUE (link));
 
@@ -6639,6 +6659,7 @@
 	    }
 	  if (asan_poisoned_variables
 	      && DECL_ALIGN (temp) <= MAX_SUPPORTED_STACK_ALIGNMENT
+	      && !TREE_STATIC (temp)
 	      && dbg_cnt (asan_use_after_scope)
 	      && !gimplify_omp_ctxp)
 	    {
@@ -8160,8 +8181,8 @@
 			      break;
 			    if (scp)
 			      continue;
-			    gcc_assert (offset == NULL_TREE
-					|| poly_int_tree_p (offset));
+			    gcc_assert (offset2 == NULL_TREE
+					|| poly_int_tree_p (offset2));
 			    tree d1 = OMP_CLAUSE_DECL (*sc);
 			    tree d2 = OMP_CLAUSE_DECL (c);
 			    while (TREE_CODE (d1) == ARRAY_REF)
@@ -9011,6 +9032,19 @@
 			   omp_find_stores_op, &wi);
 	}
     }
+
+  if (ctx->add_safelen1)
+    {
+      /* If there are VLAs in the body of simd loop, prevent
+	 vectorization.  */
+      gcc_assert (ctx->region_type == ORT_SIMD);
+      c = build_omp_clause (UNKNOWN_LOCATION, OMP_CLAUSE_SAFELEN);
+      OMP_CLAUSE_SAFELEN_EXPR (c) = integer_one_node;
+      OMP_CLAUSE_CHAIN (c) = *list_p;
+      *list_p = c;
+      list_p = &OMP_CLAUSE_CHAIN (c);
+    }
+
   while ((c = *list_p) != NULL)
     {
       splay_tree_node n;
Index: gcc/graphite-scop-detection.c
===================================================================
diff --git a/gcc/graphite-scop-detection.c b/gcc/graphite-scop-detection.c
--- a/gcc/graphite-scop-detection.c	(revision 278653)
+++ b/gcc/graphite-scop-detection.c	(revision 278653)
@@ -1414,9 +1414,13 @@
   int i, j;
   int *all_vertices;
 
+  struct loop *nest
+    = find_common_loop (scop->scop_info->region.entry->dest->loop_father,
+			scop->scop_info->region.exit->src->loop_father);
+
   FOR_EACH_VEC_ELT (scop->drs, i, dr1)
     for (j = i+1; scop->drs.iterate (j, &dr2); j++)
-      if (dr_may_alias_p (dr1->dr, dr2->dr, true))
+      if (dr_may_alias_p (dr1->dr, dr2->dr, nest))
 	{
 	  /* Dependences in the same alias set need to be handled
 	     by just looking at DR_ACCESS_FNs.  */
Index: gcc/lra-constraints.c
===================================================================
diff --git a/gcc/lra-constraints.c b/gcc/lra-constraints.c
--- a/gcc/lra-constraints.c	(revision 278653)
+++ b/gcc/lra-constraints.c	(revision 278653)
@@ -1774,14 +1774,24 @@
     return false;
   code = GET_CODE (x);
   mode = GET_MODE (x);
+
   if (code == SUBREG)
     {
+      /* For all SUBREGs we want to check whether the full multi-register
+	 overlaps the set.  For normal SUBREGs this means 'get_hard_regno' of
+	 the inner register, for paradoxical SUBREGs this means the
+	 'get_hard_regno' of the full SUBREG and for complete SUBREGs either is
+	 fine.  Use the wider mode for all cases.  */
+      rtx subreg = SUBREG_REG (x);
       mode = wider_subreg_mode (x);
-      x = SUBREG_REG (x);
-      code = GET_CODE (x);
+      if (mode == GET_MODE (subreg))
+	{
+	  x = subreg;
+	  code = GET_CODE (x);
+	}
     }
 
-  if (REG_P (x))
+  if (REG_P (x) || SUBREG_P (x))
     {
       x_hard_regno = get_hard_regno (x, true);
       return (x_hard_regno >= 0
@@ -2315,6 +2325,8 @@
 		  break;
 
 		reg:
+		  if (mode == BLKmode)
+		    break;
 		  this_alternative = reg_class_subunion[this_alternative][cl];
 		  IOR_HARD_REG_SET (this_alternative_set,
 				    reg_class_contents[cl]);
@@ -2325,8 +2337,6 @@
 		      IOR_HARD_REG_SET (this_costly_alternative_set,
 					reg_class_contents[cl]);
 		    }
-		  if (mode == BLKmode)
-		    break;
 		  winreg = true;
 		  if (REG_P (op))
 		    {
@@ -5767,6 +5777,9 @@
   enum rtx_code code;
   int i, j;
 
+  if (side_effects_p (x))
+    return false;
+
   code = GET_CODE (x);
   mode = GET_MODE (x);
   if (code == SUBREG)
@@ -6293,6 +6306,7 @@
 			add_to_hard_reg_set (&s, PSEUDO_REGNO_MODE (dst_regno),
 					     reg_renumber[dst_regno]);
 		      AND_COMPL_HARD_REG_SET (live_hard_regs, s);
+		      AND_COMPL_HARD_REG_SET (potential_reload_hard_regs, s);
 		    }
 		  /* We should invalidate potential inheritance or
 		     splitting for the current insn usages to the next
Index: gcc/tree-ssa-phiopt.c
===================================================================
diff --git a/gcc/tree-ssa-phiopt.c b/gcc/tree-ssa-phiopt.c
--- a/gcc/tree-ssa-phiopt.c	(revision 278653)
+++ b/gcc/tree-ssa-phiopt.c	(revision 278653)
@@ -1894,6 +1894,11 @@
       || gimple_has_volatile_ops (assign))
     return false;
 
+  /* And no PHI nodes so all uses in the single stmt are also
+     available where we insert to.  */
+  if (!gimple_seq_empty_p (phi_nodes (middle_bb)))
+    return false;
+
   locus = gimple_location (assign);
   lhs = gimple_assign_lhs (assign);
   rhs = gimple_assign_rhs1 (assign);
Index: gcc/calls.c
===================================================================
diff --git a/gcc/calls.c b/gcc/calls.c
--- a/gcc/calls.c	(revision 278653)
+++ b/gcc/calls.c	(revision 278653)
@@ -2078,8 +2078,7 @@
       /* If TYPE is a transparent union or record, pass things the way
 	 we would pass the first field of the union or record.  We have
 	 already verified that the modes are the same.  */
-      if ((TREE_CODE (type) == UNION_TYPE || TREE_CODE (type) == RECORD_TYPE)
-	   && TYPE_TRANSPARENT_AGGR (type))
+      if (RECORD_OR_UNION_TYPE_P (type) && TYPE_TRANSPARENT_AGGR (type))
 	type = TREE_TYPE (first_field (type));
 
       /* Decide where to pass this arg.
@@ -2873,6 +2872,9 @@
 	  poly_int64 size = 0;
 	  HOST_WIDE_INT const_size = 0;
 	  rtx_insn *before_arg = get_last_insn ();
+	  tree type = TREE_TYPE (args[i].tree_value);
+	  if (RECORD_OR_UNION_TYPE_P (type) && TYPE_TRANSPARENT_AGGR (type))
+	    type = TREE_TYPE (first_field (type));
 	  /* Set non-negative if we must move a word at a time, even if
 	     just one word (e.g, partial == 4 && mode == DFmode).  Set
 	     to -1 if we just use a normal move insn.  This value can be
@@ -2885,11 +2887,11 @@
 	      gcc_assert (partial % UNITS_PER_WORD == 0);
 	      nregs = partial / UNITS_PER_WORD;
 	    }
-	  else if (TYPE_MODE (TREE_TYPE (args[i].tree_value)) == BLKmode)
+	  else if (TYPE_MODE (type) == BLKmode)
 	    {
 	      /* Variable-sized parameters should be described by a
 		 PARALLEL instead.  */
-	      const_size = int_size_in_bytes (TREE_TYPE (args[i].tree_value));
+	      const_size = int_size_in_bytes (type);
 	      gcc_assert (const_size >= 0);
 	      nregs = (const_size + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;
 	      size = const_size;
@@ -3016,8 +3018,7 @@
 	  if (GET_CODE (reg) == PARALLEL)
 	    use_group_regs (call_fusage, reg);
 	  else if (nregs == -1)
-	    use_reg_mode (call_fusage, reg,
-			  TYPE_MODE (TREE_TYPE (args[i].tree_value)));
+	    use_reg_mode (call_fusage, reg, TYPE_MODE (type));
 	  else if (nregs > 0)
 	    use_regs (call_fusage, REGNO (reg), nregs);
 	}
@@ -3754,6 +3755,28 @@
       || dbg_cnt (tail_call) == false)
     try_tail_call = 0;
 
+  /* Workaround buggy C/C++ wrappers around Fortran routines with
+     character(len=constant) arguments if the hidden string length arguments
+     are passed on the stack; if the callers forget to pass those arguments,
+     attempting to tail call in such routines leads to stack corruption.
+     Avoid tail calls in functions where at least one such hidden string
+     length argument is passed (partially or fully) on the stack in the
+     caller and the callee needs to pass any arguments on the stack.
+     See PR90329.  */
+  if (try_tail_call && maybe_ne (args_size.constant, 0))
+    for (tree arg = DECL_ARGUMENTS (current_function_decl);
+	 arg; arg = DECL_CHAIN (arg))
+      if (DECL_HIDDEN_STRING_LENGTH (arg) && DECL_INCOMING_RTL (arg))
+	{
+	  subrtx_iterator::array_type array;
+	  FOR_EACH_SUBRTX (iter, array, DECL_INCOMING_RTL (arg), NONCONST)
+	    if (MEM_P (*iter))
+	      {
+		try_tail_call = 0;
+		break;
+	      }
+	}
+
   /* If the user has marked the function as requiring tail-call
      optimization, attempt it.  */
   if (must_tail_call)
Index: gcc/multiple_target.c
===================================================================
diff --git a/gcc/multiple_target.c b/gcc/multiple_target.c
--- a/gcc/multiple_target.c	(revision 278653)
+++ b/gcc/multiple_target.c	(revision 278653)
@@ -103,10 +103,16 @@
     inode->resolve_alias (cgraph_node::get (resolver_decl));
 
   auto_vec<cgraph_edge *> edges_to_redirect;
-  auto_vec<ipa_ref *> references_to_redirect;
+  /* We need to capture the references by value rather than just pointers to them
+     and remove them right away, as removing them later would invalidate what
+     some other reference pointers point to.  */
+  auto_vec<ipa_ref> references_to_redirect;
 
-  for (unsigned i = 0; node->iterate_referring (i, ref); i++)
-    references_to_redirect.safe_push (ref);
+  while (node->iterate_referring (0, ref))
+    {
+      references_to_redirect.safe_push (*ref);
+      ref->remove_reference ();
+    }
 
   /* We need to remember NEXT_CALLER as it could be modified in the loop.  */
   for (cgraph_edge *e = node->callers; e ; e = e->next_caller)
@@ -146,15 +152,14 @@
 		}
 
 	      symtab_node *source = ref->referring;
-	      ref->remove_reference ();
 	      source->create_reference (inode, IPA_REF_ADDR);
 	    }
 	  else if (ref->use == IPA_REF_ALIAS)
 	    {
 	      symtab_node *source = ref->referring;
-	      ref->remove_reference ();
 	      source->create_reference (inode, IPA_REF_ALIAS);
-	      source->add_to_same_comdat_group (inode);
+	      if (inode->get_comdat_group ())
+		source->add_to_same_comdat_group (inode);
 	    }
 	  else
 	    gcc_unreachable ();
@@ -294,7 +299,8 @@
 /*  Creates target clone of NODE.  */
 
 static cgraph_node *
-create_target_clone (cgraph_node *node, bool definition, char *name)
+create_target_clone (cgraph_node *node, bool definition, char *name,
+		     tree attributes)
 {
   cgraph_node *new_node;
 
@@ -303,7 +309,9 @@
       new_node = node->create_version_clone_with_body (vNULL, NULL,
     						       NULL, false,
 						       NULL, NULL,
-						       name);
+						       name, attributes);
+      if (new_node == NULL)
+	return NULL;
       new_node->force_output = true;
     }
   else
@@ -310,6 +318,7 @@
     {
       tree new_decl = copy_node (node->decl);
       new_node = cgraph_node::get_create (new_decl);
+      DECL_ATTRIBUTES (new_decl) = attributes;
       /* Generate a new name for the new version.  */
       symtab->change_decl_assembler_name (new_node->decl,
 					  clone_function_name (node->decl,
@@ -399,22 +408,16 @@
 
       create_new_asm_name (attr, suffix);
       /* Create new target clone.  */
-      cgraph_node *new_node = create_target_clone (node, definition, suffix);
+      tree attributes = make_attribute ("target", attr,
+					DECL_ATTRIBUTES (node->decl));
+
+      cgraph_node *new_node = create_target_clone (node, definition, suffix,
+						   attributes);
+      if (new_node == NULL)
+	return false;
       new_node->local.local = false;
       XDELETEVEC (suffix);
 
-      /* Set new attribute for the clone.  */
-      tree attributes = make_attribute ("target", attr,
-					DECL_ATTRIBUTES (new_node->decl));
-      DECL_ATTRIBUTES (new_node->decl) = attributes;
-      location_t saved_loc = input_location;
-      input_location = DECL_SOURCE_LOCATION (node->decl);
-      if (!targetm.target_option.valid_attribute_p (new_node->decl, NULL,
-						    TREE_VALUE (attributes),
-						    0))
-	return false;
-
-      input_location = saved_loc;
       decl2_v = new_node->function_version ();
       if (decl2_v != NULL)
         continue;
@@ -441,13 +444,7 @@
 				    DECL_ATTRIBUTES (node->decl));
   DECL_ATTRIBUTES (node->decl) = attributes;
   node->local.local = false;
-  location_t saved_loc = input_location;
-  input_location = DECL_SOURCE_LOCATION (node->decl);
-  bool ret
-    = targetm.target_option.valid_attribute_p (node->decl, NULL,
-					       TREE_VALUE (attributes), 0);
-  input_location = saved_loc;
-  return ret;
+  return true;
 }
 
 static unsigned int
Index: gcc/expmed.c
===================================================================
diff --git a/gcc/expmed.c b/gcc/expmed.c
--- a/gcc/expmed.c	(revision 278653)
+++ b/gcc/expmed.c	(revision 278653)
@@ -838,6 +838,27 @@
       if (MEM_P (op0))
 	op0 = adjust_bitfield_address_size (op0, op0_mode.else_blk (),
 					    0, MEM_SIZE (op0));
+      else if (!op0_mode.exists ())
+	{
+	  if (ibitnum == 0
+	      && known_eq (ibitsize, GET_MODE_BITSIZE (GET_MODE (op0)))
+	      && MEM_P (value)
+	      && !reverse)
+	    {
+	      value = adjust_address (value, GET_MODE (op0), 0);
+	      emit_move_insn (op0, value);
+	      return true;
+	    }
+	  if (!fallback_p)
+	    return false;
+	  rtx temp = assign_stack_temp (GET_MODE (op0),
+					GET_MODE_SIZE (GET_MODE (op0)));
+	  emit_move_insn (temp, op0);
+	  store_bit_field_1 (temp, bitsize, bitnum, 0, 0, fieldmode, value,
+			     reverse, fallback_p);
+	  emit_move_insn (op0, temp);
+	  return true;
+	}
       else
 	op0 = gen_lowpart (op0_mode.require (), op0);
     }
@@ -3352,13 +3373,20 @@
 	      tem = gen_lowpart (nmode, op0);
 	    }
 
-	  insn = get_last_insn ();
-	  wide_int wval_so_far
-	    = wi::uhwi (val_so_far,
-			GET_MODE_PRECISION (as_a <scalar_mode> (nmode)));
-	  rtx c = immed_wide_int_const (wval_so_far, nmode);
-	  set_dst_reg_note (insn, REG_EQUAL, gen_rtx_MULT (nmode, tem, c),
-			    accum_inner);
+	  /* Don't add a REG_EQUAL note if tem is a paradoxical SUBREG.
+	     In that case, only the low bits of accum would be guaranteed to
+	     be equal to the content of the REG_EQUAL note, the upper bits
+	     can be anything.  */
+	  if (!paradoxical_subreg_p (tem))
+	    {
+	      insn = get_last_insn ();
+	      wide_int wval_so_far
+		= wi::uhwi (val_so_far,
+			    GET_MODE_PRECISION (as_a <scalar_mode> (nmode)));
+	      rtx c = immed_wide_int_const (wval_so_far, nmode);
+	      set_dst_reg_note (insn, REG_EQUAL, gen_rtx_MULT (nmode, tem, c),
+				accum_inner);
+	    }
 	}
     }
 
Index: gcc/emit-rtl.c
===================================================================
diff --git a/gcc/emit-rtl.c b/gcc/emit-rtl.c
--- a/gcc/emit-rtl.c	(revision 278653)
+++ b/gcc/emit-rtl.c	(revision 278653)
@@ -3940,6 +3940,7 @@
 	  break;
 
 	case REG_NON_LOCAL_GOTO:
+	case REG_LABEL_TARGET:
 	  for (insn = insn_last; insn != NULL_RTX; insn = PREV_INSN (insn))
 	    {
 	      if (JUMP_P (insn))
Index: gcc/gimple-fold.c
===================================================================
diff --git a/gcc/gimple-fold.c b/gcc/gimple-fold.c
--- a/gcc/gimple-fold.c	(revision 278653)
+++ b/gcc/gimple-fold.c	(revision 278653)
@@ -3031,11 +3031,10 @@
       gimple_seq stmts = NULL;
       gimple *repl = gimple_build_call (fn, 2, dest, fmt);
       gimple_seq_add_stmt_without_update (&stmts, repl);
-      if (gimple_call_lhs (stmt))
+      if (tree lhs = gimple_call_lhs (stmt))
 	{
-	  repl = gimple_build_assign (gimple_call_lhs (stmt),
-				      build_int_cst (integer_type_node,
-						     strlen (fmt_str)));
+	  repl = gimple_build_assign (lhs, build_int_cst (TREE_TYPE (lhs),
+							  strlen (fmt_str)));
 	  gimple_seq_add_stmt_without_update (&stmts, repl);
 	  gsi_replace_with_seq_vops (gsi, stmts);
 	  /* gsi now points at the assignment to the lhs, get a
@@ -3079,12 +3078,12 @@
       gimple_seq stmts = NULL;
       gimple *repl = gimple_build_call (fn, 2, dest, orig);
       gimple_seq_add_stmt_without_update (&stmts, repl);
-      if (gimple_call_lhs (stmt))
+      if (tree lhs = gimple_call_lhs (stmt))
 	{
-	  if (!useless_type_conversion_p (integer_type_node,
+	  if (!useless_type_conversion_p (TREE_TYPE (lhs),
 					  TREE_TYPE (orig_len)))
-	    orig_len = fold_convert (integer_type_node, orig_len);
-	  repl = gimple_build_assign (gimple_call_lhs (stmt), orig_len);
+	    orig_len = fold_convert (TREE_TYPE (lhs), orig_len);
+	  repl = gimple_build_assign (lhs, orig_len);
 	  gimple_seq_add_stmt_without_update (&stmts, repl);
 	  gsi_replace_with_seq_vops (gsi, stmts);
 	  /* gsi now points at the assignment to the lhs, get a
@@ -3164,10 +3163,10 @@
       gimple_seq stmts = NULL;
       gimple *repl = gimple_build_call (fn, 2, dest, fmt);
       gimple_seq_add_stmt_without_update (&stmts, repl);
-      if (gimple_call_lhs (stmt))
+      if (tree lhs = gimple_call_lhs (stmt))
 	{
-	  repl = gimple_build_assign (gimple_call_lhs (stmt),
-				      build_int_cst (integer_type_node, len));
+	  repl = gimple_build_assign (lhs,
+				      build_int_cst (TREE_TYPE (lhs), len));
 	  gimple_seq_add_stmt_without_update (&stmts, repl);
 	  gsi_replace_with_seq_vops (gsi, stmts);
 	  /* gsi now points at the assignment to the lhs, get a
@@ -3216,12 +3215,12 @@
       gimple_seq stmts = NULL;
       gimple *repl = gimple_build_call (fn, 2, dest, orig);
       gimple_seq_add_stmt_without_update (&stmts, repl);
-      if (gimple_call_lhs (stmt))
+      if (tree lhs = gimple_call_lhs (stmt))
 	{
-	  if (!useless_type_conversion_p (integer_type_node,
+	  if (!useless_type_conversion_p (TREE_TYPE (lhs),
 					  TREE_TYPE (orig_len)))
-	    orig_len = fold_convert (integer_type_node, orig_len);
-	  repl = gimple_build_assign (gimple_call_lhs (stmt), orig_len);
+	    orig_len = fold_convert (TREE_TYPE (lhs), orig_len);
+	  repl = gimple_build_assign (lhs, orig_len);
 	  gimple_seq_add_stmt_without_update (&stmts, repl);
 	  gsi_replace_with_seq_vops (gsi, stmts);
 	  /* gsi now points at the assignment to the lhs, get a
@@ -6721,14 +6720,10 @@
 		= wi::sext (wi::to_poly_offset (idx)
 			    - wi::to_poly_offset (low_bound),
 			    TYPE_PRECISION (TREE_TYPE (idx)));
-
+	      woffset *= tree_to_uhwi (unit_size);
+	      woffset *= BITS_PER_UNIT;
 	      if (woffset.to_shwi (&offset))
 		{
-		  /* TODO: This code seems wrong, multiply then check
-		     to see if it fits.  */
-		  offset *= tree_to_uhwi (unit_size);
-		  offset *= BITS_PER_UNIT;
-
 		  base = TREE_OPERAND (t, 0);
 		  ctor = get_base_constructor (base, &offset, valueize);
 		  /* Empty constructor.  Always fold to 0.  */
Index: gcc/cfgexpand.c
===================================================================
diff --git a/gcc/cfgexpand.c b/gcc/cfgexpand.c
--- a/gcc/cfgexpand.c	(revision 278653)
+++ b/gcc/cfgexpand.c	(revision 278653)
@@ -4323,7 +4323,11 @@
       op0 = DECL_RTL_IF_SET (exp);
 
       /* This decl was probably optimized away.  */
-      if (!op0)
+      if (!op0
+	  /* At least label RTXen are sometimes replaced by
+	     NOTE_INSN_DELETED_LABEL.  Any notes here are not
+	     handled by copy_rtx.  */
+	  || NOTE_P (op0))
 	{
 	  if (!VAR_P (exp)
 	      || DECL_EXTERNAL (exp)
Index: gcc/tree-cfgcleanup.c
===================================================================
diff --git a/gcc/tree-cfgcleanup.c b/gcc/tree-cfgcleanup.c
--- a/gcc/tree-cfgcleanup.c	(revision 278653)
+++ b/gcc/tree-cfgcleanup.c	(revision 278653)
@@ -43,6 +43,8 @@
 #include "gimple-match.h"
 #include "gimple-fold.h"
 #include "tree-ssa-loop-niter.h"
+#include "tree-into-ssa.h"
+#include "tree-cfgcleanup.h"
 
 
 /* The set of blocks in that at least one of the following changes happened:
@@ -761,7 +763,7 @@
 /* Iterate the cfg cleanups, while anything changes.  */
 
 static bool
-cleanup_tree_cfg_1 (void)
+cleanup_tree_cfg_1 (unsigned ssa_update_flags)
 {
   bool retval = false;
   basic_block bb;
@@ -786,6 +788,8 @@
 
   /* After doing the above SSA form should be valid (or an update SSA
      should be required).  */
+  if (ssa_update_flags)
+    update_ssa (ssa_update_flags);
 
   /* Continue by iterating over all basic blocks looking for BB merging
      opportunities.  */
@@ -828,7 +832,7 @@
    Return true if the flowgraph was modified, false otherwise.  */
 
 static bool
-cleanup_tree_cfg_noloop (void)
+cleanup_tree_cfg_noloop (unsigned ssa_update_flags)
 {
   bool changed;
 
@@ -908,7 +912,7 @@
 	  }
     }
 
-  changed |= cleanup_tree_cfg_1 ();
+  changed |= cleanup_tree_cfg_1 (ssa_update_flags);
 
   gcc_assert (dom_info_available_p (CDI_DOMINATORS));
 
@@ -966,9 +970,9 @@
 /* Cleanup cfg and repair loop structures.  */
 
 bool
-cleanup_tree_cfg (void)
+cleanup_tree_cfg (unsigned ssa_update_flags)
 {
-  bool changed = cleanup_tree_cfg_noloop ();
+  bool changed = cleanup_tree_cfg_noloop (ssa_update_flags);
 
   if (current_loops != NULL
       && loops_state_satisfies_p (LOOPS_NEED_FIXUP))
Index: gcc/cfgcleanup.c
===================================================================
diff --git a/gcc/cfgcleanup.c b/gcc/cfgcleanup.c
--- a/gcc/cfgcleanup.c	(revision 278653)
+++ b/gcc/cfgcleanup.c	(revision 278653)
@@ -53,6 +53,7 @@
 #include "dce.h"
 #include "dbgcnt.h"
 #include "rtl-iter.h"
+#include "regs.h"
 
 #define FORWARDER_BLOCK_P(BB) ((BB)->flags & BB_FORWARDER_BLOCK)
 
@@ -1217,6 +1218,14 @@
 		}
 	    }
 	}
+
+      HARD_REG_SET i1_used, i2_used;
+
+      get_call_reg_set_usage (i1, &i1_used, call_used_reg_set);
+      get_call_reg_set_usage (i2, &i2_used, call_used_reg_set);
+
+      if (!hard_reg_set_equal_p (i1_used, i2_used))
+        return dir_none;
     }
 
   /* If both i1 and i2 are frame related, verify all the CFA notes
@@ -2705,23 +2714,23 @@
 
 		      if (current_ir_type () == IR_RTL_CFGLAYOUT)
 			{
-			  if (BB_FOOTER (b)
-			      && BARRIER_P (BB_FOOTER (b)))
+			  rtx_insn *insn;
+			  for (insn = BB_FOOTER (b);
+			       insn; insn = NEXT_INSN (insn))
+			    if (BARRIER_P (insn))
+			      break;
+			  if (insn)
 			    FOR_EACH_EDGE (e, ei, b->preds)
-			      if ((e->flags & EDGE_FALLTHRU)
-				  && BB_FOOTER (e->src) == NULL)
+			      if ((e->flags & EDGE_FALLTHRU))
 				{
-				  if (BB_FOOTER (b))
+				  if (BB_FOOTER (b)
+				      && BB_FOOTER (e->src) == NULL)
 				    {
 				      BB_FOOTER (e->src) = BB_FOOTER (b);
 				      BB_FOOTER (b) = NULL;
 				    }
 				  else
-				    {
-				      start_sequence ();
-				      BB_FOOTER (e->src) = emit_barrier ();
-				      end_sequence ();
-				    }
+				    emit_barrier_after_bb (e->src);
 				}
 			}
 		      else
Index: gcc/tree-ssa-pre.c
===================================================================
diff --git a/gcc/tree-ssa-pre.c b/gcc/tree-ssa-pre.c
--- a/gcc/tree-ssa-pre.c	(revision 278653)
+++ b/gcc/tree-ssa-pre.c	(revision 278653)
@@ -3919,6 +3919,13 @@
 			  continue;
 			}
 
+		      /* If the REFERENCE traps and there was a preceding
+		         point in the block that might not return avoid
+			 adding the reference to EXP_GEN.  */
+		      if (BB_MAY_NOTRETURN (block)
+			  && vn_reference_may_trap (ref))
+			continue;
+
 		      /* If the value of the reference is not invalidated in
 			 this block until it is computed, add the expression
 			 to EXP_GEN.  */
Index: gcc/tree-cfgcleanup.h
===================================================================
diff --git a/gcc/tree-cfgcleanup.h b/gcc/tree-cfgcleanup.h
--- a/gcc/tree-cfgcleanup.h	(revision 278653)
+++ b/gcc/tree-cfgcleanup.h	(revision 278653)
@@ -22,7 +22,7 @@
 
 /* In tree-cfgcleanup.c  */
 extern bitmap cfgcleanup_altered_bbs;
-extern bool cleanup_tree_cfg (void);
+extern bool cleanup_tree_cfg (unsigned = 0);
 extern bool fixup_noreturn_call (gimple *stmt);
 
 #endif /* GCC_TREE_CFGCLEANUP_H */
Index: gcc/explow.c
===================================================================
diff --git a/gcc/explow.c b/gcc/explow.c
--- a/gcc/explow.c	(revision 278653)
+++ b/gcc/explow.c	(revision 278653)
@@ -893,16 +893,7 @@
 
   tree type = TREE_TYPE (name);
   int unsignedp = TYPE_UNSIGNED (type);
-  machine_mode mode = TYPE_MODE (type);
-
-  /* Bypass TYPE_MODE when it maps vector modes to BLKmode.  */
-  if (mode == BLKmode)
-    {
-      gcc_assert (VECTOR_TYPE_P (type));
-      mode = type->type_common.mode;
-    }
-
-  machine_mode pmode = promote_mode (type, mode, &unsignedp);
+  machine_mode pmode = promote_mode (type, TYPE_MODE (type), &unsignedp);
   if (punsignedp)
     *punsignedp = unsignedp;
 
Index: gcc/tree-sra.c
===================================================================
diff --git a/gcc/tree-sra.c b/gcc/tree-sra.c
--- a/gcc/tree-sra.c	(revision 278653)
+++ b/gcc/tree-sra.c	(revision 278653)
@@ -1150,11 +1150,13 @@
   return false;
 }
 
-/* Return true if REF contains a VIEW_CONVERT_EXPR or a MEM_REF that performs
-   type conversion or a COMPONENT_REF with a bit-field field declaration.  */
+/* Return true if REF contains a VIEW_CONVERT_EXPR or a COMPONENT_REF with a
+   bit-field field declaration.  If TYPE_CHANGING_P is non-NULL, set the bool
+   it points to will be set if REF contains any of the above or a MEM_REF
+   expression that effectively performs type conversion.  */
 
 static bool
-contains_vce_or_bfcref_p (const_tree ref)
+contains_vce_or_bfcref_p (const_tree ref, bool *type_changing_p = NULL)
 {
   while (handled_component_p (ref))
     {
@@ -1161,11 +1163,16 @@
       if (TREE_CODE (ref) == VIEW_CONVERT_EXPR
 	  || (TREE_CODE (ref) == COMPONENT_REF
 	      && DECL_BIT_FIELD (TREE_OPERAND (ref, 1))))
-	return true;
+	{
+	  if (type_changing_p)
+	    *type_changing_p = true;
+	  return true;
+	}
       ref = TREE_OPERAND (ref, 0);
     }
 
-  if (TREE_CODE (ref) != MEM_REF
+  if (!type_changing_p
+      || TREE_CODE (ref) != MEM_REF
       || TREE_CODE (TREE_OPERAND (ref, 0)) != ADDR_EXPR)
     return false;
 
@@ -1172,7 +1179,7 @@
   tree mem = TREE_OPERAND (TREE_OPERAND (ref, 0), 0);
   if (TYPE_MAIN_VARIANT (TREE_TYPE (ref))
       != TYPE_MAIN_VARIANT (TREE_TYPE (mem)))
-    return true;
+    *type_changing_p = true;
 
   return false;
 }
@@ -1368,15 +1375,26 @@
       lacc->grp_assignment_write = 1;
       if (storage_order_barrier_p (rhs))
 	lacc->grp_unscalarizable_region = 1;
+
+      if (should_scalarize_away_bitmap && !is_gimple_reg_type (lacc->type))
+	{
+	  bool type_changing_p = false;
+	  contains_vce_or_bfcref_p (lhs, &type_changing_p);
+	  if (type_changing_p)
+	    bitmap_set_bit (cannot_scalarize_away_bitmap,
+			    DECL_UID (lacc->base));
+	}
     }
 
   if (racc)
     {
       racc->grp_assignment_read = 1;
-      if (should_scalarize_away_bitmap && !gimple_has_volatile_ops (stmt)
-	  && !is_gimple_reg_type (racc->type))
+      if (should_scalarize_away_bitmap && !is_gimple_reg_type (racc->type))
 	{
-	  if (contains_vce_or_bfcref_p (rhs))
+	  bool type_changing_p = false;
+	  contains_vce_or_bfcref_p (rhs, &type_changing_p);
+
+	  if (type_changing_p || gimple_has_volatile_ops (stmt))
 	    bitmap_set_bit (cannot_scalarize_away_bitmap,
 			    DECL_UID (racc->base));
 	  else
@@ -2729,8 +2747,12 @@
 
 	      rchild->grp_hint = 1;
 	      new_acc->grp_hint |= new_acc->grp_read;
-	      if (rchild->first_child)
-		ret |= propagate_subaccesses_across_link (new_acc, rchild);
+	      if (rchild->first_child
+		  && propagate_subaccesses_across_link (new_acc, rchild))
+		{
+		  ret = 1;
+		  add_access_to_work_queue (new_acc);
+		}
 	    }
 	  else
 	    {
Index: gcc/tree-predcom.c
===================================================================
diff --git a/gcc/tree-predcom.c b/gcc/tree-predcom.c
--- a/gcc/tree-predcom.c	(revision 278653)
+++ b/gcc/tree-predcom.c	(revision 278653)
@@ -1712,7 +1712,7 @@
 
   gcc_assert (!chain->has_max_use_after);
 
-  /* If loop iterates for unknown times or fewer times than chain->lenght,
+  /* If loop iterates for unknown times or fewer times than chain->length,
      we still need to setup root variable and propagate it with PHI node.  */
   tree niters = number_of_latch_executions (loop);
   if (TREE_CODE (niters) != INTEGER_CST
Index: gcc/tree-streamer-out.c
===================================================================
diff --git a/gcc/tree-streamer-out.c b/gcc/tree-streamer-out.c
--- a/gcc/tree-streamer-out.c	(revision 278653)
+++ b/gcc/tree-streamer-out.c	(revision 278653)
@@ -212,7 +212,7 @@
       bp_pack_var_len_unsigned (bp, EH_LANDING_PAD_NR (expr));
     }
 
-  if (TREE_CODE (expr) == FIELD_DECL)
+  else if (TREE_CODE (expr) == FIELD_DECL)
     {
       bp_pack_value (bp, DECL_PACKED (expr), 1);
       bp_pack_value (bp, DECL_NONADDRESSABLE_P (expr), 1);
@@ -220,12 +220,15 @@
       bp_pack_value (bp, expr->decl_common.off_align, 8);
     }
 
-  if (VAR_P (expr))
+  else if (VAR_P (expr))
     {
       bp_pack_value (bp, DECL_HAS_DEBUG_EXPR_P (expr), 1);
       bp_pack_value (bp, DECL_NONLOCAL_FRAME (expr), 1);
     }
 
+  else if (TREE_CODE (expr) == PARM_DECL)
+    bp_pack_value (bp, DECL_HIDDEN_STRING_LENGTH (expr), 1);
+
   if (TREE_CODE (expr) == RESULT_DECL
       || TREE_CODE (expr) == PARM_DECL
       || VAR_P (expr))
Index: gcc/tree-ssa-copy.c
===================================================================
diff --git a/gcc/tree-ssa-copy.c b/gcc/tree-ssa-copy.c
--- a/gcc/tree-ssa-copy.c	(revision 278653)
+++ b/gcc/tree-ssa-copy.c	(revision 278653)
@@ -545,13 +545,12 @@
 	      duplicate_ssa_name_ptr_info (copy_of[i].value,
 					   SSA_NAME_PTR_INFO (var));
 	      /* Points-to information is cfg insensitive,
-		 but alignment info might be cfg sensitive, if it
-		 e.g. is derived from VRP derived non-zero bits.
-		 So, do not copy alignment info if the two SSA_NAMEs
-		 aren't defined in the same basic block.  */
+		 but [E]VRP might record context sensitive alignment
+		 info, non-nullness, etc.  So reset context sensitive
+		 info if the two SSA_NAMEs aren't defined in the same
+		 basic block.  */
 	      if (var_bb != copy_of_bb)
-		mark_ptr_info_alignment_unknown
-				(SSA_NAME_PTR_INFO (copy_of[i].value));
+		reset_flow_sensitive_info (copy_of[i].value);
 	    }
 	  else if (!POINTER_TYPE_P (TREE_TYPE (var))
 		   && SSA_NAME_RANGE_INFO (var)
Index: gcc/tree-ssa-forwprop.c
===================================================================
diff --git a/gcc/tree-ssa-forwprop.c b/gcc/tree-ssa-forwprop.c
--- a/gcc/tree-ssa-forwprop.c	(revision 278653)
+++ b/gcc/tree-ssa-forwprop.c	(revision 278653)
@@ -2481,6 +2481,8 @@
 		  {
 		    int did_something;
 		    did_something = forward_propagate_into_comparison (&gsi);
+		    if (maybe_clean_or_replace_eh_stmt (stmt, gsi_stmt (gsi)))
+		      bitmap_set_bit (to_purge, bb->index);
 		    if (did_something == 2)
 		      cfg_changed = true;
 		    changed = did_something != 0;
Index: gcc/ggc-page.c
===================================================================
diff --git a/gcc/ggc-page.c b/gcc/ggc-page.c
--- a/gcc/ggc-page.c	(revision 278653)
+++ b/gcc/ggc-page.c	(revision 278653)
@@ -2555,6 +2555,9 @@
 
   count_old_page_tables = G.by_depth_in_use;
 
+  if (fread (&d, sizeof (d), 1, f) != 1)
+    fatal_error (input_location, "cannot read PCH file: %m");
+
   /* We've just read in a PCH file.  So, every object that used to be
      allocated is now free.  */
   clear_marks ();
@@ -2583,8 +2586,6 @@
 
   /* Allocate the appropriate page-table entries for the pages read from
      the PCH file.  */
-  if (fread (&d, sizeof (d), 1, f) != 1)
-    fatal_error (input_location, "can%'t read PCH file: %m");
 
   for (i = 0; i < NUM_ORDERS; i++)
     {
Index: gcc/varasm.c
===================================================================
diff --git a/gcc/varasm.c b/gcc/varasm.c
--- a/gcc/varasm.c	(revision 278653)
+++ b/gcc/varasm.c	(revision 278653)
@@ -1857,21 +1857,13 @@
       tree pp_val = TREE_VALUE (patchable_function_entry_attr);
       tree patchable_function_entry_value1 = TREE_VALUE (pp_val);
 
-      if (tree_fits_uhwi_p (patchable_function_entry_value1))
-	patch_area_size = tree_to_uhwi (patchable_function_entry_value1);
-      else
-	gcc_unreachable ();
-
+      patch_area_size = tree_to_uhwi (patchable_function_entry_value1);
       patch_area_entry = 0;
-      if (list_length (pp_val) > 1)
+      if (TREE_CHAIN (pp_val) != NULL_TREE)
 	{
-	  tree patchable_function_entry_value2 =
-	    TREE_VALUE (TREE_CHAIN (pp_val));
-
-	  if (tree_fits_uhwi_p (patchable_function_entry_value2))
-	    patch_area_entry = tree_to_uhwi (patchable_function_entry_value2);
-	  else
-	    gcc_unreachable ();
+	  tree patchable_function_entry_value2
+	    = TREE_VALUE (TREE_CHAIN (pp_val));
+	  patch_area_entry = tree_to_uhwi (patchable_function_entry_value2);
 	}
     }
 
@@ -1878,7 +1870,7 @@
   if (patch_area_entry > patch_area_size)
     {
       if (patch_area_size > 0)
-	warning (OPT_Wattributes, "Patchable function entry > size");
+	warning (OPT_Wattributes, "patchable function entry > size");
       patch_area_entry = 0;
     }
 
@@ -1898,7 +1890,8 @@
   /* And the area after the label.  Record it if we haven't done so yet.  */
   if (patch_area_size > patch_area_entry)
     targetm.asm_out.print_patchable_function_entry (asm_out_file,
-					     patch_area_size-patch_area_entry,
+						    patch_area_size
+						    - patch_area_entry,
 						    patch_area_entry == 0);
 
   if (lookup_attribute ("no_split_stack", DECL_ATTRIBUTES (decl)))
@@ -5292,7 +5285,7 @@
     {
       int this_time;
       int shift;
-      HOST_WIDE_INT value;
+      unsigned HOST_WIDE_INT value;
       HOST_WIDE_INT next_byte = next_offset / BITS_PER_UNIT;
       HOST_WIDE_INT next_bit = next_offset % BITS_PER_UNIT;
 
@@ -5324,15 +5317,13 @@
 	      this_time = end - shift + 1;
 	    }
 
-	  /* Now get the bits from the appropriate constant word.  */
-	  value = TREE_INT_CST_ELT (local->val, shift / HOST_BITS_PER_WIDE_INT);
-	  shift = shift & (HOST_BITS_PER_WIDE_INT - 1);
+	  /* Now get the bits we want to insert.  */
+	  value = wi::extract_uhwi (wi::to_widest (local->val),
+				    shift, this_time);
 
 	  /* Get the result.  This works only when:
 	     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
-	  local->byte |= (((value >> shift)
-			   & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
-			  << (BITS_PER_UNIT - this_time - next_bit));
+	  local->byte |= value << (BITS_PER_UNIT - this_time - next_bit);
 	}
       else
 	{
@@ -5349,15 +5340,13 @@
 	    this_time
 	      = HOST_BITS_PER_WIDE_INT - (shift & (HOST_BITS_PER_WIDE_INT - 1));
 
-	  /* Now get the bits from the appropriate constant word.  */
-	  value = TREE_INT_CST_ELT (local->val, shift / HOST_BITS_PER_WIDE_INT);
-	  shift = shift & (HOST_BITS_PER_WIDE_INT - 1);
+	  /* Now get the bits we want to insert.  */
+	  value = wi::extract_uhwi (wi::to_widest (local->val),
+				    shift, this_time);
 
 	  /* Get the result.  This works only when:
 	     1 <= this_time <= HOST_BITS_PER_WIDE_INT.  */
-	  local->byte |= (((value >> shift)
-			   & (((HOST_WIDE_INT) 2 << (this_time - 1)) - 1))
-			  << next_bit);
+	  local->byte |= value << next_bit;
 	}
 
       next_offset += this_time;
Index: gcc/ira.c
===================================================================
diff --git a/gcc/ira.c b/gcc/ira.c
--- a/gcc/ira.c	(revision 278653)
+++ b/gcc/ira.c	(revision 278653)
@@ -5147,6 +5147,8 @@
   int ira_max_point_before_emit;
   bool saved_flag_caller_saves = flag_caller_saves;
   enum ira_region saved_flag_ira_region = flag_ira_region;
+  unsigned int i;
+  int num_used_regs = 0;
 
   clear_bb_flags ();
 
@@ -5162,12 +5164,17 @@
 
   ira_conflicts_p = optimize > 0;
 
+  /* Determine the number of pseudos actually requiring coloring.  */
+  for (i = FIRST_PSEUDO_REGISTER; i < DF_REG_SIZE (df); i++)
+    num_used_regs += !!(DF_REG_USE_COUNT (i) + DF_REG_DEF_COUNT (i));
+
   /* If there are too many pseudos and/or basic blocks (e.g. 10K
      pseudos and 10K blocks or 100K pseudos and 1K blocks), we will
      use simplified and faster algorithms in LRA.  */
   lra_simple_p
     = (ira_use_lra_p
-       && max_reg_num () >= (1 << 26) / last_basic_block_for_fn (cfun));
+       && num_used_regs >= (1 << 26) / last_basic_block_for_fn (cfun));
+
   if (lra_simple_p)
     {
       /* It permits to skip live range splitting in LRA.  */
Index: gcc/rtl.c
===================================================================
diff --git a/gcc/rtl.c b/gcc/rtl.c
--- a/gcc/rtl.c	(revision 278653)
+++ b/gcc/rtl.c	(revision 278653)
@@ -731,6 +731,8 @@
     return CALL_INSN;
   if (ANY_RETURN_P (x))
     return JUMP_INSN;
+  if (GET_CODE (x) == ASM_OPERANDS && ASM_OPERANDS_LABEL_VEC (x))
+    return JUMP_INSN;
   if (GET_CODE (x) == SET)
     {
       if (GET_CODE (SET_DEST (x)) == PC)
@@ -757,6 +759,9 @@
 	  return CALL_INSN;
       if (has_return_p)
 	return JUMP_INSN;
+      if (GET_CODE (XVECEXP (x, 0, 0)) == ASM_OPERANDS
+	  && ASM_OPERANDS_LABEL_VEC (XVECEXP (x, 0, 0)))
+	return JUMP_INSN;
     }
 #ifdef GENERATOR_FILE
   if (GET_CODE (x) == MATCH_OPERAND
Index: gcc/rtl.h
===================================================================
diff --git a/gcc/rtl.h b/gcc/rtl.h
--- a/gcc/rtl.h	(revision 278653)
+++ b/gcc/rtl.h	(revision 278653)
@@ -4355,6 +4355,7 @@
 {
   switch (GET_CODE (x))
     {
+    case CONST_INT:
     case ROTATE:
     case ROTATERT:
     case SIGN_EXTRACT:
Index: gcc/dwarf2cfi.c
===================================================================
diff --git a/gcc/dwarf2cfi.c b/gcc/dwarf2cfi.c
--- a/gcc/dwarf2cfi.c	(revision 278653)
+++ b/gcc/dwarf2cfi.c	(revision 278653)
@@ -1762,7 +1762,7 @@
 
 	  /* Rule 6 */
 	case CONST_INT:
-	case POLY_INT_CST:
+	case CONST_POLY_INT:
 	  cur_trace->cfa_temp.reg = dwf_regno (dest);
 	  cur_trace->cfa_temp.offset = rtx_to_poly_int64 (src);
 	  break;
Index: gcc/tree-inline.c
===================================================================
diff --git a/gcc/tree-inline.c b/gcc/tree-inline.c
--- a/gcc/tree-inline.c	(revision 278653)
+++ b/gcc/tree-inline.c	(revision 278653)
@@ -578,6 +578,92 @@
   return new_tree;
 }
 
+/* Helper function for remap_type_2, called through walk_tree.  */
+
+static tree
+remap_type_3 (tree *tp, int *walk_subtrees, void *data)
+{
+  copy_body_data *id = (copy_body_data *) data;
+
+  if (TYPE_P (*tp))
+    *walk_subtrees = 0;
+
+  else if (DECL_P (*tp) && remap_decl (*tp, id) != *tp)
+    return *tp;
+
+  return NULL_TREE;
+}
+
+/* Return true if TYPE needs to be remapped because remap_decl on any
+   needed embedded decl returns something other than that decl.  */
+
+static bool
+remap_type_2 (tree type, copy_body_data *id)
+{
+  tree t;
+
+#define RETURN_TRUE_IF_VAR(T) \
+  do								\
+    {								\
+      tree _t = (T);						\
+      if (_t)							\
+	{							\
+	  if (DECL_P (_t) && remap_decl (_t, id) != _t)		\
+	    return true;					\
+	  if (!TYPE_SIZES_GIMPLIFIED (type)			\
+	      && walk_tree (&_t, remap_type_3, id, NULL))	\
+	    return true;					\
+	}							\
+    }								\
+  while (0)
+
+  switch (TREE_CODE (type))
+    {
+    case POINTER_TYPE:
+    case REFERENCE_TYPE:
+    case FUNCTION_TYPE:
+    case METHOD_TYPE:
+      return remap_type_2 (TREE_TYPE (type), id);
+
+    case INTEGER_TYPE:
+    case REAL_TYPE:
+    case FIXED_POINT_TYPE:
+    case ENUMERAL_TYPE:
+    case BOOLEAN_TYPE:
+      RETURN_TRUE_IF_VAR (TYPE_MIN_VALUE (type));
+      RETURN_TRUE_IF_VAR (TYPE_MAX_VALUE (type));
+      return false;
+
+    case ARRAY_TYPE:
+      if (remap_type_2 (TREE_TYPE (type), id)
+	  || (TYPE_DOMAIN (type) && remap_type_2 (TYPE_DOMAIN (type), id)))
+	return true;
+      break;
+
+    case RECORD_TYPE:
+    case UNION_TYPE:
+    case QUAL_UNION_TYPE:
+      for (t = TYPE_FIELDS (type); t; t = DECL_CHAIN (t))
+	if (TREE_CODE (t) == FIELD_DECL)
+	  {
+	    RETURN_TRUE_IF_VAR (DECL_FIELD_OFFSET (t));
+	    RETURN_TRUE_IF_VAR (DECL_SIZE (t));
+	    RETURN_TRUE_IF_VAR (DECL_SIZE_UNIT (t));
+	    if (TREE_CODE (type) == QUAL_UNION_TYPE)
+	      RETURN_TRUE_IF_VAR (DECL_QUALIFIER (t));
+	  }
+      break;
+
+    default:
+      return false;
+    }
+
+  RETURN_TRUE_IF_VAR (TYPE_SIZE (type));
+  RETURN_TRUE_IF_VAR (TYPE_SIZE_UNIT (type));
+  return false;
+#undef RETURN_TRUE_IF_VAR
+}
+
 tree
 remap_type (tree type, copy_body_data *id)
 {
@@ -593,7 +679,10 @@
     return *node;
 
   /* The type only needs remapping if it's variably modified.  */
-  if (! variably_modified_type_p (type, id->src_fn))
+  if (! variably_modified_type_p (type, id->src_fn)
+      /* Don't remap if copy_decl method doesn't always return a new
+	 decl and for all embedded decls returns the passed in decl.  */
+      || (id->dont_remap_vla_if_no_change && !remap_type_2 (type, id)))
     {
       insert_decl_map (id, type, type);
       return type;
@@ -868,7 +957,12 @@
   bool existed;
   unsigned short &newc = id->dependence_map->get_or_insert (clique, &existed);
   if (!existed)
-    newc = ++cfun->last_clique;
+    {
+      /* Clique 1 is reserved for local ones set by PTA.  */
+      if (cfun->last_clique == 0)
+	cfun->last_clique = 1;
+      newc = ++cfun->last_clique;
+    }
   return newc;
 }
 
@@ -2651,7 +2745,11 @@
 	      dest_loop->simduid = remap_decl (src_loop->simduid, id);
 	      cfun->has_simduid_loops = true;
 	    }
-
+	  if (id->src_cfun->last_clique != 0)
+	    dest_loop->owned_clique
+	      = remap_dependence_clique (id,
+					 src_loop->owned_clique
+					 ? src_loop->owned_clique : 1);
 	  /* Recurse.  */
 	  copy_loops (id, dest_loop, src_loop);
 	}
@@ -5539,6 +5637,10 @@
   if (CODE_CONTAINS_STRUCT (TREE_CODE (copy), TS_DECL_WRTL)
       && !TREE_STATIC (copy) && !DECL_EXTERNAL (copy))
     SET_DECL_RTL (copy, 0);
+  /* For vector typed decls make sure to update DECL_MODE according
+     to the new function context.  */
+  if (VECTOR_TYPE_P (TREE_TYPE (copy)))
+    SET_DECL_MODE (copy, TYPE_MODE (TREE_TYPE (copy)));
 
   /* These args would always appear unused, if not for this.  */
   TREE_USED (copy) = 1;
Index: gcc/tree-inline.h
===================================================================
diff --git a/gcc/tree-inline.h b/gcc/tree-inline.h
--- a/gcc/tree-inline.h	(revision 278653)
+++ b/gcc/tree-inline.h	(revision 278653)
@@ -119,6 +119,13 @@
   /* > 0 if we are remapping a type currently.  */
   int remapping_type_depth;
 
+  /* Usually copy_decl callback always creates new decls, in that case
+     we want to remap all variably_modified_type_p types.  If this flag
+     is set, remap_type will do further checks to see if remap_decl
+     of any decls mentioned in the type will remap to anything but itself
+     and only in that case will actually remap the type.  */
+  bool dont_remap_vla_if_no_change;
+
   /* A function to be called when duplicating BLOCK nodes.  */
   void (*transform_lang_insert_block) (tree);
 
Index: gcc/omp-simd-clone.c
===================================================================
diff --git a/gcc/omp-simd-clone.c b/gcc/omp-simd-clone.c
--- a/gcc/omp-simd-clone.c	(revision 278653)
+++ b/gcc/omp-simd-clone.c	(revision 278653)
@@ -868,6 +868,18 @@
 
   if (tp != orig_tp)
     {
+      if (gimple_code (info->stmt) == GIMPLE_PHI
+	  && cand
+	  && TREE_CODE (*orig_tp) == ADDR_EXPR
+	  && TREE_CODE (TREE_OPERAND (*orig_tp, 0)) == PARM_DECL
+	  && cand->alias_ptr_type)
+	{
+	  gcc_assert (TREE_CODE (cand->alias_ptr_type) == SSA_NAME);
+	  *orig_tp = cand->alias_ptr_type;
+	  info->modified = true;
+	  return NULL_TREE;
+	}
+
       repl = build_fold_addr_expr (repl);
       gimple *stmt;
       if (is_gimple_debug (info->stmt))
@@ -884,7 +896,18 @@
 	  stmt = gimple_build_assign (make_ssa_name (TREE_TYPE (repl)), repl);
 	  repl = gimple_assign_lhs (stmt);
 	}
-      gimple_stmt_iterator gsi = gsi_for_stmt (info->stmt);
+      gimple_stmt_iterator gsi;
+      if (gimple_code (info->stmt) == GIMPLE_PHI)
+	{
+	  gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));
+	  /* Cache SSA_NAME for next time.  */
+	  if (cand
+	      && TREE_CODE (*orig_tp) == ADDR_EXPR
+	      && TREE_CODE (TREE_OPERAND (*orig_tp, 0)) == PARM_DECL)
+	    cand->alias_ptr_type = repl;
+	}
+      else
+	gsi = gsi_for_stmt (info->stmt);
       gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);
       *orig_tp = repl;
     }
@@ -985,6 +1008,31 @@
     {
       gimple_stmt_iterator gsi;
 
+      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))
+	{
+	  gphi *phi = as_a <gphi *> (gsi_stmt (gsi));
+	  int i, n = gimple_phi_num_args (phi);
+	  info.stmt = phi;
+	  struct walk_stmt_info wi;
+	  memset (&wi, 0, sizeof (wi));
+	  info.modified = false;
+	  wi.info = &info;
+	  for (i = 0; i < n; ++i)
+	    {
+	      int walk_subtrees = 1;
+	      tree arg = gimple_phi_arg_def (phi, i);
+	      tree op = arg;
+	      ipa_simd_modify_stmt_ops (&op, &walk_subtrees, &wi);
+	      if (op != arg)
+		{
+		  SET_PHI_ARG_DEF (phi, i, op);
+		  gcc_assert (TREE_CODE (op) == SSA_NAME);
+		  if (gimple_phi_arg_edge (phi, i)->flags & EDGE_ABNORMAL)
+		    SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op) = 1;
+		}
+	    }
+	}
+
       gsi = gsi_start_bb (bb);
       while (!gsi_end_p (gsi))
 	{
Index: gcc/tree-streamer-in.c
===================================================================
diff --git a/gcc/tree-streamer-in.c b/gcc/tree-streamer-in.c
--- a/gcc/tree-streamer-in.c	(revision 278653)
+++ b/gcc/tree-streamer-in.c	(revision 278653)
@@ -252,7 +252,7 @@
       LABEL_DECL_UID (expr) = -1;
     }
 
-  if (TREE_CODE (expr) == FIELD_DECL)
+  else if (TREE_CODE (expr) == FIELD_DECL)
     {
       DECL_PACKED (expr) = (unsigned) bp_unpack_value (bp, 1);
       DECL_NONADDRESSABLE_P (expr) = (unsigned) bp_unpack_value (bp, 1);
@@ -260,12 +260,15 @@
       expr->decl_common.off_align = bp_unpack_value (bp, 8);
     }
 
-  if (VAR_P (expr))
+  else if (VAR_P (expr))
     {
       DECL_HAS_DEBUG_EXPR_P (expr) = (unsigned) bp_unpack_value (bp, 1);
       DECL_NONLOCAL_FRAME (expr) = (unsigned) bp_unpack_value (bp, 1);
     }
 
+  else if (TREE_CODE (expr) == PARM_DECL)
+    DECL_HIDDEN_STRING_LENGTH (expr) = (unsigned) bp_unpack_value (bp, 1);
+
   if (TREE_CODE (expr) == RESULT_DECL
       || TREE_CODE (expr) == PARM_DECL
       || VAR_P (expr))
Index: gcc/symtab.c
===================================================================
diff --git a/gcc/symtab.c b/gcc/symtab.c
--- a/gcc/symtab.c	(revision 278653)
+++ b/gcc/symtab.c	(revision 278653)
@@ -1546,7 +1546,7 @@
 void
 symtab_node::set_section (const char *section)
 {
-  gcc_assert (!this->alias);
+  gcc_assert (!this->alias || !this->analyzed);
   call_for_symbol_and_aliases
     (symtab_node::set_section, const_cast<char *>(section), true);
 }
Index: gcc/tree-ssa-phiprop.c
===================================================================
diff --git a/gcc/tree-ssa-phiprop.c b/gcc/tree-ssa-phiprop.c
--- a/gcc/tree-ssa-phiprop.c	(revision 278653)
+++ b/gcc/tree-ssa-phiprop.c	(revision 278653)
@@ -338,8 +338,15 @@
 	    && (!type
 		|| types_compatible_p
 		     (TREE_TYPE (gimple_assign_lhs (use_stmt)), type))
-	    /* We cannot replace a load that may throw or is volatile.  */
-	    && !stmt_can_throw_internal (use_stmt)))
+	    /* We cannot replace a load that may throw or is volatile.
+	       For volatiles the transform can change the number of
+	       executions if the load is inside a loop but the address
+	       computations outside (PR91812).  We could relax this
+	       if we guard against that appropriately.  For loads that can
+	       throw we could relax things if the moved loads all are
+	       known to not throw.  */
+	    && !stmt_can_throw_internal (use_stmt)
+	    && !gimple_has_volatile_ops (use_stmt)))
 	continue;
 
       /* Check if we can move the loads.  The def stmt of the virtual use
Index: gcc/tree-object-size.c
===================================================================
diff --git a/gcc/tree-object-size.c b/gcc/tree-object-size.c
--- a/gcc/tree-object-size.c	(revision 278653)
+++ b/gcc/tree-object-size.c	(revision 278653)
@@ -899,6 +899,9 @@
   else
     expr_object_size (osi, var, then_);
 
+  if (object_sizes[object_size_type][varno] == unknown[object_size_type])
+    return reexamine;
+
   if (TREE_CODE (else_) == SSA_NAME)
     reexamine |= merge_object_sizes (osi, var, else_, 0);
   else
Index: gcc/tree-outof-ssa.c
===================================================================
diff --git a/gcc/tree-outof-ssa.c b/gcc/tree-outof-ssa.c
--- a/gcc/tree-outof-ssa.c	(revision 278653)
+++ b/gcc/tree-outof-ssa.c	(revision 278653)
@@ -651,6 +651,8 @@
   tree type = TREE_TYPE (name);
   int unsignedp;
   machine_mode reg_mode = promote_ssa_mode (name, &unsignedp);
+  if (reg_mode == BLKmode)
+    return assign_temp (type, 0, 0);
   rtx x = gen_reg_rtx (reg_mode);
   if (POINTER_TYPE_P (type))
     mark_reg_pointer (x, TYPE_ALIGN (TREE_TYPE (type)));
Index: gcc/vr-values.c
===================================================================
diff --git a/gcc/vr-values.c b/gcc/vr-values.c
--- a/gcc/vr-values.c	(revision 278653)
+++ b/gcc/vr-values.c	(revision 278653)
@@ -211,8 +211,13 @@
 	 the same.  We may not have is_new when transitioning to
 	 UNDEFINED.  If old_vr->type is VARYING, we shouldn't be
 	 called.  */
-      if (new_vr->type == VR_UNDEFINED)
+      if (old_vr->type == VR_VARYING)
 	{
+	  set_value_range_to_varying (new_vr);
+	  is_new = false;
+	}
+      else if (new_vr->type == VR_UNDEFINED)
+	{
 	  BITMAP_FREE (new_vr->equiv);
 	  set_value_range_to_varying (old_vr);
 	  set_value_range_to_varying (new_vr);
Index: gcc/resource.c
===================================================================
diff --git a/gcc/resource.c b/gcc/resource.c
--- a/gcc/resource.c	(revision 278653)
+++ b/gcc/resource.c	(revision 278653)
@@ -969,9 +969,13 @@
     {
       regset regs_live = DF_LR_IN (BASIC_BLOCK_FOR_FN (cfun, b));
       rtx_insn *start_insn, *stop_insn;
+      df_ref def;
 
       /* Compute hard regs live at start of block.  */
       REG_SET_TO_HARD_REG_SET (current_live_regs, regs_live);
+      FOR_EACH_ARTIFICIAL_DEF (def, b)
+	if (DF_REF_FLAGS (def) & DF_REF_AT_TOP)
+	  SET_HARD_REG_BIT (current_live_regs, DF_REF_REGNO (def));
 
       /* Get starting and ending insn, handling the case where each might
 	 be a SEQUENCE.  */
Index: gcc/var-tracking.c
===================================================================
diff --git a/gcc/var-tracking.c b/gcc/var-tracking.c
--- a/gcc/var-tracking.c	(revision 278653)
+++ b/gcc/var-tracking.c	(revision 278653)
@@ -8491,7 +8491,7 @@
 
       /* Invalid SUBREGs are ok in debug info.  ??? We could try
 	 alternate expansions for the VALUE as well.  */
-      if (!result)
+      if (!result && GET_MODE (subreg) != VOIDmode)
 	result = gen_rtx_raw_SUBREG (GET_MODE (x), subreg, SUBREG_BYTE (x));
 
       return result;
Index: gcc/cfgloop.h
===================================================================
diff --git a/gcc/cfgloop.h b/gcc/cfgloop.h
--- a/gcc/cfgloop.h	(revision 278653)
+++ b/gcc/cfgloop.h	(revision 278653)
@@ -227,6 +227,10 @@
      Other values means unroll with the given unrolling factor.  */
   unsigned short unroll;
 
+  /* If this loop was inlined the main clique of the callee which does
+     not need remapping when copying the loop body.  */
+  unsigned short owned_clique;
+
   /* For SIMD loops, this is a unique identifier of the loop, referenced
      by IFN_GOMP_SIMD_VF, IFN_GOMP_SIMD_LANE and IFN_GOMP_SIMD_LAST_LANE
      builtins.  */
Index: gcc/config.gcc
===================================================================
diff --git a/gcc/config.gcc b/gcc/config.gcc
--- a/gcc/config.gcc	(revision 278653)
+++ b/gcc/config.gcc	(revision 278653)
@@ -647,7 +647,7 @@
 # Common parts for widely ported systems.
 case ${target} in
 *-*-darwin*)
-  tmake_file="t-darwin ${cpu_type}/t-darwin"
+  tmake_file="t-darwin "
   tm_file="${tm_file} darwin.h"
   case ${target} in
   *-*-darwin9*)
@@ -1479,16 +1479,25 @@
 		dwarf2=no
 	fi
 	;;
+i[34567]86-*-darwin1[89]*)
+	echo "Error: 32bit target is not supported after Darwin17" 1>&2
+	;;
 i[34567]86-*-darwin*)
 	need_64bit_isa=yes
 	# Baseline choice for a machine that allows m64 support.
 	with_cpu=${with_cpu:-core2}
+	tmake_file="${tmake_file} ${cpu_type}/t-darwin32-biarch t-slibgcc"
+	tm_file="${tm_file} ${cpu_type}/darwin32-biarch.h"
+	;;
+x86_64-*-darwin1[89]* | x86_64-*-darwin2[01]*)
+	# Only 64b from now
+	with_cpu=${with_cpu:-core2}
 	tmake_file="${tmake_file} t-slibgcc"
 	;;
 x86_64-*-darwin*)
 	with_cpu=${with_cpu:-core2}
-	tmake_file="${tmake_file} ${cpu_type}/t-darwin64 t-slibgcc"
-	tm_file="${tm_file} ${cpu_type}/darwin64.h"
+	tmake_file="${tmake_file} ${cpu_type}/t-darwin64-biarch t-slibgcc"
+	tm_file="${tm_file} ${cpu_type}/darwin64-biarch.h"
 	;;
 i[34567]86-*-elfiamcu)
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/iamcu.h"
@@ -2386,16 +2395,23 @@
 #	extra_headers=
 #	;;
 powerpc-*-darwin*)
-	extra_options="${extra_options} rs6000/darwin.opt"
+	extra_options="${extra_options} ${cpu_type}/darwin.opt"
 	case ${target} in
-	  *-darwin1[0-9]* | *-darwin[8-9]*)
-	    tmake_file="${tmake_file} rs6000/t-darwin8"
-	    tm_file="${tm_file} rs6000/darwin8.h"
+	  *-darwin1[0-9]* | *-darwin9*)
+	    tmake_file="${tmake_file} ${cpu_type}/t-darwin32-biarch"
+	    tm_file="${tm_file} ${cpu_type}/darwin32-biarch.h"
 	    ;;
+	  *-darwin8*)
+	    tmake_file="${tmake_file} ${cpu_type}/t-darwin32-biarch"
+	    tm_file="${tm_file} ${cpu_type}/darwin32-biarch.h"
+	    tm_file="${tm_file} ${cpu_type}/darwin8.h"
+	    ;;
 	  *-darwin7*)
-	    tm_file="${tm_file} rs6000/darwin7.h"
+	    tm_file="${tm_file} ${cpu_type}/darwin7.h"
 	    ;;
-	  *-darwin[0-6]*)
+	  *-darwin[456]*)
+	    # Earlier - ingle arch, with 32b only
+	    # OS X 10.0, the first edition is Darwin4
 	    ;;
 	esac
 	tmake_file="${tmake_file} t-slibgcc"
@@ -2403,8 +2419,8 @@
 	;;
 powerpc64-*-darwin*)
 	extra_options="${extra_options} ${cpu_type}/darwin.opt"
-	tmake_file="${tmake_file} ${cpu_type}/t-darwin64 t-slibgcc"
-	tm_file="${tm_file} ${cpu_type}/darwin8.h ${cpu_type}/darwin64.h"
+	tmake_file="${tmake_file} ${cpu_type}/t-darwin64-biarch t-slibgcc"
+	tm_file="${tm_file} ${cpu_type}/darwin64-biarch.h"
 	extra_headers=altivec.h
 	;;
 powerpc*-*-freebsd*)
@@ -4447,14 +4463,12 @@
 			 echo "#undef  LINK_OS_EXTRA_SPEC32"
 			 echo "#define LINK_OS_EXTRA_SPEC32" \
 			      "\"%(link_os_new_dtags)" \
-			      "-rpath $prefix/lib -rpath $at/lib" \
-			      "-L $prefix/lib -L $at/lib\""
+			      "-rpath $prefix/lib -rpath $at/lib\""
 			 echo
 			 echo "#undef  LINK_OS_EXTRA_SPEC64"
 			 echo "#define LINK_OS_EXTRA_SPEC64" \
 			      "\"%(link_os_new_dtags)" \
-			      "-rpath $prefix/lib64 -rpath $at/lib64" \
-			      "-L $prefix/lib64 -L $at/lib64\""
+			      "-rpath $prefix/lib64 -rpath $at/lib64\""
 			 echo
 			 echo "#undef  LINK_OS_NEW_DTAGS_SPEC"
 			 echo "#define LINK_OS_NEW_DTAGS_SPEC" \
@@ -4467,7 +4481,10 @@
 			 echo "#define MD_EXEC_PREFIX \"$at/bin/\""
 			 echo
 			 echo "#undef  MD_STARTFILE_PREFIX"
-			 echo "#define MD_STARTFILE_PREFIX \"$at/lib/\"") \
+			 echo "#define MD_STARTFILE_PREFIX \"$prefix/lib/\""
+			 echo
+			 echo "#undef  MD_STARTFILE_PREFIX_1"
+			 echo "#define MD_STARTFILE_PREFIX_1 \"$at/lib/\"") \
 			    > advance-toolchain.h
 		    else
 			echo "Unknown advance-toolchain $with_advance_toolchain"
@@ -4676,8 +4693,11 @@
 		;;
 	i[34567]86-*-dragonfly* | x86_64-*-dragonfly*)
 		;;
-	i[34567]86-*-freebsd* | x86_64-*-freebsd*)
+	i[34567]86-*-freebsd*)
 		;;
+	x86_64-*-freebsd*)
+		tmake_file="${tmake_file} i386/t-freebsd64"
+		;;
 	ia64*-*-linux*)
 		;;
 
Index: gcc/opts-global.c
===================================================================
diff --git a/gcc/opts-global.c b/gcc/opts-global.c
--- a/gcc/opts-global.c	(revision 278653)
+++ b/gcc/opts-global.c	(revision 278653)
@@ -103,10 +103,14 @@
 	   text, bad_lang);
   else if (lang_mask == CL_DRIVER)
     gcc_unreachable ();
-  else
+  else if (ok_langs[0] != '\0')
     /* Eventually this should become a hard error IMO.  */
     warning (0, "command line option %qs is valid for %s but not for %s",
 	     text, ok_langs, bad_lang);
+  else
+    /* Happens for -Werror=warning_name.  */
+    warning (0, "%<-Werror=%> argument %qs is not valid for %s",
+	     text, bad_lang);
 
   free (ok_langs);
   free (bad_lang);
Index: gcc/Makefile.in
===================================================================
diff --git a/gcc/Makefile.in b/gcc/Makefile.in
--- a/gcc/Makefile.in	(revision 278653)
+++ b/gcc/Makefile.in	(revision 278653)
@@ -1114,6 +1114,7 @@
 # Support for additional languages (other than C).
 # C can be supported this way too (leave for later).
 
+LANG_CONFIGUREFRAGS  = @all_lang_configurefrags@
 LANG_MAKEFRAGS = @all_lang_makefrags@
 
 # Used by gcc/jit/Make-lang.in
@@ -1877,7 +1878,7 @@
 # Really, really stupid make features, such as SUN's KEEP_STATE, may force
 # a target to build even if it is up-to-date.  So we must verify that
 # config.status does not exist before failing.
-config.status: $(srcdir)/configure $(srcdir)/config.gcc
+config.status: $(srcdir)/configure $(srcdir)/config.gcc $(LANG_CONFIGUREFRAGS)
 	@if [ ! -f config.status ] ; then \
 	  echo You must configure gcc.  Look at http://gcc.gnu.org/install/ for details.; \
 	  false; \
Index: gcc/tree-ssa-structalias.c
===================================================================
diff --git a/gcc/tree-ssa-structalias.c b/gcc/tree-ssa-structalias.c
--- a/gcc/tree-ssa-structalias.c	(revision 278653)
+++ b/gcc/tree-ssa-structalias.c	(revision 278653)
@@ -3232,9 +3232,29 @@
       return;
     }
 
-  /* Pretend to take the address of the base, we'll take care of
-     adding the required subset of sub-fields below.  */
-  get_constraint_for_1 (t, results, true, lhs_p);
+  /* Avoid creating pointer-offset constraints, so handle MEM_REF
+     offsets directly.  Pretend to take the address of the base,
+     we'll take care of adding the required subset of sub-fields below.  */
+  if (TREE_CODE (t) == MEM_REF
+      && !integer_zerop (TREE_OPERAND (t, 0)))
+    {
+      poly_offset_int off = mem_ref_offset (t);
+      off <<= LOG2_BITS_PER_UNIT;
+      off += bitpos;
+      poly_int64 off_hwi;
+      if (off.to_shwi (&off_hwi))
+	bitpos = off_hwi;
+      else
+	{
+	  bitpos = 0;
+	  bitmaxsize = -1;
+	}
+      get_constraint_for_1 (TREE_OPERAND (t, 0), results, false, lhs_p);
+      do_deref (results);
+    }
+  else
+    get_constraint_for_1 (t, results, true, lhs_p);
+
   /* Strip off nothing_id.  */
   if (results->length () == 2)
     {
@@ -7461,7 +7481,11 @@
       if (MR_DEPENDENCE_CLIQUE (ref) == 0)
 	{
 	  if (clique == 0)
-	    clique = ++cfun->last_clique;
+	    {
+	      if (cfun->last_clique == 0)
+		cfun->last_clique = 1;
+	      clique = 1;
+	    }
 	  if (restrict_var->ruid == 0)
 	    restrict_var->ruid = ++last_ruid;
 	  MR_DEPENDENCE_CLIQUE (ref) = clique;
@@ -7472,6 +7496,23 @@
   return false;
 }
 
+/* Clear dependence info for the clique DATA.  */
+
+static bool
+clear_dependence_clique (gimple *, tree base, tree, void *data)
+{
+  unsigned short clique = (uintptr_t)data;
+  if ((TREE_CODE (base) == MEM_REF
+       || TREE_CODE (base) == TARGET_MEM_REF)
+      && MR_DEPENDENCE_CLIQUE (base) == clique)
+    {
+      MR_DEPENDENCE_CLIQUE (base) = 0;
+      MR_DEPENDENCE_BASE (base) = 0;
+    }
+
+  return false;
+}
+
 /* Compute the set of independend memory references based on restrict
    tags and their conservative propagation to the points-to sets.  */
 
@@ -7478,6 +7519,19 @@
 static void
 compute_dependence_clique (void)
 {
+  /* First clear the special "local" clique.  */
+  basic_block bb;
+  if (cfun->last_clique != 0)
+    FOR_EACH_BB_FN (bb, cfun)
+      for (gimple_stmt_iterator gsi = gsi_start_bb (bb);
+	   !gsi_end_p (gsi); gsi_next (&gsi))
+	{
+	  gimple *stmt = gsi_stmt (gsi);
+	  walk_stmt_load_store_ops (stmt, (void *)(uintptr_t) 1,
+				    clear_dependence_clique,
+				    clear_dependence_clique);
+	}
+
   unsigned short clique = 0;
   unsigned short last_ruid = 0;
   bitmap rvars = BITMAP_ALLOC (NULL);
@@ -7552,7 +7606,10 @@
 	    }
 	  if (used)
 	    {
-	      bitmap_set_bit (rvars, restrict_var->id);
+	      /* Add all subvars to the set of restrict pointed-to set. */
+	      for (unsigned sv = restrict_var->head; sv != 0;
+		   sv = get_varinfo (sv)->next)
+		bitmap_set_bit (rvars, sv);
 	      varinfo_t escaped = get_varinfo (find (escaped_id));
 	      if (bitmap_bit_p (escaped->solution, restrict_var->id))
 		escaped_p = true;
Index: gcc/tree-core.h
===================================================================
diff --git a/gcc/tree-core.h b/gcc/tree-core.h
--- a/gcc/tree-core.h	(revision 278653)
+++ b/gcc/tree-core.h	(revision 278653)
@@ -997,7 +997,9 @@
        expression trees and specify known data non-dependences.  For
        two memory references in a function they are known to not
        alias if dependence_info.clique are equal and dependence_info.base
-       are distinct.  */
+       are distinct.  Clique number zero means there is no information,
+       clique number one is populated from function global information
+       and thus needs no remapping on transforms like loop unrolling.  */
     struct {
       unsigned short clique;
       unsigned short base;
@@ -1644,6 +1646,7 @@
   /* In a VAR_DECL and PARM_DECL, this is DECL_READ_P.  */
   unsigned decl_read_flag : 1;
   /* In a VAR_DECL or RESULT_DECL, this is DECL_NONSHAREABLE.  */
+  /* In a PARM_DECL, this is DECL_HIDDEN_STRING_LENGTH.  */
   unsigned decl_nonshareable_flag : 1;
 
   /* DECL_OFFSET_ALIGN, used only for FIELD_DECLs.  */
Index: gcc/tree-cfg.c
===================================================================
diff --git a/gcc/tree-cfg.c b/gcc/tree-cfg.c
--- a/gcc/tree-cfg.c	(revision 278653)
+++ b/gcc/tree-cfg.c	(revision 278653)
@@ -2307,7 +2307,7 @@
 		  new_bb = single_succ (new_bb);
 		  gcc_assert (new_bb != bb);
 		}
-	      new_gsi = gsi_start_bb (new_bb);
+	      new_gsi = gsi_after_labels (new_bb);
 	      gsi_remove (&i, false);
 	      gsi_insert_before (&new_gsi, stmt, GSI_NEW_STMT);
 	    }
@@ -6308,7 +6308,7 @@
    preserve SSA form.  */
 
 static basic_block
-gimple_duplicate_bb (basic_block bb)
+gimple_duplicate_bb (basic_block bb, copy_bb_data *id)
 {
   basic_block new_bb;
   gimple_stmt_iterator gsi_tgt;
@@ -6372,6 +6372,39 @@
 	      && (!VAR_P (base) || !DECL_HAS_VALUE_EXPR_P (base)))
 	    DECL_NONSHAREABLE (base) = 1;
 	}
+ 
+      /* If requested remap dependence info of cliques brought in
+         via inlining.  */
+      if (id)
+	for (unsigned i = 0; i < gimple_num_ops (copy); ++i)
+	  {
+	    tree op = gimple_op (copy, i);
+	    if (!op)
+	      continue;
+	    if (TREE_CODE (op) == ADDR_EXPR
+		|| TREE_CODE (op) == WITH_SIZE_EXPR)
+	      op = TREE_OPERAND (op, 0);
+	    while (handled_component_p (op))
+	      op = TREE_OPERAND (op, 0);
+	    if ((TREE_CODE (op) == MEM_REF
+		 || TREE_CODE (op) == TARGET_MEM_REF)
+		&& MR_DEPENDENCE_CLIQUE (op) > 1
+		&& MR_DEPENDENCE_CLIQUE (op) != bb->loop_father->owned_clique)
+	      {
+		if (!id->dependence_map)
+		  id->dependence_map = new hash_map<dependence_hash,
+						    unsigned short>;
+		bool existed;
+		unsigned short &newc = id->dependence_map->get_or_insert
+		    (MR_DEPENDENCE_CLIQUE (op), &existed);
+		if (!existed)
+		  {
+		    gcc_assert (MR_DEPENDENCE_CLIQUE (op) <= cfun->last_clique);
+		    newc = ++cfun->last_clique;
+		  }
+		MR_DEPENDENCE_CLIQUE (op) = newc;
+	      }
+	  }
 
       /* Create new names for all the definitions created by COPY and
 	 add replacement mappings for each new name.  */
@@ -7199,7 +7232,14 @@
       if (virtual_operand_p (op))
 	{
 	  /* Remove the phi nodes for virtual operands (alias analysis will be
-	     run for the new function, anyway).  */
+	     run for the new function, anyway).  But replace all uses that
+	     might be outside of the region we move.  */
+	  use_operand_p use_p;
+	  imm_use_iterator iter;
+	  gimple *use_stmt;
+	  FOR_EACH_IMM_USE_STMT (use_stmt, iter, op)
+	    FOR_EACH_IMM_USE_ON_STMT (use_p, iter)
+	      SET_USE (use_p, SSA_NAME_VAR (op));
           remove_phi_node (&psi, true);
 	  continue;
 	}
Index: gcc/passes.c
===================================================================
diff --git a/gcc/passes.c b/gcc/passes.c
--- a/gcc/passes.c	(revision 278653)
+++ b/gcc/passes.c	(revision 278653)
@@ -1944,7 +1944,7 @@
   /* Always cleanup the CFG before trying to update SSA.  */
   if (flags & TODO_cleanup_cfg)
     {
-      cleanup_tree_cfg ();
+      cleanup_tree_cfg (flags & TODO_update_ssa_any);
 
       /* When cleanup_tree_cfg merges consecutive blocks, it may
 	 perform some simplistic propagation when removing single
Index: gcc/tree-ssa-reassoc.c
===================================================================
diff --git a/gcc/tree-ssa-reassoc.c b/gcc/tree-ssa-reassoc.c
--- a/gcc/tree-ssa-reassoc.c	(revision 278653)
+++ b/gcc/tree-ssa-reassoc.c	(revision 278653)
@@ -2143,7 +2143,8 @@
 	  exp_type = boolean_type_node;
 	}
 
-      if (TREE_CODE (arg0) != SSA_NAME)
+      if (TREE_CODE (arg0) != SSA_NAME
+	  || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (arg0))
 	break;
       loc = gimple_location (stmt);
       switch (code)
@@ -4768,6 +4769,7 @@
       else
 	{
 	  stmts[i] = build_and_add_sum (TREE_TYPE (last_rhs1), op1, op2, opcode);
+	  gimple_set_visited (stmts[i], true);
 	}
       if (dump_file && (dump_flags & TDF_DETAILS))
 	{
Index: gcc/config/nvptx/nvptx.c
===================================================================
diff --git a/gcc/config/nvptx/nvptx.c b/gcc/config/nvptx/nvptx.c
--- a/gcc/config/nvptx/nvptx.c	(revision 278653)
+++ b/gcc/config/nvptx/nvptx.c	(revision 278653)
@@ -1377,7 +1377,7 @@
       fputs (";\n", file);
       if (!CONST_INT_P (size) || UINTVAL (align) > GET_MODE_SIZE (DImode))
 	fprintf (file,
-		 "\t\tand.u%d %%r%d, %%r%d, -" HOST_WIDE_INT_PRINT_DEC ";\n",
+		 "\t\tand.b%d %%r%d, %%r%d, -" HOST_WIDE_INT_PRINT_DEC ";\n",
 		 bits, regno, regno, UINTVAL (align));
     }
   if (cfun->machine->has_softstack)
Index: gcc/config/alpha/alpha.c
===================================================================
diff --git a/gcc/config/alpha/alpha.c b/gcc/config/alpha/alpha.c
--- a/gcc/config/alpha/alpha.c	(revision 278653)
+++ b/gcc/config/alpha/alpha.c	(revision 278653)
@@ -8835,6 +8835,9 @@
 		    case CODE_LABEL:
 		      goto close_shadow;
 
+		    case DEBUG_INSN:
+		      break;
+
 		    default:
 		      gcc_unreachable ();
 		    }
Index: gcc/config/alpha/alpha.h
===================================================================
diff --git a/gcc/config/alpha/alpha.h b/gcc/config/alpha/alpha.h
--- a/gcc/config/alpha/alpha.h	(revision 278653)
+++ b/gcc/config/alpha/alpha.h	(revision 278653)
@@ -678,7 +678,7 @@
 
 #define CONSTANT_ADDRESS_P(X)   \
   (CONST_INT_P (X)		\
-   && (unsigned HOST_WIDE_INT) (INTVAL (X) + 0x8000) < 0x10000)
+   && (UINTVAL (X) + 0x8000) < 0x10000)
 
 /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx
    and check its validity for a certain class.
Index: gcc/config/s390/s390-c.c
===================================================================
diff --git a/gcc/config/s390/s390-c.c b/gcc/config/s390/s390-c.c
--- a/gcc/config/s390/s390-c.c	(revision 278653)
+++ b/gcc/config/s390/s390-c.c	(revision 278653)
@@ -477,16 +477,30 @@
     case S390_OVERLOADED_BUILTIN_s390_vec_xl:
     case S390_OVERLOADED_BUILTIN_s390_vec_xld2:
     case S390_OVERLOADED_BUILTIN_s390_vec_xlw4:
-      return build2 (MEM_REF, return_type,
-		     fold_build_pointer_plus ((*arglist)[1], (*arglist)[0]),
-		     build_int_cst (TREE_TYPE ((*arglist)[1]), 0));
+      {
+	/* Build a vector type with the alignment of the source
+	   location in order to enable correct alignment hints to be
+	   generated for vl.  */
+	tree mem_type = build_aligned_type (return_type,
+					    TYPE_ALIGN (TREE_TYPE (TREE_TYPE ((*arglist)[1]))));
+	return build2 (MEM_REF, mem_type,
+		       fold_build_pointer_plus ((*arglist)[1], (*arglist)[0]),
+		       build_int_cst (TREE_TYPE ((*arglist)[1]), 0));
+      }
     case S390_OVERLOADED_BUILTIN_s390_vec_xst:
     case S390_OVERLOADED_BUILTIN_s390_vec_xstd2:
     case S390_OVERLOADED_BUILTIN_s390_vec_xstw4:
-      return build2 (MODIFY_EXPR, TREE_TYPE((*arglist)[0]),
-		     build1 (INDIRECT_REF, TREE_TYPE((*arglist)[0]),
-			     fold_build_pointer_plus ((*arglist)[2], (*arglist)[1])),
-		     (*arglist)[0]);
+      {
+	/* Build a vector type with the alignment of the target
+	   location in order to enable correct alignment hints to be
+	   generated for vst.  */
+	tree mem_type = build_aligned_type (TREE_TYPE((*arglist)[0]),
+					    TYPE_ALIGN (TREE_TYPE (TREE_TYPE ((*arglist)[2]))));
+	return build2 (MODIFY_EXPR, mem_type,
+		       build1 (INDIRECT_REF, mem_type,
+			       fold_build_pointer_plus ((*arglist)[2], (*arglist)[1])),
+		       (*arglist)[0]);
+      }
     case S390_OVERLOADED_BUILTIN_s390_vec_load_pair:
       return build_constructor_va (return_type, 2,
 				   NULL_TREE, (*arglist)[0],
Index: gcc/config/s390/s390-builtin-types.def
===================================================================
diff --git a/gcc/config/s390/s390-builtin-types.def b/gcc/config/s390/s390-builtin-types.def
--- a/gcc/config/s390/s390-builtin-types.def	(revision 278653)
+++ b/gcc/config/s390/s390-builtin-types.def	(revision 278653)
@@ -260,6 +260,7 @@
 DEF_FN_TYPE_2 (BT_FN_V4SF_V4SF_UCHAR, BT_V4SF, BT_V4SF, BT_UCHAR)
 DEF_FN_TYPE_2 (BT_FN_V4SF_V4SF_V4SF, BT_V4SF, BT_V4SF, BT_V4SF)
 DEF_FN_TYPE_2 (BT_FN_V4SI_BV4SI_V4SI, BT_V4SI, BT_BV4SI, BT_V4SI)
+DEF_FN_TYPE_2 (BT_FN_V4SI_INT_VOIDCONSTPTR, BT_V4SI, BT_INT, BT_VOIDCONSTPTR)
 DEF_FN_TYPE_2 (BT_FN_V4SI_INT_VOIDPTR, BT_V4SI, BT_INT, BT_VOIDPTR)
 DEF_FN_TYPE_2 (BT_FN_V4SI_UV4SI_UV4SI, BT_V4SI, BT_UV4SI, BT_UV4SI)
 DEF_FN_TYPE_2 (BT_FN_V4SI_V2DI_V2DI, BT_V4SI, BT_V2DI, BT_V2DI)
@@ -492,6 +493,7 @@
 DEF_OV_TYPE (BT_OV_UV16QI_BV16QI_BV16QI, BT_UV16QI, BT_BV16QI, BT_BV16QI)
 DEF_OV_TYPE (BT_OV_UV16QI_BV16QI_BV16QI_INTPTR, BT_UV16QI, BT_BV16QI, BT_BV16QI, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_UV16QI_BV16QI_UV16QI, BT_UV16QI, BT_BV16QI, BT_UV16QI)
+DEF_OV_TYPE (BT_OV_UV16QI_LONG_UCHARCONSTPTR, BT_UV16QI, BT_LONG, BT_UCHARCONSTPTR)
 DEF_OV_TYPE (BT_OV_UV16QI_LONG_UCHARPTR, BT_UV16QI, BT_LONG, BT_UCHARPTR)
 DEF_OV_TYPE (BT_OV_UV16QI_UCHAR, BT_UV16QI, BT_UCHAR)
 DEF_OV_TYPE (BT_OV_UV16QI_UCHARCONSTPTR, BT_UV16QI, BT_UCHARCONSTPTR)
@@ -523,6 +525,7 @@
 DEF_OV_TYPE (BT_OV_UV16QI_V16QI, BT_UV16QI, BT_V16QI)
 DEF_OV_TYPE (BT_OV_UV16QI_V8HI_V8HI, BT_UV16QI, BT_V8HI, BT_V8HI)
 DEF_OV_TYPE (BT_OV_UV2DI_BV2DI_UV2DI, BT_UV2DI, BT_BV2DI, BT_UV2DI)
+DEF_OV_TYPE (BT_OV_UV2DI_LONG_ULONGLONGCONSTPTR, BT_UV2DI, BT_LONG, BT_ULONGLONGCONSTPTR)
 DEF_OV_TYPE (BT_OV_UV2DI_LONG_ULONGLONGPTR, BT_UV2DI, BT_LONG, BT_ULONGLONGPTR)
 DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONG, BT_UV2DI, BT_ULONGLONG)
 DEF_OV_TYPE (BT_OV_UV2DI_ULONGLONGCONSTPTR, BT_UV2DI, BT_ULONGLONGCONSTPTR)
@@ -556,6 +559,8 @@
 DEF_OV_TYPE (BT_OV_UV4SI_BV4SI_BV4SI, BT_UV4SI, BT_BV4SI, BT_BV4SI)
 DEF_OV_TYPE (BT_OV_UV4SI_BV4SI_BV4SI_INTPTR, BT_UV4SI, BT_BV4SI, BT_BV4SI, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_UV4SI_BV4SI_UV4SI, BT_UV4SI, BT_BV4SI, BT_UV4SI)
+DEF_OV_TYPE (BT_OV_UV4SI_LONG_FLTPTR, BT_UV4SI, BT_LONG, BT_FLTPTR)
+DEF_OV_TYPE (BT_OV_UV4SI_LONG_UINTCONSTPTR, BT_UV4SI, BT_LONG, BT_UINTCONSTPTR)
 DEF_OV_TYPE (BT_OV_UV4SI_LONG_UINTPTR, BT_UV4SI, BT_LONG, BT_UINTPTR)
 DEF_OV_TYPE (BT_OV_UV4SI_UINT, BT_UV4SI, BT_UINT)
 DEF_OV_TYPE (BT_OV_UV4SI_UINTCONSTPTR, BT_UV4SI, BT_UINTCONSTPTR)
@@ -593,6 +598,7 @@
 DEF_OV_TYPE (BT_OV_UV8HI_BV8HI_BV8HI, BT_UV8HI, BT_BV8HI, BT_BV8HI)
 DEF_OV_TYPE (BT_OV_UV8HI_BV8HI_BV8HI_INTPTR, BT_UV8HI, BT_BV8HI, BT_BV8HI, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_UV8HI_BV8HI_UV8HI, BT_UV8HI, BT_BV8HI, BT_UV8HI)
+DEF_OV_TYPE (BT_OV_UV8HI_LONG_USHORTCONSTPTR, BT_UV8HI, BT_LONG, BT_USHORTCONSTPTR)
 DEF_OV_TYPE (BT_OV_UV8HI_LONG_USHORTPTR, BT_UV8HI, BT_LONG, BT_USHORTPTR)
 DEF_OV_TYPE (BT_OV_UV8HI_USHORT, BT_UV8HI, BT_USHORT)
 DEF_OV_TYPE (BT_OV_UV8HI_USHORTCONSTPTR, BT_UV8HI, BT_USHORTCONSTPTR)
@@ -626,6 +632,7 @@
 DEF_OV_TYPE (BT_OV_UV8HI_V4SI_V4SI, BT_UV8HI, BT_V4SI, BT_V4SI)
 DEF_OV_TYPE (BT_OV_UV8HI_V8HI, BT_UV8HI, BT_V8HI)
 DEF_OV_TYPE (BT_OV_V16QI_BV16QI_V16QI, BT_V16QI, BT_BV16QI, BT_V16QI)
+DEF_OV_TYPE (BT_OV_V16QI_LONG_SCHARCONSTPTR, BT_V16QI, BT_LONG, BT_SCHARCONSTPTR)
 DEF_OV_TYPE (BT_OV_V16QI_LONG_SCHARPTR, BT_V16QI, BT_LONG, BT_SCHARPTR)
 DEF_OV_TYPE (BT_OV_V16QI_SCHAR, BT_V16QI, BT_SCHAR)
 DEF_OV_TYPE (BT_OV_V16QI_SCHARCONSTPTR, BT_V16QI, BT_SCHARCONSTPTR)
@@ -660,6 +667,7 @@
 DEF_OV_TYPE (BT_OV_V2DF_DBLCONSTPTR_USHORT, BT_V2DF, BT_DBLCONSTPTR, BT_USHORT)
 DEF_OV_TYPE (BT_OV_V2DF_DBL_INT, BT_V2DF, BT_DBL, BT_INT)
 DEF_OV_TYPE (BT_OV_V2DF_DBL_V2DF_INT, BT_V2DF, BT_DBL, BT_V2DF, BT_INT)
+DEF_OV_TYPE (BT_OV_V2DF_LONG_DBLCONSTPTR, BT_V2DF, BT_LONG, BT_DBLCONSTPTR)
 DEF_OV_TYPE (BT_OV_V2DF_LONG_DBLPTR, BT_V2DF, BT_LONG, BT_DBLPTR)
 DEF_OV_TYPE (BT_OV_V2DF_UV2DI, BT_V2DF, BT_UV2DI)
 DEF_OV_TYPE (BT_OV_V2DF_UV2DI_INT, BT_V2DF, BT_UV2DI, BT_INT)
@@ -687,6 +695,7 @@
 DEF_OV_TYPE (BT_OV_V2DI_LONGLONG_INT, BT_V2DI, BT_LONGLONG, BT_INT)
 DEF_OV_TYPE (BT_OV_V2DI_LONGLONG_LONGLONG, BT_V2DI, BT_LONGLONG, BT_LONGLONG)
 DEF_OV_TYPE (BT_OV_V2DI_LONGLONG_V2DI_INT, BT_V2DI, BT_LONGLONG, BT_V2DI, BT_INT)
+DEF_OV_TYPE (BT_OV_V2DI_LONG_LONGLONGCONSTPTR, BT_V2DI, BT_LONG, BT_LONGLONGCONSTPTR)
 DEF_OV_TYPE (BT_OV_V2DI_LONG_LONGLONGPTR, BT_V2DI, BT_LONG, BT_LONGLONGPTR)
 DEF_OV_TYPE (BT_OV_V2DI_V16QI, BT_V2DI, BT_V16QI)
 DEF_OV_TYPE (BT_OV_V2DI_V2DI, BT_V2DI, BT_V2DI)
@@ -716,7 +725,7 @@
 DEF_OV_TYPE (BT_OV_V4SF_FLTCONSTPTR_USHORT, BT_V4SF, BT_FLTCONSTPTR, BT_USHORT)
 DEF_OV_TYPE (BT_OV_V4SF_FLT_INT, BT_V4SF, BT_FLT, BT_INT)
 DEF_OV_TYPE (BT_OV_V4SF_FLT_V4SF_INT, BT_V4SF, BT_FLT, BT_V4SF, BT_INT)
-DEF_OV_TYPE (BT_OV_V4SF_LONG_FLTPTR, BT_V4SF, BT_LONG, BT_FLTPTR)
+DEF_OV_TYPE (BT_OV_V4SF_LONG_FLTCONSTPTR, BT_V4SF, BT_LONG, BT_FLTCONSTPTR)
 DEF_OV_TYPE (BT_OV_V4SF_V4SF, BT_V4SF, BT_V4SF)
 DEF_OV_TYPE (BT_OV_V4SF_V4SF_BV4SI, BT_V4SF, BT_V4SF, BT_BV4SI)
 DEF_OV_TYPE (BT_OV_V4SF_V4SF_UCHAR, BT_V4SF, BT_V4SF, BT_UCHAR)
@@ -737,6 +746,7 @@
 DEF_OV_TYPE (BT_OV_V4SI_INTCONSTPTR_USHORT, BT_V4SI, BT_INTCONSTPTR, BT_USHORT)
 DEF_OV_TYPE (BT_OV_V4SI_INT_INT, BT_V4SI, BT_INT, BT_INT)
 DEF_OV_TYPE (BT_OV_V4SI_INT_V4SI_INT, BT_V4SI, BT_INT, BT_V4SI, BT_INT)
+DEF_OV_TYPE (BT_OV_V4SI_LONG_INTCONSTPTR, BT_V4SI, BT_LONG, BT_INTCONSTPTR)
 DEF_OV_TYPE (BT_OV_V4SI_LONG_INTPTR, BT_V4SI, BT_LONG, BT_INTPTR)
 DEF_OV_TYPE (BT_OV_V4SI_UV4SI_V4SI_V4SI, BT_V4SI, BT_UV4SI, BT_V4SI, BT_V4SI)
 DEF_OV_TYPE (BT_OV_V4SI_V2DI_V2DI, BT_V4SI, BT_V2DI, BT_V2DI)
@@ -764,6 +774,7 @@
 DEF_OV_TYPE (BT_OV_V4SI_V8HI_V8HI, BT_V4SI, BT_V8HI, BT_V8HI)
 DEF_OV_TYPE (BT_OV_V4SI_V8HI_V8HI_V4SI, BT_V4SI, BT_V8HI, BT_V8HI, BT_V4SI)
 DEF_OV_TYPE (BT_OV_V8HI_BV8HI_V8HI, BT_V8HI, BT_BV8HI, BT_V8HI)
+DEF_OV_TYPE (BT_OV_V8HI_LONG_SHORTCONSTPTR, BT_V8HI, BT_LONG, BT_SHORTCONSTPTR)
 DEF_OV_TYPE (BT_OV_V8HI_LONG_SHORTPTR, BT_V8HI, BT_LONG, BT_SHORTPTR)
 DEF_OV_TYPE (BT_OV_V8HI_SHORT, BT_V8HI, BT_SHORT)
 DEF_OV_TYPE (BT_OV_V8HI_SHORTCONSTPTR, BT_V8HI, BT_SHORTCONSTPTR)
@@ -802,6 +813,7 @@
 DEF_OV_TYPE (BT_OV_VOID_UV2DI_LONG_ULONGLONGPTR, BT_VOID, BT_UV2DI, BT_LONG, BT_ULONGLONGPTR)
 DEF_OV_TYPE (BT_OV_VOID_UV2DI_ULONGLONGPTR_UINT, BT_VOID, BT_UV2DI, BT_ULONGLONGPTR, BT_UINT)
 DEF_OV_TYPE (BT_OV_VOID_UV2DI_UV2DI_ULONGLONGPTR_ULONGLONG, BT_VOID, BT_UV2DI, BT_UV2DI, BT_ULONGLONGPTR, BT_ULONGLONG)
+DEF_OV_TYPE (BT_OV_VOID_UV4SI_LONG_FLTPTR, BT_VOID, BT_UV4SI, BT_LONG, BT_FLTPTR)
 DEF_OV_TYPE (BT_OV_VOID_UV4SI_LONG_UINTPTR, BT_VOID, BT_UV4SI, BT_LONG, BT_UINTPTR)
 DEF_OV_TYPE (BT_OV_VOID_UV4SI_UINTPTR_UINT, BT_VOID, BT_UV4SI, BT_UINTPTR, BT_UINT)
 DEF_OV_TYPE (BT_OV_VOID_UV4SI_UV4SI_UINTPTR_ULONGLONG, BT_VOID, BT_UV4SI, BT_UV4SI, BT_UINTPTR, BT_ULONGLONG)
Index: gcc/config/s390/vector.md
===================================================================
diff --git a/gcc/config/s390/vector.md b/gcc/config/s390/vector.md
--- a/gcc/config/s390/vector.md	(revision 278653)
+++ b/gcc/config/s390/vector.md	(revision 278653)
@@ -944,7 +944,7 @@
 	(VEC_SHIFTS:VI (match_operand:VI 1 "register_operand"   "v")
 		       (match_operand:SI 2 "nonmemory_operand" "an")))]
   "TARGET_VX"
-  "<vec_shifts_mnem><bhfgq>\t%v0,%v1,%Y2"
+  "<vec_shifts_mnem><bhfgq>\t%v0,%v1,<addr_style_op_ops>"
   [(set_attr "op_type" "VRS")])
 
 ; Shift each element by corresponding vector element
Index: gcc/config/s390/s390.c
===================================================================
diff --git a/gcc/config/s390/s390.c b/gcc/config/s390/s390.c
--- a/gcc/config/s390/s390.c	(revision 278653)
+++ b/gcc/config/s390/s390.c	(revision 278653)
@@ -937,6 +937,8 @@
 	  continue;
 	}
 
+      /* A memory operand is rejected by the memory_operand predicate.
+	 Try making the address legal by copying it into a register.  */
       if (MEM_P (op[arity])
 	  && insn_op->predicate == memory_operand
 	  && (GET_MODE (XEXP (op[arity], 0)) == Pmode
@@ -960,10 +962,14 @@
 	{
 	  op[arity] = tmp_rtx;
 	}
-      else if (GET_MODE (op[arity]) == insn_op->mode
-	       || GET_MODE (op[arity]) == VOIDmode
-	       || (insn_op->predicate == address_operand
-		   && GET_MODE (op[arity]) == Pmode))
+
+      /* The predicate rejects the operand although the mode is fine.
+	 Copy the operand to register.  */
+      if (!insn_op->predicate (op[arity], insn_op->mode)
+	  && (GET_MODE (op[arity]) == insn_op->mode
+	      || GET_MODE (op[arity]) == VOIDmode
+	      || (insn_op->predicate == address_operand
+		  && GET_MODE (op[arity]) == Pmode)))
 	{
 	  /* An address_operand usually has VOIDmode in the expander
 	     so we cannot use this.  */
@@ -10106,6 +10112,21 @@
   s390_register_info_stdarg_gpr ();
 }
 
+/* Return true if REGNO is a global register, but not one
+   of the special ones that need to be saved/restored in anyway.  */
+
+static inline bool
+global_not_special_regno_p (int regno)
+{
+  return (global_regs[regno]
+	  /* These registers are special and need to be
+	     restored in any case.  */
+	  && !(regno == STACK_POINTER_REGNUM
+	       || regno == RETURN_REGNUM
+	       || regno == BASE_REGNUM
+	       || (flag_pic && regno == (int)PIC_OFFSET_TABLE_REGNUM)));
+}
+
 /* This function is called by s390_optimize_prologue in order to get
    rid of unnecessary GPR save/restore instructions.  The register info
    for the GPRs is re-computed and the ranges are re-calculated.  */
@@ -10121,8 +10142,10 @@
 
   s390_regs_ever_clobbered (clobbered_regs);
 
+  /* Global registers do not need to be saved and restored unless it
+     is one of our special regs.  (r12, r13, r14, or r15).  */
   for (i = 0; i < 32; i++)
-    clobbered_regs[i] = clobbered_regs[i] && !global_regs[i];
+    clobbered_regs[i] = clobbered_regs[i] && !global_not_special_regno_p (i);
 
   /* There is still special treatment needed for cases invisible to
      s390_regs_ever_clobbered.  */
@@ -10876,21 +10899,6 @@
   return emit_move_insn (gen_rtx_REG (DFmode, regnum), addr);
 }
 
-/* Return true if REGNO is a global register, but not one
-   of the special ones that need to be saved/restored in anyway.  */
-
-static inline bool
-global_not_special_regno_p (int regno)
-{
-  return (global_regs[regno]
-	  /* These registers are special and need to be
-	     restored in any case.  */
-	  && !(regno == STACK_POINTER_REGNUM
-	       || regno == RETURN_REGNUM
-	       || regno == BASE_REGNUM
-	       || (flag_pic && regno == (int)PIC_OFFSET_TABLE_REGNUM)));
-}
-
 /* Generate insn to save registers FIRST to LAST into
    the register save area located at offset OFFSET
    relative to register BASE.  */
@@ -16039,6 +16047,7 @@
 
   return ret;
 }
+#endif
 
 /* Set VAL to correct enum value according to the indirect-branch or
    function-return attribute in ATTR.  */
@@ -16112,6 +16121,7 @@
     s390_indirect_branch_attrvalue (attr, &cfun->machine->function_return_mem);
 }
 
+#if S390_USE_TARGET_ATTRIBUTE
 /* Restore targets globals from NEW_TREE and invalidate s390_previous_fndecl
    cache.  */
 
@@ -16127,6 +16137,7 @@
     TREE_TARGET_GLOBALS (new_tree) = save_target_globals_default_opts ();
   s390_previous_fndecl = NULL_TREE;
 }
+#endif
 
 /* Establish appropriate back-end context for processing the function
    FNDECL.  The argument might be NULL to indicate processing at top
@@ -16134,6 +16145,7 @@
 static void
 s390_set_current_function (tree fndecl)
 {
+#if S390_USE_TARGET_ATTRIBUTE
   /* Only change the context if the function changes.  This hook is called
      several times in the course of compiling a function, and we don't want to
      slow things down too much or call target_reinit when it isn't safe.  */
@@ -16165,10 +16177,9 @@
   if (old_tree != new_tree)
     s390_activate_target_options (new_tree);
   s390_previous_fndecl = fndecl;
-
+#endif
   s390_indirect_branch_settings (fndecl);
 }
-#endif
 
 /* Implement TARGET_USE_BY_PIECES_INFRASTRUCTURE_P.  */
 
@@ -16907,10 +16918,10 @@
 #undef TARGET_ASM_FILE_END
 #define TARGET_ASM_FILE_END s390_asm_file_end
 
-#if S390_USE_TARGET_ATTRIBUTE
 #undef TARGET_SET_CURRENT_FUNCTION
 #define TARGET_SET_CURRENT_FUNCTION s390_set_current_function
 
+#if S390_USE_TARGET_ATTRIBUTE
 #undef TARGET_OPTION_VALID_ATTRIBUTE_P
 #define TARGET_OPTION_VALID_ATTRIBUTE_P s390_valid_target_attribute_p
 
Index: gcc/config/s390/s390-builtins.def
===================================================================
diff --git a/gcc/config/s390/s390-builtins.def b/gcc/config/s390/s390-builtins.def
--- a/gcc/config/s390/s390-builtins.def	(revision 278653)
+++ b/gcc/config/s390/s390-builtins.def	(revision 278653)
@@ -328,36 +328,38 @@
 B_DEF      (s390_vgmf,                  vec_genmaskv4si,    0,                  B_VX,               O1_U8 | O2_U8,      BT_FN_UV4SI_UCHAR_UCHAR)
 B_DEF      (s390_vgmg,                  vec_genmaskv2di,    0,                  B_VX,               O1_U8 | O2_U8,      BT_FN_UV2DI_UCHAR_UCHAR)
 
-OB_DEF     (s390_vec_xl,                s390_vec_xl_s8,     s390_vec_xl_dbl,    B_VX,               BT_FN_V4SI_INT_VOIDPTR)
-OB_DEF_VAR (s390_vec_xl_s8,             MAX,                0,                  O1_LIT,             BT_OV_V16QI_LONG_SCHARPTR)               /* vl */
-OB_DEF_VAR (s390_vec_xl_u8,             MAX,                0,                  O1_LIT,             BT_OV_UV16QI_LONG_UCHARPTR)              /* vl */
-OB_DEF_VAR (s390_vec_xl_s16,            MAX,                0,                  O1_LIT,             BT_OV_V8HI_LONG_SHORTPTR)                /* vl */
-OB_DEF_VAR (s390_vec_xl_u16,            MAX,                0,                  O1_LIT,             BT_OV_UV8HI_LONG_USHORTPTR)              /* vl */
-OB_DEF_VAR (s390_vec_xl_s32,            MAX,                0,                  O1_LIT,             BT_OV_V4SI_LONG_INTPTR)                  /* vl */
-OB_DEF_VAR (s390_vec_xl_u32,            MAX,                0,                  O1_LIT,             BT_OV_UV4SI_LONG_UINTPTR)                /* vl */
-OB_DEF_VAR (s390_vec_xl_s64,            MAX,                0,                  O1_LIT,             BT_OV_V2DI_LONG_LONGLONGPTR)             /* vl */
-OB_DEF_VAR (s390_vec_xl_u64,            MAX,                0,                  O1_LIT,             BT_OV_UV2DI_LONG_ULONGLONGPTR)           /* vl */
-OB_DEF_VAR (s390_vec_xl_flt,            MAX,                0,                  O1_LIT,             BT_OV_V4SF_LONG_FLTPTR)                  /* vl */
-OB_DEF_VAR (s390_vec_xl_dbl,            MAX,                0,                  O1_LIT,             BT_OV_V2DF_LONG_DBLPTR)                  /* vl */
+OB_DEF     (s390_vec_xl,                s390_vec_xl_s8,     s390_vec_xl_dbl,    B_VX,               BT_FN_V4SI_INT_VOIDCONSTPTR)
+OB_DEF_VAR (s390_vec_xl_s8,             MAX,                0,                  O1_LIT,             BT_OV_V16QI_LONG_SCHARCONSTPTR)          /* vl */
+OB_DEF_VAR (s390_vec_xl_u8,             MAX,                0,                  O1_LIT,             BT_OV_UV16QI_LONG_UCHARCONSTPTR)         /* vl */
+OB_DEF_VAR (s390_vec_xl_s16,            MAX,                0,                  O1_LIT,             BT_OV_V8HI_LONG_SHORTCONSTPTR)           /* vl */
+OB_DEF_VAR (s390_vec_xl_u16,            MAX,                0,                  O1_LIT,             BT_OV_UV8HI_LONG_USHORTCONSTPTR)         /* vl */
+OB_DEF_VAR (s390_vec_xl_s32,            MAX,                0,                  O1_LIT,             BT_OV_V4SI_LONG_INTCONSTPTR)             /* vl */
+OB_DEF_VAR (s390_vec_xl_u32,            MAX,                0,                  O1_LIT,             BT_OV_UV4SI_LONG_UINTCONSTPTR)           /* vl */
+OB_DEF_VAR (s390_vec_xl_s64,            MAX,                0,                  O1_LIT,             BT_OV_V2DI_LONG_LONGLONGCONSTPTR)        /* vl */
+OB_DEF_VAR (s390_vec_xl_u64,            MAX,                0,                  O1_LIT,             BT_OV_UV2DI_LONG_ULONGLONGCONSTPTR)      /* vl */
+OB_DEF_VAR (s390_vec_xl_flt,            MAX,                0,                  O1_LIT,             BT_OV_V4SF_LONG_FLTCONSTPTR)             /* vl */
+OB_DEF_VAR (s390_vec_xl_dbl,            MAX,                0,                  O1_LIT,             BT_OV_V2DF_LONG_DBLCONSTPTR)             /* vl */
 
-OB_DEF     (s390_vec_xld2,              s390_vec_xld2_s8,   s390_vec_xld2_dbl,  B_DEP | B_VX,       BT_FN_V4SI_INT_VOIDPTR)
-OB_DEF_VAR (s390_vec_xld2_s8,           MAX,                0,                  O1_LIT,             BT_OV_V16QI_LONG_SCHARPTR)               /* vl */
-OB_DEF_VAR (s390_vec_xld2_u8,           MAX,                0,                  O1_LIT,             BT_OV_UV16QI_LONG_UCHARPTR)              /* vl */
-OB_DEF_VAR (s390_vec_xld2_s16,          MAX,                0,                  O1_LIT,             BT_OV_V8HI_LONG_SHORTPTR)                /* vl */
-OB_DEF_VAR (s390_vec_xld2_u16,          MAX,                0,                  O1_LIT,             BT_OV_UV8HI_LONG_USHORTPTR)              /* vl */
-OB_DEF_VAR (s390_vec_xld2_s32,          MAX,                0,                  O1_LIT,             BT_OV_V4SI_LONG_INTPTR)                  /* vl */
-OB_DEF_VAR (s390_vec_xld2_u32,          MAX,                0,                  O1_LIT,             BT_OV_UV4SI_LONG_UINTPTR)                /* vl */
-OB_DEF_VAR (s390_vec_xld2_s64,          MAX,                0,                  O1_LIT,             BT_OV_V2DI_LONG_LONGLONGPTR)             /* vl */
-OB_DEF_VAR (s390_vec_xld2_u64,          MAX,                0,                  O1_LIT,             BT_OV_UV2DI_LONG_ULONGLONGPTR)           /* vl */
-OB_DEF_VAR (s390_vec_xld2_dbl,          MAX,                0,                  O1_LIT,             BT_OV_V2DF_LONG_DBLPTR)                  /* vl */
+OB_DEF     (s390_vec_xld2,              s390_vec_xld2_s8,   s390_vec_xld2_dbl,  B_DEP | B_VX,       BT_FN_V4SI_INT_VOIDCONSTPTR)
+OB_DEF_VAR (s390_vec_xld2_s8,           MAX,                0,                  O1_LIT,             BT_OV_V16QI_LONG_SCHARCONSTPTR)          /* vl */
+OB_DEF_VAR (s390_vec_xld2_u8,           MAX,                0,                  O1_LIT,             BT_OV_UV16QI_LONG_UCHARCONSTPTR)         /* vl */
+OB_DEF_VAR (s390_vec_xld2_s16,          MAX,                0,                  O1_LIT,             BT_OV_V8HI_LONG_SHORTCONSTPTR)           /* vl */
+OB_DEF_VAR (s390_vec_xld2_u16,          MAX,                0,                  O1_LIT,             BT_OV_UV8HI_LONG_USHORTCONSTPTR)         /* vl */
+OB_DEF_VAR (s390_vec_xld2_s32,          MAX,                0,                  O1_LIT,             BT_OV_V4SI_LONG_INTCONSTPTR)             /* vl */
+OB_DEF_VAR (s390_vec_xld2_u32,          MAX,                0,                  O1_LIT,             BT_OV_UV4SI_LONG_UINTCONSTPTR)           /* vl */
+OB_DEF_VAR (s390_vec_xld2_s64,          MAX,                0,                  O1_LIT,             BT_OV_V2DI_LONG_LONGLONGCONSTPTR)        /* vl */
+OB_DEF_VAR (s390_vec_xld2_u64,          MAX,                0,                  O1_LIT,             BT_OV_UV2DI_LONG_ULONGLONGCONSTPTR)      /* vl */
+OB_DEF_VAR (s390_vec_xld2_flt,          MAX,                B_VXE,              O1_LIT,             BT_OV_V4SF_LONG_FLTCONSTPTR)             /* vl */
+OB_DEF_VAR (s390_vec_xld2_dbl,          MAX,                0,                  O1_LIT,             BT_OV_V2DF_LONG_DBLCONSTPTR)             /* vl */
 
-OB_DEF     (s390_vec_xlw4,              s390_vec_xlw4_s8,   s390_vec_xlw4_u32,  B_DEP | B_VX,       BT_FN_V4SI_INT_VOIDPTR)
-OB_DEF_VAR (s390_vec_xlw4_s8,           MAX,                0,                  O1_LIT,             BT_OV_V16QI_LONG_SCHARPTR)               /* vl */
-OB_DEF_VAR (s390_vec_xlw4_u8,           MAX,                0,                  O1_LIT,             BT_OV_UV16QI_LONG_UCHARPTR)              /* vl */
-OB_DEF_VAR (s390_vec_xlw4_s16,          MAX,                0,                  O1_LIT,             BT_OV_V8HI_LONG_SHORTPTR)                /* vl */
-OB_DEF_VAR (s390_vec_xlw4_u16,          MAX,                0,                  O1_LIT,             BT_OV_UV8HI_LONG_USHORTPTR)              /* vl */
-OB_DEF_VAR (s390_vec_xlw4_s32,          MAX,                0,                  O1_LIT,             BT_OV_V4SI_LONG_INTPTR)                  /* vl */
-OB_DEF_VAR (s390_vec_xlw4_u32,          MAX,                0,                  O1_LIT,             BT_OV_UV4SI_LONG_UINTPTR)                /* vl */
+OB_DEF     (s390_vec_xlw4,              s390_vec_xlw4_s8,   s390_vec_xlw4_flt,  B_DEP | B_VX,       BT_FN_V4SI_INT_VOIDCONSTPTR)
+OB_DEF_VAR (s390_vec_xlw4_s8,           MAX,                0,                  O1_LIT,             BT_OV_V16QI_LONG_SCHARCONSTPTR)          /* vl */
+OB_DEF_VAR (s390_vec_xlw4_u8,           MAX,                0,                  O1_LIT,             BT_OV_UV16QI_LONG_UCHARCONSTPTR)         /* vl */
+OB_DEF_VAR (s390_vec_xlw4_s16,          MAX,                0,                  O1_LIT,             BT_OV_V8HI_LONG_SHORTCONSTPTR)           /* vl */
+OB_DEF_VAR (s390_vec_xlw4_u16,          MAX,                0,                  O1_LIT,             BT_OV_UV8HI_LONG_USHORTCONSTPTR)         /* vl */
+OB_DEF_VAR (s390_vec_xlw4_s32,          MAX,                0,                  O1_LIT,             BT_OV_V4SI_LONG_INTCONSTPTR)             /* vl */
+OB_DEF_VAR (s390_vec_xlw4_u32,          MAX,                0,                  O1_LIT,             BT_OV_UV4SI_LONG_UINTCONSTPTR)           /* vl */
+OB_DEF_VAR (s390_vec_xlw4_flt,          MAX,                B_VXE,              O1_LIT,             BT_OV_V4SF_LONG_FLTCONSTPTR)             /* vl */
 
 OB_DEF     (s390_vec_splats,            s390_vec_splats_s8, s390_vec_splats_dbl,B_VX,               BT_FN_OV4SI_INT)
 OB_DEF_VAR (s390_vec_splats_s8,         s390_vlrepb,        0,                  0,                  BT_OV_V16QI_SCHAR)
@@ -746,7 +748,7 @@
 OB_DEF_VAR (s390_vec_xstd2_u64,         MAX,                0,                  O2_LIT,             BT_OV_VOID_UV2DI_LONG_ULONGLONGPTR)      /* vst */
 OB_DEF_VAR (s390_vec_xstd2_dbl,         MAX,                0,                  O2_LIT,             BT_OV_VOID_V2DF_LONG_DBLPTR)             /* vst */
 
-OB_DEF     (s390_vec_xstw4,             s390_vec_xstw4_s8,  s390_vec_xstw4_u32, B_DEP | B_VX,       BT_FN_VOID_OV4SI_INT_VOIDPTR)
+OB_DEF     (s390_vec_xstw4,             s390_vec_xstw4_s8,  s390_vec_xstw4_flt, B_DEP | B_VX,       BT_FN_VOID_OV4SI_INT_VOIDPTR)
 OB_DEF_VAR (s390_vec_xstw4_s8,          MAX,                0,                  O2_LIT,             BT_OV_VOID_V16QI_LONG_SCHARPTR)          /* vst */
 OB_DEF_VAR (s390_vec_xstw4_u8,          MAX,                0,                  O2_LIT,             BT_OV_VOID_UV16QI_LONG_UCHARPTR)         /* vst */
 OB_DEF_VAR (s390_vec_xstw4_s16,         MAX,                0,                  O2_LIT,             BT_OV_VOID_V8HI_LONG_SHORTPTR)           /* vst */
@@ -753,6 +755,7 @@
 OB_DEF_VAR (s390_vec_xstw4_u16,         MAX,                0,                  O2_LIT,             BT_OV_VOID_UV8HI_LONG_USHORTPTR)         /* vst */
 OB_DEF_VAR (s390_vec_xstw4_s32,         MAX,                0,                  O2_LIT,             BT_OV_VOID_V4SI_LONG_INTPTR)             /* vst */
 OB_DEF_VAR (s390_vec_xstw4_u32,         MAX,                0,                  O2_LIT,             BT_OV_VOID_UV4SI_LONG_UINTPTR)           /* vst */
+OB_DEF_VAR (s390_vec_xstw4_flt,         MAX,                B_VXE,              O2_LIT,             BT_OV_VOID_V4SF_LONG_FLTPTR)             /* vst */
 
 OB_DEF     (s390_vec_store_len,         s390_vec_store_len_s8,s390_vec_store_len_dbl,B_VX,          BT_FN_VOID_OV4SI_VOIDPTR_UINT)
 OB_DEF_VAR (s390_vec_store_len_s8,      s390_vstl,          0,                  0,                  BT_OV_VOID_V16QI_SCHARPTR_UINT)
Index: gcc/config/sparc/sparc.md
===================================================================
diff --git a/gcc/config/sparc/sparc.md b/gcc/config/sparc/sparc.md
--- a/gcc/config/sparc/sparc.md	(revision 278653)
+++ b/gcc/config/sparc/sparc.md	(revision 278653)
@@ -1601,10 +1601,7 @@
    (clobber (reg:P O7_REG))]
   "REGNO (operands[0]) == INTVAL (operands[3])"
 {
-  if (flag_delayed_branch)
-    return "sethi\t%%hi(%a1-4), %0\n\tcall\t%a2\n\t add\t%0, %%lo(%a1+4), %0";
-  else
-    return "sethi\t%%hi(%a1-8), %0\n\tadd\t%0, %%lo(%a1-4), %0\n\tcall\t%a2\n\t nop";
+  return output_load_pcrel_sym (operands);
 }
   [(set (attr "type") (const_string "multi"))
    (set (attr "length")
Index: gcc/config/sparc/sparc-protos.h
===================================================================
diff --git a/gcc/config/sparc/sparc-protos.h b/gcc/config/sparc/sparc-protos.h
--- a/gcc/config/sparc/sparc-protos.h	(revision 278653)
+++ b/gcc/config/sparc/sparc-protos.h	(revision 278653)
@@ -69,6 +69,7 @@
 extern void sparc_split_mem_reg (rtx, rtx, machine_mode);
 extern int sparc_split_reg_reg_legitimate (rtx, rtx);
 extern void sparc_split_reg_reg (rtx, rtx, machine_mode);
+extern const char *output_load_pcrel_sym (rtx *);
 extern const char *output_ubranch (rtx, rtx_insn *);
 extern const char *output_cbranch (rtx, rtx, int, int, int, rtx_insn *);
 extern const char *output_return (rtx_insn *);
Index: gcc/config/sparc/sparc.c
===================================================================
diff --git a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
--- a/gcc/config/sparc/sparc.c	(revision 278653)
+++ b/gcc/config/sparc/sparc.c	(revision 278653)
@@ -4238,10 +4238,12 @@
 }
 
 /* Global Offset Table support.  */
+static GTY(()) rtx got_symbol_rtx = NULL_RTX;
+static GTY(()) rtx got_register_rtx = NULL_RTX;
 static GTY(()) rtx got_helper_rtx = NULL_RTX;
-static GTY(()) rtx got_register_rtx = NULL_RTX;
-static GTY(()) rtx got_symbol_rtx = NULL_RTX;
 
+static GTY(()) bool got_helper_needed = false;
+
 /* Return the SYMBOL_REF for the Global Offset Table.  */
 
 static rtx
@@ -4253,27 +4255,6 @@
   return got_symbol_rtx;
 }
 
-#ifdef HAVE_GAS_HIDDEN
-# define USE_HIDDEN_LINKONCE 1
-#else
-# define USE_HIDDEN_LINKONCE 0
-#endif
-
-static void
-get_pc_thunk_name (char name[32], unsigned int regno)
-{
-  const char *reg_name = reg_names[regno];
-
-  /* Skip the leading '%' as that cannot be used in a
-     symbol name.  */
-  reg_name += 1;
-
-  if (USE_HIDDEN_LINKONCE)
-    sprintf (name, "__sparc_get_pc_thunk.%s", reg_name);
-  else
-    ASM_GENERATE_INTERNAL_LABEL (name, "LADDPC", regno);
-}
-
 /* Wrapper around the load_pcrel_sym{si,di} patterns.  */
 
 static rtx
@@ -4293,30 +4274,78 @@
   return insn;
 }
 
+/* Output the load_pcrel_sym{si,di} patterns.  */
+
+const char *
+output_load_pcrel_sym (rtx *operands)
+{
+  if (flag_delayed_branch)
+    {
+      output_asm_insn ("sethi\t%%hi(%a1-4), %0", operands);
+      output_asm_insn ("call\t%a2", operands);
+      output_asm_insn (" add\t%0, %%lo(%a1+4), %0", operands);
+    }
+  else
+    {
+      output_asm_insn ("sethi\t%%hi(%a1-8), %0", operands);
+      output_asm_insn ("add\t%0, %%lo(%a1-4), %0", operands);
+      output_asm_insn ("call\t%a2", operands);
+      output_asm_insn (" nop", NULL);
+    }
+
+  if (operands[2] == got_helper_rtx)
+    got_helper_needed = true;
+
+  return "";
+}
+
+#ifdef HAVE_GAS_HIDDEN
+# define USE_HIDDEN_LINKONCE 1
+#else
+# define USE_HIDDEN_LINKONCE 0
+#endif
+
 /* Emit code to load the GOT register.  */
 
 void
 load_got_register (void)
 {
-  if (!got_register_rtx)
-    got_register_rtx = gen_rtx_REG (Pmode, GLOBAL_OFFSET_TABLE_REGNUM);
+  rtx insn;
 
   if (TARGET_VXWORKS_RTP)
-    emit_insn (gen_vxworks_load_got ());
+    {
+      if (!got_register_rtx)
+	got_register_rtx = pic_offset_table_rtx;
+
+      insn = gen_vxworks_load_got ();
+    }
   else
     {
+      if (!got_register_rtx)
+	got_register_rtx = gen_rtx_REG (Pmode, GLOBAL_OFFSET_TABLE_REGNUM);
+
       /* The GOT symbol is subject to a PC-relative relocation so we need a
 	 helper function to add the PC value and thus get the final value.  */
       if (!got_helper_rtx)
 	{
 	  char name[32];
-	  get_pc_thunk_name (name, GLOBAL_OFFSET_TABLE_REGNUM);
+
+	  /* Skip the leading '%' as that cannot be used in a symbol name.  */
+	  if (USE_HIDDEN_LINKONCE)
+	    sprintf (name, "__sparc_get_pc_thunk.%s",
+		     reg_names[REGNO (got_register_rtx)] + 1);
+	  else
+	    ASM_GENERATE_INTERNAL_LABEL (name, "LADDPC",
+					 REGNO (got_register_rtx));
+
 	  got_helper_rtx = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (name));
 	}
 
-      emit_insn (gen_load_pcrel_sym (got_register_rtx, sparc_got (),
-				     got_helper_rtx));
+      insn
+	= gen_load_pcrel_sym (got_register_rtx, sparc_got (), got_helper_rtx);
     }
+
+  emit_insn (insn);
 }
 
 /* Ensure that we are not using patterns that are not OK with PIC.  */
@@ -4452,7 +4481,7 @@
     return true;
 
   if (!HARD_REGISTER_P (pic_offset_table_rtx)
-      && (HARD_REGISTER_P (x) || lra_in_progress)
+      && (HARD_REGISTER_P (x) || lra_in_progress || reload_in_progress)
       && ORIGINAL_REGNO (x) == REGNO (pic_offset_table_rtx))
     return true;
 
@@ -5468,7 +5497,7 @@
     return true;
 
   /* GOT register (%l7) if needed.  */
-  if (regno == GLOBAL_OFFSET_TABLE_REGNUM && got_register_rtx)
+  if (got_register_rtx && regno == REGNO (got_register_rtx))
     return true;
 
   /* If the function accesses prior frames, the frame pointer and the return
@@ -12449,10 +12478,9 @@
 sparc_file_end (void)
 {
   /* If we need to emit the special GOT helper function, do so now.  */
-  if (got_helper_rtx)
+  if (got_helper_needed)
     {
       const char *name = XSTR (got_helper_rtx, 0);
-      const char *reg_name = reg_names[GLOBAL_OFFSET_TABLE_REGNUM];
 #ifdef DWARF2_UNWIND_INFO
       bool do_cfi;
 #endif
@@ -12489,17 +12517,22 @@
 #ifdef DWARF2_UNWIND_INFO
       do_cfi = dwarf2out_do_cfi_asm ();
       if (do_cfi)
-	fprintf (asm_out_file, "\t.cfi_startproc\n");
+	output_asm_insn (".cfi_startproc", NULL);
 #endif
       if (flag_delayed_branch)
-	fprintf (asm_out_file, "\tjmp\t%%o7+8\n\t add\t%%o7, %s, %s\n",
-		 reg_name, reg_name);
+	{
+	  output_asm_insn ("jmp\t%%o7+8", NULL);
+	  output_asm_insn (" add\t%%o7, %0, %0", &got_register_rtx);
+	}
       else
-	fprintf (asm_out_file, "\tadd\t%%o7, %s, %s\n\tjmp\t%%o7+8\n\t nop\n",
-		 reg_name, reg_name);
+	{
+	  output_asm_insn ("add\t%%o7, %0, %0", &got_register_rtx);
+	  output_asm_insn ("jmp\t%%o7+8", NULL);
+	  output_asm_insn (" nop", NULL);
+	}
 #ifdef DWARF2_UNWIND_INFO
       if (do_cfi)
-	fprintf (asm_out_file, "\t.cfi_endproc\n");
+	output_asm_insn (".cfi_endproc", NULL);
 #endif
     }
 
@@ -13005,7 +13038,10 @@
   edge entry_edge;
   rtx_insn *seq;
 
-  if (!crtl->uses_pic_offset_table)
+  /* In PIC mode, we need to always initialize the PIC register if optimization
+     is enabled, because we are called from IRA and LRA may later force things
+     to the constant pool for optimization purposes.  */
+  if (!flag_pic || (!crtl->uses_pic_offset_table && !optimize))
     return;
 
   start_sequence ();
Index: gcc/config/sparc/sparc.h
===================================================================
diff --git a/gcc/config/sparc/sparc.h b/gcc/config/sparc/sparc.h
--- a/gcc/config/sparc/sparc.h	(revision 278653)
+++ b/gcc/config/sparc/sparc.h	(revision 278653)
@@ -748,6 +748,13 @@
    register window instruction in the prologue.  */
 #define HARD_REGNO_RENAME_OK(FROM, TO) ((FROM) != 1)
 
+/* Select a register mode required for caller save of hard regno REGNO.
+   Contrary to what is documented, the default is not the smallest suitable
+   mode but the largest suitable mode for the given (REGNO, NREGS) pair and
+   it quickly creates paradoxical subregs that can be problematic.  */
+#define HARD_REGNO_CALLER_SAVE_MODE(REGNO, NREGS, MODE) \
+  ((MODE) == VOIDmode ? choose_hard_reg_mode (REGNO, NREGS, false) : (MODE))
+
 /* Specify the registers used for certain standard purposes.
    The values of these macros are register numbers.  */
 
Index: gcc/config/darwin.opt
===================================================================
diff --git a/gcc/config/darwin.opt b/gcc/config/darwin.opt
--- a/gcc/config/darwin.opt	(revision 278653)
+++ b/gcc/config/darwin.opt	(revision 278653)
@@ -18,241 +18,383 @@
 ; along with GCC; see the file COPYING3.  If not see
 ; <http://www.gnu.org/licenses/>.
 
-; Various linker options have a -Z added so that they can get to specs
-; processing without interference.  Note that an option name with a
-; prefix that matches another option name, that also takes an
-; argument, being mapped to a -Z linker option, needs to be modified
-; so the prefix is different, otherwise a '*' after the shorter option
-; will match with the longer one.
+; We have a lot of Driver options, many of which are obsolete or very very
+; rarely used so, to keep this file easier to manage:
 
+; Please place all Non-driver options first (in alphabetical order), followed
+; by Driver-only options.
+
+; Non-driver options.
+
+dependency-file
+C ObjC C++ ObjC++ Separate Alias(MF) MissingArgError(missing filename after %qs)
+
+fapple-kext
+Target Report C++ Var(flag_apple_kext)
+Generate code for darwin loadable kernel extensions.
+
+iframework
+Target RejectNegative C ObjC C++ ObjC++ Joined Separate
+-iframework <dir>	Add <dir> to the end of the system framework include path.
+
+mconstant-cfstrings
+Target Report Var(darwin_constant_cfstrings) Init(1)
+Generate compile-time CFString objects.
+
+Wnonportable-cfstrings
+Target Report Var(darwin_warn_nonportable_cfstrings) Init(1) Warning
+Warn if constant CFString objects contain non-portable characters.
+
+; Use new-style pic stubs if this is true, x86 only so far.
+matt-stubs
+Target Report Var(darwin_macho_att_stub) Init(1)
+Generate AT&T-style stubs for Mach-O.
+
+mdynamic-no-pic
+Target Common Report Mask(MACHO_DYNAMIC_NO_PIC)
+Generate code suitable for executables (NOT shared libs).
+
+mfix-and-continue
+Target Report Var(darwin_fix_and_continue)
+Generate code suitable for fast turn around debugging.
+
+mkernel
+Target Report Var(flag_mkernel)
+Generate code for the kernel or loadable kernel extensions.
+
+; The Init here is for the convenience of GCC developers, so that cc1
+; and cc1plus don't crash if no -mmacosx-version-min is passed.  The
+; driver will always pass a -mmacosx-version-min, so in normal use the
+; Init is never used.
+mmacosx-version-min=
+Target RejectNegative Joined Report Var(darwin_macosx_version_min) Init(DEF_MIN_OSX_VERSION)
+The earliest MacOS X version on which this program will run.
+
+; Really, only relevant to PowerPC which has a 4 byte bool by default.
+mone-byte-bool
+Target RejectNegative Report Var(darwin_one_byte_bool)
+Set sizeof(bool) to 1.
+
+msymbol-stubs
+Target Report Var(darwin_symbol_stubs) Init(0)
+Force generation of external symbol indirection stubs.
+
+; Some code-gen may be improved / adjusted if the linker is sufficiently modern.
+mtarget-linker=
+Target RejectNegative Joined Report Alias(mtarget-linker)
+
+mtarget-linker
+Target RejectNegative Joined Separate Report Var(darwin_target_linker) Init(LD64_VERSION)
+The version of ld64 in use for this toolchain.
+
+; Driver options.
+
 all_load
-Driver Alias(Zall_load)
+Driver RejectNegative Alias(Zall_load)
+Loads all members of archive libraries
 
 allowable_client
-Driver Separate Alias(Zallowable_client)
+Driver RejectNegative Separate Alias(Zallowable_client)
+-allowable_client <name>	The output dylib is private to the client(s) named
 
 arch
 Driver RejectNegative Separate
+-arch <name>	Specify that the output file should be generated for architecture  \"name\"
 
 arch_errors_fatal
-Driver Alias(Zarch_errors_fatal)
+Driver RejectNegative Alias(Zarch_errors_fatal)
+Mismatches between file architecture and the \"-arch\" are errors instead of warnings
 
 asm_macosx_version_min=
 Driver RejectNegative Joined
+The earliest MacOS X version on which this program will run (formatted for the assembler)
 
 bind_at_load
-Driver Alias(Zbind_at_load)
+Driver RejectNegative Alias(Zbind_at_load)
+Produce an output file that will bind symbols on load, rather than lazily.
 
 bundle
-Driver Alias(Zbundle)
+Driver RejectNegative Alias(Zbundle)
+Produce a Mach-O bundle (file type MH_BUNDLE)
 
 bundle_loader
-Driver Separate Alias(Zbundle_loader)
+Driver RejectNegative Separate Alias(Zbundle_loader)
+-bundle_loader <executable>	Treat \"executable\" (that will be loading this bundle) as if it was one of the dynamic libraries the bundle is linked against for symbol resolution
 
+client_name
+Driver RejectNegative Separate
+-client_name <name>	Enable the executable being built to link against a private dylib (using allowable_client)
+
+compatibility_version
+Driver RejectNegative Separate
+-compatibility_version <number>	Set the minimum version for the client interface.  Clients must record a greater number than this or the binding will fail at runtime
+
+current_version
+Driver RejectNegative Separate
+-current_version <number>	Set the current version for the library.
+
 dead_strip
-Driver Alias(Zdead_strip)
+Driver RejectNegative Alias(Zdead_strip)
+Remove code and data that is unreachable from any exported symbol (including the entry point)
 
-dependency-file
-C ObjC C++ ObjC++ Separate Alias(MF) MissingArgError(missing filename after %qs)
-
 dylib_file
 Driver Separate Alias(Zdylib_file)
 
 dylinker
-Driver
+Driver RejectNegative
+Produce a Mach-O dylinker (file type MH_DYLINKER), only used for building dyld.
 
+dylinker_install_name
+Driver RejectNegative Separate
+-dylinker_install_name <path>	Only used for building dyld.
+
 dynamic
-Driver Alias(Zdynamic)
+Driver RejectNegative Alias(Zdynamic)
+The default (and opposite of -static), implied by user mode executables, shared libraries and bundles.
 
 dynamiclib
-Driver Alias(Zdynamiclib)
+Driver RejectNegative Alias(Zdynamiclib)
+Produce a Mach-O shared library (file type MH_DYLIB), synonym for -shared
 
 exported_symbols_list
-Driver Separate Alias(Zexported_symbols_list)
+Driver RejectNegative Separate Alias(Zexported_symbols_list)
+-exported_symbols_list <filename>	Global symbols in \"filename\" will be exported from the linked output file, any symbols not mentioned will be treated as hidden.
 
 filelist
 Driver RejectNegative Separate
+Supply a list of objects to be linked from a file, rather than the command line
 
 findirect-virtual-calls
 Driver RejectNegative
+Used for generating code for some older kernel revisions.
 
 flat_namespace
 Driver RejectNegative Alias(Zflat_namespace)
+Ignore the normal two-level namespace; resolve symbols in command line order and do not record which library provided the resolved symbol.
 
 force_cpusubtype_ALL
 Driver RejectNegative Alias(Zforce_cpusubtype_ALL)
+For the assembler (and linker) permit any architecture sub-variant to be used without error.
 
 force_flat_namespace
 Driver RejectNegative Alias(Zforce_flat_namespace)
+Set the output object such that, on loading, dyld  will ignore any two-level information and resolve symbols in the discovery order for loaded libs.
 
 framework
 Driver RejectNegative Separate
+-framework <name>	The linker should search for the named framework in the framework search path.
 
 fterminated-vtables
 Driver RejectNegative
+Used for generating code for some older kernel revisions.
 
 gfull
 Driver RejectNegative
+Abbreviation for \"-g -fno-eliminate-unused-debug-symbols\"
 
 gused
 Driver RejectNegative
+Abbreviation for \"-g -feliminate-unused-debug-symbols\"
 
 headerpad_max_install_names
-Driver
+Driver RejectNegative
+Automatically adds space for longer path names in load commands (up to MAXPATHLEN)
 
 image_base
-Driver Separate Alias(Zimage_base)
+Driver RejectNegative Separate Alias(Zimage_base)
+-image_base <address>	Choose a base address for a dylib or bundle.
 
 init
-Driver Separate Alias(Zinit)
+Driver RejectNegative Separate Alias(Zinit)
+-init <symbol_name>	The symbol \"symbol_name\" will be used as the first initialiser for a dylib.
 
 install_name
-Driver Separate Alias(Zinstall_name)
+Driver RejectNegative Separate Alias(Zinstall_name)
+-install_name <name>	Set the install name for a dylib.
 
 keep_private_externs
-Driver
+Driver RejectNegative
+Usually \"private extern\" (hidden) symbols are made local when linking, this command suppresses that such that they remain exported.
 
-mconstant-cfstrings
-Target Report Var(darwin_constant_cfstrings) Init(1)
-Generate compile-time CFString objects.
-
 multi_module
 Driver RejectNegative Alias(Zmulti_module)
+(Obsolete after 10.4) Multi modules are ignored at runtime since MacOS 10.4
 
 multiply_defined
 Driver RejectNegative Separate Alias(Zmultiply_defined)
+(Obsolete after 10.4) -multiply_defined <treatment> Provided a mechanism for warning about symbols defined in multiple dylibs.
 
 multiply_defined_unused
 Driver RejectNegative Separate Alias(Zmultiplydefinedunused)
+(Obsolete after 10.4) -multiply_defined_unused <treatment>	Provided a mechanism for warning about symbols defined in the current executable also being defined in linked dylibs.
 
 no_dead_strip_inits_and_terms
-Driver Alias(Zno_dead_strip_inits_and_terms)
+Driver RejectNegative Alias(Zno_dead_strip_inits_and_terms)
+(Obsolete) The linker never dead strips these items, so the option is not needed.
 
 nofixprebinding
-Driver
+Driver RejectNegative
+(Obsolete after 10.3.9) Set MH_NOPREFIXBINDING, in an exectuable.
 
 nomultidefs
-Driver
+Driver RejectNegative
+(Obsolete after 10.4)	Set MH_NOMULTIDEFS in an umbrella framework.
 
 noprebind
-Driver
+Driver RejectNegative Negative(prebind)
+(Obsolete) LD_PREBIND is no longer supported.
 
 noseglinkedit
-Driver
+Driver RejectNegative Negative(seglinkedit)
+(Obsolete) This is the default.
 
 object
-Driver
+Driver RejectNegative
 
+pagezero_size
+Driver RejectNegative Separate
+-pagezero_size size	Allows setting the page 0 size to 4kb for certain special cases.
+
 prebind
-Driver
+Driver RejectNegative Negative(noprebind)
+(Obsolete) LD_PREBIND is no longer supported.
 
 prebind_all_twolevel_modules
-Driver
+Driver RejectNegative
+(Obsolete) LD_PREBIND is no longer supported.
 
 preload
-Driver
+Driver RejectNegative
+Produces a Mach-O file suitable for embedded/ROM use.
 
 private_bundle
-Driver
+Driver RejectNegative
+(Obsolete) Allowed linking to proceed with \"-flat_namespace\" when a linked bundle contained a symbol also exported from the main executable.
 
 pthread
-Driver
+Driver RejectNegative
 
 rdynamic
-Driver
+Driver RejectNegative
+Synonym for \"-export-dynamic\" for linker versions that support it.
 
+read_only_relocs
+Driver RejectNegative Separate
+-read_only_relocs <treatment>	This will allow relocs in read-only pages (not advisable).
+
+sectalign
+Driver RejectNegative Separate Args(3)
+-sectalign <segname> <sectname> <value>	Set section \"sectname\" in segment \"segname\" to have alignment \"value\" which must be an integral power of two expressed in hexadecimal form.
+
+sectcreate
+Driver RejectNegative Separate Args(3)
+-sectcreate <segname> <sectname> <file>	Create section \"sectname\" in segment \"segname\" from the contents of \"file\".
+
+sectobjectsymbols
+Driver RejectNegative Separate Args(2)
+(Obsolete) -sectobjectsymbols <segname> <sectname>	Setting a local symbol at the start of a section is no longer supported.
+
+sectorder
+Driver RejectNegative Separate Args(3)
+(Obsolete) -sectorder <segname> <sectname> orderfile	Replaced by a more general option \"-order_file\".
+
 seg_addr_table
-Driver Separate Alias(Zseg_addr_table)
+Driver RejectNegative Separate Alias(Zseg_addr_table)
+-seg_addr_table <file>	Specify the base addresses for dynamic libraries, \"file\" contains a line for each library.
 
+; This is only usable by the ld_classic linker.
 seg_addr_table_filename
-Driver Separate Alias(Zfn_seg_addr_table_filename)
+Driver RejectNegative Separate Alias(Zfn_seg_addr_table_filename)
+(Obsolete, ld_classic only) -seg_addr_table_filename <path>
 
+seg1addr
+Driver RejectNegative Separate
+Synonym for \"image_base\"
+
 segaddr
-Driver Separate Args(2) Alias(Zsegaddr)
+Driver RejectNegative Separate Args(2) Alias(Zsegaddr)
+-segaddr <name> <address>	Set the base address of segment \"name\" to \"address\" which must be aligned to a page boundary (currently 4kb).
 
+; This is only usable by the ld_classic linker.
+segcreate
+Driver RejectNegative Separate Args(3)
+(Obsolete, ld_classic only) -sectcreate segname sectname file
+
 seglinkedit
-Driver
+Driver RejectNegative Negative(noseglinkedit)
+(Obsolete) Object files with LINKEDIT sections are no longer supported.
 
+segprot
+Driver RejectNegative Separate Args(3)
+-segprot <segname> max_prot init_prot	The protection values are \"r\", \"w\", \"x\" or \"-\" the latter meaning \"no access\".
+
 segs_read_only_addr
-Driver Separate Alias(Zsegs_read_only_addr)
+Driver RejectNegative Separate Alias(Zsegs_read_only_addr)
+-segs_read_only_addr address 	Allows specifying the address of the read only portion of a dylib.
 
 segs_read_write_addr
-Driver Separate Alias(Zsegs_read_write_addr)
+Driver RejectNegative Separate Alias(Zsegs_read_write_addr)
+-segs_read_write_addr address 	Allows specifying the address of the read/write portion of a dylib.
 
 single_module
-Driver Alias(Zsingle_module)
+Driver RejectNegative Alias(Zsingle_module)
+(Obsolete)	This is the default.
 
+sub_library
+Driver RejectNegative Separate
+-sub_library <name>	Library named \"name\" will be re-exported (only useful for dylibs).
+
+sub_umbrella
+Driver RejectNegative Separate
+-sub_umbrella <name>	Framework named \"name\" will be re-exported (only useful for dylibs).
+
 twolevel_namespace
-Driver
+Driver RejectNegative
+This is the default
 
 twolevel_namespace_hints
-Driver
+Driver RejectNegative
+Specifies content that can speed up dynamic loading when the binaries are unchanged.
 
 umbrella
-Driver Separate Alias(Zumbrella)
+Driver RejectNegative Separate Alias(Zumbrella)
+-umbrella <framework>	The specified framework will be re-exported.
 
+undefined
+Driver RejectNegative Separate
+-undefined <treatment>	Specify the handling for undefined symbols (default is error).
+
 unexported_symbols_list
-Driver Separate Alias(Zunexported_symbols_list)
+Driver RejectNegative Separate Alias(Zunexported_symbols_list)
+-unexported_symbols_list <filename>	Don't export global symbols listed in filename.
 
 weak_reference_mismatches
-Driver Separate Alias(Zweak_reference_mismatches)
+Driver RejectNegative Separate Alias(Zweak_reference_mismatches)
+-weak_reference_mismatches <treatment>	Specifies what to do if a symbol import conflicts between file (weak in one and not in another) the default is to treat the symbol as non-weak.
 
 whatsloaded
-Driver
+Driver RejectNegative
+Logs the object files the linker loads
 
 whyload
-Driver
+Driver RejectNegative
+Logs which symbol(s) caused an object to be loaded.
 
+;(Obsolete, ignored)	Strip symbols starting with "L", this is the default.
+X
+Driver RejectNegative
+
 y
-Driver Joined
+Driver RejectNegative Joined
+(Obsolete, ignored)	Old support similar to whyload.
 
 Mach
-Driver
+Driver RejectNegative
+(Obsolete and unhandled by ld64, ignored)	ld should produce an executable (only handled by ld_classic).
 
-Wnonportable-cfstrings
-Target Report Var(darwin_warn_nonportable_cfstrings) Init(1) Warning
-Warn if constant CFString objects contain non-portable characters.
+;; These are not "real" options, but placeholders used to hide the real options
+;; from generic options processing... FIXME: they can be eliminated now.
 
-; Use new-style pic stubs if this is true, x86 only so far.
-matt-stubs
-Target Report Var(darwin_macho_att_stub) Init(1)
-Generate AT&T-style stubs for Mach-O.
-
-mdynamic-no-pic
-Target Common Report Mask(MACHO_DYNAMIC_NO_PIC)
-Generate code suitable for executables (NOT shared libs).
-
-mfix-and-continue
-Target Report Var(darwin_fix_and_continue)
-Generate code suitable for fast turn around debugging.
-
-; The Init here is for the convenience of GCC developers, so that cc1
-; and cc1plus don't crash if no -mmacosx-version-min is passed.  The
-; driver will always pass a -mmacosx-version-min, so in normal use the
-; Init is never used.
-mmacosx-version-min=
-Target Joined Report Var(darwin_macosx_version_min) Init(DEF_MIN_OSX_VERSION)
-The earliest MacOS X version on which this program will run.
-
-mone-byte-bool
-Target RejectNegative Report Var(darwin_one_byte_bool)
-Set sizeof(bool) to 1.
-
-fapple-kext
-Target Report C++ Var(flag_apple_kext)
-Generate code for darwin loadable kernel extensions.
-
-mkernel
-Target Report Var(flag_mkernel)
-Generate code for the kernel or loadable kernel extensions.
-
-iframework
-Target RejectNegative C ObjC C++ ObjC++ Joined Separate 
--iframework <dir>	Add <dir> to the end of the system framework include path.
-
-X
-Driver
-
 Zall_load
 Driver
 
@@ -343,62 +485,3 @@
 Zweak_reference_mismatches
 Driver Separate
 
-client_name
-Driver Separate
-
-compatibility_version
-Driver Separate
-
-current_version
-Driver Separate
-
-dylinker_install_name
-Driver Separate
-
-pagezero_size
-Driver Separate
-
-read_only_relocs
-Driver Separate
-
-sectalign
-Driver Separate Args(3)
-
-sectcreate
-Driver Separate Args(3)
-
-sectobjectsymbols
-Driver Separate Args(2)
-
-sectorder
-Driver Separate Args(3)
-
-seg1addr
-Driver Separate
-
-segcreate
-Driver Separate Args(3)
-
-segprot
-Driver Separate Args(3)
-
-segs_read_only_addr
-Driver Separate
-
-segs_read_write_addr
-Driver Separate
-
-sub_library
-Driver Separate
-
-sub_umbrella
-Driver Separate
-
-; Certain aspects of code-gen may be improved / adjusted if the version of ld64
-; is sufficiently modern.
-mtarget-linker
-Target RejectNegative Joined Separate Report Var(darwin_target_linker) Init(LD64_VERSION)
-The version of ld64 in use for this toolchain.
-
-undefined
-Driver Separate
Index: gcc/config/darwin-c.c
===================================================================
diff --git a/gcc/config/darwin-c.c b/gcc/config/darwin-c.c
--- a/gcc/config/darwin-c.c	(revision 278653)
+++ b/gcc/config/darwin-c.c	(revision 278653)
@@ -463,41 +463,32 @@
 /* Register the GNU objective-C runtime include path if STDINC.  */
 
 void
-darwin_register_objc_includes (const char *sysroot, const char *iprefix,
-			       int stdinc)
+darwin_register_objc_includes (const char *sysroot ATTRIBUTE_UNUSED,
+			       const char *iprefix, int stdinc)
 {
-  const char *fname;
-  size_t len;
-  /* We do not do anything if we do not want the standard includes. */
-  if (!stdinc)
-    return;
+  /* If we want standard includes;  Register the GNU OBJC runtime include
+     path if we are compiling OBJC with GNU-runtime.
+     This path is compiler-relative, we don't want to prepend the sysroot
+     since it's not expected to find the headers there.  */
 
-  fname = GCC_INCLUDE_DIR "-gnu-runtime";
-
-  /* Register the GNU OBJC runtime include path if we are compiling  OBJC
-    with GNU-runtime.  */
-
-  if (c_dialect_objc () && !flag_next_runtime)
+  if (stdinc && c_dialect_objc () && !flag_next_runtime)
     {
+      const char *fname = GCC_INCLUDE_DIR "-gnu-runtime";
       char *str;
-      /* See if our directory starts with the standard prefix.
+      size_t len;
+
+     /* See if our directory starts with the standard prefix.
 	 "Translate" them, i.e. replace /usr/local/lib/gcc... with
 	 IPREFIX and search them first.  */
-      if (iprefix && (len = cpp_GCC_INCLUDE_DIR_len) != 0 && !sysroot
+      if (iprefix && (len = cpp_GCC_INCLUDE_DIR_len) != 0
 	  && !strncmp (fname, cpp_GCC_INCLUDE_DIR, len))
 	{
 	  str = concat (iprefix, fname + len, NULL);
-          /* FIXME: wrap the headers for C++awareness.  */
-	  add_path (str, INC_SYSTEM, /*c++aware=*/false, false);
+	  add_path (str, INC_SYSTEM, /*c++aware=*/true, false);
 	}
 
-      /* Should this directory start with the sysroot?  */
-      if (sysroot)
-	str = concat (sysroot, fname, NULL);
-      else
-	str = update_path (fname, "");
-
-      add_path (str, INC_SYSTEM, /*c++aware=*/false, false);
+      str = update_path (fname, "");
+      add_path (str, INC_SYSTEM, /*c++aware=*/true, false);
     }
 }
 
Index: gcc/config/i386/t-darwin
===================================================================
diff --git a/gcc/config/i386/t-darwin b/gcc/config/i386/t-darwin
deleted file mode 10644
--- a/gcc/config/i386/t-darwin	(revision 278653)
+++ /dev/null	(nonexistent)
@@ -1,2 +0,0 @@
-MULTILIB_OPTIONS = m64
-MULTILIB_DIRNAMES = x86_64
Index: gcc/config/i386/darwin64.h
===================================================================
diff --git a/gcc/config/i386/darwin64.h b/gcc/config/i386/darwin64.h
deleted file mode 10644
--- a/gcc/config/i386/darwin64.h	(revision 278653)
+++ /dev/null	(nonexistent)
@@ -1,58 +0,0 @@
-/* Target definitions for x86_64 running Darwin.
-   Copyright (C) 2006-2018 Free Software Foundation, Inc.
-   Contributed by Apple Computer Inc.
-
-This file is part of GCC.
-
-GCC is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 3, or (at your option)
-any later version.
-
-GCC is distributed in the hope that it will be useful,
-but WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GCC; see the file COPYING3.  If not see
-<http://www.gnu.org/licenses/>.  */
-
-#undef  DARWIN_ARCH_SPEC
-#define DARWIN_ARCH_SPEC "%{m32:i386;:x86_64}"
-
-/* WORKAROUND pr80556:
-   For x86_64 Darwin10 and later, the unwinder is in libunwind (redirected
-   from libSystem).  This doesn't use the keymgr (see keymgr.c) and therefore
-   the calls that libgcc makes to obtain the KEYMGR_GCC3_DW2_OBJ_LIST are not
-   updated to include new images, and might not even be valid for a single
-   image.
-   Therefore, for 64b exes at least, we must use the libunwind implementation,
-   even when static-libgcc is specified.  We put libSystem first so that
-   unwinder symbols are satisfied from there. */
-#undef REAL_LIBGCC_SPEC
-#define REAL_LIBGCC_SPEC						   \
-   "%{static-libgcc|static: 						   \
-      %{!m32:%:version-compare(>= 10.6 mmacosx-version-min= -lSystem)}	   \
-        -lgcc_eh -lgcc;							   \
-      shared-libgcc|fexceptions|fgnu-runtime:				   \
-       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_s.10.4)	   \
-       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
-       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
-       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
-       -lgcc ;								   \
-      :%:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_s.10.4) \
-       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
-       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
-       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
-       -lgcc }"
-
-#undef  DARWIN_SUBARCH_SPEC
-#define DARWIN_SUBARCH_SPEC DARWIN_ARCH_SPEC
-
-#undef SUBTARGET_EXTRA_SPECS
-#define SUBTARGET_EXTRA_SPECS                                   \
-  DARWIN_EXTRA_SPECS                                            \
-  { "darwin_arch", DARWIN_ARCH_SPEC },                          \
-  { "darwin_crt2", "" },                                        \
-  { "darwin_subarch", DARWIN_SUBARCH_SPEC },
Index: gcc/config/i386/t-darwin64
===================================================================
diff --git a/gcc/config/i386/t-darwin64 b/gcc/config/i386/t-darwin64
deleted file mode 10644
--- a/gcc/config/i386/t-darwin64	(revision 278653)
+++ /dev/null	(nonexistent)
@@ -1,2 +0,0 @@
-MULTILIB_OPTIONS = m32
-MULTILIB_DIRNAMES = i386
Index: gcc/config/i386/i386.h
===================================================================
diff --git a/gcc/config/i386/i386.h b/gcc/config/i386/i386.h
--- a/gcc/config/i386/i386.h	(revision 278653)
+++ b/gcc/config/i386/i386.h	(revision 278653)
@@ -621,7 +621,7 @@
 /* Replace MACH-O, ifdefs by in-line tests, where possible. 
    (a) Macros defined in config/i386/darwin.h  */
 #define TARGET_MACHO 0
-#define TARGET_MACHO_BRANCH_ISLANDS 0
+#define TARGET_MACHO_SYMBOL_STUBS 0
 #define MACHOPIC_ATT_STUB 0
 /* (b) Macros defined in config/darwin.h  */
 #define MACHO_DYNAMIC_NO_PIC_P 0
Index: gcc/config/i386/t-darwin64-biarch
===================================================================
diff --git a/gcc/config/i386/t-darwin64-biarch b/gcc/config/i386/t-darwin64-biarch
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/config/i386/t-darwin64-biarch	(revision 278653)
@@ -0,0 +1,2 @@
+MULTILIB_OPTIONS = m32
+MULTILIB_DIRNAMES = i386
Index: gcc/config/i386/t-freebsd64
===================================================================
diff --git a/gcc/config/i386/t-freebsd64 b/gcc/config/i386/t-freebsd64
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/config/i386/t-freebsd64	(revision 278653)
@@ -0,0 +1,30 @@
+# Copyright (C) 2019 Free Software Foundation, Inc.
+#
+# This file is part of GCC.
+#
+# GCC is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GCC is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# The 32-bit libraries are found in /usr/lib32
+
+# To support i386 and x86-64, the directory structrue
+# should be:
+#
+# 	/lib has x86-64 libraries.
+# 	/lib32 has i386 libraries.
+#
+
+MULTILIB_OPTIONS    = m32
+MULTILIB_DIRNAMES   = 32
+MULTILIB_OSDIRNAMES = ../lib32
Index: gcc/config/i386/i386.md
===================================================================
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
--- a/gcc/config/i386/i386.md	(revision 278653)
+++ b/gcc/config/i386/i386.md	(revision 278653)
@@ -8942,7 +8942,24 @@
   [(parallel [(set (match_dup 0)
 		   (zero_extend:DI (and:SI (match_dup 1) (match_dup 2))))
 	      (clobber (reg:CC FLAGS_REG))])]
-  "operands[2] = gen_lowpart (SImode, operands[2]);")
+{
+  if (GET_CODE (operands[2]) == SYMBOL_REF
+      || GET_CODE (operands[2]) == LABEL_REF)
+    {
+      operands[2] = shallow_copy_rtx (operands[2]);
+      PUT_MODE (operands[2], SImode);
+    }
+  else if (GET_CODE (operands[2]) == CONST)
+    {
+      /* (const:DI (plus:DI (symbol_ref:DI ("...")) (const_int N))) */
+      operands[2] = copy_rtx (operands[2]);
+      PUT_MODE (operands[2], SImode);
+      PUT_MODE (XEXP (operands[2], 0), SImode);
+      PUT_MODE (XEXP (XEXP (operands[2], 0), 0), SImode);
+    }    
+  else
+    operands[2] = gen_lowpart (SImode, operands[2]);
+})
 
 ;; See comment for addsi_1_zext why we do use nonimmediate_operand
 (define_insn "*andsi_1_zext"
Index: gcc/config/i386/avx2intrin.h
===================================================================
diff --git a/gcc/config/i386/avx2intrin.h b/gcc/config/i386/avx2intrin.h
--- a/gcc/config/i386/avx2intrin.h	(revision 278653)
+++ b/gcc/config/i386/avx2intrin.h	(revision 278653)
@@ -258,7 +258,7 @@
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm256_cmpgt_epi8 (__m256i __A, __m256i __B)
 {
-  return (__m256i) ((__v32qi)__A > (__v32qi)__B);
+  return (__m256i) ((__v32qs)__A > (__v32qs)__B);
 }
 
 extern __inline __m256i
Index: gcc/config/i386/t-darwin32-biarch
===================================================================
diff --git a/gcc/config/i386/t-darwin32-biarch b/gcc/config/i386/t-darwin32-biarch
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/config/i386/t-darwin32-biarch	(revision 278653)
@@ -0,0 +1,2 @@
+MULTILIB_OPTIONS = m64
+MULTILIB_DIRNAMES = x86_64
Index: gcc/config/i386/freebsd64.h
===================================================================
diff --git a/gcc/config/i386/freebsd64.h b/gcc/config/i386/freebsd64.h
--- a/gcc/config/i386/freebsd64.h	(revision 278653)
+++ b/gcc/config/i386/freebsd64.h	(revision 278653)
@@ -31,7 +31,7 @@
 
 #undef	LINK_SPEC
 #define LINK_SPEC "\
-  %{m32:-m elf_i386_fbsd} \
+  %{m32:-m elf_i386_fbsd}%{!m32:-m elf_x86_64_fbsd} \
   %{p:%nconsider using '-pg' instead of '-p' with gprof(1)} \
   %{v:-V} \
   %{assert*} %{R*} %{rpath*} %{defsym*} \
@@ -42,3 +42,6 @@
 	-dynamic-linker %(fbsd_dynamic_linker) } \
     %{static:-Bstatic}} \
   %{symbolic:-Bsymbolic}"
+
+#undef	MULTILIB_DEFAULTS
+#define MULTILIB_DEFAULTS { "m64" }
Index: gcc/config/i386/cpuid.h
===================================================================
diff --git a/gcc/config/i386/cpuid.h b/gcc/config/i386/cpuid.h
--- a/gcc/config/i386/cpuid.h	(revision 278653)
+++ b/gcc/config/i386/cpuid.h	(revision 278653)
@@ -178,10 +178,27 @@
 #define signature_VORTEX_ecx	0x436f5320
 #define signature_VORTEX_edx	0x36387865
 
+#ifndef __x86_64__
+/* At least one cpu (Winchip 2) does not set %ebx and %ecx
+   for cpuid leaf 1. Forcibly zero the two registers before
+   calling cpuid as a precaution.  */
 #define __cpuid(level, a, b, c, d)			\
+  do {							\
+    if (__builtin_constant_p (level) && (level) != 1)	\
+      __asm__ ("cpuid\n\t"				\
+	      : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
+	      : "0" (level));				\
+    else						\
+      __asm__ ("cpuid\n\t"				\
+	      : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
+	      : "0" (level), "1" (0), "2" (0));		\
+  } while (0)
+#else
+#define __cpuid(level, a, b, c, d)			\
   __asm__ ("cpuid\n\t"					\
 	   : "=a" (a), "=b" (b), "=c" (c), "=d" (d)	\
 	   : "0" (level))
+#endif
 
 #define __cpuid_count(level, count, a, b, c, d)		\
   __asm__ ("cpuid\n\t"					\
Index: gcc/config/i386/darwin32-biarch.h
===================================================================
diff --git a/gcc/config/i386/darwin32-biarch.h b/gcc/config/i386/darwin32-biarch.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/config/i386/darwin32-biarch.h	(revision 278653)
@@ -0,0 +1,58 @@
+/* Target definitions for i386 running Darwin with a 32b host and supporting
+   a 64b multilib.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#undef DARWIN_ARCH_SPEC
+#define DARWIN_ARCH_SPEC "%{m64:x86_64;:i386}"
+
+/* WORKAROUND pr80556:
+   For x86_64 Darwin10 and later, the unwinder is in libunwind (redirected
+   from libSystem).  This doesn't use the keymgr (see keymgr.c) and therefore
+   the calls that libgcc makes to obtain the KEYMGR_GCC3_DW2_OBJ_LIST are not
+   updated to include new images, and might not even be valid for a single
+   image.
+   Therefore, for 64b exes at least, we must use the libunwind implementation,
+   even when static-libgcc is specified.  We put libSystem first so that
+   unwinder symbols are satisfied from there. */
+#undef REAL_LIBGCC_SPEC
+#define REAL_LIBGCC_SPEC						   \
+   "%{static-libgcc|static: 						   \
+      %{m64:%:version-compare(>= 10.6 mmacosx-version-min= -lSystem)}	   \
+        -lgcc_eh -lgcc;							   \
+      shared-libgcc|fexceptions|fgnu-runtime:				   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_s.10.4)	   \
+       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
+       -lgcc ;								   \
+      :%:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_s.10.4) \
+       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
+       -lgcc }"
+
+#undef  DARWIN_SUBARCH_SPEC
+#define DARWIN_SUBARCH_SPEC DARWIN_ARCH_SPEC
+
+#undef SUBTARGET_EXTRA_SPECS
+#define SUBTARGET_EXTRA_SPECS                                   \
+  DARWIN_EXTRA_SPECS                                            \
+  { "darwin_arch", DARWIN_ARCH_SPEC },                          \
+  { "darwin_crt2", "" },                                        \
+  { "darwin_subarch", DARWIN_SUBARCH_SPEC },
Index: gcc/config/i386/darwin64-biarch.h
===================================================================
diff --git a/gcc/config/i386/darwin64-biarch.h b/gcc/config/i386/darwin64-biarch.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/config/i386/darwin64-biarch.h	(revision 278653)
@@ -0,0 +1,59 @@
+/* Target definitions for x86_64 running Darwin with a 64b host supporting a
+   32b multilib.
+   Copyright (C) 2006-2019 Free Software Foundation, Inc.
+   Contributed by Apple Computer Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+#undef  DARWIN_ARCH_SPEC
+#define DARWIN_ARCH_SPEC "%{m32:i386;:x86_64}"
+
+/* WORKAROUND pr80556:
+   For x86_64 Darwin10 and later, the unwinder is in libunwind (redirected
+   from libSystem).  This doesn't use the keymgr (see keymgr.c) and therefore
+   the calls that libgcc makes to obtain the KEYMGR_GCC3_DW2_OBJ_LIST are not
+   updated to include new images, and might not even be valid for a single
+   image.
+   Therefore, for 64b exes at least, we must use the libunwind implementation,
+   even when static-libgcc is specified.  We put libSystem first so that
+   unwinder symbols are satisfied from there. */
+#undef REAL_LIBGCC_SPEC
+#define REAL_LIBGCC_SPEC						   \
+   "%{static-libgcc|static: 						   \
+      %{!m32:%:version-compare(>= 10.6 mmacosx-version-min= -lSystem)}	   \
+        -lgcc_eh -lgcc;							   \
+      shared-libgcc|fexceptions|fgnu-runtime:				   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_s.10.4)	   \
+       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
+       -lgcc ;								   \
+      :%:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_s.10.4) \
+       %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
+       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
+       -lgcc }"
+
+#undef  DARWIN_SUBARCH_SPEC
+#define DARWIN_SUBARCH_SPEC DARWIN_ARCH_SPEC
+
+#undef SUBTARGET_EXTRA_SPECS
+#define SUBTARGET_EXTRA_SPECS                                   \
+  DARWIN_EXTRA_SPECS                                            \
+  { "darwin_arch", DARWIN_ARCH_SPEC },                          \
+  { "darwin_crt2", "" },                                        \
+  { "darwin_subarch", DARWIN_SUBARCH_SPEC },
Index: gcc/config/i386/sse.md
===================================================================
diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
--- a/gcc/config/i386/sse.md	(revision 278653)
+++ b/gcc/config/i386/sse.md	(revision 278653)
@@ -1908,7 +1908,7 @@
   [(set (match_operand:VF1_128_256 0 "register_operand")
 	(unspec:VF1_128_256
 	  [(match_operand:VF1_128_256 1 "vector_operand")] UNSPEC_RSQRT))]
-  "TARGET_SSE_MATH"
+  "TARGET_SSE && TARGET_SSE_MATH"
 {
   ix86_emit_swsqrtsf (operands[0], operands[1], <MODE>mode, true);
   DONE;
@@ -15172,7 +15172,7 @@
     }
 })
 
-(define_insn "abs<mode>2"
+(define_insn "ssse3_abs<mode>2"
   [(set (match_operand:MMXMODEI 0 "register_operand" "=y")
 	(abs:MMXMODEI
 	  (match_operand:MMXMODEI 1 "nonimmediate_operand" "ym")))]
@@ -16271,9 +16271,9 @@
     case 3:
       /* %X5 so that we don't emit any *WORD PTR for -masm=intel, as
 	 gas changed what it requires incompatibly.  */
-      return "vgatherpf0<ssemodesuffix>ps\t{%5%{%0%}|%X5%{%0%}}";
+      return "%M2vgatherpf0<ssemodesuffix>ps\t{%5%{%0%}|%X5%{%0%}}";
     case 2:
-      return "vgatherpf1<ssemodesuffix>ps\t{%5%{%0%}|%X5%{%0%}}";
+      return "%M2vgatherpf1<ssemodesuffix>ps\t{%5%{%0%}|%X5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -16318,9 +16318,9 @@
     case 3:
       /* %X5 so that we don't emit any *WORD PTR for -masm=intel, as
 	 gas changed what it requires incompatibly.  */
-      return "vgatherpf0<ssemodesuffix>pd\t{%5%{%0%}|%X5%{%0%}}";
+      return "%M2vgatherpf0<ssemodesuffix>pd\t{%5%{%0%}|%X5%{%0%}}";
     case 2:
-      return "vgatherpf1<ssemodesuffix>pd\t{%5%{%0%}|%X5%{%0%}}";
+      return "%M2vgatherpf1<ssemodesuffix>pd\t{%5%{%0%}|%X5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -16366,10 +16366,10 @@
     case 7:
       /* %X5 so that we don't emit any *WORD PTR for -masm=intel, as
 	 gas changed what it requires incompatibly.  */
-      return "vscatterpf0<ssemodesuffix>ps\t{%5%{%0%}|%X5%{%0%}}";
+      return "%M2vscatterpf0<ssemodesuffix>ps\t{%5%{%0%}|%X5%{%0%}}";
     case 2:
     case 6:
-      return "vscatterpf1<ssemodesuffix>ps\t{%5%{%0%}|%X5%{%0%}}";
+      return "%M2vscatterpf1<ssemodesuffix>ps\t{%5%{%0%}|%X5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -16415,10 +16415,10 @@
     case 7:
       /* %X5 so that we don't emit any *WORD PTR for -masm=intel, as
 	 gas changed what it requires incompatibly.  */
-      return "vscatterpf0<ssemodesuffix>pd\t{%5%{%0%}|%X5%{%0%}}";
+      return "%M2vscatterpf0<ssemodesuffix>pd\t{%5%{%0%}|%X5%{%0%}}";
     case 2:
     case 6:
-      return "vscatterpf1<ssemodesuffix>pd\t{%5%{%0%}|%X5%{%0%}}";
+      return "%M2vscatterpf1<ssemodesuffix>pd\t{%5%{%0%}|%X5%{%0%}}";
     default:
       gcc_unreachable ();
     }
@@ -19157,7 +19157,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:VEC_GATHER_MODE 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %7, %0|%0, %7, %1}"
+  "%M3v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %7, %0|%0, %7, %1}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19177,7 +19177,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:VEC_GATHER_MODE 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %6, %0|%0, %6, %1}"
+  "%M2v<sseintprefix>gatherd<ssemodesuffix>\t{%1, %6, %0|%0, %6, %1}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19218,7 +19218,7 @@
 	  UNSPEC_GATHER))
    (clobber (match_scratch:VEC_GATHER_MODE 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %2|%2, %7, %5}"
+  "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %2|%2, %7, %5}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19240,8 +19240,8 @@
   "TARGET_AVX2"
 {
   if (<MODE>mode != <VEC_GATHER_SRCDI>mode)
-    return "v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %x0|%x0, %6, %4}";
-  return "v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}";
+    return "%M2v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %x0|%x0, %6, %4}";
+  return "%M2v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}";
 }
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
@@ -19265,7 +19265,7 @@
 		     (const_int 2) (const_int 3)])))
    (clobber (match_scratch:VI4F_256 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %0|%0, %7, %5}"
+  "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %7, %0|%0, %7, %5}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19288,7 +19288,7 @@
 		     (const_int 2) (const_int 3)])))
    (clobber (match_scratch:VI4F_256 1 "=&x"))]
   "TARGET_AVX2"
-  "v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}"
+  "%M2v<sseintprefix>gatherq<ssemodesuffix>\t{%4, %6, %0|%0, %6, %4}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "vex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19328,7 +19328,7 @@
   "TARGET_AVX512F"
 ;; %X6 so that we don't emit any *WORD PTR for -masm=intel, as
 ;; gas changed what it requires incompatibly.
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%6, %0%{%2%}|%0%{%2%}, %X6}"
+  "%M4v<sseintprefix>gatherd<ssemodesuffix>\t{%6, %0%{%2%}|%0%{%2%}, %X6}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19349,7 +19349,7 @@
   "TARGET_AVX512F"
 ;; %X5 so that we don't emit any *WORD PTR for -masm=intel, as
 ;; gas changed what it requires incompatibly.
-  "v<sseintprefix>gatherd<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %X5}"
+  "%M3v<sseintprefix>gatherd<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %X5}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19390,7 +19390,7 @@
   "TARGET_AVX512F"
 ;; %X6 so that we don't emit any *WORD PTR for -masm=intel, as
 ;; gas changed what it requires incompatibly.
-  "v<sseintprefix>gatherq<ssemodesuffix>\t{%6, %1%{%2%}|%1%{%2%}, %X6}"
+  "%M4v<sseintprefix>gatherq<ssemodesuffix>\t{%6, %1%{%2%}|%1%{%2%}, %X6}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19415,11 +19415,11 @@
   if (<MODE>mode != <VEC_GATHER_SRCDI>mode)
     {
       if (<MODE_SIZE> != 64)
-	return "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %x0%{%1%}|%x0%{%1%}, %X5}";
+	return "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %x0%{%1%}|%x0%{%1%}, %X5}";
       else
-	return "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %t0%{%1%}|%t0%{%1%}, %X5}";
+	return "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %t0%{%1%}|%t0%{%1%}, %X5}";
     }
-  return "v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %X5}";
+  return "%M3v<sseintprefix>gatherq<ssemodesuffix>\t{%5, %0%{%1%}|%0%{%1%}, %X5}";
 }
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
@@ -19458,7 +19458,7 @@
   "TARGET_AVX512F"
 ;; %X5 so that we don't emit any *WORD PTR for -masm=intel, as
 ;; gas changed what it requires incompatibly.
-  "v<sseintprefix>scatterd<ssemodesuffix>\t{%3, %5%{%1%}|%X5%{%1%}, %3}"
+  "%M0v<sseintprefix>scatterd<ssemodesuffix>\t{%3, %5%{%1%}|%X5%{%1%}, %3}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
@@ -19496,7 +19496,7 @@
   "TARGET_AVX512F"
 ;; %X5 so that we don't emit any *WORD PTR for -masm=intel, as
 ;; gas changed what it requires incompatibly.
-  "v<sseintprefix>scatterq<ssemodesuffix>\t{%3, %5%{%1%}|%X5%{%1%}, %3}"
+  "%M0v<sseintprefix>scatterq<ssemodesuffix>\t{%3, %5%{%1%}|%X5%{%1%}, %3}"
   [(set_attr "type" "ssemov")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<sseinsnmode>")])
Index: gcc/config/i386/i386-builtin.def
===================================================================
diff --git a/gcc/config/i386/i386-builtin.def b/gcc/config/i386/i386-builtin.def
--- a/gcc/config/i386/i386-builtin.def	(revision 278653)
+++ b/gcc/config/i386/i386-builtin.def	(revision 278653)
@@ -806,11 +806,11 @@
 
 /* SSSE3 */
 BDESC (OPTION_MASK_ISA_SSSE3, CODE_FOR_absv16qi2, "__builtin_ia32_pabsb128", IX86_BUILTIN_PABSB128, UNKNOWN, (int) V16QI_FTYPE_V16QI)
-BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, CODE_FOR_absv8qi2, "__builtin_ia32_pabsb", IX86_BUILTIN_PABSB, UNKNOWN, (int) V8QI_FTYPE_V8QI)
+BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, CODE_FOR_ssse3_absv8qi2, "__builtin_ia32_pabsb", IX86_BUILTIN_PABSB, UNKNOWN, (int) V8QI_FTYPE_V8QI)
 BDESC (OPTION_MASK_ISA_SSSE3, CODE_FOR_absv8hi2, "__builtin_ia32_pabsw128", IX86_BUILTIN_PABSW128, UNKNOWN, (int) V8HI_FTYPE_V8HI)
-BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, CODE_FOR_absv4hi2, "__builtin_ia32_pabsw", IX86_BUILTIN_PABSW, UNKNOWN, (int) V4HI_FTYPE_V4HI)
+BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, CODE_FOR_ssse3_absv4hi2, "__builtin_ia32_pabsw", IX86_BUILTIN_PABSW, UNKNOWN, (int) V4HI_FTYPE_V4HI)
 BDESC (OPTION_MASK_ISA_SSSE3, CODE_FOR_absv4si2, "__builtin_ia32_pabsd128", IX86_BUILTIN_PABSD128, UNKNOWN, (int) V4SI_FTYPE_V4SI)
-BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, CODE_FOR_absv2si2, "__builtin_ia32_pabsd", IX86_BUILTIN_PABSD, UNKNOWN, (int) V2SI_FTYPE_V2SI)
+BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, CODE_FOR_ssse3_absv2si2, "__builtin_ia32_pabsd", IX86_BUILTIN_PABSD, UNKNOWN, (int) V2SI_FTYPE_V2SI)
 
 BDESC (OPTION_MASK_ISA_SSSE3, CODE_FOR_ssse3_phaddwv8hi3, "__builtin_ia32_phaddw128", IX86_BUILTIN_PHADDW128, UNKNOWN, (int) V8HI_FTYPE_V8HI_V8HI)
 BDESC (OPTION_MASK_ISA_SSSE3 | OPTION_MASK_ISA_MMX, CODE_FOR_ssse3_phaddwv4hi3, "__builtin_ia32_phaddw", IX86_BUILTIN_PHADDW, UNKNOWN, (int) V4HI_FTYPE_V4HI_V4HI)
Index: gcc/config/i386/darwin.h
===================================================================
diff --git a/gcc/config/i386/darwin.h b/gcc/config/i386/darwin.h
--- a/gcc/config/i386/darwin.h	(revision 278653)
+++ b/gcc/config/i386/darwin.h	(revision 278653)
@@ -47,12 +47,13 @@
    image.
    Therefore, for 64b exes at least, we must use the libunwind implementation,
    even when static-libgcc is specified.  We put libSystem first so that
-   unwinder symbols are satisfied from there. */
+   unwinder symbols are satisfied from there.
+   We default to 64b for single-arch builds, so apply this unconditionally. */
 #undef REAL_LIBGCC_SPEC
 #define REAL_LIBGCC_SPEC						   \
    "%{static-libgcc|static: 						   \
-      %{m64:%:version-compare(>= 10.6 mmacosx-version-min= -lSystem)}	   \
-        -lgcc_eh -lgcc;							   \
+       %:version-compare(>= 10.6 mmacosx-version-min= -lSystem)		   \
+       -lgcc_eh -lgcc;							   \
       shared-libgcc|fexceptions|fgnu-runtime:				   \
        %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_s.10.4)	   \
        %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
@@ -88,14 +89,12 @@
 #undef WCHAR_TYPE_SIZE
 #define WCHAR_TYPE_SIZE 32
 
-/* Generate branch islands stubs if this is true.  */
-extern int darwin_emit_branch_islands;
+/* Generate pic symbol indirection stubs if this is true.  */
+#undef TARGET_MACHO_SYMBOL_STUBS
+#define TARGET_MACHO_SYMBOL_STUBS (darwin_symbol_stubs)
 
-#undef TARGET_MACHO_BRANCH_ISLANDS
-#define TARGET_MACHO_BRANCH_ISLANDS darwin_emit_branch_islands
-
 /* For compatibility with OSX system tools, use the new style of pic stub
-   if this is set.  */
+   if this is set (default).  */
 #undef  MACHOPIC_ATT_STUB
 #define MACHOPIC_ATT_STUB (darwin_macho_att_stub)
 
@@ -130,7 +129,8 @@
 #undef CC1_SPEC
 #define CC1_SPEC "%(cc1_cpu) \
   %{!mkernel:%{!static:%{!mdynamic-no-pic:-fPIC}}} \
-  %{g: %{!fno-eliminate-unused-debug-symbols: -feliminate-unused-debug-symbols }} " \
+  %{g: %{!fno-eliminate-unused-debug-symbols: -feliminate-unused-debug-symbols }} \
+  %{mx32:%eDarwin is not an mx32 platform}" \
   DARWIN_CC1_SPEC
 
 #undef ASM_SPEC
@@ -138,9 +138,6 @@
   " ASM_OPTIONS " -force_cpusubtype_ALL \
   %{static}" ASM_MMACOSX_VERSION_MIN_SPEC
 
-#define DARWIN_ARCH_SPEC "%{m64:x86_64;:i386}"
-#define DARWIN_SUBARCH_SPEC DARWIN_ARCH_SPEC
-
 #undef ENDFILE_SPEC
 #define ENDFILE_SPEC \
   "%{Ofast|ffast-math|funsafe-math-optimizations:crtfastmath.o%s} \
@@ -148,12 +145,15 @@
    %{mpc64:crtprec64.o%s} \
    %{mpc80:crtprec80.o%s}" TM_DESTRUCTOR
 
+/* We default to x86_64 for single-arch builds, bi-arch overrides.  */
+#define DARWIN_ARCH_SPEC "x86_64"
+
 #undef SUBTARGET_EXTRA_SPECS
 #define SUBTARGET_EXTRA_SPECS                                   \
   DARWIN_EXTRA_SPECS                                            \
-  { "darwin_arch", DARWIN_ARCH_SPEC },                          \
+  { "darwin_arch", DARWIN_ARCH_SPEC },				\
   { "darwin_crt2", "" },                                        \
-  { "darwin_subarch", DARWIN_SUBARCH_SPEC },
+  { "darwin_subarch", DARWIN_ARCH_SPEC },
 
 /* The Darwin assembler mostly follows AT&T syntax.  */
 #undef ASSEMBLER_DIALECT
@@ -219,19 +219,36 @@
         }				\
     } while (0)
 
+#ifdef HAVE_GAS_MAX_SKIP_P2ALIGN
+#define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE,LOG,MAX_SKIP)                    \
+  do {                                                                  \
+    if ((LOG) != 0) {                                                   \
+      if ((MAX_SKIP) == 0 || (MAX_SKIP) >= (1 << (LOG)) - 1)            \
+        fprintf ((FILE), "\t.p2align %d\n", (LOG));                     \
+      else                                                              \
+        fprintf ((FILE), "\t.p2align %d,,%d\n", (LOG), (MAX_SKIP));     \
+    }                                                                   \
+  } while (0)
+#endif
+
+/* Darwin x86 assemblers support the .ident directive.  */
+
+#undef TARGET_ASM_OUTPUT_IDENT
+#define TARGET_ASM_OUTPUT_IDENT default_asm_output_ident_directive
+
 /* Darwin profiling -- call mcount.  */
 #undef FUNCTION_PROFILER
 #define FUNCTION_PROFILER(FILE, LABELNO)				\
-    do {								\
-      if (TARGET_MACHO_BRANCH_ISLANDS 					\
-	   && MACHOPIC_INDIRECT && !TARGET_64BIT)			\
-	{								\
-	  const char *name = machopic_mcount_stub_name ();		\
-	  fprintf (FILE, "\tcall %s\n", name+1);  /*  skip '&'  */	\
-	  machopic_validate_stub_or_non_lazy_ptr (name);		\
-	}								\
-      else fprintf (FILE, "\tcall mcount\n");				\
-    } while (0)
+  do {									\
+    if (TARGET_MACHO_SYMBOL_STUBS 					\
+	&& MACHOPIC_INDIRECT && !TARGET_64BIT)				\
+      {									\
+	const char *name = machopic_mcount_stub_name ();		\
+	fprintf (FILE, "\tcall %s\n", name+1);  /*  skip '&'  */	\
+	machopic_validate_stub_or_non_lazy_ptr (name);			\
+      }									\
+    else fprintf (FILE, "\tcall mcount\n");				\
+  } while (0)
 
 #define C_COMMON_OVERRIDE_OPTIONS					\
   do {									\
@@ -304,10 +321,8 @@
         }                                                                       \
     }
 
-/* This needs to move since i386 uses the first flag and other flags are
-   used in Mach-O.  */
-#undef MACHO_SYMBOL_FLAG_VARIABLE
-#define MACHO_SYMBOL_FLAG_VARIABLE ((SYMBOL_FLAG_MACH_DEP) << 3)
+/* First available SYMBOL flag bit for use by subtargets.  */
+#define SYMBOL_FLAG_SUBT_DEP (SYMBOL_FLAG_MACH_DEP << 5)
 
 #undef MACHOPIC_NL_SYMBOL_PTR_SECTION
 #define MACHOPIC_NL_SYMBOL_PTR_SECTION \
Index: gcc/config/i386/emmintrin.h
===================================================================
diff --git a/gcc/config/i386/emmintrin.h b/gcc/config/i386/emmintrin.h
--- a/gcc/config/i386/emmintrin.h	(revision 278653)
+++ b/gcc/config/i386/emmintrin.h	(revision 278653)
@@ -1296,7 +1296,7 @@
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _mm_cmpeq_epi8 (__m128i __A, __m128i __B)
 {
-  return (__m128i) ((__v16qs)__A == (__v16qs)__B);
+  return (__m128i) ((__v16qi)__A == (__v16qi)__B);
 }
 
 extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
Index: gcc/config/i386/intelmic-mkoffload.c
===================================================================
diff --git a/gcc/config/i386/intelmic-mkoffload.c b/gcc/config/i386/intelmic-mkoffload.c
--- a/gcc/config/i386/intelmic-mkoffload.c	(revision 278653)
+++ b/gcc/config/i386/intelmic-mkoffload.c	(revision 278653)
@@ -453,8 +453,6 @@
   if (verbose)
     obstack_ptr_grow (&argv_obstack, "-v");
   obstack_ptr_grow (&argv_obstack, "-xlto");
-  obstack_ptr_grow (&argv_obstack, "-shared");
-  obstack_ptr_grow (&argv_obstack, "-fPIC");
   obstack_ptr_grow (&argv_obstack, opt1);
   for (int i = 1; i < argc; i++)
     {
@@ -466,6 +464,9 @@
   if (!out_obj_filename)
     fatal_error (input_location, "output file not specified");
   obstack_ptr_grow (&argv_obstack, opt2);
+  /* NB: Put -fPIC and -shared the last to create shared library.  */
+  obstack_ptr_grow (&argv_obstack, "-fPIC");
+  obstack_ptr_grow (&argv_obstack, "-shared");
   obstack_ptr_grow (&argv_obstack, "-o");
   obstack_ptr_grow (&argv_obstack, target_so_filename);
   compile_for_target (&argv_obstack);
Index: gcc/config/i386/avxintrin.h
===================================================================
diff --git a/gcc/config/i386/avxintrin.h b/gcc/config/i386/avxintrin.h
--- a/gcc/config/i386/avxintrin.h	(revision 278653)
+++ b/gcc/config/i386/avxintrin.h	(revision 278653)
@@ -47,6 +47,7 @@
 typedef short __v16hi __attribute__ ((__vector_size__ (32)));
 typedef unsigned short __v16hu __attribute__ ((__vector_size__ (32)));
 typedef char __v32qi __attribute__ ((__vector_size__ (32)));
+typedef signed char __v32qs __attribute__ ((__vector_size__ (32)));
 typedef unsigned char __v32qu __attribute__ ((__vector_size__ (32)));
 
 /* The Intel API is flexible enough that we must allow aliasing with other
Index: gcc/config/i386/i386.c
===================================================================
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
--- a/gcc/config/i386/i386.c	(revision 278653)
+++ b/gcc/config/i386/i386.c	(revision 278653)
@@ -1024,17 +1024,9 @@
 
     case ASHIFT:
     case LSHIFTRT:
-      if (!REG_P (XEXP (src, 1))
-	  && (!SUBREG_P (XEXP (src, 1))
-	      || SUBREG_BYTE (XEXP (src, 1)) != 0
-	      || !REG_P (SUBREG_REG (XEXP (src, 1))))
-	  && (!CONST_INT_P (XEXP (src, 1))
-	      || !IN_RANGE (INTVAL (XEXP (src, 1)), 0, 63)))
+      if (!CONST_INT_P (XEXP (src, 1))
+	  || !IN_RANGE (INTVAL (XEXP (src, 1)), 0, 63))
 	return false;
-
-      if (GET_MODE (XEXP (src, 1)) != QImode
-	  && !CONST_INT_P (XEXP (src, 1)))
-	return false;
       break;
 
     case PLUS:
@@ -1630,15 +1622,10 @@
 	{
     	  if (CONST_INT_P (XEXP (src, 0)))
 	    gain -= vector_const_cost (XEXP (src, 0));
-	  if (CONST_INT_P (XEXP (src, 1)))
-	    {
-	      gain += ix86_cost->shift_const;
-	      if (INTVAL (XEXP (src, 1)) >= 32)
-		gain -= COSTS_N_INSNS (1);
-	    }
-	  else
-	    /* Additional gain for omitting two CMOVs.  */
-	    gain += ix86_cost->shift_var + COSTS_N_INSNS (2);
+
+	  gain += ix86_cost->shift_const;
+	  if (INTVAL (XEXP (src, 1)) >= 32)
+	    gain -= COSTS_N_INSNS (1);
 	}
       else if (GET_CODE (src) == PLUS
 	       || GET_CODE (src) == MINUS
@@ -1754,60 +1741,14 @@
 {
   rtx reg = regno_reg_rtx[regno];
   rtx vreg = gen_reg_rtx (DImode);
-  bool count_reg = false;
   df_ref ref;
 
   for (ref = DF_REG_DEF_CHAIN (regno); ref; ref = DF_REF_NEXT_REG (ref))
     if (!bitmap_bit_p (insns, DF_REF_INSN_UID (ref)))
       {
-	df_ref use;
-
-	/* Detect the count register of a shift instruction.  */
-	for (use = DF_REG_USE_CHAIN (regno); use; use = DF_REF_NEXT_REG (use))
-	  if (bitmap_bit_p (insns, DF_REF_INSN_UID (use)))
-	    {
-	      rtx_insn *insn = DF_REF_INSN (use);
-	      rtx def_set = single_set (insn);
-
-	      gcc_assert (def_set);
-
-	      rtx src = SET_SRC (def_set);
-
-	      if ((GET_CODE (src) == ASHIFT
-		   || GET_CODE (src) == ASHIFTRT
-		   || GET_CODE (src) == LSHIFTRT)
-		  && !CONST_INT_P (XEXP (src, 1))
-		  && reg_or_subregno (XEXP (src, 1)) == regno)
-		count_reg = true;
-	    }
-
 	start_sequence ();
-	if (count_reg)
-	  {
-	    rtx qreg = gen_lowpart (QImode, reg);
-	    rtx tmp = gen_reg_rtx (SImode);
 
-	    if (TARGET_ZERO_EXTEND_WITH_AND
-		&& optimize_function_for_speed_p (cfun))
-	      {
-		emit_move_insn (tmp, const0_rtx);
-		emit_insn (gen_movstrictqi
-			   (gen_lowpart (QImode, tmp), qreg));
-	      }
-	    else
-	      emit_insn (gen_rtx_SET
-			 (tmp, gen_rtx_ZERO_EXTEND (SImode, qreg)));
-
-	    if (!TARGET_INTER_UNIT_MOVES_TO_VEC)
-	      {
-		rtx slot = assign_386_stack_local (SImode, SLOT_STV_TEMP);
-		emit_move_insn (slot, tmp);
-		tmp = copy_rtx (slot);
-	      }
-
-	    emit_insn (gen_zero_extendsidi2 (vreg, tmp));
-	  }
-	else if (!TARGET_INTER_UNIT_MOVES_TO_VEC)
+	if (!TARGET_INTER_UNIT_MOVES_TO_VEC)
 	  {
 	    rtx tmp = assign_386_stack_local (DImode, SLOT_STV_TEMP);
 	    emit_move_insn (adjust_address (tmp, SImode, 0),
@@ -1855,23 +1796,9 @@
     if (bitmap_bit_p (insns, DF_REF_INSN_UID (ref)))
       {
 	rtx_insn *insn = DF_REF_INSN (ref);
-	if (count_reg)
-	  {
-	    rtx def_set = single_set (insn);
-	    gcc_assert (def_set);
 
-	    rtx src = SET_SRC (def_set);
+	replace_with_subreg_in_insn (insn, reg, vreg);
 
-	    if ((GET_CODE (src) == ASHIFT
-		 || GET_CODE (src) == ASHIFTRT
-		 || GET_CODE (src) == LSHIFTRT)
-		&& !CONST_INT_P (XEXP (src, 1))
-		&& reg_or_subregno (XEXP (src, 1)) == regno)
-	      XEXP (src, 1) = vreg;
-	  }
-	else
-	  replace_with_subreg_in_insn (insn, reg, vreg);
-
 	if (dump_file)
 	  fprintf (dump_file, "  Replaced r%d with r%d in insn %d\n",
 		   regno, REGNO (vreg), INSN_UID (insn));
@@ -1973,42 +1900,7 @@
 	    rtx src = SET_SRC (def_set);
 	    rtx dst = SET_DEST (def_set);
 
-	    if ((GET_CODE (src) == ASHIFT
-		 || GET_CODE (src) == ASHIFTRT
-		 || GET_CODE (src) == LSHIFTRT)
-		&& !CONST_INT_P (XEXP (src, 1))
-		&& reg_or_subregno (XEXP (src, 1)) == regno)
-	      {
-		rtx tmp2 = gen_reg_rtx (V2DImode);
-
-		start_sequence ();
-
-		if (TARGET_SSE4_1)
-		  emit_insn (gen_sse4_1_zero_extendv2qiv2di2
-			     (tmp2, gen_rtx_SUBREG (V16QImode, reg, 0)));
-		else
-		  {
-		    rtx vec_cst
-		      = gen_rtx_CONST_VECTOR (V2DImode,
-					      gen_rtvec (2, GEN_INT (0xff),
-							 const0_rtx));
-		    vec_cst
-		      = validize_mem (force_const_mem (V2DImode, vec_cst));
-
-		    emit_insn (gen_rtx_SET
-			       (tmp2,
-				gen_rtx_AND (V2DImode,
-					     gen_rtx_SUBREG (V2DImode, reg, 0),
-					     vec_cst)));
-		  }
-		rtx_insn *seq = get_insns ();
-		end_sequence ();
-
-		emit_insn_before (seq, insn);
-
-		XEXP (src, 1) = gen_rtx_SUBREG (DImode, tmp2, 0);
-	      }
-	    else if (!MEM_P (dst) || !REG_P (src))
+	    if (!MEM_P (dst) || !REG_P (src))
 	      replace_with_subreg_in_insn (insn, reg, reg);
 
 	    bitmap_clear_bit (conv, INSN_UID (insn));
@@ -3488,7 +3380,7 @@
     | PTA_AVX512VBMI | PTA_AVX512IFMA | PTA_SHA;
   const wide_int_bitmask PTA_ICELAKE_CLIENT = PTA_CANNONLAKE | PTA_AVX512VNNI
     | PTA_GFNI | PTA_VAES | PTA_AVX512VBMI2 | PTA_VPCLMULQDQ | PTA_AVX512BITALG
-    | PTA_RDPID | PTA_CLWB;
+    | PTA_RDPID | PTA_CLWB | PTA_AVX512VPOPCNTDQ;
   const wide_int_bitmask PTA_ICELAKE_SERVER = PTA_ICELAKE_CLIENT | PTA_PCONFIG
     | PTA_WBNOINVD;
   const wide_int_bitmask PTA_KNL = PTA_BROADWELL | PTA_AVX512PF | PTA_AVX512ER
@@ -4958,6 +4850,12 @@
 			   opts->x_param_values,
 			   opts_set->x_param_values);
 
+  /* PR86952: jump table usage with retpolines is slow.
+     The PR provides some numbers about the slowness.  */
+  if (ix86_indirect_branch != indirect_branch_keep
+      && !opts_set->x_flag_jump_tables)
+    opts->x_flag_jump_tables = 0;
+
   return true;
 }
 
@@ -5552,7 +5450,25 @@
 	      ret = false;
 	    }
 	  else
-	    p_strings[opt] = xstrdup (p + opt_len);
+	    {
+	      p_strings[opt] = xstrdup (p + opt_len);
+	      if (opt == IX86_FUNCTION_SPECIFIC_ARCH)
+		{
+		  /* If arch= is set,  clear all bits in x_ix86_isa_flags,
+		     except for ISA_64BIT, ABI_64, ABI_X32, and CODE16
+		     and all bits in x_ix86_isa_flags2.  */
+		  opts->x_ix86_isa_flags &= (OPTION_MASK_ISA_64BIT
+					     | OPTION_MASK_ABI_64
+					     | OPTION_MASK_ABI_X32
+					     | OPTION_MASK_CODE16);
+		  opts->x_ix86_isa_flags_explicit &= (OPTION_MASK_ISA_64BIT
+						      | OPTION_MASK_ABI_64
+						      | OPTION_MASK_ABI_X32
+						      | OPTION_MASK_CODE16);
+		  opts->x_ix86_isa_flags2 = 0;
+		  opts->x_ix86_isa_flags2_explicit = 0;
+		}
+	    }
 	}
 
       else if (type == ix86_opt_enum)
@@ -5627,18 +5543,8 @@
       /* If we are using the default tune= or arch=, undo the string assigned,
 	 and use the default.  */
       if (option_strings[IX86_FUNCTION_SPECIFIC_ARCH])
-	{
-	  opts->x_ix86_arch_string
-	    = ggc_strdup (option_strings[IX86_FUNCTION_SPECIFIC_ARCH]);
-
-	  /* If arch= is set,  clear all bits in x_ix86_isa_flags,
-	     except for ISA_64BIT, ABI_64, ABI_X32, and CODE16.  */
-	  opts->x_ix86_isa_flags &= (OPTION_MASK_ISA_64BIT
-				     | OPTION_MASK_ABI_64
-				     | OPTION_MASK_ABI_X32
-				     | OPTION_MASK_CODE16);
-	  opts->x_ix86_isa_flags2 = 0;
-	}
+	opts->x_ix86_arch_string
+	  = ggc_strdup (option_strings[IX86_FUNCTION_SPECIFIC_ARCH]);
       else if (!orig_arch_specified)
 	opts->x_ix86_arch_string = NULL;
 
@@ -17313,7 +17219,7 @@
       break;
 
     case SYMBOL_REF:
-      if (TARGET_64BIT || ! TARGET_MACHO_BRANCH_ISLANDS)
+      if (TARGET_64BIT || ! TARGET_MACHO_SYMBOL_STUBS)
 	output_addr_const (file, x);
       else
 	{
@@ -18121,6 +18027,7 @@
    ; -- print a semicolon (after prefixes due to bug in older gas).
    ~ -- print "i" if TARGET_AVX2, "f" otherwise.
    ^ -- print addr32 prefix if TARGET_64BIT and Pmode != word_mode
+   M -- print addr32 prefix for TARGET_X32 with VSIB address.
    ! -- print MPX prefix for jxx/call/ret instructions if required.
  */
 
@@ -18668,6 +18575,26 @@
 	  putc (TARGET_AVX2 ? 'i' : 'f', file);
 	  return;
 
+	case 'M':
+	  if (TARGET_X32)
+	    {
+	      /* NB: 32-bit indices in VSIB address are sign-extended
+		 to 64 bits. In x32, if 32-bit address 0xf7fa3010 is
+		 sign-extended to 0xfffffffff7fa3010 which is invalid
+		 address.  Add addr32 prefix if there is no base
+		 register nor symbol.  */
+	      bool ok;
+	      struct ix86_address parts;
+	      ok = ix86_decompose_address (x, &parts);
+	      gcc_assert (ok && parts.index == NULL_RTX);
+	      if (parts.base == NULL_RTX
+		  && (parts.disp == NULL_RTX
+		      || !symbolic_operand (parts.disp,
+					    GET_MODE (parts.disp))))
+		fputs ("addr32 ", file);
+	    }
+	  return;
+
 	case '^':
 	  if (TARGET_64BIT && Pmode != word_mode)
 	    fputs ("addr32 ", file);
@@ -24062,6 +23989,8 @@
   else
     {
       code = is_min ? SMIN : SMAX;
+      if (MEM_P (if_true) && MEM_P (if_false))
+	if_true = force_reg (mode, if_true);
       tmp = gen_rtx_fmt_ee (code, mode, if_true, if_false);
     }
 
@@ -28757,6 +28686,25 @@
   return false;
 }
 
+/* Helper to output the jmp/call.  */
+static void
+ix86_output_jmp_thunk_or_indirect (const char *thunk_name,
+				   enum indirect_thunk_prefix need_prefix,
+				   const int regno)
+{
+  if (thunk_name != NULL)
+    {
+      if (need_prefix == indirect_thunk_prefix_bnd)
+	fprintf (asm_out_file, "\tbnd jmp\t");
+      else
+	fprintf (asm_out_file, "\tjmp\t");
+      assemble_name (asm_out_file, thunk_name);
+      putc ('\n', asm_out_file);
+    }
+  else
+    output_indirect_thunk (need_prefix, regno);
+}
+
 /* Output indirect branch via a call and return thunk.  CALL_OP is a
    register which contains the branch target.  XASM is the assembly
    template for CALL_OP.  Branch is a tail call if SIBCALL_P is true.
@@ -28798,25 +28746,17 @@
     thunk_name = NULL;
 
   if (sibcall_p)
-    {
-      if (thunk_name != NULL)
-	{
-	  if (need_prefix == indirect_thunk_prefix_bnd)
-	    fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
-	  else
-	    fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
-	}
-      else
-	output_indirect_thunk (need_prefix, regno);
-    }
+    ix86_output_jmp_thunk_or_indirect (thunk_name, need_prefix, regno);
   else
     {
       if (thunk_name != NULL)
 	{
 	  if (need_prefix == indirect_thunk_prefix_bnd)
-	    fprintf (asm_out_file, "\tbnd call\t%s\n", thunk_name);
+	    fprintf (asm_out_file, "\tbnd call\t");
 	  else
-	    fprintf (asm_out_file, "\tcall\t%s\n", thunk_name);
+	    fprintf (asm_out_file, "\tcall\t");
+	  assemble_name (asm_out_file, thunk_name);
+	  putc ('\n', asm_out_file);
 	  return;
 	}
 
@@ -28840,15 +28780,7 @@
 
       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel1);
 
-      if (thunk_name != NULL)
-	{
-	  if (need_prefix == indirect_thunk_prefix_bnd)
-	    fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
-	  else
-	    fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
-	}
-      else
-	output_indirect_thunk (need_prefix, regno);
+      ix86_output_jmp_thunk_or_indirect (thunk_name, need_prefix, regno);
 
       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel2);
 
@@ -28913,15 +28845,7 @@
   if (sibcall_p)
     {
       output_asm_insn (push_buf, &call_op);
-      if (thunk_name != NULL)
-	{
-	  if (need_prefix == indirect_thunk_prefix_bnd)
-	    fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
-	  else
-	    fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
-	}
-      else
-	output_indirect_thunk (need_prefix, regno);
+      ix86_output_jmp_thunk_or_indirect (thunk_name, need_prefix, regno);
     }
   else
     {
@@ -28980,15 +28904,7 @@
 
       output_asm_insn (push_buf, &call_op);
 
-      if (thunk_name != NULL)
-	{
-	  if (need_prefix == indirect_thunk_prefix_bnd)
-	    fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
-	  else
-	    fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
-	}
-      else
-	output_indirect_thunk (need_prefix, regno);
+      ix86_output_jmp_thunk_or_indirect (thunk_name, need_prefix, regno);
 
       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel2);
 
@@ -29057,13 +28973,15 @@
 	  if (need_prefix == indirect_thunk_prefix_bnd)
 	    {
 	      indirect_return_bnd_needed |= need_thunk;
-	      fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
+	      fprintf (asm_out_file, "\tbnd jmp\t");
 	    }
 	  else
 	    {
 	      indirect_return_needed |= need_thunk;
-	      fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
+	      fprintf (asm_out_file, "\tjmp\t");
 	    }
+	  assemble_name (asm_out_file, thunk_name);
+	  putc ('\n', asm_out_file);
 	}
       else
 	output_indirect_thunk (need_prefix, INVALID_REGNUM);
@@ -29104,7 +29022,7 @@
 		  indirect_return_via_cx_bnd = true;
 		  indirect_thunks_bnd_used |= 1 << CX_REG;
 		}
-	      fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
+	      fprintf (asm_out_file, "\tbnd jmp\t");
 	    }
 	  else
 	    {
@@ -29113,8 +29031,10 @@
 		  indirect_return_via_cx = true;
 		  indirect_thunks_used |= 1 << CX_REG;
 		}
-	      fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
+	      fprintf (asm_out_file, "\tjmp\t");
 	    }
+	  assemble_name (asm_out_file, thunk_name);
+	  putc ('\n', asm_out_file);
 	}
       else
 	output_indirect_thunk (need_prefix, regno);
@@ -32923,6 +32843,7 @@
     }
   /* Build result decl and add to function_decl. */
   t = build_decl (UNKNOWN_LOCATION, RESULT_DECL, NULL_TREE, ptr_type_node);
+  DECL_CONTEXT (t) = decl;
   DECL_ARTIFICIAL (t) = 1;
   DECL_IGNORED_P (t) = 1;
   DECL_RESULT (decl) = t;
@@ -39641,7 +39562,7 @@
 static bool
 use_rsqrt_p ()
 {
-  return (TARGET_SSE_MATH
+  return (TARGET_SSE && TARGET_SSE_MATH
 	  && flag_finite_math_only
 	  && !flag_trapping_math
 	  && flag_unsafe_math_optimizations);
@@ -45705,8 +45626,10 @@
           x2 -= 1;
      Compensate.  Ceil:
         if (x2 < x)
-          x2 -= -1;
-        return x2;
+          x2 += 1;
+	if (HONOR_SIGNED_ZEROS (mode))
+	  x2 = copysign (x2, x);
+	return x2;
    */
   machine_mode mode = GET_MODE (operand0);
   rtx xa, TWO52, tmp, one, res, mask;
@@ -45732,17 +45655,16 @@
   /* xa = copysign (xa, operand1) */
   ix86_sse_copysign_to_positive (xa, xa, res, mask);
 
-  /* generate 1.0 or -1.0 */
-  one = force_reg (mode,
-	           const_double_from_real_value (do_floor
-						 ? dconst1 : dconstm1, mode));
+  /* generate 1.0 */
+  one = force_reg (mode, const_double_from_real_value (dconst1, mode));
 
   /* Compensate: xa = xa - (xa > operand1 ? 1 : 0) */
   tmp = ix86_expand_sse_compare_mask (UNGT, xa, res, !do_floor);
   emit_insn (gen_rtx_SET (tmp, gen_rtx_AND (mode, one, tmp)));
-  /* We always need to subtract here to preserve signed zero.  */
-  tmp = expand_simple_binop (mode, MINUS,
+  tmp = expand_simple_binop (mode, do_floor ? MINUS : PLUS,
 			     xa, tmp, NULL_RTX, 0, OPTAB_DIRECT);
+  if (!do_floor && HONOR_SIGNED_ZEROS (mode))
+    ix86_sse_copysign_to_positive (tmp, tmp, res, mask);
   emit_move_insn (res, tmp);
 
   emit_label (label);
@@ -46379,7 +46301,8 @@
 expand_vec_perm_blend (struct expand_vec_perm_d *d)
 {
   machine_mode mmode, vmode = d->vmode;
-  unsigned i, mask, nelt = d->nelt;
+  unsigned i, nelt = d->nelt;
+  unsigned HOST_WIDE_INT mask;
   rtx target, op0, op1, maskop, x;
   rtx rperm[32], vperm;
 
@@ -46433,7 +46356,7 @@
     case E_V16SImode:
     case E_V8DImode:
       for (i = 0; i < nelt; ++i)
-	mask |= (d->perm[i] >= nelt) << i;
+	mask |= ((unsigned HOST_WIDE_INT) (d->perm[i] >= nelt)) << i;
       break;
 
     case E_V2DImode:
@@ -50999,7 +50922,7 @@
      there is no adddf3 pattern (since x87 floating point only has
      XFmode operations) so the default hook implementation gets this
      wrong.  */
-  return TARGET_80387 || TARGET_SSE_MATH;
+  return TARGET_80387 || (TARGET_SSE && TARGET_SSE_MATH);
 }
 
 /* Implement TARGET_ATOMIC_ASSIGN_EXPAND_FENV.  */
@@ -51007,7 +50930,7 @@
 static void
 ix86_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)
 {
-  if (!TARGET_80387 && !TARGET_SSE_MATH)
+  if (!TARGET_80387 && !(TARGET_SSE && TARGET_SSE_MATH))
     return;
   tree exceptions_var = create_tmp_var_raw (integer_type_node);
   if (TARGET_80387)
@@ -51042,7 +50965,7 @@
       tree update_fldenv = build_call_expr (fldenv, 1, fenv_addr);
       *update = build2 (COMPOUND_EXPR, void_type_node, *update, update_fldenv);
     }
-  if (TARGET_SSE_MATH)
+  if (TARGET_SSE && TARGET_SSE_MATH)
     {
       tree mxcsr_orig_var = create_tmp_var_raw (unsigned_type_node);
       tree mxcsr_mod_var = create_tmp_var_raw (unsigned_type_node);
@@ -51399,7 +51322,7 @@
 	  return FLT_EVAL_METHOD_PROMOTE_TO_FLOAT;
 	else if (!TARGET_MIX_SSE_I387)
 	  {
-	    if (!TARGET_SSE_MATH)
+	    if (!(TARGET_SSE && TARGET_SSE_MATH))
 	      return FLT_EVAL_METHOD_PROMOTE_TO_LONG_DOUBLE;
 	    else if (TARGET_SSE2)
 	      return FLT_EVAL_METHOD_PROMOTE_TO_FLOAT;
Index: gcc/config/darwin-protos.h
===================================================================
diff --git a/gcc/config/darwin-protos.h b/gcc/config/darwin-protos.h
--- a/gcc/config/darwin-protos.h	(revision 278653)
+++ b/gcc/config/darwin-protos.h	(revision 278653)
@@ -53,8 +53,6 @@
 
 #endif /* TREE_CODE */
 
-extern void machopic_finish (FILE *);
-
 extern int machopic_reloc_rw_mask (void);
 extern section *machopic_select_section (tree, int, unsigned HOST_WIDE_INT);
 
Index: gcc/config/sh/sh.c
===================================================================
diff --git a/gcc/config/sh/sh.c b/gcc/config/sh/sh.c
--- a/gcc/config/sh/sh.c	(revision 278653)
+++ b/gcc/config/sh/sh.c	(revision 278653)
@@ -736,7 +736,7 @@
     {
       if (tokens[i] == "strict")
 	ret.strict = true;
-      else if (tokens[i].find ("gbr-offset=") == 0)
+      else if (!tokens[i].compare (0, strlen ("gbr-offset="), "gbr-offset="))
 	{
 	  std::string offset_str = tokens[i].substr (strlen ("gbr-offset="));
 	  ret.tcb_gbr_offset = integral_argument (offset_str.c_str ());
@@ -957,11 +957,13 @@
   if (flag_unsafe_math_optimizations)
     {
       /* Enable fsca insn for SH4A if not otherwise specified by the user.  */
-      if (global_options_set.x_TARGET_FSCA == 0 && TARGET_SH4A_FP)
+      if (global_options_set.x_TARGET_FSCA == 0
+	  && (TARGET_SH4A_FP || TARGET_FPU_SH4_300))
 	TARGET_FSCA = 1;
 
       /* Enable fsrra insn for SH4A if not otherwise specified by the user.  */
-      if (global_options_set.x_TARGET_FSRRA == 0 && TARGET_SH4A_FP)
+      if (global_options_set.x_TARGET_FSRRA == 0
+	  && (TARGET_SH4A_FP || TARGET_FPU_SH4_300))
 	TARGET_FSRRA = 1;
     }
 
@@ -10875,12 +10877,6 @@
 	  emit_insn (gen_add2_insn (scratch0, GEN_INT (vcall_offset)));
 	  offset_addr = scratch0;
 	}
-      else if (scratch0 != scratch1)
-	{
-	  emit_move_insn (scratch1, GEN_INT (vcall_offset));
-	  emit_insn (gen_add2_insn (scratch0, scratch1));
-	  offset_addr = scratch0;
-	}
       else
 	gcc_unreachable (); /* FIXME */
       emit_load_ptr (scratch0, offset_addr);
@@ -12077,9 +12073,11 @@
 	rtx r = gen_reg_rtx (SImode);
 	rtx_insn* i0;
 	if (from_mode == QImode)
-	  i0 = emit_insn_after (gen_extendqisi2 (r, set_src), insn);
+	  i0 = sh_check_add_incdec_notes (
+			emit_insn_after (gen_extendqisi2 (r, set_src), insn));
 	else if (from_mode == HImode)
-	  i0 = emit_insn_after (gen_extendhisi2 (r, set_src), insn);
+	  i0 = sh_check_add_incdec_notes (
+			emit_insn_after (gen_extendhisi2 (r, set_src), insn));
 	else
 	  gcc_unreachable ();
 
@@ -12497,7 +12495,7 @@
 sh_emit_mode_set (int entity ATTRIBUTE_UNUSED, int mode,
 		  int prev_mode, HARD_REG_SET regs_live ATTRIBUTE_UNUSED)
 {
-  if ((TARGET_SH4A_FP || TARGET_SH4_300)
+  if ((TARGET_SH4A_FP || TARGET_FPU_SH4_300)
       && prev_mode != FP_MODE_NONE && prev_mode != mode)
     {
       emit_insn (gen_toggle_pr ());
Index: gcc/config/sh/sh.h
===================================================================
diff --git a/gcc/config/sh/sh.h b/gcc/config/sh/sh.h
--- a/gcc/config/sh/sh.h	(revision 278653)
+++ b/gcc/config/sh/sh.h	(revision 278653)
@@ -69,6 +69,8 @@
    FPU is disabled (which makes it compatible with SH4al-dsp).  */
 #define TARGET_SH4A_FP (TARGET_SH4A && TARGET_FPU_ANY)
 
+/* True if the FPU is a SH4-300 variant.  */
+#define TARGET_FPU_SH4_300 (TARGET_FPU_ANY && TARGET_SH4_300)
 
 /* This is not used by the SH2E calling convention  */
 #define TARGET_VARARGS_PRETEND_ARGS(FUN_DECL) \
Index: gcc/config/sh/sh.md
===================================================================
diff --git a/gcc/config/sh/sh.md b/gcc/config/sh/sh.md
--- a/gcc/config/sh/sh.md	(revision 278653)
+++ b/gcc/config/sh/sh.md	(revision 278653)
@@ -9163,7 +9163,7 @@
 	(xor:SI (reg:SI FPSCR_REG) (const_int FPSCR_PR)))
    (set (reg:SI FPSCR_MODES_REG)
 	(unspec_volatile:SI [(const_int 0)] UNSPECV_FPSCR_MODES))]
-  "TARGET_SH4A_FP"
+  "TARGET_SH4A_FP || TARGET_FPU_SH4_300"
   "fpchg"
   [(set_attr "type" "fpscr_toggle")])
 
@@ -9391,15 +9391,31 @@
 (define_expand "negsf2"
   [(set (match_operand:SF 0 "fp_arith_reg_operand")
 	(neg:SF (match_operand:SF 1 "fp_arith_reg_operand")))]
-  "TARGET_SH2E")
+  "TARGET_FPU_ANY"
+{
+  if (TARGET_FPU_SH4_300)
+    emit_insn (gen_negsf2_fpscr (operands[0], operands[1]));
+  else
+    emit_insn (gen_negsf2_no_fpscr (operands[0], operands[1]));
+  DONE;
+})
 
-(define_insn "*negsf2_i"
+(define_insn "negsf2_no_fpscr"
   [(set (match_operand:SF 0 "fp_arith_reg_operand" "=f")
 	(neg:SF (match_operand:SF 1 "fp_arith_reg_operand" "0")))]
-  "TARGET_SH2E"
+  "TARGET_FPU_ANY && !TARGET_FPU_SH4_300"
   "fneg	%0"
   [(set_attr "type" "fmove")])
 
+(define_insn "negsf2_fpscr"
+  [(set (match_operand:SF 0 "fp_arith_reg_operand" "=f")
+	(neg:SF (match_operand:SF 1 "fp_arith_reg_operand" "0")))
+   (use (reg:SI FPSCR_MODES_REG))]
+  "TARGET_FPU_SH4_300"
+  "fneg	%0"
+  [(set_attr "type" "fmove")
+   (set_attr "fp_mode" "single")])
+
 (define_expand "sqrtsf2"
   [(set (match_operand:SF 0 "fp_arith_reg_operand" "")
 	(sqrt:SF (match_operand:SF 1 "fp_arith_reg_operand" "")))]
@@ -9489,15 +9505,31 @@
 (define_expand "abssf2"
   [(set (match_operand:SF 0 "fp_arith_reg_operand")
 	(abs:SF (match_operand:SF 1 "fp_arith_reg_operand")))]
-  "TARGET_SH2E")
+  "TARGET_FPU_ANY"
+{
+  if (TARGET_FPU_SH4_300)
+    emit_insn (gen_abssf2_fpscr (operands[0], operands[1]));
+  else
+    emit_insn (gen_abssf2_no_fpscr (operands[0], operands[1]));
+  DONE;
+})
 
-(define_insn "*abssf2_i"
+(define_insn "abssf2_no_fpscr"
   [(set (match_operand:SF 0 "fp_arith_reg_operand" "=f")
 	(abs:SF (match_operand:SF 1 "fp_arith_reg_operand" "0")))]
-  "TARGET_SH2E"
+  "TARGET_FPU_ANY && !TARGET_FPU_SH4_300"
   "fabs	%0"
   [(set_attr "type" "fmove")])
 
+(define_insn "abssf2_fpscr"
+  [(set (match_operand:SF 0 "fp_arith_reg_operand" "=f")
+	(abs:SF (match_operand:SF 1 "fp_arith_reg_operand" "0")))
+   (use (reg:SI FPSCR_MODES_REG))]
+  "TARGET_FPU_SH4_300"
+  "fabs	%0"
+  [(set_attr "type" "fmove")
+   (set_attr "fp_mode" "single")])
+
 (define_expand "adddf3"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "")
 	(plus:DF (match_operand:DF 1 "fp_arith_reg_operand" "")
@@ -9673,12 +9705,28 @@
 (define_expand "negdf2"
   [(set (match_operand:DF 0 "fp_arith_reg_operand")
 	(neg:DF (match_operand:DF 1 "fp_arith_reg_operand")))]
-  "TARGET_FPU_DOUBLE")
+  "TARGET_FPU_DOUBLE"
+{
+  if (TARGET_FPU_SH4_300)
+    emit_insn (gen_negdf2_fpscr (operands[0], operands[1]));
+  else
+    emit_insn (gen_negdf2_no_fpscr (operands[0], operands[1]));
+  DONE;
+})
 
-(define_insn "*negdf2_i"
+(define_insn "negdf2_fpscr"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "=f")
+	(neg:DF (match_operand:DF 1 "fp_arith_reg_operand" "0")))
+   (use (reg:SI FPSCR_MODES_REG))]
+  "TARGET_FPU_SH4_300"
+  "fneg	%0"
+  [(set_attr "type" "fmove")
+   (set_attr "fp_mode" "double")])
+
+(define_insn "negdf2_no_fpscr"
+  [(set (match_operand:DF 0 "fp_arith_reg_operand" "=f")
 	(neg:DF (match_operand:DF 1 "fp_arith_reg_operand" "0")))]
-  "TARGET_FPU_DOUBLE"
+  "TARGET_FPU_DOUBLE && !TARGET_FPU_SH4_300"
   "fneg	%0"
   [(set_attr "type" "fmove")])
 
@@ -9704,15 +9752,31 @@
 (define_expand "absdf2"
   [(set (match_operand:DF 0 "fp_arith_reg_operand")
 	(abs:DF (match_operand:DF 1 "fp_arith_reg_operand")))]
-  "TARGET_FPU_DOUBLE")
+  "TARGET_FPU_DOUBLE"
+{
+  if (TARGET_FPU_SH4_300)
+    emit_insn (gen_absdf2_fpscr (operands[0], operands[1]));
+  else
+    emit_insn (gen_absdf2_no_fpscr (operands[0], operands[1]));
+  DONE;
+})
 
-(define_insn "*absdf2_i"
+(define_insn "absdf2_no_fpscr"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "=f")
 	(abs:DF (match_operand:DF 1 "fp_arith_reg_operand" "0")))]
-  "TARGET_FPU_DOUBLE"
+  "TARGET_FPU_DOUBLE && !TARGET_FPU_SH4_300"
   "fabs	%0"
   [(set_attr "type" "fmove")])
 
+(define_insn "absdf2_fpscr"
+  [(set (match_operand:DF 0 "fp_arith_reg_operand" "=f")
+	(abs:DF (match_operand:DF 1 "fp_arith_reg_operand" "0")))
+   (use (reg:SI FPSCR_MODES_REG))]
+  "TARGET_FPU_SH4_300"
+  "fabs	%0"
+  [(set_attr "type" "fmove")
+   (set_attr "fp_mode" "double")])
+
 (define_expand "extendsfdf2"
   [(set (match_operand:DF 0 "fp_arith_reg_operand" "")
 	(float_extend:DF (match_operand:SF 1 "fpul_operand" "")))]
Index: gcc/config/avr/avr.c
===================================================================
diff --git a/gcc/config/avr/avr.c b/gcc/config/avr/avr.c
--- a/gcc/config/avr/avr.c	(revision 278653)
+++ b/gcc/config/avr/avr.c	(revision 278653)
@@ -3797,13 +3797,14 @@
           gcc_unreachable();
 
         case 1:
-          return avr_asm_len ("%4lpm %0,%a2", xop, plen, 1);
+          avr_asm_len ("%4lpm %0,%a2", xop, plen, 1);
+          break;
 
         case 2:
           if (REGNO (dest) == REG_Z)
-            return avr_asm_len ("%4lpm %5,%a2+" CR_TAB
-                                "%4lpm %B0,%a2" CR_TAB
-                                "mov %A0,%5", xop, plen, 3);
+            avr_asm_len ("%4lpm %5,%a2+" CR_TAB
+                         "%4lpm %B0,%a2" CR_TAB
+                         "mov %A0,%5", xop, plen, 3);
           else
             {
               avr_asm_len ("%4lpm %A0,%a2+" CR_TAB
@@ -3832,9 +3833,9 @@
                        "%4lpm %B0,%a2+", xop, plen, 2);
 
           if (REGNO (dest) == REG_Z - 2)
-            return avr_asm_len ("%4lpm %5,%a2+" CR_TAB
-                                "%4lpm %C0,%a2" CR_TAB
-                                "mov %D0,%5", xop, plen, 3);
+            avr_asm_len ("%4lpm %5,%a2+" CR_TAB
+                         "%4lpm %C0,%a2" CR_TAB
+                         "mov %D0,%5", xop, plen, 3);
           else
             {
               avr_asm_len ("%4lpm %C0,%a2+" CR_TAB
Index: gcc/config/xtensa/xtensa.c
===================================================================
diff --git a/gcc/config/xtensa/xtensa.c b/gcc/config/xtensa/xtensa.c
--- a/gcc/config/xtensa/xtensa.c	(revision 278653)
+++ b/gcc/config/xtensa/xtensa.c	(revision 278653)
@@ -2862,7 +2862,8 @@
 			    gen_rtx_SET (mem, reg));
 	    }
 	}
-      if (total_size > 1024)
+      if (total_size > 1024
+	  || (!callee_save_size && total_size > 128))
 	{
 	  rtx tmp_reg = gen_rtx_REG (Pmode, A9_REG);
 	  emit_move_insn (tmp_reg, GEN_INT (total_size -
Index: gcc/config/riscv/riscv.c
===================================================================
diff --git a/gcc/config/riscv/riscv.c b/gcc/config/riscv/riscv.c
--- a/gcc/config/riscv/riscv.c	(revision 278653)
+++ b/gcc/config/riscv/riscv.c	(revision 278653)
@@ -4389,6 +4389,32 @@
   return align;
 }
 
+/* Implement TARGET_PROMOTE_FUNCTION_MODE.  */
+
+/* This function is equivalent to default_promote_function_mode_always_promote
+   except that it returns a promoted mode even if type is NULL_TREE.  This is
+   needed by libcalls which have no type (only a mode) such as fixed conversion
+   routines that take a signed or unsigned char/short/int argument and convert
+   it to a fixed type.  */
+
+static machine_mode
+riscv_promote_function_mode (const_tree type ATTRIBUTE_UNUSED,
+			     machine_mode mode,
+			     int *punsignedp ATTRIBUTE_UNUSED,
+			     const_tree fntype ATTRIBUTE_UNUSED,
+			     int for_return ATTRIBUTE_UNUSED)
+{
+  int unsignedp;
+
+  if (type != NULL_TREE)
+    return promote_mode (type, mode, punsignedp);
+
+  unsignedp = *punsignedp;
+  PROMOTE_MODE (mode, unsignedp, type);
+  *punsignedp = unsignedp;
+  return mode;
+}
+
 /* Initialize the GCC target structure.  */
 #undef TARGET_ASM_ALIGNED_HI_OP
 #define TARGET_ASM_ALIGNED_HI_OP "\t.half\t"
@@ -4430,7 +4456,7 @@
 #define TARGET_EXPAND_BUILTIN_VA_START riscv_va_start
 
 #undef  TARGET_PROMOTE_FUNCTION_MODE
-#define TARGET_PROMOTE_FUNCTION_MODE default_promote_function_mode_always_promote
+#define TARGET_PROMOTE_FUNCTION_MODE riscv_promote_function_mode
 
 #undef TARGET_RETURN_IN_MEMORY
 #define TARGET_RETURN_IN_MEMORY riscv_return_in_memory
Index: gcc/config/aarch64/driver-aarch64.c
===================================================================
diff --git a/gcc/config/aarch64/driver-aarch64.c b/gcc/config/aarch64/driver-aarch64.c
--- a/gcc/config/aarch64/driver-aarch64.c	(revision 278653)
+++ b/gcc/config/aarch64/driver-aarch64.c	(revision 278653)
@@ -36,7 +36,8 @@
   const char *feat_string;
 };
 
-#define AARCH64_OPT_EXTENSION(EXT_NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, FEATURE_STRING) \
+#define AARCH64_OPT_EXTENSION(EXT_NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, \
+			      SYNTHETIC, FEATURE_STRING) \
   { EXT_NAME, FLAG_CANONICAL, FEATURE_STRING },
 static struct aarch64_arch_extension aarch64_extensions[] =
 {
@@ -249,19 +250,24 @@
 	{
 	  for (i = 0; i < num_exts; i++)
 	    {
-	      char *p = NULL;
-	      char *feat_string
-		= concat (aarch64_extensions[i].feat_string, NULL);
+	      const char *p = aarch64_extensions[i].feat_string;
+
+	      /* If the feature contains no HWCAPS string then ignore it for the
+		 auto detection.  */
+	      if (*p == '\0')
+		continue;
+
 	      bool enabled = true;
 
 	      /* This may be a multi-token feature string.  We need
-		 to match all parts, which could be in any order.
-		 If this isn't a multi-token feature string, strtok is
-		 just going to return a pointer to feat_string.  */
-	      p = strtok (feat_string, " ");
-	      while (p != NULL)
+		 to match all parts, which could be in any order.  */
+	      size_t len = strlen (buf);
+	      do
 		{
-		  if (strstr (buf, p) == NULL)
+		  const char *end = strchr (p, ' ');
+		  if (end == NULL)
+		    end = strchr (p, '\0');
+		  if (memmem (buf, len, p, end - p) == NULL)
 		    {
 		      /* Failed to match this token.  Turn off the
 			 features we'd otherwise enable.  */
@@ -268,8 +274,11 @@
 		      enabled = false;
 		      break;
 		    }
-		  p = strtok (NULL, " ");
+		  if (*end == '\0')
+		    break;
+		  p = end + 1;
 		}
+	      while (1);
 
 	      if (enabled)
 		extension_flags |= aarch64_extensions[i].flag;
@@ -359,12 +368,12 @@
 not_found:
   {
    /* If detection fails we ignore the option.
-      Clean up and return empty string.  */
+      Clean up and return NULL.  */
 
     if (f)
       fclose (f);
 
-    return "";
+    return NULL;
   }
 }
 
Index: gcc/config/aarch64/iterators.md
===================================================================
diff --git a/gcc/config/aarch64/iterators.md b/gcc/config/aarch64/iterators.md
--- a/gcc/config/aarch64/iterators.md	(revision 278653)
+++ b/gcc/config/aarch64/iterators.md	(revision 278653)
@@ -578,7 +578,8 @@
 (define_mode_attr sizen [(QI "8") (HI "16") (SI "32") (DI "64")])
 
 ;; Give the ordinal of the MSB in the mode
-(define_mode_attr sizem1 [(QI "#7") (HI "#15") (SI "#31") (DI "#63")])
+(define_mode_attr sizem1 [(QI "#7") (HI "#15") (SI "#31") (DI "#63")
+			  (HF "#15") (SF "#31") (DF "#63")])
 
 ;; Attribute to describe constants acceptable in logical operations
 (define_mode_attr lconst [(SI "K") (DI "L")])
@@ -664,7 +665,7 @@
 			  (V8HF "16b") (V2SF  "8b")
 			  (V4SF "16b") (V2DF  "16b")
 			  (DI   "8b")  (DF    "8b")
-			  (SI   "8b")])
+			  (SI   "8b")  (SF    "8b")])
 
 ;; Define element mode for each vector mode.
 (define_mode_attr VEL [(V8QI  "QI") (V16QI "QI") (VNx16QI "QI")
Index: gcc/config/aarch64/aarch64.md
===================================================================
diff --git a/gcc/config/aarch64/aarch64.md b/gcc/config/aarch64/aarch64.md
--- a/gcc/config/aarch64/aarch64.md	(revision 278653)
+++ b/gcc/config/aarch64/aarch64.md	(revision 278653)
@@ -189,6 +189,7 @@
     UNSPEC_CLASTB
     UNSPEC_FADDA
     UNSPEC_REV_SUBREG
+    UNSPEC_COPYSIGN
 ])
 
 (define_c_enum "unspecv" [
@@ -974,8 +975,8 @@
 	(match_operand:GPI 1 "general_operand" ""))]
   ""
   "
-    if (MEM_P (operands[0]) && CONST_INT_P (operands[1])
-	&& <MODE>mode == DImode
+    if (MEM_P (operands[0]) && !MEM_VOLATILE_P (operands[0])
+	&& CONST_INT_P (operands[1]) && <MODE>mode == DImode
 	&& aarch64_split_dimode_const_store (operands[0], operands[1]))
       DONE;
 
@@ -5412,7 +5413,7 @@
   [(match_operand:GPI 0 "register_operand")
    (match_operand:GPF 1 "register_operand")]
   "TARGET_FLOAT
-   && ((GET_MODE_SIZE (<GPF:MODE>mode) <= GET_MODE_SIZE (<GPI:MODE>mode))
+   && ((GET_MODE_BITSIZE (<GPF:MODE>mode) <= LONG_TYPE_SIZE)
    || !flag_trapping_math || flag_fp_int_builtin_inexact)"
 {
   rtx cvt = gen_reg_rtx (<GPF:MODE>mode);
@@ -5427,49 +5428,48 @@
 ;;   LDR d2, #(1 << 63)
 ;;   BSL v2.8b, [y], [x]
 ;;
-;; or another, equivalent, sequence using one of BSL/BIT/BIF.
-;; aarch64_simd_bsldf will select the best suited of these instructions
-;; to generate based on register allocation, and knows how to partially
-;; constant fold based on the values of X and Y, so expand through that.
+;; or another, equivalent, sequence using one of BSL/BIT/BIF.  Because
+;; we expect these operations to nearly always operate on
+;; floating-point values, we do not want the operation to be
+;; simplified into a bit-field insert operation that operates on the
+;; integer side, since typically that would involve three inter-bank
+;; register copies.  As we do not expect copysign to be followed by
+;; other logical operations on the result, it seems preferable to keep
+;; this as an unspec operation, rather than exposing the underlying
+;; logic to the compiler.
 
-(define_expand "copysigndf3"
-  [(match_operand:DF 0 "register_operand")
-   (match_operand:DF 1 "register_operand")
-   (match_operand:DF 2 "register_operand")]
+(define_expand "copysign<GPF:mode>3"
+  [(match_operand:GPF 0 "register_operand")
+   (match_operand:GPF 1 "register_operand")
+   (match_operand:GPF 2 "register_operand")]
   "TARGET_FLOAT && TARGET_SIMD"
 {
-  rtx mask = gen_reg_rtx (DImode);
-  emit_move_insn (mask, GEN_INT (HOST_WIDE_INT_1U << 63));
-  emit_insn (gen_aarch64_simd_bsldf (operands[0], mask,
-				     operands[2], operands[1]));
+  rtx bitmask = gen_reg_rtx (<V_INT_EQUIV>mode);
+  emit_move_insn (bitmask, GEN_INT (HOST_WIDE_INT_M1U
+				    << (GET_MODE_BITSIZE (<MODE>mode) - 1)));
+  emit_insn (gen_copysign<mode>3_insn (operands[0], operands[1], operands[2],
+				       bitmask));
   DONE;
 }
 )
 
-;; As above, but we must first get to a 64-bit value if we wish to use
-;; aarch64_simd_bslv2sf.
-
-(define_expand "copysignsf3"
-  [(match_operand:SF 0 "register_operand")
-   (match_operand:SF 1 "register_operand")
-   (match_operand:SF 2 "register_operand")]
+(define_insn "copysign<GPF:mode>3_insn"
+  [(set (match_operand:GPF 0 "register_operand" "=w,w,w,r")
+	(unspec:GPF [(match_operand:GPF 1 "register_operand" "w,0,w,r")
+		     (match_operand:GPF 2 "register_operand" "w,w,0,0")
+		     (match_operand:<V_INT_EQUIV> 3 "register_operand"
+		      "0,w,w,X")]
+	 UNSPEC_COPYSIGN))]
   "TARGET_FLOAT && TARGET_SIMD"
-{
-  rtx v_bitmask = gen_reg_rtx (V2SImode);
-
-  /* Juggle modes to get us in to a vector mode for BSL.  */
-  rtx op1 = lowpart_subreg (DImode, operands[1], SFmode);
-  rtx op2 = lowpart_subreg (V2SFmode, operands[2], SFmode);
-  rtx tmp = gen_reg_rtx (V2SFmode);
-  emit_move_insn (v_bitmask,
-		  aarch64_simd_gen_const_vector_dup (V2SImode,
-						     HOST_WIDE_INT_M1U << 31));
-  emit_insn (gen_aarch64_simd_bslv2sf (tmp, v_bitmask, op2, op1));
-  emit_move_insn (operands[0], lowpart_subreg (SFmode, tmp, V2SFmode));
-  DONE;
-}
+  "@
+   bsl\\t%0.<Vbtype>, %2.<Vbtype>, %1.<Vbtype>
+   bit\\t%0.<Vbtype>, %2.<Vbtype>, %3.<Vbtype>
+   bif\\t%0.<Vbtype>, %1.<Vbtype>, %3.<Vbtype>
+   bfxil\\t%<w1>0, %<w1>1, #0, <sizem1>"
+  [(set_attr "type" "neon_bsl<q>,neon_bsl<q>,neon_bsl<q>,bfm")]
 )
 
+
 ;; For xorsign (x, y), we want to generate:
 ;;
 ;; LDR   d2, #1<<63
Index: gcc/config/aarch64/aarch64-option-extensions.def
===================================================================
diff --git a/gcc/config/aarch64/aarch64-option-extensions.def b/gcc/config/aarch64/aarch64-option-extensions.def
--- a/gcc/config/aarch64/aarch64-option-extensions.def	(revision 278653)
+++ b/gcc/config/aarch64/aarch64-option-extensions.def	(revision 278653)
@@ -21,88 +21,97 @@
 
    Before using #include to read this file, define a macro:
 
-      AARCH64_OPT_EXTENSION(EXT_NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF, FEATURE_STRING)
+      AARCH64_OPT_EXTENSION(EXT_NAME, FLAG_CANONICAL, FLAGS_ON, FLAGS_OFF,
+			    SYNTHETIC, FEATURE_STRING)
 
-   EXT_NAME is the name of the extension, represented as a string constant.
-   FLAGS_CANONICAL is the canonical internal name for this flag.
-   FLAGS_ON are the bitwise-or of the features that enabling the extension
-   adds, or zero if enabling this extension has no effect on other features.
-   FLAGS_OFF are the bitwise-or of the features that disabling the extension
-   removes, or zero if disabling this extension has no effect on other
-   features.
-   FEAT_STRING is a string containing the entries in the 'Features' field of
-   /proc/cpuinfo on a GNU/Linux system that correspond to this architecture
-   extension being available.  Sometimes multiple entries are needed to enable
-   the extension (for example, the 'crypto' extension depends on four
-   entries: aes, pmull, sha1, sha2 being present).  In that case this field
-   should contain a space (" ") separated list of the strings in 'Features'
-   that are required.  Their order is not important.  */
+   - EXT_NAME is the name of the extension, represented as a string constant.
+   - FLAGS_CANONICAL is the canonical internal name for this flag.
+   - FLAGS_ON are the bitwise-or of the features that enabling the extension
+     adds, or zero if enabling this extension has no effect on other features.
+   - FLAGS_OFF are the bitwise-or of the features that disabling the extension
+     removes, or zero if disabling this extension has no effect on other
+     features.
+   - SYNTHETIC is a boolean to indicate whether the option is a purely synthetic
+     grouping of options and that the option itself has no feature bit (e.g.
+     crypto).  This is used to determine when sum of the individual options in
+     FLAGS_ON can be replaced by FLAG_CANONICAL in options minimization.  If the
+     group is synthetic then they can be replaced when all options in FLAGS_ON
+     are enabled, otherwise they can only be replaced when
+     FLAGS_ON | FLAG_CANONICAL are enabled.
+   - FEAT_STRING is a string containing the entries in the 'Features' field of
+     /proc/cpuinfo on a GNU/Linux system that correspond to this architecture
+     extension being available.  Sometimes multiple entries are needed to enable
+     the extension (for example, the 'crypto' extension depends on four
+     entries: aes, pmull, sha1, sha2 being present).  In that case this field
+     should contain a space (" ") separated list of the strings in 'Features'
+     that are required.  Their order is not important.  An empty string means
+     do not detect this feature during auto detection.  */
 
+/* NOTE: This file is being parsed by config.gcc and so the
+   AARCH64_OPT_EXTENSION must adhere to a strict format:
+   1) No space between the AARCH64_OPT_EXTENSION and the opening (.
+   2) No space between the opening ( and the extension name.
+   3) No space after the extension name before the ,.
+   4) Spaces are only allowed after a , and around |.
+   5) Everything must be on one line.  */
+
 /* Enabling "fp" just enables "fp".
    Disabling "fp" also disables "simd", "crypto", "fp16", "aes", "sha2",
    "sha3", sm3/sm4 and "sve".  */
-AARCH64_OPT_EXTENSION("fp", AARCH64_FL_FP, 0, AARCH64_FL_SIMD | AARCH64_FL_CRYPTO |\
-		      AARCH64_FL_F16 | AARCH64_FL_AES | AARCH64_FL_SHA2 |\
-		      AARCH64_FL_SHA3 | AARCH64_FL_SM4 | AARCH64_FL_SVE, "fp")
+AARCH64_OPT_EXTENSION("fp", AARCH64_FL_FP, 0, AARCH64_FL_SIMD | AARCH64_FL_CRYPTO | AARCH64_FL_F16 | AARCH64_FL_AES | AARCH64_FL_SHA2 | AARCH64_FL_SHA3 | AARCH64_FL_SM4 | AARCH64_FL_SVE, false, "fp")
 
 /* Enabling "simd" also enables "fp".
    Disabling "simd" also disables "crypto", "dotprod", "aes", "sha2", "sha3",
    "sm3/sm4" and "sve".  */
-AARCH64_OPT_EXTENSION("simd", AARCH64_FL_SIMD, AARCH64_FL_FP, AARCH64_FL_CRYPTO |\
-		      AARCH64_FL_DOTPROD | AARCH64_FL_AES | AARCH64_FL_SHA2 |\
-		      AARCH64_FL_SHA3 | AARCH64_FL_SM4 | AARCH64_FL_SVE,
-		      "asimd")
+AARCH64_OPT_EXTENSION("simd", AARCH64_FL_SIMD, AARCH64_FL_FP, AARCH64_FL_CRYPTO | AARCH64_FL_DOTPROD | AARCH64_FL_AES | AARCH64_FL_SHA2 | AARCH64_FL_SHA3 | AARCH64_FL_SM4 | AARCH64_FL_SVE, false, "asimd")
 
-/* Enabling "crypto" also enables "fp" and "simd".
+/* Enabling "crypto" also enables "fp", "simd", "aes" and "sha2".
    Disabling "crypto" disables "crypto", "aes", "sha2", "sha3" and "sm3/sm4".  */
-AARCH64_OPT_EXTENSION("crypto", AARCH64_FL_CRYPTO, AARCH64_FL_FP | AARCH64_FL_SIMD,\
-		      AARCH64_FL_AES | AARCH64_FL_SHA2 |AARCH64_FL_SHA3 | AARCH64_FL_SM4,\
-		      "aes pmull sha1 sha2")
+AARCH64_OPT_EXTENSION("crypto", AARCH64_FL_CRYPTO, AARCH64_FL_FP | AARCH64_FL_SIMD | AARCH64_FL_AES | AARCH64_FL_SHA2, AARCH64_FL_AES | AARCH64_FL_SHA2 |AARCH64_FL_SHA3 | AARCH64_FL_SM4, true, "aes pmull sha1 sha2")
 
 /* Enabling or disabling "crc" only changes "crc".  */
-AARCH64_OPT_EXTENSION("crc", AARCH64_FL_CRC, 0, 0, "crc32")
+AARCH64_OPT_EXTENSION("crc", AARCH64_FL_CRC, 0, 0, false, "crc32")
 
 /* Enabling or disabling "lse" only changes "lse".  */
-AARCH64_OPT_EXTENSION("lse", AARCH64_FL_LSE, 0, 0, "atomics")
+AARCH64_OPT_EXTENSION("lse", AARCH64_FL_LSE, 0, 0, false, "atomics")
 
 /* Enabling "fp16" also enables "fp".
    Disabling "fp16" disables "fp16", "fp16fml" and "sve".  */
-AARCH64_OPT_EXTENSION("fp16", AARCH64_FL_F16, AARCH64_FL_FP,
-		      AARCH64_FL_F16FML | AARCH64_FL_SVE, "fphp asimdhp")
+AARCH64_OPT_EXTENSION("fp16", AARCH64_FL_F16, AARCH64_FL_FP, AARCH64_FL_F16FML | AARCH64_FL_SVE, false, "fphp asimdhp")
 
 /* Enabling or disabling "rcpc" only changes "rcpc".  */
-AARCH64_OPT_EXTENSION("rcpc", AARCH64_FL_RCPC, 0, 0, "lrcpc")
+AARCH64_OPT_EXTENSION("rcpc", AARCH64_FL_RCPC, 0, 0, false, "lrcpc")
 
 /* Enabling "rdma" also enables "fp", "simd".
    Disabling "rdma" just disables "rdma".  */
-AARCH64_OPT_EXTENSION("rdma", AARCH64_FL_RDMA, AARCH64_FL_FP | AARCH64_FL_SIMD, 0, "asimdrdm")
+AARCH64_OPT_EXTENSION("rdma", AARCH64_FL_RDMA, AARCH64_FL_FP | AARCH64_FL_SIMD, 0, false, "asimdrdm")
 
 /* Enabling "dotprod" also enables "simd".
    Disabling "dotprod" only disables "dotprod".  */
-AARCH64_OPT_EXTENSION("dotprod", AARCH64_FL_DOTPROD, AARCH64_FL_SIMD, 0, "asimddp")
+AARCH64_OPT_EXTENSION("dotprod", AARCH64_FL_DOTPROD, AARCH64_FL_SIMD, 0, false, "asimddp")
 
 /* Enabling "aes" also enables "simd".
    Disabling "aes" just disables "aes".  */
-AARCH64_OPT_EXTENSION("aes", AARCH64_FL_AES, AARCH64_FL_SIMD, 0, "aes")
+AARCH64_OPT_EXTENSION("aes", AARCH64_FL_AES, AARCH64_FL_SIMD, 0, false, "aes")
 
 /* Enabling "sha2" also enables "simd".
    Disabling "sha2" just disables "sha2".  */
-AARCH64_OPT_EXTENSION("sha2", AARCH64_FL_SHA2, AARCH64_FL_SIMD, 0, "sha1 sha2")
+AARCH64_OPT_EXTENSION("sha2", AARCH64_FL_SHA2, AARCH64_FL_SIMD, 0, false, "sha1 sha2")
 
 /* Enabling "sha3" enables "simd" and "sha2".
    Disabling "sha3" just disables "sha3".  */
-AARCH64_OPT_EXTENSION("sha3", AARCH64_FL_SHA3, AARCH64_FL_SIMD | AARCH64_FL_SHA2, 0, "sha3 sha512")
+AARCH64_OPT_EXTENSION("sha3", AARCH64_FL_SHA3, AARCH64_FL_SIMD | AARCH64_FL_SHA2, 0, false, "sha3 sha512")
 
 /* Enabling "sm4" also enables "simd".
    Disabling "sm4" just disables "sm4".  */
-AARCH64_OPT_EXTENSION("sm4", AARCH64_FL_SM4, AARCH64_FL_SIMD, 0, "sm3 sm4")
+AARCH64_OPT_EXTENSION("sm4", AARCH64_FL_SM4, AARCH64_FL_SIMD, 0, false, "sm3 sm4")
 
 /* Enabling "fp16fml" also enables "fp" and "fp16".
    Disabling "fp16fml" just disables "fp16fml".  */
-AARCH64_OPT_EXTENSION("fp16fml", AARCH64_FL_F16FML, AARCH64_FL_FP | AARCH64_FL_F16, 0, "asimdfml")
+AARCH64_OPT_EXTENSION("fp16fml", AARCH64_FL_F16FML, AARCH64_FL_FP | AARCH64_FL_F16, 0, false, "asimdfml")
 
 /* Enabling "sve" also enables "fp16", "fp" and "simd".
    Disabling "sve" just disables "sve".  */
-AARCH64_OPT_EXTENSION("sve", AARCH64_FL_SVE, AARCH64_FL_FP | AARCH64_FL_SIMD | AARCH64_FL_F16, 0, "sve")
+AARCH64_OPT_EXTENSION("sve", AARCH64_FL_SVE, AARCH64_FL_FP | AARCH64_FL_SIMD | AARCH64_FL_F16, 0, false, "sve")
 
 #undef AARCH64_OPT_EXTENSION
Index: gcc/config/aarch64/aarch64-c.c
===================================================================
diff --git a/gcc/config/aarch64/aarch64-c.c b/gcc/config/aarch64/aarch64-c.c
--- a/gcc/config/aarch64/aarch64-c.c	(revision 278653)
+++ b/gcc/config/aarch64/aarch64-c.c	(revision 278653)
@@ -146,6 +146,7 @@
       builtin_define_with_int_value ("__ARM_FEATURE_SVE_BITS", bits);
     }
 
+  aarch64_def_or_undef (TARGET_LSE, "__ARM_FEATURE_ATOMICS", pfile);
   aarch64_def_or_undef (TARGET_AES, "__ARM_FEATURE_AES", pfile);
   aarch64_def_or_undef (TARGET_SHA2, "__ARM_FEATURE_SHA2", pfile);
   aarch64_def_or_undef (TARGET_SHA3, "__ARM_FEATURE_SHA3", pfile);
Index: gcc/config/aarch64/aarch64.c
===================================================================
diff --git a/gcc/config/aarch64/aarch64.c b/gcc/config/aarch64/aarch64.c
--- a/gcc/config/aarch64/aarch64.c	(revision 278653)
+++ b/gcc/config/aarch64/aarch64.c	(revision 278653)
@@ -15623,7 +15623,7 @@
 	return true;
       if (d->vec_flags == VEC_SVE_DATA)
 	return aarch64_evpc_sve_tbl (d);
-      else if (d->vec_flags == VEC_SVE_DATA)
+      else if (d->vec_flags == VEC_ADVSIMD)
 	return aarch64_evpc_tbl (d);
     }
   return false;
Index: gcc/config/rs6000/darwin64.h
===================================================================
diff --git a/gcc/config/rs6000/darwin64.h b/gcc/config/rs6000/darwin64.h
deleted file mode 10644
--- a/gcc/config/rs6000/darwin64.h	(revision 278653)
+++ /dev/null	(nonexistent)
@@ -1,32 +0,0 @@
-/* Target definitions for PowerPC running Darwin (Mac OS X).
-   Copyright (C) 2006-2018 Free Software Foundation, Inc.
-   Contributed by Apple Computer Inc.
-
-   This file is part of GCC.
-
-   GCC is free software; you can redistribute it and/or modify it
-   under the terms of the GNU General Public License as published
-   by the Free Software Foundation; either version 3, or (at your
-   option) any later version.
-
-   GCC is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-   License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with GCC; see the file COPYING3.  If not see
-   <http://www.gnu.org/licenses/>.  */
-
-#undef  TARGET_DEFAULT
-#define TARGET_DEFAULT (MASK_POWERPC64 | MASK_64BIT \
-			| MASK_MULTIPLE | MASK_PPC_GFXOPT)
-
-#undef DARWIN_ARCH_SPEC
-#define DARWIN_ARCH_SPEC "%{m32:ppc;:ppc64}"
-
-#undef DARWIN_SUBARCH_SPEC
-#define DARWIN_SUBARCH_SPEC DARWIN_ARCH_SPEC
-
-#undef DARWIN_CRT2_SPEC
-#define DARWIN_CRT2_SPEC ""
Index: gcc/config/rs6000/t-darwin64
===================================================================
diff --git a/gcc/config/rs6000/t-darwin64 b/gcc/config/rs6000/t-darwin64
deleted file mode 10644
--- a/gcc/config/rs6000/t-darwin64	(revision 278653)
+++ /dev/null	(nonexistent)
@@ -1,2 +0,0 @@
-MULTILIB_OPTIONS = m32
-MULTILIB_DIRNAMES = ppc
Index: gcc/config/rs6000/t-darwin8
===================================================================
diff --git a/gcc/config/rs6000/t-darwin8 b/gcc/config/rs6000/t-darwin8
deleted file mode 10644
--- a/gcc/config/rs6000/t-darwin8	(revision 278653)
+++ /dev/null	(nonexistent)
@@ -1,3 +0,0 @@
-# 64-bit libraries can only be built in Darwin 8.x or later.
-MULTILIB_OPTIONS = m64
-MULTILIB_DIRNAMES = ppc64
Index: gcc/config/rs6000/t-darwin64-biarch
===================================================================
diff --git a/gcc/config/rs6000/t-darwin64-biarch b/gcc/config/rs6000/t-darwin64-biarch
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/config/rs6000/t-darwin64-biarch	(revision 278653)
@@ -0,0 +1,2 @@
+MULTILIB_OPTIONS = m32
+MULTILIB_DIRNAMES = ppc
Index: gcc/config/rs6000/darwin.md
===================================================================
diff --git a/gcc/config/rs6000/darwin.md b/gcc/config/rs6000/darwin.md
--- a/gcc/config/rs6000/darwin.md	(revision 278653)
+++ b/gcc/config/rs6000/darwin.md	(revision 278653)
@@ -137,38 +137,6 @@
   [(set_attr "type" "store")
    (set_attr "length" "4")])
 
-;; 64-bit MachO load/store support
-(define_insn "movdi_low"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=r,*!d")
-        (mem:DI (lo_sum:DI (match_operand:DI 1 "gpc_reg_operand" "b,b")
-                           (match_operand 2 "" ""))))]
-  "TARGET_MACHO && TARGET_64BIT"
-  "@
-   ld %0,lo16(%2)(%1)
-   lfd %0,lo16(%2)(%1)"
-  [(set_attr "type" "load")
-   (set_attr "length" "4")])
-
-(define_insn "movsi_low_st"
-  [(set (mem:SI (lo_sum:SI (match_operand:SI 1 "gpc_reg_operand" "b")
-                           (match_operand 2 "" "")))
-	(match_operand:SI 0 "gpc_reg_operand" "r"))]
-  "TARGET_MACHO && ! TARGET_64BIT"
-  "stw %0,lo16(%2)(%1)"
-  [(set_attr "type" "store")
-   (set_attr "length" "4")])
-
-(define_insn "movdi_low_st"
-  [(set (mem:DI (lo_sum:DI (match_operand:DI 1 "gpc_reg_operand" "b,b")
-                           (match_operand 2 "" "")))
-	(match_operand:DI 0 "gpc_reg_operand" "r,*!d"))]
-  "TARGET_MACHO && TARGET_64BIT"
-  "@
-   std %0,lo16(%2)(%1)
-   stfd %0,lo16(%2)(%1)"
-  [(set_attr "type" "store")
-   (set_attr "length" "4")])
-
 ;; Mach-O PIC trickery.
 (define_expand "macho_high"
   [(set (match_operand 0 "")
Index: gcc/config/rs6000/mmintrin.h
===================================================================
diff --git a/gcc/config/rs6000/mmintrin.h b/gcc/config/rs6000/mmintrin.h
--- a/gcc/config/rs6000/mmintrin.h	(revision 278653)
+++ b/gcc/config/rs6000/mmintrin.h	(revision 278653)
@@ -581,7 +581,7 @@
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
 _m_psubd (__m64 __m1, __m64 __m2)
 {
-  return _mm_add_pi32 (__m1, __m2);
+  return _mm_sub_pi32 (__m1, __m2);
 }
 
 extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
Index: gcc/config/rs6000/t-darwin32-biarch
===================================================================
diff --git a/gcc/config/rs6000/t-darwin32-biarch b/gcc/config/rs6000/t-darwin32-biarch
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/config/rs6000/t-darwin32-biarch	(revision 278653)
@@ -0,0 +1,3 @@
+# 64-bit libraries can only be built in Darwin 8.x or later.
+MULTILIB_OPTIONS = m64
+MULTILIB_DIRNAMES = ppc64
Index: gcc/config/rs6000/predicates.md
===================================================================
diff --git a/gcc/config/rs6000/predicates.md b/gcc/config/rs6000/predicates.md
--- a/gcc/config/rs6000/predicates.md	(revision 278653)
+++ b/gcc/config/rs6000/predicates.md	(revision 278653)
@@ -1085,8 +1085,7 @@
     return 1;
 
   /* Allow any integer constant.  */
-  if (GET_MODE_CLASS (mode) == MODE_INT
-      && CONST_SCALAR_INT_P (op))
+  if (SCALAR_INT_MODE_P (mode) && CONST_SCALAR_INT_P (op))
     return 1;
 
   /* Allow easy vector constants.  */
Index: gcc/config/rs6000/power9.md
===================================================================
diff --git a/gcc/config/rs6000/power9.md b/gcc/config/rs6000/power9.md
--- a/gcc/config/rs6000/power9.md	(revision 278653)
+++ b/gcc/config/rs6000/power9.md	(revision 278653)
@@ -236,6 +236,9 @@
        (eq_attr "cpu" "power9"))
   "DU_super_power9,LSU_pair_power9")
 
+; Store forwarding latency is 6
+(define_bypass 6 "power9-*store*" "power9-*load*")
+
 (define_insn_reservation "power9-larx" 4
   (and (eq_attr "type" "load_l")
        (eq_attr "cpu" "power9"))
Index: gcc/config/rs6000/t-linux
===================================================================
diff --git a/gcc/config/rs6000/t-linux b/gcc/config/rs6000/t-linux
--- a/gcc/config/rs6000/t-linux	(revision 278653)
+++ b/gcc/config/rs6000/t-linux	(revision 278653)
@@ -4,7 +4,7 @@
 ifneq (,$(findstring powerpc64,$(target)))
 MULTILIB_OSDIRNAMES := .=../lib64$(call if_multiarch,:powerpc64-linux-gnu)
 else
-MULTIARCH_DIRNAME := powerpc-linux-gnu
+MULTIARCH_DIRNAME := $(call if_multiarch,powerpc-linux-gnu)
 endif
 ifneq (,$(findstring powerpcle,$(target)))
 MULTIARCH_DIRNAME := $(subst -linux,le-linux,$(MULTIARCH_DIRNAME))
Index: gcc/config/rs6000/darwin32-biarch.h
===================================================================
diff --git a/gcc/config/rs6000/darwin32-biarch.h b/gcc/config/rs6000/darwin32-biarch.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/config/rs6000/darwin32-biarch.h	(revision 278653)
@@ -0,0 +1,49 @@
+/* Target definitions for PowerPC running Darwin (Mac OS X) for a 32b host
+   with a 64b miultilib.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#undef DARWIN_ARCH_SPEC
+#define DARWIN_ARCH_SPEC "%{m64:ppc64;:ppc}"
+
+#undef DARWIN_SUBARCH_SPEC
+#define DARWIN_SUBARCH_SPEC "			\
+ %{m64: ppc64}					\
+ %{!m64:					\
+ %{mcpu=601:ppc601;				\
+   mcpu=603:ppc603;				\
+   mcpu=603e:ppc603;				\
+   mcpu=604:ppc604;				\
+   mcpu=604e:ppc604e;				\
+   mcpu=740:ppc750;				\
+   mcpu=750:ppc750;				\
+   mcpu=G3:ppc750;				\
+   mcpu=7400:ppc7400;				\
+   mcpu=G4:ppc7400;				\
+   mcpu=7450:ppc7450;				\
+   mcpu=970:ppc970;				\
+   mcpu=power4:ppc970;				\
+   mcpu=G5:ppc970;				\
+   :ppc}}"
+
+#undef SUBTARGET_EXTRA_SPECS
+#define SUBTARGET_EXTRA_SPECS			\
+  DARWIN_EXTRA_SPECS                            \
+  { "darwin_arch", DARWIN_ARCH_SPEC },		\
+  { "darwin_crt2", DARWIN_CRT2_SPEC },		\
+  { "darwin_subarch", DARWIN_SUBARCH_SPEC },
Index: gcc/config/rs6000/darwin64-biarch.h
===================================================================
diff --git a/gcc/config/rs6000/darwin64-biarch.h b/gcc/config/rs6000/darwin64-biarch.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/config/rs6000/darwin64-biarch.h	(revision 278653)
@@ -0,0 +1,38 @@
+/* Target definitions for PowerPC64 running Darwin (Mac OS X) for a 64b host
+   supporting a 32b multilib.
+   Copyright (C) 2006-2019 Free Software Foundation, Inc.
+   Contributed by Apple Computer Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#undef  TARGET_DEFAULT
+#define TARGET_DEFAULT (MASK_POWERPC64 | MASK_64BIT \
+			| MASK_MULTIPLE | MASK_PPC_GFXOPT)
+
+#undef DARWIN_ARCH_SPEC
+#define DARWIN_ARCH_SPEC "%{m32:ppc;:ppc64}"
+
+/* Actually, there's really only 970 as an active option.  */
+#undef DARWIN_SUBARCH_SPEC
+#define DARWIN_SUBARCH_SPEC DARWIN_ARCH_SPEC
+
+#undef SUBTARGET_EXTRA_SPECS
+#define SUBTARGET_EXTRA_SPECS			\
+  DARWIN_EXTRA_SPECS                            \
+  { "darwin_arch", DARWIN_ARCH_SPEC },		\
+  { "darwin_crt2", "" },			\
+  { "darwin_subarch", DARWIN_SUBARCH_SPEC },
Index: gcc/config/rs6000/rs6000-builtin.def
===================================================================
diff --git a/gcc/config/rs6000/rs6000-builtin.def b/gcc/config/rs6000/rs6000-builtin.def
--- a/gcc/config/rs6000/rs6000-builtin.def	(revision 278653)
+++ b/gcc/config/rs6000/rs6000-builtin.def	(revision 278653)
@@ -1048,12 +1048,12 @@
 BU_ALTIVEC_2 (VADDSWS,	      "vaddsws",	CONST,	altivec_vaddsws)
 BU_ALTIVEC_2 (VAND,	      "vand",		CONST,	andv4si3)
 BU_ALTIVEC_2 (VANDC,	      "vandc",		CONST,	andcv4si3)
-BU_ALTIVEC_2 (VAVGUB,	      "vavgub",		CONST,	altivec_vavgub)
-BU_ALTIVEC_2 (VAVGSB,	      "vavgsb",		CONST,	altivec_vavgsb)
-BU_ALTIVEC_2 (VAVGUH,	      "vavguh",		CONST,	altivec_vavguh)
-BU_ALTIVEC_2 (VAVGSH,	      "vavgsh",		CONST,	altivec_vavgsh)
-BU_ALTIVEC_2 (VAVGUW,	      "vavguw",		CONST,	altivec_vavguw)
-BU_ALTIVEC_2 (VAVGSW,	      "vavgsw",		CONST,	altivec_vavgsw)
+BU_ALTIVEC_2 (VAVGUB,	      "vavgub",		CONST,	uavgv16qi3_ceil)
+BU_ALTIVEC_2 (VAVGSB,	      "vavgsb",		CONST,	avgv16qi3_ceil)
+BU_ALTIVEC_2 (VAVGUH,	      "vavguh",		CONST,	uavgv8hi3_ceil)
+BU_ALTIVEC_2 (VAVGSH,	      "vavgsh",		CONST,	avgv8hi3_ceil)
+BU_ALTIVEC_2 (VAVGUW,	      "vavguw",		CONST,	uavgv4si3_ceil)
+BU_ALTIVEC_2 (VAVGSW,	      "vavgsw",		CONST,	avgv4si3_ceil)
 BU_ALTIVEC_2 (VCFUX,	      "vcfux",		CONST,	altivec_vcfux)
 BU_ALTIVEC_2 (VCFSX,	      "vcfsx",		CONST,	altivec_vcfsx)
 BU_ALTIVEC_2 (VCMPBFP,	      "vcmpbfp",	CONST,	altivec_vcmpbfp)
@@ -1223,26 +1223,26 @@
 BU_ALTIVEC_X (MFVSCR,		"mfvscr",	    MISC)
 BU_ALTIVEC_X (DSSALL,		"dssall",	    MISC)
 BU_ALTIVEC_X (DSS,		"dss",		    MISC)
-BU_ALTIVEC_X (LVSL,		"lvsl",		    MEM)
-BU_ALTIVEC_X (LVSR,		"lvsr",		    MEM)
-BU_ALTIVEC_X (LVEBX,		"lvebx",	    MEM)
-BU_ALTIVEC_X (LVEHX,		"lvehx",	    MEM)
-BU_ALTIVEC_X (LVEWX,		"lvewx",	    MEM)
-BU_ALTIVEC_X (LVXL,		"lvxl",		    MEM)
-BU_ALTIVEC_X (LVXL_V2DF,	"lvxl_v2df",	    MEM)
-BU_ALTIVEC_X (LVXL_V2DI,	"lvxl_v2di",	    MEM)
-BU_ALTIVEC_X (LVXL_V4SF,	"lvxl_v4sf",	    MEM)
-BU_ALTIVEC_X (LVXL_V4SI,	"lvxl_v4si",	    MEM)
-BU_ALTIVEC_X (LVXL_V8HI,	"lvxl_v8hi",	    MEM)
-BU_ALTIVEC_X (LVXL_V16QI,	"lvxl_v16qi",	    MEM)
-BU_ALTIVEC_X (LVX,		"lvx",		    MEM)
-BU_ALTIVEC_X (LVX_V1TI,		"lvx_v1ti",	    MEM)
-BU_ALTIVEC_X (LVX_V2DF,		"lvx_v2df",	    MEM)
-BU_ALTIVEC_X (LVX_V2DI,		"lvx_v2di",	    MEM)
-BU_ALTIVEC_X (LVX_V4SF,		"lvx_v4sf",	    MEM)
-BU_ALTIVEC_X (LVX_V4SI,		"lvx_v4si",	    MEM)
-BU_ALTIVEC_X (LVX_V8HI,		"lvx_v8hi",	    MEM)
-BU_ALTIVEC_X (LVX_V16QI,	"lvx_v16qi",	    MEM)
+BU_ALTIVEC_X (LVSL,		"lvsl",		    PURE)
+BU_ALTIVEC_X (LVSR,		"lvsr",		    PURE)
+BU_ALTIVEC_X (LVEBX,		"lvebx",	    PURE)
+BU_ALTIVEC_X (LVEHX,		"lvehx",	    PURE)
+BU_ALTIVEC_X (LVEWX,		"lvewx",	    PURE)
+BU_ALTIVEC_X (LVXL,		"lvxl",		    PURE)
+BU_ALTIVEC_X (LVXL_V2DF,	"lvxl_v2df",	    PURE)
+BU_ALTIVEC_X (LVXL_V2DI,	"lvxl_v2di",	    PURE)
+BU_ALTIVEC_X (LVXL_V4SF,	"lvxl_v4sf",	    PURE)
+BU_ALTIVEC_X (LVXL_V4SI,	"lvxl_v4si",	    PURE)
+BU_ALTIVEC_X (LVXL_V8HI,	"lvxl_v8hi",	    PURE)
+BU_ALTIVEC_X (LVXL_V16QI,	"lvxl_v16qi",	    PURE)
+BU_ALTIVEC_X (LVX,		"lvx",		    PURE)
+BU_ALTIVEC_X (LVX_V1TI,		"lvx_v1ti",	    PURE)
+BU_ALTIVEC_X (LVX_V2DF,		"lvx_v2df",	    PURE)
+BU_ALTIVEC_X (LVX_V2DI,		"lvx_v2di",	    PURE)
+BU_ALTIVEC_X (LVX_V4SF,		"lvx_v4sf",	    PURE)
+BU_ALTIVEC_X (LVX_V4SI,		"lvx_v4si",	    PURE)
+BU_ALTIVEC_X (LVX_V8HI,		"lvx_v8hi",	    PURE)
+BU_ALTIVEC_X (LVX_V16QI,	"lvx_v16qi",	    PURE)
 BU_ALTIVEC_X (STVX,		"stvx",		    MEM)
 BU_ALTIVEC_X (STVX_V2DF,	"stvx_v2df",	    MEM)
 BU_ALTIVEC_X (STVX_V2DI,	"stvx_v2di",	    MEM)
@@ -1250,10 +1250,10 @@
 BU_ALTIVEC_X (STVX_V4SI,	"stvx_v4si",	    MEM)
 BU_ALTIVEC_X (STVX_V8HI,	"stvx_v8hi",	    MEM)
 BU_ALTIVEC_X (STVX_V16QI,	"stvx_v16qi",	    MEM)
-BU_ALTIVEC_C (LVLX,		"lvlx",		    MEM)
-BU_ALTIVEC_C (LVLXL,		"lvlxl",	    MEM)
-BU_ALTIVEC_C (LVRX,		"lvrx",		    MEM)
-BU_ALTIVEC_C (LVRXL,		"lvrxl",	    MEM)
+BU_ALTIVEC_C (LVLX,		"lvlx",		    PURE)
+BU_ALTIVEC_C (LVLXL,		"lvlxl",	    PURE)
+BU_ALTIVEC_C (LVRX,		"lvrx",		    PURE)
+BU_ALTIVEC_C (LVRXL,		"lvrxl",	    PURE)
 BU_ALTIVEC_X (STVEBX,		"stvebx",	    MEM)
 BU_ALTIVEC_X (STVEHX,		"stvehx",	    MEM)
 BU_ALTIVEC_X (STVEWX,		"stvewx",	    MEM)
@@ -1764,15 +1764,15 @@
 BU_VSX_P (XVCMPGTDP_P,	      "xvcmpgtdp_p",	CONST,	vector_gt_v2df_p)
 
 /* VSX builtins that are handled as special cases.  */
-BU_VSX_X (LXSDX,	      "lxsdx",		MEM)
-BU_VSX_X (LXVD2X_V1TI,	      "lxvd2x_v1ti",	MEM)
-BU_VSX_X (LXVD2X_V2DF,	      "lxvd2x_v2df",	MEM)
-BU_VSX_X (LXVD2X_V2DI,	      "lxvd2x_v2di",	MEM)
-BU_VSX_X (LXVDSX,	      "lxvdsx",		MEM)
-BU_VSX_X (LXVW4X_V4SF,	      "lxvw4x_v4sf",	MEM)
-BU_VSX_X (LXVW4X_V4SI,        "lxvw4x_v4si",	MEM)
-BU_VSX_X (LXVW4X_V8HI,        "lxvw4x_v8hi",	MEM)
-BU_VSX_X (LXVW4X_V16QI,	      "lxvw4x_v16qi",	MEM)
+BU_VSX_X (LXSDX,	      "lxsdx",		PURE)
+BU_VSX_X (LXVD2X_V1TI,	      "lxvd2x_v1ti",	PURE)
+BU_VSX_X (LXVD2X_V2DF,	      "lxvd2x_v2df",	PURE)
+BU_VSX_X (LXVD2X_V2DI,	      "lxvd2x_v2di",	PURE)
+BU_VSX_X (LXVDSX,	      "lxvdsx",		PURE)
+BU_VSX_X (LXVW4X_V4SF,	      "lxvw4x_v4sf",	PURE)
+BU_VSX_X (LXVW4X_V4SI,	      "lxvw4x_v4si",	PURE)
+BU_VSX_X (LXVW4X_V8HI,	      "lxvw4x_v8hi",	PURE)
+BU_VSX_X (LXVW4X_V16QI,	      "lxvw4x_v16qi",	PURE)
 BU_VSX_X (STXSDX,	      "stxsdx",		MEM)
 BU_VSX_X (STXVD2X_V1TI,	      "stxvd2x_v1ti",	MEM)
 BU_VSX_X (STXVD2X_V2DF,	      "stxvd2x_v2df",	MEM)
@@ -1781,13 +1781,13 @@
 BU_VSX_X (STXVW4X_V4SI,	      "stxvw4x_v4si",	MEM)
 BU_VSX_X (STXVW4X_V8HI,	      "stxvw4x_v8hi",	MEM)
 BU_VSX_X (STXVW4X_V16QI,      "stxvw4x_v16qi",	MEM)
-BU_VSX_X (LD_ELEMREV_V1TI,    "ld_elemrev_v1ti",  MEM)
-BU_VSX_X (LD_ELEMREV_V2DF,    "ld_elemrev_v2df",  MEM)
-BU_VSX_X (LD_ELEMREV_V2DI,    "ld_elemrev_v2di",  MEM)
-BU_VSX_X (LD_ELEMREV_V4SF,    "ld_elemrev_v4sf",  MEM)
-BU_VSX_X (LD_ELEMREV_V4SI,    "ld_elemrev_v4si",  MEM)
-BU_VSX_X (LD_ELEMREV_V8HI,    "ld_elemrev_v8hi",  MEM)
-BU_VSX_X (LD_ELEMREV_V16QI,   "ld_elemrev_v16qi", MEM)
+BU_VSX_X (LD_ELEMREV_V1TI,    "ld_elemrev_v1ti",  PURE)
+BU_VSX_X (LD_ELEMREV_V2DF,    "ld_elemrev_v2df",  PURE)
+BU_VSX_X (LD_ELEMREV_V2DI,    "ld_elemrev_v2di",  PURE)
+BU_VSX_X (LD_ELEMREV_V4SF,    "ld_elemrev_v4sf",  PURE)
+BU_VSX_X (LD_ELEMREV_V4SI,    "ld_elemrev_v4si",  PURE)
+BU_VSX_X (LD_ELEMREV_V8HI,    "ld_elemrev_v8hi",  PURE)
+BU_VSX_X (LD_ELEMREV_V16QI,   "ld_elemrev_v16qi", PURE)
 BU_VSX_X (ST_ELEMREV_V1TI,    "st_elemrev_v1ti",  MEM)
 BU_VSX_X (ST_ELEMREV_V2DF,    "st_elemrev_v2df",  MEM)
 BU_VSX_X (ST_ELEMREV_V2DI,    "st_elemrev_v2di",  MEM)
@@ -2442,13 +2442,22 @@
 BU_P9_OVERLOAD_2 (CMPEQB,	"byte_in_set")
 
 /* 1 argument crypto functions.  */
-BU_CRYPTO_1 (VSBOX,		"vsbox",	  CONST, crypto_vsbox)
+BU_CRYPTO_1 (VSBOX,		"vsbox",	  CONST, crypto_vsbox_v2di)
+BU_CRYPTO_1 (VSBOX_BE,		"vsbox_be",	  CONST, crypto_vsbox_v16qi)
 
 /* 2 argument crypto functions.  */
-BU_CRYPTO_2 (VCIPHER,		"vcipher",	  CONST, crypto_vcipher)
-BU_CRYPTO_2 (VCIPHERLAST,	"vcipherlast",	  CONST, crypto_vcipherlast)
-BU_CRYPTO_2 (VNCIPHER,		"vncipher",	  CONST, crypto_vncipher)
-BU_CRYPTO_2 (VNCIPHERLAST,	"vncipherlast",	  CONST, crypto_vncipherlast)
+BU_CRYPTO_2 (VCIPHER,		"vcipher",	  CONST, crypto_vcipher_v2di)
+BU_CRYPTO_2 (VCIPHER_BE,	"vcipher_be",	  CONST, crypto_vcipher_v16qi)
+BU_CRYPTO_2 (VCIPHERLAST,	"vcipherlast",
+	     CONST, crypto_vcipherlast_v2di)
+BU_CRYPTO_2 (VCIPHERLAST_BE,	"vcipherlast_be",
+	     CONST, crypto_vcipherlast_v16qi)
+BU_CRYPTO_2 (VNCIPHER,		"vncipher",	  CONST, crypto_vncipher_v2di)
+BU_CRYPTO_2 (VNCIPHER_BE,	"vncipher_be",	  CONST, crypto_vncipher_v16qi)
+BU_CRYPTO_2 (VNCIPHERLAST,	"vncipherlast",
+	     CONST, crypto_vncipherlast_v2di)
+BU_CRYPTO_2 (VNCIPHERLAST_BE,	"vncipherlast_be",
+	     CONST, crypto_vncipherlast_v16qi)
 BU_CRYPTO_2A (VPMSUMB,		"vpmsumb",	  CONST, crypto_vpmsumb)
 BU_CRYPTO_2A (VPMSUMH,		"vpmsumh",	  CONST, crypto_vpmsumh)
 BU_CRYPTO_2A (VPMSUMW,		"vpmsumw",	  CONST, crypto_vpmsumw)
Index: gcc/config/rs6000/rs6000-c.c
===================================================================
diff --git a/gcc/config/rs6000/rs6000-c.c b/gcc/config/rs6000/rs6000-c.c
--- a/gcc/config/rs6000/rs6000-c.c	(revision 278653)
+++ b/gcc/config/rs6000/rs6000-c.c	(revision 278653)
@@ -6605,12 +6605,14 @@
 
 	  arg2 = fold_for_warn (arg2);
 
-	  /* If the second argument is an integer constant, if the value is in
-	     the expected range, generate the built-in code if we can.  We need
-	     64-bit and direct move to extract the small integer vectors.  */
-	  if (TREE_CODE (arg2) == INTEGER_CST
-	      && wi::ltu_p (wi::to_wide (arg2), nunits))
+	  /* If the second argument is an integer constant, generate
+	     the built-in code if we can.  We need 64-bit and direct
+	     move to extract the small integer vectors.  */
+	  if (TREE_CODE (arg2) == INTEGER_CST)
 	    {
+	      wide_int selector = wi::to_wide (arg2);
+	      selector = wi::umod_trunc (selector, nunits);
+	      arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);
 	      switch (mode)
 		{
 		default:
@@ -6785,11 +6787,13 @@
       /* If we can use the VSX xxpermdi instruction, use that for insert.  */
       mode = TYPE_MODE (arg1_type);
       if ((mode == V2DFmode || mode == V2DImode) && VECTOR_UNIT_VSX_P (mode)
-	  && TREE_CODE (arg2) == INTEGER_CST
-	  && wi::ltu_p (wi::to_wide (arg2), 2))
+	  && TREE_CODE (arg2) == INTEGER_CST)
 	{
+	  wide_int selector = wi::to_wide (arg2);
+	  selector = wi::umod_trunc (selector, 2);
 	  tree call = NULL_TREE;
 
+	  arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);
 	  if (mode == V2DFmode)
 	    call = rs6000_builtin_decls[VSX_BUILTIN_VEC_SET_V2DF];
 	  else if (mode == V2DImode)
@@ -6801,11 +6805,12 @@
 	    return build_call_expr (call, 3, arg1, arg0, arg2);
 	}
       else if (mode == V1TImode && VECTOR_UNIT_VSX_P (mode)
-	       && TREE_CODE (arg2) == INTEGER_CST
-	       && wi::eq_p (wi::to_wide (arg2), 0))
+	       && TREE_CODE (arg2) == INTEGER_CST)
 	{
 	  tree call = rs6000_builtin_decls[VSX_BUILTIN_VEC_SET_V1TI];
+	  wide_int selector = wi::zero(32);
 
+	  arg2 = wide_int_to_tree (TREE_TYPE (arg2), selector);
 	  /* Note, __builtin_vec_insert_<xxx> has vector and scalar types
 	     reversed.  */
 	  return build_call_expr (call, 3, arg1, arg0, arg2);
@@ -6813,10 +6818,13 @@
 
       /* Build *(((arg1_inner_type*)&(vector type){arg1})+arg2) = arg0. */
       arg1_inner_type = TREE_TYPE (arg1_type);
-      arg2 = build_binary_op (loc, BIT_AND_EXPR, arg2,
-			      build_int_cst (TREE_TYPE (arg2),
-					     TYPE_VECTOR_SUBPARTS (arg1_type)
-					     - 1), 0);
+      if (TYPE_VECTOR_SUBPARTS (arg1_type) == 1)
+	arg2 = build_int_cst (TREE_TYPE (arg2), 0);
+      else
+	arg2 = build_binary_op (loc, BIT_AND_EXPR, arg2,
+				build_int_cst (TREE_TYPE (arg2),
+					       TYPE_VECTOR_SUBPARTS (arg1_type)
+					       - 1), 0);
       decl = build_decl (loc, VAR_DECL, NULL_TREE, arg1_type);
       DECL_EXTERNAL (decl) = 0;
       TREE_PUBLIC (decl) = 0;
Index: gcc/config/rs6000/rs6000-p8swap.c
===================================================================
diff --git a/gcc/config/rs6000/rs6000-p8swap.c b/gcc/config/rs6000/rs6000-p8swap.c
--- a/gcc/config/rs6000/rs6000-p8swap.c	(revision 278653)
+++ b/gcc/config/rs6000/rs6000-p8swap.c	(revision 278653)
@@ -792,6 +792,11 @@
 	  case UNSPEC_REDUC_PLUS:
 	  case UNSPEC_REDUC:
 	    return 1;
+	  case UNSPEC_VPMSUM:
+	    /* vpmsumd is not swappable, but vpmsum[bhw] are.  */
+	    if (GET_MODE (op) == V2DImode)
+	      return 0;
+	    break;
 	  }
       }
 
@@ -2317,7 +2322,14 @@
 
   /* Pre-pass to recombine lvx and stvx patterns so we don't lose info.  */
   recombine_lvx_stvx_patterns (fun);
+
+  /* Rebuild ud- and du-chains.  */
+  df_remove_problem (df_chain);
   df_process_deferred_rescans ();
+  df_set_flags (DF_RD_PRUNE_DEAD_DEFS);
+  df_chain_add_problem (DF_DU_CHAIN | DF_UD_CHAIN);
+  df_analyze ();
+  df_set_flags (DF_DEFER_INSN_RESCAN);
 
   /* Allocate structure to represent webs of insns.  */
   insn_entry = XCNEWVEC (swap_web_entry, get_max_uid ());
Index: gcc/config/rs6000/darwin.h
===================================================================
diff --git a/gcc/config/rs6000/darwin.h b/gcc/config/rs6000/darwin.h
--- a/gcc/config/rs6000/darwin.h	(revision 278653)
+++ b/gcc/config/rs6000/darwin.h	(revision 278653)
@@ -53,17 +53,28 @@
 #define TARGET_OS_CPP_BUILTINS()			\
   do							\
     {							\
-      if (!TARGET_64BIT) builtin_define ("__ppc__");	\
-      if (TARGET_64BIT) builtin_define ("__ppc64__");	\
       builtin_define ("__POWERPC__");			\
+      builtin_define ("__PPC__");			\
+      if (TARGET_64BIT)					\
+	{						\
+	  builtin_define ("__ppc64__");			\
+	  builtin_define ("__PPC64__");			\
+	  builtin_define ("__powerpc64__");		\
+	  builtin_assert ("cpu=powerpc64");		\
+	  builtin_assert ("machine=powerpc64");		\
+	}						\
+      else						\
+	{						\
+	  builtin_define ("__ppc__");			\
+	  builtin_define_std ("PPC");			\
+	  builtin_assert ("cpu=powerpc");		\
+	  builtin_assert ("machine=powerpc");		\
+	}						\
       builtin_define ("__NATURAL_ALIGNMENT__");		\
       darwin_cpp_builtins (pfile);			\
     }							\
   while (0)
 
-/* Generate branch islands stubs if this is true.  */
-extern int darwin_emit_branch_islands;
-
 #define SUBTARGET_OVERRIDE_OPTIONS darwin_rs6000_override_options ()
 
 #define C_COMMON_OVERRIDE_OPTIONS do {					\
@@ -98,11 +109,10 @@
   %<faltivec %<fno-altivec " \
   DARWIN_CC1_SPEC
 
-#define DARWIN_ARCH_SPEC "%{m64:ppc64;:ppc}"
+/* Default to PPC for single arch builds.  */
+#define DARWIN_ARCH_SPEC "ppc"
 
 #define DARWIN_SUBARCH_SPEC "			\
- %{m64: ppc64}					\
- %{!m64:					\
  %{mcpu=601:ppc601;				\
    mcpu=603:ppc603;				\
    mcpu=603e:ppc603;				\
@@ -117,12 +127,40 @@
    mcpu=970:ppc970;				\
    mcpu=power4:ppc970;				\
    mcpu=G5:ppc970;				\
-   :ppc}}"
+   :ppc}"
 
-/* crt2.o is at least partially required for 10.3.x and earlier.  */
+/* We need to jam the crt to 10.5 for 10.6 (Rosetta) use.  */
+#undef DARWIN_CRT1_SPEC
+#define DARWIN_CRT1_SPEC						\
+  "%:version-compare(!> 10.5 mmacosx-version-min= -lcrt1.o)		\
+   %:version-compare(>< 10.5 10.7 mmacosx-version-min= -lcrt1.10.5.o)	\
+   %{fgnu-tm: -lcrttms.o}"
+
+/* crt2.o is at least partially required for 10.3.x and earlier.
+   It deals with registration of the unwind frames, where this is not
+   automatically provided by the system.  So we need it for any case that
+   might use exceptions.  */
+#undef DARWIN_CRT2_SPEC
 #define DARWIN_CRT2_SPEC \
-  "%{!m64:%:version-compare(!> 10.4 mmacosx-version-min= crt2.o%s)}"
+"%{!m64:%{shared-libgcc|static-libstdc++|fexceptions|fobjc-exceptions|fgnu-runtime: \
+   %:version-compare(!> 10.4 mmacosx-version-min= crt2.o%s) \
+  }}"
 
+/* crt3 deals with providing cxa_atexit on earlier systems (or fixing it up,
+   for broken versions).  It's only needed for c++ code, so we can make it
+   conditional on shared-libgcc since that's forced on for c++.  */
+#undef DARWIN_CRT3_SPEC
+#define DARWIN_CRT3_SPEC \
+"%{!m64:%{shared-libgcc|static-libstdc++:							\
+   %:version-compare(>< 10.4 10.5 mmacosx-version-min= crt3.o%s) \
+   %:version-compare(!> 10.4 mmacosx-version-min= crt3_2.o%s) \
+  }}"
+
+/* The PPC regs save/restore functions are leaves and could, conceivably
+   be used by the tm destructor.  */
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC TM_DESTRUCTOR " -lef_ppc"
+
 #undef SUBTARGET_EXTRA_SPECS
 #define SUBTARGET_EXTRA_SPECS			\
   DARWIN_EXTRA_SPECS                            \
@@ -265,9 +303,9 @@
 /* This is supported in cctools 465 and later.  The macro test
    above prevents using it in earlier build environments.  */
 #define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE,LOG,MAX_SKIP)          \
-  if ((LOG) != 0)                                             \
+  if ((LOG) > 0)                                             \
     {                                                         \
-      if ((MAX_SKIP) == 0)                                    \
+      if ((MAX_SKIP) <= 0)                                    \
         fprintf ((FILE), "\t.p2align %d\n", (LOG));           \
       else                                                    \
         fprintf ((FILE), "\t.p2align %d,,%d\n", (LOG), (MAX_SKIP)); \
@@ -382,6 +420,7 @@
   do \
     { \
       DARWIN_REGISTER_TARGET_PRAGMAS(); \
+      targetm.target_option.pragma_parse = rs6000_pragma_target_parse; \
       targetm.resolve_overloaded_builtin = altivec_resolve_overloaded_builtin; \
     } \
   while (0)
@@ -441,6 +480,9 @@
    this will need to be modified similar to the x86 case.  */
 #define TARGET_FOLD_BUILTIN SUBTARGET_FOLD_BUILTIN
 
+/* First available SYMBOL flag bit for use by subtargets.  */
+#define SYMBOL_FLAG_SUBT_DEP (SYMBOL_FLAG_MACH_DEP)
+
 /* Use standard DWARF numbering for DWARF debugging information.  */
 #define RS6000_USE_DWARF_NUMBERING
 
Index: gcc/config/rs6000/rs6000.c
===================================================================
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
--- a/gcc/config/rs6000/rs6000.c	(revision 278653)
+++ b/gcc/config/rs6000/rs6000.c	(revision 278653)
@@ -3880,10 +3880,22 @@
       rs6000_isa_flags |= OPTION_MASK_POWERPC64;
       warning (0, "%qs requires PowerPC64 architecture, enabling", "-m64");
     }
+
+  /* The linkers [ld64] that support 64Bit do not need the JBSR longcall
+     optimisation, and will not work with the most generic case (where the
+     symbol is undefined external, but there is no symbl stub).  */
+  if (TARGET_64BIT)
+    rs6000_default_long_calls = 0;
+
+  /* ld_classic is (so far) still used for kernel (static) code, and supports
+     the JBSR longcall / branch islands.  */
   if (flag_mkernel)
     {
       rs6000_default_long_calls = 1;
-      rs6000_isa_flags |= OPTION_MASK_SOFT_FLOAT;
+
+      /* Allow a kext author to do -mkernel -mhard-float.  */
+      if (! (rs6000_isa_flags_explicit & OPTION_MASK_SOFT_FLOAT))
+        rs6000_isa_flags |= OPTION_MASK_SOFT_FLOAT;
     }
 
   /* Make -m64 imply -maltivec.  Darwin's 64-bit ABI includes
@@ -7374,7 +7386,6 @@
 	default:
 	  break;
 	case E_V1TImode:
-	  gcc_assert (INTVAL (elt) == 0 && inner_mode == TImode);
 	  emit_move_insn (target, gen_lowpart (TImode, vec));
 	  break;
 	case E_V2DFmode:
@@ -7425,6 +7436,10 @@
 
       switch (mode)
 	{
+	case E_V1TImode:
+	  emit_move_insn (target, gen_lowpart (TImode, vec));
+	  return;
+
 	case E_V2DFmode:
 	  emit_insn (gen_vsx_extract_v2df_var (target, vec, elt));
 	  return;
@@ -7454,18 +7469,32 @@
 	}
     }
 
-  gcc_assert (CONST_INT_P (elt));
-
   /* Allocate mode-sized buffer.  */
   mem = assign_stack_temp (mode, GET_MODE_SIZE (mode));
 
   emit_move_insn (mem, vec);
+  if (CONST_INT_P (elt))
+    {
+      int modulo_elt = INTVAL (elt) % GET_MODE_NUNITS (mode);
 
-  /* Add offset to field within buffer matching vector element.  */
-  mem = adjust_address_nv (mem, inner_mode,
-			   INTVAL (elt) * GET_MODE_SIZE (inner_mode));
+      /* Add offset to field within buffer matching vector element.  */
+      mem = adjust_address_nv (mem, inner_mode,
+			       modulo_elt * GET_MODE_SIZE (inner_mode));
+      emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));
+    }
+  else
+    {
+      unsigned int ele_size = GET_MODE_SIZE (inner_mode);
+      rtx num_ele_m1 = GEN_INT (GET_MODE_NUNITS (mode) - 1);
+      rtx new_addr = gen_reg_rtx (Pmode);
 
-  emit_move_insn (target, adjust_address_nv (mem, inner_mode, 0));
+      elt = gen_rtx_AND (Pmode, elt, num_ele_m1);
+      if (ele_size > 1)
+	elt = gen_rtx_MULT (Pmode, elt, GEN_INT (ele_size));
+      new_addr = gen_rtx_PLUS (Pmode, XEXP (mem, 0), elt);
+      new_addr = change_address (mem, inner_mode, new_addr);
+      emit_move_insn (target, new_addr);
+    }
 }
 
 /* Helper function to return the register number of a RTX.  */
@@ -7646,7 +7675,7 @@
 			      rtx tmp_altivec)
 {
   machine_mode mode = GET_MODE (src);
-  machine_mode scalar_mode = GET_MODE (dest);
+  machine_mode scalar_mode = GET_MODE_INNER (GET_MODE (src));
   unsigned scalar_size = GET_MODE_SIZE (scalar_mode);
   int byte_shift = exact_log2 (scalar_size);
 
@@ -7657,6 +7686,10 @@
      systems.  */
   if (MEM_P (src))
     {
+      int num_elements = GET_MODE_NUNITS (mode);
+      rtx num_ele_m1 = GEN_INT (num_elements - 1);
+
+      emit_insn (gen_anddi3 (element, element, num_ele_m1));
       gcc_assert (REG_P (tmp_gpr));
       emit_move_insn (dest, rs6000_adjust_vec_address (dest, src, element,
 						       tmp_gpr, scalar_mode));
@@ -7665,7 +7698,9 @@
 
   else if (REG_P (src) || SUBREG_P (src))
     {
-      int bit_shift = byte_shift + 3;
+      int num_elements = GET_MODE_NUNITS (mode);
+      int bits_in_element = mode_to_bits (GET_MODE_INNER (mode));
+      int bit_shift = 7 - exact_log2 (num_elements);
       rtx element2;
       int dest_regno = regno_or_subregno (dest);
       int src_regno = regno_or_subregno (src);
@@ -7741,7 +7776,7 @@
 	{
 	  if (!VECTOR_ELT_ORDER_BIG)
 	    {
-	      rtx num_ele_m1 = GEN_INT (GET_MODE_NUNITS (mode) - 1);
+	      rtx num_ele_m1 = GEN_INT (num_elements - 1);
 
 	      emit_insn (gen_anddi3 (tmp_gpr, element, num_ele_m1));
 	      emit_insn (gen_subdi3 (tmp_gpr, num_ele_m1, tmp_gpr));
@@ -7799,8 +7834,8 @@
 	    emit_insn (gen_vsx_vslo_v2di (tmp_altivec_di, src_v2di,
 					  tmp_altivec));
 	    emit_move_insn (tmp_gpr_di, tmp_altivec_di);
-	    emit_insn (gen_ashrdi3 (tmp_gpr_di, tmp_gpr_di,
-				    GEN_INT (64 - (8 * scalar_size))));
+	    emit_insn (gen_lshrdi3 (tmp_gpr_di, tmp_gpr_di,
+				    GEN_INT (64 - bits_in_element)));
 	    return;
 	  }
 
@@ -8223,6 +8258,101 @@
   return NULL_RTX;
 }
 
+/* This tests that a lo_sum {constant, symbol, symbol+offset} is valid for
+   the mode.  If we can't find (or don't know) the alignment of the symbol
+   we assume (optimistically) that it's sufficiently aligned [??? maybe we
+   should be pessimistic].  Offsets are validated in the same way as for
+   reg + offset.  */
+static bool
+darwin_rs6000_legitimate_lo_sum_const_p (rtx x, machine_mode mode)
+{
+  if (GET_CODE (x) == CONST)
+    x = XEXP (x, 0);
+
+  if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_MACHOPIC_OFFSET)
+    x =  XVECEXP (x, 0, 0);
+
+  rtx sym = NULL_RTX;
+  unsigned HOST_WIDE_INT offset = 0;
+
+  if (GET_CODE (x) == PLUS)
+    {
+      sym = XEXP (x, 0);
+      if (! SYMBOL_REF_P (sym))
+	return false;
+      if (!CONST_INT_P (XEXP (x, 1)))
+	return false;
+      offset = INTVAL (XEXP (x, 1));
+    }
+  else if (SYMBOL_REF_P (x))
+    sym = x;
+  else if (CONST_INT_P (x))
+    offset = INTVAL (x);
+  else if (GET_CODE (x) == LABEL_REF)
+    offset = 0; // We assume code labels are Pmode aligned
+  else
+    return false; // not sure what we have here.
+
+  /* If we don't know the alignment of the thing to which the symbol refers,
+     we assume optimistically it is "enough".
+     ??? maybe we should be pessimistic instead.  */
+  unsigned align = 0;
+
+  if (sym)
+    {
+      tree decl = SYMBOL_REF_DECL (sym);
+#if TARGET_MACHO
+      if (MACHO_SYMBOL_INDIRECTION_P (sym))
+      /* The decl in an indirection symbol is the original one, which might
+	 be less aligned than the indirection.  Our indirections are always
+	 pointer-aligned.  */
+	;
+      else
+#endif
+      if (decl && DECL_ALIGN (decl))
+	align = DECL_ALIGN_UNIT (decl);
+   }
+
+  unsigned int extra = 0;
+  switch (mode)
+    {
+    case E_DFmode:
+    case E_DDmode:
+    case E_DImode:
+      /* If we are using VSX scalar loads, restrict ourselves to reg+reg
+	 addressing.  */
+      if (VECTOR_MEM_VSX_P (mode))
+	return false;
+
+      if (!TARGET_POWERPC64)
+	extra = 4;
+      else if ((offset & 3) || (align & 3))
+	return false;
+      break;
+
+    case E_TFmode:
+    case E_IFmode:
+    case E_KFmode:
+    case E_TDmode:
+    case E_TImode:
+    case E_PTImode:
+      extra = 8;
+      if (!TARGET_POWERPC64)
+	extra = 12;
+      else if ((offset & 3) || (align & 3))
+	return false;
+      break;
+
+    default:
+      break;
+    }
+
+  /* We only care if the access(es) would cause a change to the high part.  */
+  offset = ((offset & 0xffff) ^ 0x8000) - 0x8000;
+  return IN_RANGE (offset, -(HOST_WIDE_INT_1 << 15),
+                            (HOST_WIDE_INT_1 << 15) - 1 - extra);
+}
+
 /* Return true if the MEM operand is a memory operand suitable for use
    with a (full width, possibly multiple) gpr load/store.  On
    powerpc64 this means the offset must be divisible by 4.
@@ -8257,7 +8387,13 @@
       && legitimate_indirect_address_p (XEXP (addr, 0), false))
     return true;
 
-  /* Don't allow non-offsettable addresses.  See PRs 83969 and 84279.  */
+  /* We need to look through Mach-O PIC unspecs to determine if a lo_sum is
+     really OK.  Doing this early avoids teaching all the other machinery
+     about them.  */
+  if (TARGET_MACHO && GET_CODE (addr) == LO_SUM)
+    return darwin_rs6000_legitimate_lo_sum_const_p (XEXP (addr, 1), mode);
+
+  /* Only allow offsettable addresses.  See PRs 83969 and 84279.  */
   if (!rs6000_offsettable_memref_p (op, mode, false))
     return false;
 
@@ -12592,7 +12728,9 @@
       if (elt_mode == TDmode && (cum->fregno % 2) == 1)
 	cum->fregno++;
 
-      if (USE_FP_FOR_ARG_P (cum, elt_mode))
+      if (USE_FP_FOR_ARG_P (cum, elt_mode)
+	  && !(TARGET_AIX && !TARGET_ELF
+	       && type != NULL && AGGREGATE_TYPE_P (type)))
 	{
 	  rtx rvec[GP_ARG_NUM_REG + AGGR_ARG_NUM_REG + 1];
 	  rtx r, off;
@@ -12728,7 +12866,9 @@
 
   align_words = rs6000_parm_start (mode, type, cum->words);
 
-  if (USE_FP_FOR_ARG_P (cum, elt_mode))
+  if (USE_FP_FOR_ARG_P (cum, elt_mode)
+      && !(TARGET_AIX && !TARGET_ELF
+	   && type != NULL && AGGREGATE_TYPE_P (type)))
     {
       unsigned long n_fpreg = (GET_MODE_SIZE (elt_mode) + 7) >> 3;
 
@@ -15417,9 +15557,17 @@
   op0 = expand_normal (arg0);
   op1 = expand_normal (arg1);
 
-  /* Call get_element_number to validate arg1 if it is a constant.  */
   if (TREE_CODE (arg1) == INTEGER_CST)
-    (void) get_element_number (TREE_TYPE (arg0), arg1);
+    {
+      unsigned HOST_WIDE_INT elt;
+      unsigned HOST_WIDE_INT size = TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0));
+      unsigned int truncated_selector;
+      /* Even if !tree_fits_uhwi_p (arg1)), TREE_INT_CST_LOW (arg0)
+	 returns low-order bits of INTEGER_CST for modulo indexing.  */
+      elt = TREE_INT_CST_LOW (arg1);
+      truncated_selector = elt % size;
+      op1 = GEN_INT (truncated_selector);
+    }
 
   tmode = TYPE_MODE (TREE_TYPE (TREE_TYPE (arg0)));
   mode0 = TYPE_MODE (TREE_TYPE (arg0));
@@ -16765,15 +16913,6 @@
     case ALTIVEC_BUILTIN_VSPLTISH:
     case ALTIVEC_BUILTIN_VSPLTISW:
       {
-	 int size;
-
-         if (fn_code == ALTIVEC_BUILTIN_VSPLTISB)
-           size = 8;
-         else if (fn_code == ALTIVEC_BUILTIN_VSPLTISH)
-           size = 16;
-         else
-           size = 32;
-
 	 arg0 = gimple_call_arg (stmt, 0);
 	 lhs = gimple_call_lhs (stmt);
 
@@ -16780,8 +16919,7 @@
 	 /* Only fold the vec_splat_*() if the lower bits of arg 0 is a
 	    5-bit signed constant in range -16 to +15.  */
 	 if (TREE_CODE (arg0) != INTEGER_CST
-	     || !IN_RANGE (sext_hwi(TREE_INT_CST_LOW (arg0), size),
-			   -16, 15))
+	     || !IN_RANGE (TREE_INT_CST_LOW (arg0), -16, 15))
 	   return false;
 	 gimple_seq stmts = NULL;
 	 location_t loc = gimple_location (stmt);
@@ -18261,6 +18399,7 @@
     {
     /* unsigned 1 argument functions.  */
     case CRYPTO_BUILTIN_VSBOX:
+    case CRYPTO_BUILTIN_VSBOX_BE:
     case P8V_BUILTIN_VGBBD:
     case MISC_BUILTIN_CDTBCD:
     case MISC_BUILTIN_CBCDTD:
@@ -18276,9 +18415,13 @@
     case ALTIVEC_BUILTIN_VMULOUH:
     case P8V_BUILTIN_VMULOUW:
     case CRYPTO_BUILTIN_VCIPHER:
+    case CRYPTO_BUILTIN_VCIPHER_BE:
     case CRYPTO_BUILTIN_VCIPHERLAST:
+    case CRYPTO_BUILTIN_VCIPHERLAST_BE:
     case CRYPTO_BUILTIN_VNCIPHER:
+    case CRYPTO_BUILTIN_VNCIPHER_BE:
     case CRYPTO_BUILTIN_VNCIPHERLAST:
+    case CRYPTO_BUILTIN_VNCIPHERLAST_BE:
     case CRYPTO_BUILTIN_VPMSUMB:
     case CRYPTO_BUILTIN_VPMSUMH:
     case CRYPTO_BUILTIN_VPMSUMW:
@@ -21883,7 +22026,7 @@
 	{
 	  const char *name = XSTR (x, 0);
 #if TARGET_MACHO
-	  if (darwin_emit_branch_islands
+	  if (darwin_symbol_stubs
 	      && MACHOPIC_INDIRECT
 	      && machopic_classify_symbol (x) == MACHOPIC_UNDEFINED_FUNCTION)
 	    name = machopic_indirection_name (x, /*stub_p=*/true);
@@ -25996,10 +26139,14 @@
 						    stack_limit_rtx,
 						    GEN_INT (size)));
 
-	  emit_insn (gen_elf_high (tmp_reg, toload));
-	  emit_insn (gen_elf_low (tmp_reg, tmp_reg, toload));
-	  emit_insn (gen_cond_trap (LTU, stack_reg, tmp_reg,
-				    const0_rtx));
+	  /* We cannot use r0 with elf_low.  Lamely solve this problem by
+	     moving registers around.  */
+	  rtx r11_reg = gen_rtx_REG (Pmode, 11);
+	  emit_move_insn (tmp_reg, r11_reg);
+	  emit_insn (gen_elf_high (r11_reg, toload));
+	  emit_insn (gen_elf_low (r11_reg, r11_reg, toload));
+	  emit_insn (gen_cond_trap (LTU, stack_reg, r11_reg, const0_rtx));
+	  emit_move_insn (r11_reg, tmp_reg);
 	}
       else
 	warning (0, "stack limit expression is not supported");
@@ -33632,7 +33779,7 @@
 	     int cookie_operand_number)
 {
   static char buf[256];
-  if (darwin_emit_branch_islands
+  if (darwin_symbol_stubs
       && GET_CODE (operands[dest_operand_number]) == SYMBOL_REF
       && (INTVAL (operands[cookie_operand_number]) & CALL_LONG))
     {
@@ -34192,6 +34339,10 @@
 			   rs6000_xcoff_output_readwrite_section_asm_op,
 			   &xcoff_private_data_section_name);
 
+  read_only_private_data_section
+    = get_unnamed_section (0, rs6000_xcoff_output_readonly_section_asm_op,
+			   &xcoff_private_rodata_section_name);
+
   tls_data_section
     = get_unnamed_section (SECTION_TLS,
 			   rs6000_xcoff_output_tls_section_asm_op,
@@ -34202,10 +34353,6 @@
 			   rs6000_xcoff_output_tls_section_asm_op,
 			   &xcoff_private_data_section_name);
 
-  read_only_private_data_section
-    = get_unnamed_section (0, rs6000_xcoff_output_readonly_section_asm_op,
-			   &xcoff_private_data_section_name);
-
   toc_section
     = get_unnamed_section (0, rs6000_xcoff_output_toc_section_asm_op, NULL);
 
@@ -34386,6 +34533,8 @@
 			   main_input_filename, ".bss_");
   rs6000_gen_section_name (&xcoff_private_data_section_name,
 			   main_input_filename, ".rw_");
+  rs6000_gen_section_name (&xcoff_private_rodata_section_name,
+			   main_input_filename, ".rop_");
   rs6000_gen_section_name (&xcoff_read_only_section_name,
 			   main_input_filename, ".ro_");
   rs6000_gen_section_name (&xcoff_tls_data_section_name,
@@ -36605,11 +36754,21 @@
 unsigned int
 rs6000_dbx_register_number (unsigned int regno, unsigned int format)
 {
-  /* Except for the above, we use the internal number for non-DWARF
-     debug information, and also for .eh_frame.  */
+  /* We use the GCC 7 (and before) internal number for non-DWARF debug
+     information, and also for .eh_frame.  */
   if ((format == 0 && write_symbols != DWARF2_DEBUG) || format == 2)
-    return regno;
+    {
+      /* Translate the regnos to their numbers in GCC 7 (and before).  */
+      if (regno == TFHAR_REGNO)
+	regno = 114;
+      else if (regno == TFIAR_REGNO)
+	regno = 115;
+      else if (regno == TEXASR_REGNO)
+	regno = 116;
 
+      return regno;
+    }
+
   /* On some platforms, we use the standard DWARF register
      numbering for .debug_info and .debug_frame.  */
 #ifdef RS6000_USE_DWARF_NUMBERING
@@ -36635,6 +36794,12 @@
     return 356;
   if (regno == VSCR_REGNO)
     return 67;
+  if (regno == TFHAR_REGNO)
+    return 228;
+  if (regno == TFIAR_REGNO)
+    return 229;
+  if (regno == TEXASR_REGNO)
+    return 230;
 #endif
   return regno;
 }
@@ -37840,6 +38005,7 @@
 
   /* Build result decl and add to function_decl.  */
   tree t = build_decl (UNKNOWN_LOCATION, RESULT_DECL, NULL_TREE, ptr_type_node);
+  DECL_CONTEXT (t) = decl;
   DECL_ARTIFICIAL (t) = 1;
   DECL_IGNORED_P (t) = 1;
   DECL_RESULT (decl) = t;
@@ -38061,25 +38227,31 @@
   tree caller_tree = DECL_FUNCTION_SPECIFIC_TARGET (caller);
   tree callee_tree = DECL_FUNCTION_SPECIFIC_TARGET (callee);
 
-  /* If callee has no option attributes, then it is ok to inline.  */
+  /* If the callee has no option attributes, then it is ok to inline.  */
   if (!callee_tree)
     ret = true;
 
-  /* If caller has no option attributes, but callee does then it is not ok to
-     inline.  */
-  else if (!caller_tree)
-    ret = false;
-
   else
     {
-      struct cl_target_option *caller_opts = TREE_TARGET_OPTION (caller_tree);
+      HOST_WIDE_INT caller_isa;
       struct cl_target_option *callee_opts = TREE_TARGET_OPTION (callee_tree);
+      HOST_WIDE_INT callee_isa = callee_opts->x_rs6000_isa_flags;
+      HOST_WIDE_INT explicit_isa = callee_opts->x_rs6000_isa_flags_explicit;
 
-      /* Callee's options should a subset of the caller's, i.e. a vsx function
-	 can inline an altivec function but a non-vsx function can't inline a
-	 vsx function.  */
-      if ((caller_opts->x_rs6000_isa_flags & callee_opts->x_rs6000_isa_flags)
-	  == callee_opts->x_rs6000_isa_flags)
+      /* If the caller has option attributes, then use them.
+	 Otherwise, use the command line options.  */
+      if (caller_tree)
+	caller_isa = TREE_TARGET_OPTION (caller_tree)->x_rs6000_isa_flags;
+      else
+	caller_isa = rs6000_isa_flags;
+
+      /* The callee's options must be a subset of the caller's options, i.e.
+	 a vsx function may inline an altivec function, but a no-vsx function
+	 must not inline a vsx function.  However, for those options that the
+	 callee has explicitly enabled or disabled, then we must enforce that
+	 the callee's and caller's options match exactly; see PR70010.  */
+      if (((caller_isa & callee_isa) == callee_isa)
+	  && (caller_isa & explicit_isa) == (callee_isa & explicit_isa))
 	ret = true;
     }
 
Index: gcc/config/rs6000/vsx.md
===================================================================
diff --git a/gcc/config/rs6000/vsx.md b/gcc/config/rs6000/vsx.md
--- a/gcc/config/rs6000/vsx.md	(revision 278653)
+++ b/gcc/config/rs6000/vsx.md	(revision 278653)
@@ -3756,9 +3756,9 @@
   DONE;
 })
 
-(define_insn_and_split "*vsx_extract_<VSX_EXTRACT_I:mode>_<SDI:mode>_var"
-  [(set (match_operand:SDI 0 "gpc_reg_operand" "=r,r,r")
-	(zero_extend:SDI
+(define_insn_and_split "*vsx_extract_<mode>_<VS_scalar>mode_var"
+  [(set (match_operand:<VS_scalar> 0 "gpc_reg_operand" "=r,r,r")
+	(zero_extend:<VS_scalar>
 	 (unspec:<VSX_EXTRACT_I:VS_scalar>
 	  [(match_operand:VSX_EXTRACT_I 1 "input_operand" "wK,v,m")
 	   (match_operand:DI 2 "gpc_reg_operand" "r,r,r")]
@@ -3770,7 +3770,7 @@
   "&& reload_completed"
   [(const_int 0)]
 {
-  machine_mode smode = <VSX_EXTRACT_I:MODE>mode;
+  machine_mode smode = <VS_scalar>mode;
   rs6000_split_vec_extract_var (gen_rtx_REG (smode, REGNO (operands[0])),
 				operands[1], operands[2],
 				operands[3], operands[4]);
Index: gcc/config/rs6000/altivec.md
===================================================================
diff --git a/gcc/config/rs6000/altivec.md b/gcc/config/rs6000/altivec.md
--- a/gcc/config/rs6000/altivec.md	(revision 278653)
+++ b/gcc/config/rs6000/altivec.md	(revision 278653)
@@ -80,9 +80,6 @@
    UNSPEC_VUPKHPX
    UNSPEC_VUPKLPX
    UNSPEC_CONVERT_4F32_8I16
-   UNSPEC_DARN
-   UNSPEC_DARN_32
-   UNSPEC_DARN_RAW
    UNSPEC_DST
    UNSPEC_DSTT
    UNSPEC_DSTST
@@ -161,9 +158,6 @@
    UNSPEC_BCDADD
    UNSPEC_BCDSUB
    UNSPEC_BCD_OVERFLOW
-   UNSPEC_CMPRB
-   UNSPEC_CMPRB2
-   UNSPEC_CMPEQB
    UNSPEC_VRLMI
    UNSPEC_VRLNM
 ])
@@ -581,7 +575,7 @@
   [(set_attr "type" "vecsimple")])
 
 ;;
-(define_insn "altivec_vavgu<VI_char>"
+(define_insn "uavg<mode>3_ceil"
   [(set (match_operand:VI 0 "register_operand" "=v")
         (unspec:VI [(match_operand:VI 1 "register_operand" "v")
                     (match_operand:VI 2 "register_operand" "v")]
@@ -590,7 +584,7 @@
   "vavgu<VI_char> %0,%1,%2"
   [(set_attr "type" "vecsimple")])
 
-(define_insn "altivec_vavgs<VI_char>"
+(define_insn "avg<mode>3_ceil"
   [(set (match_operand:VI 0 "register_operand" "=v")
         (unspec:VI [(match_operand:VI 1 "register_operand" "v")
                     (match_operand:VI 2 "register_operand" "v")]
@@ -4317,223 +4311,6 @@
   [(set_attr "length" "4")
    (set_attr "type" "vecsimple")])
 
-(define_insn "darn_32"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-        (unspec:SI [(const_int 0)] UNSPEC_DARN_32))]
-  "TARGET_P9_MISC"
-  "darn %0,0"
-  [(set_attr "type" "integer")])
-
-(define_insn "darn_raw"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-        (unspec:DI [(const_int 0)] UNSPEC_DARN_RAW))]
-  "TARGET_P9_MISC && TARGET_64BIT"
-  "darn %0,2"
-  [(set_attr "type" "integer")])
-
-(define_insn "darn"
-  [(set (match_operand:DI 0 "register_operand" "=r")
-        (unspec:DI [(const_int 0)] UNSPEC_DARN))]
-  "TARGET_P9_MISC && TARGET_64BIT"
-  "darn %0,1"
-  [(set_attr "type" "integer")])
-
-;; Test byte within range.
-;;
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the range specified by operand 2.
-;; The bytes of operand 2 are organized as xx:xx:hi:lo.
-;;
-;; Return in target register operand 0 a value of 1 if lo <= vv and
-;; vv <= hi.  Otherwise, set register operand 0 to 0.
-;;
-;; Though the instructions to which this expansion maps operate on
-;; 64-bit registers, the current implementation only operates on
-;; SI-mode operands as the high-order bits provide no information
-;; that is not already available in the low-order bits.  To avoid the
-;; costs of data widening operations, future enhancements might allow
-;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
-(define_expand "cmprb"
-  [(set (match_dup 3)
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:SI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPRB))
-   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	(if_then_else:SI (lt (match_dup 3)
-			     (const_int 0))
-			 (const_int -1)
-			 (if_then_else (gt (match_dup 3)
-					   (const_int 0))
-				       (const_int 1)
-				       (const_int 0))))]
-  "TARGET_P9_MISC"
-{
-  operands[3] = gen_reg_rtx (CCmode);
-})
-
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the range specified by operand 2.
-;; The bytes of operand 2 are organized as xx:xx:hi:lo.
-;;
-;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if
-;; lo <= vv and vv <= hi.  Otherwise, set the GT bit to 0.  The other
-;; 3 bits of the target CR register are all set to 0.
-(define_insn "*cmprb_internal"
-  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:SI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPRB))]
-  "TARGET_P9_MISC"
-  "cmprb %0,0,%1,%2"
-  [(set_attr "type" "logical")])
-
-;; Set operand 0 register to -1 if the LT bit (0x8) of condition
-;; register operand 1 is on.  Otherwise, set operand 0 register to 1
-;; if the GT bit (0x4) of condition register operand 1 is on.
-;; Otherwise, set operand 0 to 0.  Note that the result stored into
-;; register operand 0 is non-zero iff either the LT or GT bits are on
-;; within condition register operand 1.
-(define_insn "setb_signed"
-   [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	 (if_then_else:SI (lt (match_operand:CC 1 "cc_reg_operand" "y")
-			      (const_int 0))
-			  (const_int -1)
-			  (if_then_else (gt (match_dup 1)
-					    (const_int 0))
-					(const_int 1)
-					(const_int 0))))]
-  "TARGET_P9_MISC"
-  "setb %0,%1"
-  [(set_attr "type" "logical")])
-
-(define_insn "setb_unsigned"
-   [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	 (if_then_else:SI (ltu (match_operand:CCUNS 1 "cc_reg_operand" "y")
-			      (const_int 0))
-			  (const_int -1)
-			  (if_then_else (gtu (match_dup 1)
-					    (const_int 0))
-					(const_int 1)
-					(const_int 0))))]
-  "TARGET_P9_MISC"
-  "setb %0,%1"
-  [(set_attr "type" "logical")])
-
-;; Test byte within two ranges.
-;;
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the range specified by operand 2.
-;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.
-;;
-;; Return in target register operand 0 a value of 1 if (lo_1 <= vv and
-;; vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).  Otherwise, set register
-;; operand 0 to 0.
-;;
-;; Though the instructions to which this expansion maps operate on
-;; 64-bit registers, the current implementation only operates on
-;; SI-mode operands as the high-order bits provide no information
-;; that is not already available in the low-order bits.  To avoid the
-;; costs of data widening operations, future enhancements might allow
-;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
-(define_expand "cmprb2"
-  [(set (match_dup 3)
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:SI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPRB2))
-   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	(if_then_else:SI (lt (match_dup 3)
-			     (const_int 0))
-			 (const_int -1)
-			 (if_then_else (gt (match_dup 3)
-					   (const_int 0))
-				       (const_int 1)
-				       (const_int 0))))]
-  "TARGET_P9_MISC"
-{
-  operands[3] = gen_reg_rtx (CCmode);
-})
-
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the ranges specified by operand 2.
-;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.
-;;
-;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if
-;; (lo_1 <= vv and vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).
-;; Otherwise, set the GT bit to 0.  The other 3 bits of the target
-;; CR register are all set to 0.
-(define_insn "*cmprb2_internal"
-  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:SI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPRB2))]
-  "TARGET_P9_MISC"
-  "cmprb %0,1,%1,%2"
-  [(set_attr "type" "logical")])
-
-;; Test byte membership within set of 8 bytes.
-;;
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the set specified by operand 2.
-;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.
-;;
-;; Return in target register operand 0 a value of 1 if vv equals one
-;; of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise, set
-;; register operand 0 to 0.  Note that the 8 byte values held within
-;; operand 2 need not be unique.
-;;
-;; Though the instructions to which this expansion maps operate on
-;; 64-bit registers, the current implementation requires that operands
-;; 0 and 1 have mode SI as the high-order bits provide no information
-;; that is not already available in the low-order bits.  To avoid the
-;; costs of data widening operations, future enhancements might allow
-;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
-(define_expand "cmpeqb"
-  [(set (match_dup 3)
-	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		    (match_operand:DI 2 "gpc_reg_operand" "r")]
-	 UNSPEC_CMPEQB))
-   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
-	(if_then_else:SI (lt (match_dup 3)
-			     (const_int 0))
-			 (const_int -1)
-			 (if_then_else (gt (match_dup 3)
-					   (const_int 0))
-				       (const_int 1)
-				       (const_int 0))))]
-  "TARGET_P9_MISC && TARGET_64BIT"
-{
-  operands[3] = gen_reg_rtx (CCmode);
-})
-
-;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
-;; represents a byte whose value is ignored in this context and
-;; vv, the least significant byte, holds the byte value that is to
-;; be tested for membership within the set specified by operand 2.
-;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.
-;;
-;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if vv
-;; equals one of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise,
-;; set the GT bit to zero.  The other 3 bits of the target CR register
-;; are all set to 0.
-(define_insn "*cmpeqb_internal"
-  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
-	 (unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
-		     (match_operand:DI 2 "gpc_reg_operand" "r")]
-	  UNSPEC_CMPEQB))]
-  "TARGET_P9_MISC && TARGET_64BIT"
-  "cmpeqb %0,%1,%2"
-  [(set_attr "type" "logical")])
-
 (define_expand "bcd<bcd_add_sub>_<code>"
   [(parallel [(set (reg:CCFP CR6_REGNO)
 		   (compare:CCFP
Index: gcc/config/rs6000/crypto.md
===================================================================
diff --git a/gcc/config/rs6000/crypto.md b/gcc/config/rs6000/crypto.md
--- a/gcc/config/rs6000/crypto.md	(revision 278653)
+++ b/gcc/config/rs6000/crypto.md	(revision 278653)
@@ -48,6 +48,9 @@
 ;; Iterator for VSHASIGMAD/VSHASIGMAW
 (define_mode_iterator CR_hash [V4SI V2DI])
 
+;; Iterator for VSBOX/VCIPHER/VNCIPHER/VCIPHERLAST/VNCIPHERLAST
+(define_mode_iterator CR_vqdi [V16QI V2DI])
+
 ;; Iterator for the other crypto functions
 (define_int_iterator CR_code   [UNSPEC_VCIPHER
 				UNSPEC_VNCIPHER
@@ -60,10 +63,10 @@
 			  (UNSPEC_VNCIPHERLAST "vncipherlast")])
 
 ;; 2 operand crypto instructions
-(define_insn "crypto_<CR_insn>"
-  [(set (match_operand:V2DI 0 "register_operand" "=v")
-	(unspec:V2DI [(match_operand:V2DI 1 "register_operand" "v")
-		      (match_operand:V2DI 2 "register_operand" "v")]
+(define_insn "crypto_<CR_insn>_<mode>"
+  [(set (match_operand:CR_vqdi 0 "register_operand" "=v")
+	(unspec:CR_vqdi [(match_operand:CR_vqdi 1 "register_operand" "v")
+		      (match_operand:CR_vqdi 2 "register_operand" "v")]
 		     CR_code))]
   "TARGET_CRYPTO"
   "<CR_insn> %0,%1,%2"
@@ -90,9 +93,9 @@
   [(set_attr "type" "vecperm")])
 
 ;; 1 operand crypto instruction
-(define_insn "crypto_vsbox"
-  [(set (match_operand:V2DI 0 "register_operand" "=v")
-	(unspec:V2DI [(match_operand:V2DI 1 "register_operand" "v")]
+(define_insn "crypto_vsbox_<mode>"
+  [(set (match_operand:CR_vqdi 0 "register_operand" "=v")
+	(unspec:CR_vqdi [(match_operand:CR_vqdi 1 "register_operand" "v")]
 		     UNSPEC_VSBOX))]
   "TARGET_CRYPTO"
   "vsbox %0,%1"
Index: gcc/config/rs6000/rs6000.md
===================================================================
diff --git a/gcc/config/rs6000/rs6000.md b/gcc/config/rs6000/rs6000.md
--- a/gcc/config/rs6000/rs6000.md	(revision 278653)
+++ b/gcc/config/rs6000/rs6000.md	(revision 278653)
@@ -136,6 +136,9 @@
    UNSPEC_LSQ
    UNSPEC_FUSION_GPR
    UNSPEC_STACK_CHECK
+   UNSPEC_CMPRB
+   UNSPEC_CMPRB2
+   UNSPEC_CMPEQB
    UNSPEC_FUSION_P9
    UNSPEC_FUSION_ADDIS
    UNSPEC_ADD_ROUND_TO_ODD
@@ -162,6 +165,9 @@
    UNSPECV_EH_RR		; eh_reg_restore
    UNSPECV_ISYNC		; isync instruction
    UNSPECV_MFTB			; move from time base
+   UNSPECV_DARN			; darn 1 (deliver a random number)
+   UNSPECV_DARN_32		; darn 2
+   UNSPECV_DARN_RAW		; darn 0
    UNSPECV_NLGR			; non-local goto receiver
    UNSPECV_MFFS			; Move from FPSCR
    UNSPECV_MTFSF		; Move to FPSCR Fields
@@ -6692,14 +6698,6 @@
 ;; do the load 16-bits at a time.  We could do this by loading from memory,
 ;; and this is even supposed to be faster, but it is simpler not to get
 ;; integers in the TOC.
-(define_insn "movsi_low"
-  [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
-        (mem:SI (lo_sum:SI (match_operand:SI 1 "gpc_reg_operand" "b")
-                           (match_operand 2 "" ""))))]
-  "TARGET_MACHO && ! TARGET_64BIT"
-  "lwz %0,lo16(%2)(%1)"
-  [(set_attr "type" "load")
-   (set_attr "length" "4")])
 
 ;;		MR           LA           LWZ          LFIWZX       LXSIWZX
 ;;		STW          STFIWX       STXSIWX      LI           LIS
@@ -12594,15 +12592,18 @@
   [(unspec [(const_int 0)] UNSPEC_GRP_END_NOP)]
   ""
 {
-  if (rs6000_tune == PROCESSOR_POWER6)
-    return "ori 1,1,0";
-  return "ori 2,2,0";
+  operands[0] = gen_rtx_REG (Pmode,
+			     rs6000_tune == PROCESSOR_POWER6 ? 1 : 2);
+  return "ori %0,%0,0";
 })
 
 (define_insn "rs6000_speculation_barrier"
   [(unspec_volatile:BLK [(const_int 0)] UNSPECV_SPEC_BARRIER)]
   ""
-  "ori 31,31,0")
+{
+  operands[0] = gen_rtx_REG (Pmode, 31);
+  return "ori %0,%0,0";
+})
 
 ;; Define the subtract-one-and-jump insns, starting with the template
 ;; so loop.c knows what to generate.
@@ -12699,7 +12700,7 @@
 				const0_rtx);
   emit_insn (gen_rtx_SET (operands[3],
 			  gen_rtx_COMPARE (CCmode, operands[1], const1_rtx)));
-  if (gpc_reg_operand (operands[0], <MODE>mode))
+  if (int_reg_operand (operands[0], <MODE>mode))
     emit_insn (gen_add<mode>3 (operands[0], operands[1], constm1_rtx));
   else
     {
@@ -12768,7 +12769,7 @@
 		       (const_int 0)]))
 	  (match_operand 4)
 	  (match_operand 5)))
-   (set (match_operand:P 6 "int_reg_operand")
+   (set (match_operand:P 6 "nonimmediate_operand")
 	(plus:P (match_dup 0)
 		(const_int -1)))
    (clobber (match_scratch:P 7))
@@ -12801,7 +12802,7 @@
   else
      emit_insn (gen_cceq_ior_compare_complement (operands[9], andexpr, ctrcmpcc,
 						 operands[8], cccmp, ccin));
-  if (gpc_reg_operand (operands[0], <MODE>mode))
+  if (int_reg_operand (ctrout, <MODE>mode))
      emit_insn (gen_add<mode>3 (ctrout, ctr, constm1_rtx));
   else
     {
@@ -14597,7 +14598,225 @@
    "xscmpuqp %0,%1,%2"
   [(set_attr "type" "veccmp")
    (set_attr "size" "128")])
+
+;; Miscellaneous ISA 3.0 (power9) instructions
 
+(define_insn "darn_32"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+        (unspec_volatile:SI [(const_int 0)] UNSPECV_DARN_32))]
+  "TARGET_P9_MISC"
+  "darn %0,0"
+  [(set_attr "type" "integer")])
+
+(define_insn "darn_raw"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+        (unspec_volatile:DI [(const_int 0)] UNSPECV_DARN_RAW))]
+  "TARGET_P9_MISC && TARGET_64BIT"
+  "darn %0,2"
+  [(set_attr "type" "integer")])
+
+(define_insn "darn"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+        (unspec_volatile:DI [(const_int 0)] UNSPECV_DARN))]
+  "TARGET_P9_MISC && TARGET_64BIT"
+  "darn %0,1"
+  [(set_attr "type" "integer")])
+
+;; Test byte within range.
+;;
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the range specified by operand 2.
+;; The bytes of operand 2 are organized as xx:xx:hi:lo.
+;;
+;; Return in target register operand 0 a value of 1 if lo <= vv and
+;; vv <= hi.  Otherwise, set register operand 0 to 0.
+;;
+;; Though the instructions to which this expansion maps operate on
+;; 64-bit registers, the current implementation only operates on
+;; SI-mode operands as the high-order bits provide no information
+;; that is not already available in the low-order bits.  To avoid the
+;; costs of data widening operations, future enhancements might allow
+;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
+(define_expand "cmprb"
+  [(set (match_dup 3)
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:SI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPRB))
+   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	(if_then_else:SI (lt (match_dup 3)
+			     (const_int 0))
+			 (const_int -1)
+			 (if_then_else (gt (match_dup 3)
+					   (const_int 0))
+				       (const_int 1)
+				       (const_int 0))))]
+  "TARGET_P9_MISC"
+{
+  operands[3] = gen_reg_rtx (CCmode);
+})
+
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the range specified by operand 2.
+;; The bytes of operand 2 are organized as xx:xx:hi:lo.
+;;
+;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if
+;; lo <= vv and vv <= hi.  Otherwise, set the GT bit to 0.  The other
+;; 3 bits of the target CR register are all set to 0.
+(define_insn "*cmprb_internal"
+  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:SI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPRB))]
+  "TARGET_P9_MISC"
+  "cmprb %0,0,%1,%2"
+  [(set_attr "type" "logical")])
+
+;; Set operand 0 register to -1 if the LT bit (0x8) of condition
+;; register operand 1 is on.  Otherwise, set operand 0 register to 1
+;; if the GT bit (0x4) of condition register operand 1 is on.
+;; Otherwise, set operand 0 to 0.  Note that the result stored into
+;; register operand 0 is non-zero iff either the LT or GT bits are on
+;; within condition register operand 1.
+(define_insn "setb_signed"
+   [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	 (if_then_else:SI (lt (match_operand:CC 1 "cc_reg_operand" "y")
+			      (const_int 0))
+			  (const_int -1)
+			  (if_then_else (gt (match_dup 1)
+					    (const_int 0))
+					(const_int 1)
+					(const_int 0))))]
+  "TARGET_P9_MISC"
+  "setb %0,%1"
+  [(set_attr "type" "logical")])
+
+(define_insn "setb_unsigned"
+   [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	 (if_then_else:SI (ltu (match_operand:CCUNS 1 "cc_reg_operand" "y")
+			      (const_int 0))
+			  (const_int -1)
+			  (if_then_else (gtu (match_dup 1)
+					    (const_int 0))
+					(const_int 1)
+					(const_int 0))))]
+  "TARGET_P9_MISC"
+  "setb %0,%1"
+  [(set_attr "type" "logical")])
+
+;; Test byte within two ranges.
+;;
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the range specified by operand 2.
+;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.
+;;
+;; Return in target register operand 0 a value of 1 if (lo_1 <= vv and
+;; vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).  Otherwise, set register
+;; operand 0 to 0.
+;;
+;; Though the instructions to which this expansion maps operate on
+;; 64-bit registers, the current implementation only operates on
+;; SI-mode operands as the high-order bits provide no information
+;; that is not already available in the low-order bits.  To avoid the
+;; costs of data widening operations, future enhancements might allow
+;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
+(define_expand "cmprb2"
+  [(set (match_dup 3)
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:SI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPRB2))
+   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	(if_then_else:SI (lt (match_dup 3)
+			     (const_int 0))
+			 (const_int -1)
+			 (if_then_else (gt (match_dup 3)
+					   (const_int 0))
+				       (const_int 1)
+				       (const_int 0))))]
+  "TARGET_P9_MISC"
+{
+  operands[3] = gen_reg_rtx (CCmode);
+})
+
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the ranges specified by operand 2.
+;; The bytes of operand 2 are organized as hi_1:lo_1:hi_2:lo_2.
+;;
+;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if
+;; (lo_1 <= vv and vv <= hi_1) or if (lo_2 <= vv and vv <= hi_2).
+;; Otherwise, set the GT bit to 0.  The other 3 bits of the target
+;; CR register are all set to 0.
+(define_insn "*cmprb2_internal"
+  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:SI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPRB2))]
+  "TARGET_P9_MISC"
+  "cmprb %0,1,%1,%2"
+  [(set_attr "type" "logical")])
+
+;; Test byte membership within set of 8 bytes.
+;;
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the set specified by operand 2.
+;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.
+;;
+;; Return in target register operand 0 a value of 1 if vv equals one
+;; of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise, set
+;; register operand 0 to 0.  Note that the 8 byte values held within
+;; operand 2 need not be unique.
+;;
+;; Though the instructions to which this expansion maps operate on
+;; 64-bit registers, the current implementation requires that operands
+;; 0 and 1 have mode SI as the high-order bits provide no information
+;; that is not already available in the low-order bits.  To avoid the
+;; costs of data widening operations, future enhancements might allow
+;; DI mode for operand 0 and/or might allow operand 1 to be QI mode.
+(define_expand "cmpeqb"
+  [(set (match_dup 3)
+	(unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		    (match_operand:DI 2 "gpc_reg_operand" "r")]
+	 UNSPEC_CMPEQB))
+   (set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	(if_then_else:SI (lt (match_dup 3)
+			     (const_int 0))
+			 (const_int -1)
+			 (if_then_else (gt (match_dup 3)
+					   (const_int 0))
+				       (const_int 1)
+				       (const_int 0))))]
+  "TARGET_P9_MISC && TARGET_64BIT"
+{
+  operands[3] = gen_reg_rtx (CCmode);
+})
+
+;; The bytes of operand 1 are organized as xx:xx:xx:vv, where xx
+;; represents a byte whose value is ignored in this context and
+;; vv, the least significant byte, holds the byte value that is to
+;; be tested for membership within the set specified by operand 2.
+;; The bytes of operand 2 are organized as e0:e1:e2:e3:e4:e5:e6:e7.
+;;
+;; Set bit 1 (the GT bit, 0x4) of CR register operand 0 to 1 if vv
+;; equals one of the values e0, e1, e2, e3, e4, e5, e6, or e7.  Otherwise,
+;; set the GT bit to zero.  The other 3 bits of the target CR register
+;; are all set to 0.
+(define_insn "*cmpeqb_internal"
+  [(set (match_operand:CC 0 "cc_reg_operand" "=y")
+	 (unspec:CC [(match_operand:SI 1 "gpc_reg_operand" "r")
+		     (match_operand:DI 2 "gpc_reg_operand" "r")]
+	  UNSPEC_CMPEQB))]
+  "TARGET_P9_MISC && TARGET_64BIT"
+  "cmpeqb %0,%1,%2"
+  [(set_attr "type" "logical")])
 
 
 (include "sync.md")
Index: gcc/config/rs6000/altivec.h
===================================================================
diff --git a/gcc/config/rs6000/altivec.h b/gcc/config/rs6000/altivec.h
--- a/gcc/config/rs6000/altivec.h	(revision 278653)
+++ b/gcc/config/rs6000/altivec.h	(revision 278653)
@@ -418,6 +418,11 @@
 #define vec_vupkhsw __builtin_vec_vupkhsw
 #define vec_vupklsw __builtin_vec_vupklsw
 #define vec_revb __builtin_vec_revb
+#define vec_sbox_be __builtin_crypto_vsbox_be
+#define vec_cipher_be __builtin_crypto_vcipher_be
+#define vec_cipherlast_be __builtin_crypto_vcipherlast_be
+#define vec_ncipher_be __builtin_crypto_vncipher_be
+#define vec_ncipherlast_be __builtin_crypto_vncipherlast_be
 #endif
 
 #ifdef __POWER9_VECTOR__
Index: gcc/config/darwin.c
===================================================================
diff --git a/gcc/config/darwin.c b/gcc/config/darwin.c
--- a/gcc/config/darwin.c	(revision 278653)
+++ b/gcc/config/darwin.c	(revision 278653)
@@ -74,15 +74,9 @@
    setting the second word in the .non_lazy_symbol_pointer data
    structure to symbol.  See indirect_data for the code that handles
    the extra indirection, and machopic_output_indirection and its use
-   of MACHO_SYMBOL_STATIC for the code that handles @code{static}
+   of MACHO_SYMBOL_FLAG_STATIC for the code that handles @code{static}
    symbol indirection.  */
 
-/* For darwin >= 9  (OSX 10.5) the linker is capable of making the necessary
-   branch islands and we no longer need to emit darwin stubs.
-   However, if we are generating code for earlier systems (or for use in the 
-   kernel) the stubs might still be required, and this will be set true.  */
-int darwin_emit_branch_islands = false;
-
 typedef struct GTY(()) cdtor_record {
   rtx symbol;
   int priority;		/* [con/de]structor priority */
@@ -104,6 +98,10 @@
    for weak or single-definition items.  */
 static bool ld_uses_coal_sects = false;
 
+/* Very old (ld_classic) linkers need a symbol to mark the start of
+   each FDE.  */
+static bool ld_needs_eh_markers = false;
+
 /* Section names.  */
 section * darwin_sections[NUM_DARWIN_SECTIONS];
 
@@ -249,7 +247,7 @@
 int
 machopic_symbol_defined_p (rtx sym_ref)
 {
-  if (SYMBOL_REF_FLAGS (sym_ref) & MACHO_SYMBOL_FLAG_DEFINED)
+  if (MACHO_SYMBOL_DEFINED_P (sym_ref))
     return true;
 
   /* If a symbol references local and is not an extern to this
@@ -258,7 +256,7 @@
     {
       /* If the symbol references a variable and the variable is a
 	 common symbol, then this symbol is not defined.  */
-      if (SYMBOL_REF_FLAGS (sym_ref) & MACHO_SYMBOL_FLAG_VARIABLE)
+      if (MACHO_SYMBOL_VARIABLE_P (sym_ref))
 	{
 	  tree decl = SYMBOL_REF_DECL (sym_ref);
 	  if (!decl)
@@ -454,6 +452,13 @@
   bool stub_p;
   /* True iff this stub or pointer has been referenced.  */
   bool used;
+  /* True iff a non-lazy symbol pointer should be emitted into the .data
+     section, rather than the non-lazy symbol pointers section.  The cases
+     for which this occurred seem to have been unintentional, and later
+     toolchains emit all of the indirections to the 'usual' section.  We
+     are keeping this in case it is necessary to preserve compatibility with
+     older toolchains.  */
+  bool nlsp_in_data_section;
 } machopic_indirection;
 
 struct indirection_hasher : ggc_ptr_hash<machopic_indirection>
@@ -488,7 +493,7 @@
 /* Return the name of the non-lazy pointer (if STUB_P is false) or
    stub (if STUB_B is true) corresponding to the given name.
 
-  If we have a situation like:
+  PR71767 - If we have a situation like:
 
 global_weak_symbol:
   ....
@@ -497,36 +502,22 @@
 
   ld64 will be unable to split this into two atoms (because the "L" makes
   the second symbol 'invisible').  This means that legitimate direct accesses
-  to the second symbol will appear to be non-allowed direct accesses to an
-  atom of type weak, global which are not allowed.
+  to the second symbol will appear to be direct accesses to an atom of type
+  weak, global which are not allowed.
 
-  To avoid this, we make the indirections have a leading 'l' (lower-case L)
-  which has a special meaning: linker can see this and use it to determine
-  atoms, but it is not placed into the final symbol table.
+  To avoid this, we make any data-section indirections have a leading 'l'
+  (lower-case L) which has a special meaning: linker can see this and use
+  it to determine  atoms, but it is not placed into the final symbol table.
 
-  The implementation here is somewhat heavy-handed in that it will also mark
-  indirections to the __IMPORT,__pointers section the same way which is
-  really unnecessary, since ld64 _can_ split those into atoms as they are
-  fixed size.  FIXME: determine if this is a penalty worth extra code to
-  fix.
-
+  Symbols in the non-lazy symbol pointers section (or stubs) do not have this
+  problem because ld64 already knows the size of each entry.
 */
 
 const char *
 machopic_indirection_name (rtx sym_ref, bool stub_p)
 {
-  char *buffer;
   const char *name = XSTR (sym_ref, 0);
-  size_t namelen = strlen (name);
-  machopic_indirection *p;
-  bool needs_quotes;
-  const char *suffix;
-  char L_or_l = 'L';
-  const char *prefix = user_label_prefix;
-  const char *quote = "";
-  tree id;
-
-  id = maybe_get_identifier (name);
+  tree id = maybe_get_identifier (name);
   if (id)
     {
       tree id_orig = id;
@@ -534,43 +525,47 @@
       while (IDENTIFIER_TRANSPARENT_ALIAS (id))
 	id = TREE_CHAIN (id);
       if (id != id_orig)
-	{
-	  name = IDENTIFIER_POINTER (id);
-	  namelen = strlen (name);
-	}
+	name = IDENTIFIER_POINTER (id);
     }
 
+  const char *prefix = user_label_prefix;
+  /* If we are emitting the label 'verbatim' then omit the U_L_P and count
+     the name without the leading '*'.  */
   if (name[0] == '*')
     {
       prefix = "";
       ++name;
-      --namelen;
     }
 
-  needs_quotes = name_needs_quotes (name);
-  if (needs_quotes)
-    {
-      quote = "\"";
-    }
+  /* Here we are undoing a number of causes that placed some indirections
+     (apparently erroneously) into the .data section.  Specifically, some
+     symbols that are ABI mandated indirections and some hidden symbols
+     were being placed there - which cause difficulties with later
+     versions of ld64.  Iff (after these checks) some symbol still gets an
+     indirection in the data section, we want to adjust the indirection
+     name to be linker visible to deal with PR71767 (notes above).  */
+  bool nlsp_in_data_section =
+       ! MACHO_SYMBOL_MUST_INDIRECT_P (sym_ref)
+    && ! MACHO_SYMBOL_HIDDEN_VIS_P (sym_ref)
+    && (machopic_symbol_defined_p (sym_ref) || SYMBOL_REF_LOCAL_P (sym_ref))
+    && ! indirect_data (sym_ref);
 
-  if (stub_p)
-    suffix = STUB_SUFFIX;
-  else
-    {
-      suffix = NON_LAZY_POINTER_SUFFIX;
-      /* Let the linker see this.  */
-      L_or_l = 'l';
-    }
+  const char *suffix = stub_p ? STUB_SUFFIX : NON_LAZY_POINTER_SUFFIX;
+  /* If the indirection is in the data section, let the linker see it.  */
+  char L_or_l = (!stub_p && nlsp_in_data_section) ? 'l' : 'L';
+  /* We have mangled symbols with spaces and punctuation which typically
+     need surrounding in quotes for the assembler to consume them.  */
+  const char *quote = name_needs_quotes (name) ? "\"" : "";
+  char *buffer = XALLOCAVEC (char, 2  /* strlen ("&L") or ("&l") */
+			     + strlen (prefix)
+			     + strlen (name)
+			     + strlen (suffix)
+			     + 2 * strlen (quote)
+			     + 1 /* '\0' */);
 
-  buffer = XALLOCAVEC (char, 2  /* strlen ("&L") or ("&l") */
-		   + strlen (prefix)
-		   + namelen
-		   + strlen (suffix)
-		   + 2 * strlen (quote)
-		   + 1 /* '\0' */);
-
   /* Construct the name of the non-lazy pointer or stub.  */
-  sprintf (buffer, "&%s%c%s%s%s%s", quote, L_or_l, prefix, name, suffix, quote);
+  sprintf (buffer, "&%s%c%s%s%s%s", quote, L_or_l, prefix, name,
+	   suffix, quote);
 
   if (!machopic_indirections)
     machopic_indirections = hash_table<indirection_hasher>::create_ggc (37);
@@ -579,10 +574,9 @@
     = machopic_indirections->find_slot_with_hash (buffer,
 						  htab_hash_string (buffer),
 						  INSERT);
+  machopic_indirection *p;
   if (*slot)
-    {
-      p = *slot;
-    }
+    p = *slot;
   else
     {
       p = ggc_alloc<machopic_indirection> ();
@@ -590,6 +584,7 @@
       p->ptr_name = xstrdup (buffer);
       p->stub_p = stub_p;
       p->used = false;
+      p->nlsp_in_data_section = nlsp_in_data_section;
       *slot = p;
     }
 
@@ -665,7 +660,7 @@
 	   /* some other cpu -- writeme!  */
 	   gcc_unreachable ();
 	}
-      else if (defined)
+      else if (defined && ! MACHO_SYMBOL_MUST_INDIRECT_P (orig))
 	{
 	  rtx offset = NULL;
 	  if (DARWIN_PPC || HAVE_lo_sum)
@@ -707,6 +702,7 @@
 		  machopic_indirection_name (orig, /*stub_p=*/false)));
 
       SYMBOL_REF_DATA (ptr_ref) = SYMBOL_REF_DATA (orig);
+      SYMBOL_REF_FLAGS (ptr_ref) |= MACHO_SYMBOL_FLAG_INDIRECTION;
 
       ptr_ref = gen_const_mem (Pmode, ptr_ref);
       machopic_define_symbol (ptr_ref);
@@ -789,7 +785,7 @@
 rtx
 machopic_indirect_call_target (rtx target)
 {
-  if (! darwin_emit_branch_islands)
+  if (! darwin_symbol_stubs)
     return target;
 
   if (GET_CODE (target) != MEM)
@@ -797,8 +793,7 @@
 
   if (MACHOPIC_INDIRECT
       && GET_CODE (XEXP (target, 0)) == SYMBOL_REF
-      && !(SYMBOL_REF_FLAGS (XEXP (target, 0))
-	   & MACHO_SYMBOL_FLAG_DEFINED))
+      && ! MACHO_SYMBOL_DEFINED_P (XEXP (target, 0)))
     {
       rtx sym_ref = XEXP (target, 0);
       const char *stub_name = machopic_indirection_name (sym_ref,
@@ -807,6 +802,7 @@
 
       XEXP (target, 0) = gen_rtx_SYMBOL_REF (mode, stub_name);
       SYMBOL_REF_DATA (XEXP (target, 0)) = SYMBOL_REF_DATA (sym_ref);
+      SYMBOL_REF_FLAGS (XEXP (target, 0)) |= MACHO_SYMBOL_FLAG_INDIRECTION;
       MEM_READONLY_P (target) = 1;
       MEM_NOTRAP_P (target) = 1;
     }
@@ -844,7 +840,7 @@
 	{
 	  if (reg == 0)
 	    {
-	      gcc_assert (!reload_in_progress);
+	      gcc_assert (!lra_in_progress);
 	      reg = gen_reg_rtx (Pmode);
 	    }
 
@@ -928,7 +924,7 @@
 	      emit_use (gen_rtx_REG (Pmode, PIC_OFFSET_TABLE_REGNUM));
 #endif
 
-	      if (reload_in_progress)
+	      if (lra_in_progress)
 		df_set_regs_ever_live (REGNO (pic), true);
 	      pic_ref = gen_rtx_PLUS (Pmode, pic,
 				      machopic_gen_offset (XEXP (orig, 0)));
@@ -952,7 +948,7 @@
 
 	      if (reg == 0)
 		{
-		  gcc_assert (!reload_in_progress);
+		  gcc_assert (!lra_in_progress);
 		  reg = gen_reg_rtx (Pmode);
 		}
 
@@ -998,7 +994,7 @@
 #if 0
 		  emit_use (pic_offset_table_rtx);
 #endif
-		  if (reload_in_progress)
+		  if (lra_in_progress)
 		    df_set_regs_ever_live (REGNO (pic), true);
 		  pic_ref = gen_rtx_PLUS (Pmode,
 					  pic,
@@ -1075,129 +1071,160 @@
   return pic_ref;
 }
 
-/* Output the stub or non-lazy pointer in *SLOT, if it has been used.
-   DATA is the FILE* for assembly output.  Called from
-   htab_traverse.  */
+/* Callbacks to output the stub or non-lazy pointers.
+   Each works on the item in *SLOT,if it has been used.
+   DATA is the FILE* for assembly output.
+   Called from htab_traverses, invoked from machopic_finish().  */
 
 int
-machopic_output_indirection (machopic_indirection **slot, FILE *asm_out_file)
+machopic_output_data_section_indirection (machopic_indirection **slot,
+					  FILE *asm_out_file)
 {
   machopic_indirection *p = *slot;
-  rtx symbol;
-  const char *sym_name;
-  const char *ptr_name;
 
-  if (!p->used)
+  if (!p->used || !p->nlsp_in_data_section)
     return 1;
 
-  symbol = p->symbol;
-  sym_name = XSTR (symbol, 0);
-  ptr_name = p->ptr_name;
+  rtx symbol = p->symbol;
+  /* The original symbol name.  */
+  const char *sym_name = XSTR (symbol, 0);
+  /* The name of the indirection symbol.  */
+  const char *ptr_name = p->ptr_name;
 
-  if (p->stub_p)
-    {
-      char *sym;
-      char *stub;
-      tree id;
+  switch_to_section (data_section);
+  assemble_align (GET_MODE_ALIGNMENT (Pmode));
+  assemble_label (asm_out_file, ptr_name);
+  assemble_integer (gen_rtx_SYMBOL_REF (Pmode, sym_name),
+		    GET_MODE_SIZE (Pmode),
+		    GET_MODE_ALIGNMENT (Pmode), 1);
 
-      id = maybe_get_identifier (sym_name);
-      if (id)
-	{
-	  tree id_orig = id;
+  return 1;
+}
 
-	  while (IDENTIFIER_TRANSPARENT_ALIAS (id))
-	    id = TREE_CHAIN (id);
-	  if (id != id_orig)
-	    sym_name = IDENTIFIER_POINTER (id);
-	}
+int
+machopic_output_stub_indirection (machopic_indirection **slot,
+				  FILE *asm_out_file)
+{
+  machopic_indirection *p = *slot;
 
-      sym = XALLOCAVEC (char, strlen (sym_name) + 2);
-      if (sym_name[0] == '*' || sym_name[0] == '&')
-	strcpy (sym, sym_name + 1);
-      else if (sym_name[0] == '-' || sym_name[0] == '+')
-	strcpy (sym, sym_name);
-      else
-	sprintf (sym, "%s%s", user_label_prefix, sym_name);
+  if (!p->used || !p->stub_p)
+    return 1;
 
-      stub = XALLOCAVEC (char, strlen (ptr_name) + 2);
-      if (ptr_name[0] == '*' || ptr_name[0] == '&')
-	strcpy (stub, ptr_name + 1);
-      else
-	sprintf (stub, "%s%s", user_label_prefix, ptr_name);
+  rtx symbol = p->symbol;
+  /* The original symbol name.  */
+  const char *sym_name = XSTR (symbol, 0);
+  /* The name of the stub symbol.  */
+  const char *ptr_name = p->ptr_name;
 
-      machopic_output_stub (asm_out_file, sym, stub);
-    }
-  else if (! indirect_data (symbol)
-	   && (machopic_symbol_defined_p (symbol)
-	       || SYMBOL_REF_LOCAL_P (symbol)))
+  tree id = maybe_get_identifier (sym_name);
+  if (id)
     {
-      switch_to_section (data_section);
-      assemble_align (GET_MODE_ALIGNMENT (Pmode));
-      assemble_label (asm_out_file, ptr_name);
-      assemble_integer (gen_rtx_SYMBOL_REF (Pmode, sym_name),
-			GET_MODE_SIZE (Pmode),
-			GET_MODE_ALIGNMENT (Pmode), 1);
+      tree id_orig = id;
+
+      while (IDENTIFIER_TRANSPARENT_ALIAS (id))
+	id = TREE_CHAIN (id);
+      if (id != id_orig)
+	sym_name = IDENTIFIER_POINTER (id);
     }
+
+  char *sym = XALLOCAVEC (char, strlen (sym_name) + 2);
+  if (sym_name[0] == '*' || sym_name[0] == '&')
+    strcpy (sym, sym_name + 1);
+  else if (sym_name[0] == '-' || sym_name[0] == '+')
+    strcpy (sym, sym_name);
   else
-    {
-      rtx init = const0_rtx;
+    sprintf (sym, "%s%s", user_label_prefix, sym_name);
 
-      switch_to_section (darwin_sections[machopic_nl_symbol_ptr_section]);
+  char *stub = XALLOCAVEC (char, strlen (ptr_name) + 2);
+  if (ptr_name[0] == '*' || ptr_name[0] == '&')
+    strcpy (stub, ptr_name + 1);
+  else
+    sprintf (stub, "%s%s", user_label_prefix, ptr_name);
 
-      /* Mach-O symbols are passed around in code through indirect
-	 references and the original symbol_ref hasn't passed through
-	 the generic handling and reference-catching in
-	 output_operand, so we need to manually mark weak references
-	 as such.  */
-      if (SYMBOL_REF_WEAK (symbol))
-	{
-	  tree decl = SYMBOL_REF_DECL (symbol);
-	  gcc_assert (DECL_P (decl));
+  machopic_output_stub (asm_out_file, sym, stub);
 
-	  if (decl != NULL_TREE
-	      && DECL_EXTERNAL (decl) && TREE_PUBLIC (decl)
-	      /* Handle only actual external-only definitions, not
-		 e.g. extern inline code or variables for which
-		 storage has been allocated.  */
-	      && !TREE_STATIC (decl))
-	    {
-	      fputs ("\t.weak_reference ", asm_out_file);
-	      assemble_name (asm_out_file, sym_name);
-	      fputc ('\n', asm_out_file);
-	    }
-	}
+  return 1;
+}
 
-      assemble_name (asm_out_file, ptr_name);
-      fprintf (asm_out_file, ":\n");
+int
+machopic_output_indirection (machopic_indirection **slot, FILE *asm_out_file)
+{
+  machopic_indirection *p = *slot;
 
-      fprintf (asm_out_file, "\t.indirect_symbol ");
-      assemble_name (asm_out_file, sym_name);
-      fprintf (asm_out_file, "\n");
+  if (!p->used || p->stub_p || p->nlsp_in_data_section)
+    return 1;
 
-      /* Variables that are marked with MACHO_SYMBOL_STATIC need to
-	 have their symbol name instead of 0 in the second entry of
-	 the non-lazy symbol pointer data structure when they are
-	 defined.  This allows the runtime to rebind newer instances
-	 of the translation unit with the original instance of the
-	 symbol.  */
+  rtx symbol = p->symbol;
+  /* The original symbol name.  */
+  const char *sym_name = XSTR (symbol, 0);
+  /* The nonlazy-stub symbol name.  */
+  const char *ptr_name = p->ptr_name;
 
-      if ((SYMBOL_REF_FLAGS (symbol) & MACHO_SYMBOL_STATIC)
-	  && machopic_symbol_defined_p (symbol))
-	init = gen_rtx_SYMBOL_REF (Pmode, sym_name);
+  switch_to_section (darwin_sections[machopic_nl_symbol_ptr_section]);
 
-      assemble_integer (init, GET_MODE_SIZE (Pmode),
-			GET_MODE_ALIGNMENT (Pmode), 1);
+  /* Mach-O symbols are passed around in code through indirect references and
+     the original symbol_ref hasn't passed through the generic handling and
+     reference-catching in output_operand, so we need to manually mark weak
+     references as such.  */
+
+  if (SYMBOL_REF_WEAK (symbol))
+    {
+      tree decl = SYMBOL_REF_DECL (symbol);
+      gcc_checking_assert (DECL_P (decl));
+
+      if (decl != NULL_TREE
+	  && DECL_EXTERNAL (decl) && TREE_PUBLIC (decl)
+	  /* Handle only actual external-only definitions, not
+	     e.g. extern inline code or variables for which
+	     storage has been allocated.  */
+	  && !TREE_STATIC (decl))
+	{
+	  fputs ("\t.weak_reference ", asm_out_file);
+	  assemble_name (asm_out_file, sym_name);
+	  fputc ('\n', asm_out_file);
+	}
     }
 
+  assemble_name (asm_out_file, ptr_name);
+  fprintf (asm_out_file, ":\n");
+
+  fprintf (asm_out_file, "\t.indirect_symbol ");
+  assemble_name (asm_out_file, sym_name);
+  fprintf (asm_out_file, "\n");
+
+  /* Variables that are marked with MACHO_SYMBOL_FLAG_STATIC need to
+     have their symbol name instead of 0 in the second entry of
+     the non-lazy symbol pointer data structure when they are
+     defined.  This allows the runtime to rebind newer instances
+     of the translation unit with the original instance of the
+     symbol.  */
+
+  rtx init = const0_rtx;
+  if (MACHO_SYMBOL_STATIC_P (symbol) && machopic_symbol_defined_p (symbol))
+    init = gen_rtx_SYMBOL_REF (Pmode, sym_name);
+
+  assemble_integer (init, GET_MODE_SIZE (Pmode),
+		    GET_MODE_ALIGNMENT (Pmode), 1);
+
   return 1;
 }
 
-void
+static void
 machopic_finish (FILE *asm_out_file)
 {
-  if (machopic_indirections)
-    machopic_indirections
-      ->traverse_noresize<FILE *, machopic_output_indirection> (asm_out_file);
+  if (!machopic_indirections)
+    return;
+
+  /* First output an symbol indirections that have been placed into .data
+     (we don't expect these now).  */
+  machopic_indirections->traverse_noresize
+    <FILE *, machopic_output_data_section_indirection> (asm_out_file);
+
+  machopic_indirections->traverse_noresize
+    <FILE *, machopic_output_stub_indirection> (asm_out_file);
+
+  machopic_indirections->traverse_noresize
+    <FILE *, machopic_output_indirection> (asm_out_file);
 }
 
 int
@@ -1212,25 +1239,51 @@
 	    && XINT (XEXP (op, 0), 1) == UNSPEC_MACHOPIC_OFFSET);
 }
 
-/* This function records whether a given name corresponds to a defined
-   or undefined function or variable, for machopic_classify_ident to
-   use later.  */
+/* This function:
+   computes and caches a series of flags that characterise the symbol's
+   properties that affect Mach-O code gen (including accidental cases
+   from older toolchains).
 
+   TODO:
+   Here we also need to do enough analysis to determine if a symbol's
+   name needs to be made linker-visible.  This is more tricky - since
+   it depends on whether we've previously seen a global weak definition
+   in the same section.
+   */
+
 void
-darwin_encode_section_info (tree decl, rtx rtl, int first ATTRIBUTE_UNUSED)
+darwin_encode_section_info (tree decl, rtx rtl, int first)
 {
-  rtx sym_ref;
+  /* Careful not to prod global register variables.  */
+  if (!MEM_P (rtl))
+    return;
 
-  /* Do the standard encoding things first.  */
+  /* Do the standard encoding things first; this sets:
+     SYMBOL_FLAG_FUNCTION,
+     SYMBOL_FLAG_LOCAL, (binds_local_p)
+     TLS_MODEL, SYMBOL_FLAG_SMALL
+     SYMBOL_FLAG_EXTERNAL.  */
   default_encode_section_info (decl, rtl, first);
 
-  if (TREE_CODE (decl) != FUNCTION_DECL && TREE_CODE (decl) != VAR_DECL)
+  if (! VAR_OR_FUNCTION_DECL_P (decl))
     return;
 
-  sym_ref = XEXP (rtl, 0);
-  if (TREE_CODE (decl) == VAR_DECL)
+  rtx sym_ref = XEXP (rtl, 0);
+  if (VAR_P (decl))
     SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_VARIABLE;
 
+  /* Only really common if there's no initialiser.  */
+  bool really_common_p = (DECL_COMMON (decl)
+			  && (DECL_INITIAL (decl) == NULL
+			      || (!in_lto_p
+				  && DECL_INITIAL (decl) == error_mark_node)));
+
+  /* For Darwin, if we have specified visibility and it's not the default
+     that's counted 'hidden'.  */
+  if (DECL_VISIBILITY_SPECIFIED (decl)
+      && DECL_VISIBILITY (decl) != VISIBILITY_DEFAULT)
+    SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_HIDDEN_VIS;
+
   if (!DECL_EXTERNAL (decl)
       && (!TREE_PUBLIC (decl) || !DECL_WEAK (decl))
       && ! lookup_attribute ("weakref", DECL_ATTRIBUTES (decl))
@@ -1241,7 +1294,13 @@
     SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_DEFINED;
 
   if (! TREE_PUBLIC (decl))
-    SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_STATIC;
+    SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_STATIC;
+
+  /* Short cut check for Darwin 'must indirect' rules.  */
+  if (really_common_p
+      || (DECL_WEAK (decl) && ! MACHO_SYMBOL_HIDDEN_VIS_P (sym_ref))
+      || lookup_attribute ("weakref", DECL_ATTRIBUTES (decl)))
+     SYMBOL_REF_FLAGS (sym_ref) |= MACHO_SYMBOL_FLAG_MUST_INDIRECT;
 }
 
 void
@@ -1258,12 +1317,13 @@
 }
 
 static section *
-darwin_rodata_section (int use_coal, bool zsize)
+darwin_rodata_section (int use_coal, bool zsize, int reloc)
 {
   return (use_coal
 	  ? darwin_sections[const_coal_section]
 	  : (zsize ? darwin_sections[zobj_const_section]
-		   : darwin_sections[const_section]));
+		   : reloc ? darwin_sections[const_data_section]
+			   : darwin_sections[const_section]));
 }
 
 static section *
@@ -1556,7 +1616,7 @@
 
     case SECCAT_RODATA:
     case SECCAT_SRODATA:
-      base_section = darwin_rodata_section (use_coal, zsize);
+      base_section = darwin_rodata_section (use_coal, zsize, reloc);
       break;
 
     case SECCAT_RODATA_MERGE_STR:
@@ -2092,11 +2152,11 @@
   static int invok_count = 0;
   static tree last_fun_decl = NULL_TREE;
   
-  /* We use the linker to emit the .eh labels for Darwin 9 and above.  */
-  if (! for_eh || generating_for_darwin_version >= 9)
+  /* Modern linkers can produce distinct FDEs without compiler support.  */
+  if (! for_eh || ! ld_needs_eh_markers)
     return;
 
-  /* FIXME: This only works when the eh for all sections of a function is 
+  /* FIXME: This only works when the eh for all sections of a function are
      emitted at the same time.  If that changes, we would need to use a lookup
      table of some form to determine what to do.  Also, we should emit the
      unadorned label for the partition containing the public label for a
@@ -2945,12 +3005,10 @@
       if (flag_objc_abi >= 2)
 	{
 	  flags = 16;
-	  output_section_asm_op
-	    (darwin_sections[objc2_image_info_section]->unnamed.data);
+          switch_to_section (darwin_sections[objc2_image_info_section]);
 	}
       else
-	output_section_asm_op
-	  (darwin_sections[objc_image_info_section]->unnamed.data);
+	switch_to_section (darwin_sections[objc_image_info_section]);
 
       ASM_OUTPUT_ALIGN (asm_out_file, 2);
       fputs ("L_OBJC_ImageInfo:\n", asm_out_file);
@@ -3156,17 +3214,19 @@
 				: (generating_for_darwin_version >= 9) ? 1
 								       : 0);
 
-  /* Objective-C family ABI 2 is only valid for next/m64 at present.  */
   if (global_options_set.x_flag_objc_abi && flag_next_runtime)
     {
-      if (TARGET_64BIT && global_options.x_flag_objc_abi < 2)
-	error_at (UNKNOWN_LOCATION, "%<-fobjc-abi-version%> >= 2 must be"
-				    " used for %<-m64%> targets with"
-				    " %<-fnext-runtime%>");
-      if (!TARGET_64BIT && global_options.x_flag_objc_abi >= 2)
-	error_at (UNKNOWN_LOCATION, "%<-fobjc-abi-version%> >= 2 is not"
-				    " supported on %<-m32%> targets with"
-				    " %<-fnext-runtime%>");
+      if (TARGET_64BIT && global_options.x_flag_objc_abi != 2)
+	/* The Objective-C family ABI 2 is the only valid version NeXT/m64.  */
+	error_at (UNKNOWN_LOCATION,
+		  "%<-fobjc-abi-version%> 2 must be used for 64 bit targets"
+		  " with %<-fnext-runtime%>");
+      else if (!TARGET_64BIT && global_options.x_flag_objc_abi >= 2)
+	/* ABI versions 0 and 1 are the only valid versions NeXT/m32.  */
+	error_at (UNKNOWN_LOCATION,
+		  "%<-fobjc-abi-version%> %d is not supported for 32 bit"
+		  " targets with %<-fnext-runtime%>",
+		  global_options.x_flag_objc_abi);
     }
 
   /* Don't emit DWARF3/4 unless specifically selected.  This is a 
@@ -3242,8 +3302,6 @@
       /* so no tables either.. */
       flag_unwind_tables = 0;
       flag_asynchronous_unwind_tables = 0;
-      /* We still need to emit branch islands for kernel context.  */
-      darwin_emit_branch_islands = true;
     }
 
   if (flag_var_tracking_uninit == 0
@@ -3253,6 +3311,8 @@
       && write_symbols == DWARF2_DEBUG)
     flag_var_tracking_uninit = flag_var_tracking;
 
+  /* Final check on PCI options; for Darwin these are not dependent on the PIE
+     ones, although PIE does require PIC to support it.  */
   if (MACHO_DYNAMIC_NO_PIC_P)
     {
       if (flag_pic)
@@ -3261,18 +3321,53 @@
 		 " %<-fpie%> or %<-fPIE%>");
       flag_pic = 0;
     }
-  else if (flag_pic == 1)
+  else if (flag_pic == 1
+	   || (flag_pic == 0 && !(flag_mkernel || flag_apple_kext)))
     {
-      /* Darwin's -fpic is -fPIC.  */
+      /* Darwin's -fpic is -fPIC.
+	 We only support "static" code in the kernel and kernel exts.  */
       flag_pic = 2;
     }
 
-  /* It is assumed that branch island stubs are needed for earlier systems.  */
-  if (generating_for_darwin_version < 9)
-    darwin_emit_branch_islands = true;
-  else
-    emit_aligned_common = true; /* Later systems can support aligned common.  */
+  /* Linkers >= ld64-62.1 (at least) are capable of making the necessary PIC
+     indirections and we no longer need to emit pic symbol stubs.
+     However, if we are generating code for earlier ones (or for use in the
+     kernel) the stubs might still be required, and this will be set true.
+     If the user sets it on or off - then that takes precedence.
 
+     Linkers that don't need stubs, don't need the EH symbol markers either.
+  */
+
+  if (!global_options_set.x_darwin_symbol_stubs)
+    {
+      if (darwin_target_linker)
+	{
+	  if (strverscmp (darwin_target_linker, MIN_LD64_OMIT_STUBS) < 0)
+	    {
+	      darwin_symbol_stubs = true;
+	      ld_needs_eh_markers = true;
+	    }
+	}
+      else if (generating_for_darwin_version < 9)
+	{
+	  /* If we don't know the linker version and we're targeting an old
+	     system, we know no better than to assume the use of an earlier
+	     linker.  */
+	  darwin_symbol_stubs = true;
+	  ld_needs_eh_markers = true;
+	}
+    }
+  else if (DARWIN_X86 && darwin_symbol_stubs && TARGET_64BIT)
+    {
+      inform (input_location,
+	      "%<-msymbol-stubs%> is not required for 64b code (ignored)");
+      darwin_symbol_stubs = false;
+    }
+
+  if (generating_for_darwin_version >= 9)
+    /* Later systems can support aligned common.  */
+    emit_aligned_common = true;
+
   /* The c_dialect...() macros are not available to us here.  */
   darwin_running_cxx = (strstr (lang_hooks.name, "C++") != 0);
 }
Index: gcc/config/darwin.h
===================================================================
diff --git a/gcc/config/darwin.h b/gcc/config/darwin.h
--- a/gcc/config/darwin.h	(revision 278653)
+++ b/gcc/config/darwin.h	(revision 278653)
@@ -129,6 +129,24 @@
   "%{gsplit-dwarf:%ngsplit-dwarf is not supported on this platform } \
      %<gsplit-dwarf"
 
+#if LD64_HAS_EXPORT_DYNAMIC
+#define DARWIN_RDYNAMIC "%{rdynamic:-export_dynamic}"
+#else
+#define DARWIN_RDYNAMIC "%{rdynamic:%nrdynamic is not supported}"
+#endif
+
+/* FIXME: we should check that the linker supports the -pie and -no_pie.
+   options.  */
+#define DARWIN_PIE_SPEC \
+"%{pie|fpie|fPIE:\
+   %{mdynamic-no-pic: \
+     %n'-mdynamic-no-pic' overrides '-pie', '-fpie' or '-fPIE'; \
+     :%:version-compare(>= 10.5 mmacosx-version-min= -pie) }} "
+
+#define DARWIN_NOPIE_SPEC \
+"%{no-pie|fno-pie|fno-PIE: \
+   %:version-compare(>= 10.7 mmacosx-version-min= -no_pie) }"
+
 #define DARWIN_CC1_SPEC							\
   "%{findirect-virtual-calls: -fapple-kext} %<findirect-virtual-calls " \
   "%{fterminated-vtables: -fapple-kext} %<fterminated-vtables "		\
@@ -159,26 +177,37 @@
 #define CPP_SPEC "%{static:%{!dynamic:-D__STATIC__}}%{!static:-D__DYNAMIC__}" \
 	" %{pthread:-D_REENTRANT}"
 
-/* This is mostly a clone of the standard LINK_COMMAND_SPEC, plus
-   precomp, libtool, and fat build additions.
+/* This is a fix for PR41260 by passing -no_compact_unwind on darwin10 and
+   later until the assembler, linker and libunwind are able to deal with the
+   output from GCC.
 
+   FIXME: we should check that the linker supports the option.
+*/
+
+#define DARWIN_NOCOMPACT_UNWIND \
+" %:version-compare(>= 10.6 mmacosx-version-min= -no_compact_unwind) "
+
+/* In Darwin linker specs we can put -lcrt0.o and ld will search the library
+   path for crt0.o or -lcrtx.a and it will search for for libcrtx.a.  As for
+   other ports, we can also put xxx.{o,a}%s and get the appropriate complete
+   startfile absolute directory.  This latter point is important when we want
+   to override ld's rule of .dylib being found ahead of .a and the user wants
+   the convenience library to be linked.  */
+
+/* The LINK_COMMAND spec is mostly a clone of the standard LINK_COMMAND_SPEC,
+   plus precomp, libtool, and fat build additions.
+
    In general, random Darwin linker flags should go into LINK_SPEC
    instead of LINK_COMMAND_SPEC.  The command spec is better for
    specifying the handling of options understood by generic Unix
    linkers, and for positional arguments like libraries.  */
 
-#if LD64_HAS_EXPORT_DYNAMIC
-#define DARWIN_EXPORT_DYNAMIC " %{rdynamic:-export_dynamic}"
-#else
-#define DARWIN_EXPORT_DYNAMIC " %{rdynamic: %nrdynamic is not supported}"
-#endif
-
 #define LINK_COMMAND_SPEC_A \
    "%{!fdump=*:%{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\
     %(linker)" \
     LINK_PLUGIN_SPEC \
     "%{flto*:%<fcompare-debug*} \
-    %{flto*} \
+     %{flto} %{fno-lto} %{flto=*} \
     %l " LINK_COMPRESS_DEBUG_SPEC \
    "%X %{s} %{t} %{Z} %{u*} \
     %{e*} %{r} \
@@ -193,10 +222,14 @@
       %{%:sanitize(address): -lasan } \
       %{%:sanitize(undefined): -lubsan } \
       %(link_ssp) \
-      " DARWIN_EXPORT_DYNAMIC " %<rdynamic \
       %(link_gcc_c_sequence) \
     }}\
-    %{!nostdlib:%{!nostartfiles:%E}} %{T*} %{F*} }}}}}}}"
+    %{!nostdlib:%{!r:%{!nostartfiles:%E}}} %{T*} %{F*} "\
+    DARWIN_PIE_SPEC \
+    DARWIN_NOPIE_SPEC \
+    DARWIN_RDYNAMIC \
+    DARWIN_NOCOMPACT_UNWIND \
+    "}}}}}}} %<pie %<no-pie %<rdynamic "
 
 #define DSYMUTIL "\ndsymutil"
 
@@ -233,8 +266,6 @@
 #define STANDARD_STARTFILE_PREFIX_1 ""
 #define STANDARD_STARTFILE_PREFIX_2 ""
 
-#define DARWIN_PIE_SPEC "%{fpie|pie|fPIE:}"
-
 /* Please keep the random linker options in alphabetical order (modulo
    'Z' and 'no' prefixes). Note that options taking arguments may appear
    multiple times on a command line with different arguments each time,
@@ -298,7 +329,6 @@
      %:version-compare(< 10.5 mmacosx-version-min= -multiply_defined) \
      %:version-compare(< 10.5 mmacosx-version-min= suppress)}} \
    %{Zmultiplydefinedunused*:-multiply_defined_unused %*} \
-   " DARWIN_PIE_SPEC " \
    %{prebind} %{noprebind} %{nofixprebinding} %{prebind_all_twolevel_modules} \
    %{read_only_relocs} \
    %{sectcreate*} %{sectorder*} %{seg1addr*} %{segprot*} \
@@ -330,43 +360,42 @@
 
 /* Support -mmacosx-version-min by supplying different (stub) libgcc_s.dylib
    libraries to link against, and by not linking against libgcc_s on
-   earlier-than-10.3.9.
+   earlier-than-10.3.9.  If we need exceptions, prior to 10.3.9, then we have
+   to link the static eh lib, since there's no shared version on the system.
 
-   Note that by default, -lgcc_eh is not linked against!  This is
-   because in a future version of Darwin the EH frame information may
-   be in a new format, or the fallback routine might be changed; if
-   you want to explicitly link against the static version of those
-   routines, because you know you don't need to unwind through system
-   libraries, you need to explicitly say -static-libgcc.
+   Note that by default, except as above, -lgcc_eh is not linked against.
+   This is because,in general, we need to unwind through system libraries that
+   are linked with the shared unwinder in libunwind (or libgcc_s for 10.4/5).
 
-   If it is linked against, it has to be before -lgcc, because it may
+   The static version of the current libgcc unwinder (which differs from the
+   implementation in libunwind.dylib on systems Darwin10 [10.6]+) can be used
+   by specifying -static-libgcc.
+
+   If libgcc_eh is linked against, it has to be before -lgcc, because it might
    need symbols from -lgcc.  */
+
 #undef REAL_LIBGCC_SPEC
 #define REAL_LIBGCC_SPEC						   \
    "%{static-libgcc|static: -lgcc_eh -lgcc;				   \
-      shared-libgcc|fexceptions|fgnu-runtime:				   \
-       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_s.10.4)	   \
+      shared-libgcc|fexceptions|fobjc-exceptions|fgnu-runtime:		   \
+       %:version-compare(!> 10.3.9 mmacosx-version-min= -lgcc_eh)	   \
+       %:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_s.10.4) \
        %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
-       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_ext.10.4) \
        %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
        -lgcc ;								   \
       :%:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_s.10.4) \
        %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lgcc_s.10.5)   \
-       %:version-compare(!> 10.5 mmacosx-version-min= -lgcc_ext.10.4)	   \
+       %:version-compare(>< 10.3.9 10.5 mmacosx-version-min= -lgcc_ext.10.4) \
        %:version-compare(>= 10.5 mmacosx-version-min= -lgcc_ext.10.5)	   \
        -lgcc }"
 
-/* We specify crt0.o as -lcrt0.o so that ld will search the library path.
+/* We specify crt0.o as -lcrt0.o so that ld will search the library path.  */
 
-   crt3.o provides __cxa_atexit on systems that don't have it.  Since
-   it's only used with C++, which requires passing -shared-libgcc, key
-   off that to avoid unnecessarily adding a destructor to every
-   powerpc program built.  */
-
 #undef  STARTFILE_SPEC
 #define STARTFILE_SPEC							    \
-  "%{Zdynamiclib: %(darwin_dylib1) %{fgnu-tm: -lcrttms.o}}		    \
-   %{!Zdynamiclib:%{Zbundle:%{!static:					    \
+"%{Zdynamiclib: %(darwin_dylib1) %{fgnu-tm: -lcrttms.o}}		    \
+ %{!Zdynamiclib:%{Zbundle:%{!static:					    \
 	%:version-compare(< 10.6 mmacosx-version-min= -lbundle1.o)	    \
 	%{fgnu-tm: -lcrttms.o}}}					    \
      %{!Zbundle:%{pg:%{static:-lgcrt0.o}				    \
@@ -380,7 +409,7 @@
                                 %{!object:%{preload:-lcrt0.o}		    \
                                   %{!preload: %(darwin_crt1)		    \
 					      %(darwin_crt2)}}}}}}	    \
-  %{shared-libgcc:%:version-compare(< 10.5 mmacosx-version-min= crt3.o%s)}"
+ %(darwin_crt3)"
 
 /* We want a destructor last in the list.  */
 #define TM_DESTRUCTOR "%{fgnu-tm: -lcrttme.o}"
@@ -388,12 +417,10 @@
 
 #define DARWIN_EXTRA_SPECS						\
   { "darwin_crt1", DARWIN_CRT1_SPEC },					\
+  { "darwin_crt2", DARWIN_CRT2_SPEC },					\
+  { "darwin_crt3", DARWIN_CRT3_SPEC },					\
   { "darwin_dylib1", DARWIN_DYLIB1_SPEC },
 
-#define DARWIN_DYLIB1_SPEC						\
-  "%:version-compare(!> 10.5 mmacosx-version-min= -ldylib1.o)		\
-   %:version-compare(>< 10.5 10.6 mmacosx-version-min= -ldylib1.10.5.o)"
-
 #define DARWIN_CRT1_SPEC						\
   "%:version-compare(!> 10.5 mmacosx-version-min= -lcrt1.o)		\
    %:version-compare(>< 10.5 10.6 mmacosx-version-min= -lcrt1.10.5.o)	\
@@ -400,6 +427,20 @@
    %:version-compare(>< 10.6 10.8 mmacosx-version-min= -lcrt1.10.6.o)	\
    %{fgnu-tm: -lcrttms.o}"
 
+#define DARWIN_CRT2_SPEC ""
+
+/* crt3.o provides __cxa_atexit on systems that don't have it (and a fix
+   up for faulty versions on 10.4).  Since it's only used with C++, which
+   requires passing -shared-libgcc, key off that to avoid unnecessarily
+   adding a destructor to every program built for 10.4 or earlier.  */
+
+#define DARWIN_CRT3_SPEC \
+"%{shared-libgcc:%:version-compare(< 10.5 mmacosx-version-min= crt3.o%s)}"
+
+#define DARWIN_DYLIB1_SPEC						\
+  "%:version-compare(!> 10.5 mmacosx-version-min= -ldylib1.o)		\
+   %:version-compare(>< 10.5 10.6 mmacosx-version-min= -ldylib1.10.5.o)"
+
 #ifdef HAVE_AS_MMACOSX_VERSION_MIN_OPTION
 /* Emit macosx version (but only major).  */
 #define ASM_MMACOSX_VERSION_MIN_SPEC \
@@ -765,21 +806,52 @@
 #undef TARGET_ASM_MARK_DECL_PRESERVED
 #define TARGET_ASM_MARK_DECL_PRESERVED darwin_mark_decl_preserved
 
-/* Set on a symbol with SYMBOL_FLAG_FUNCTION or
-   MACHO_SYMBOL_FLAG_VARIABLE to indicate that the function or
-   variable has been defined in this translation unit.
-   When porting Mach-O to new architectures you need to make
-   sure these aren't clobbered by the backend.  */
+/* Any port using this header needs to define the first available
+   subtarget symbol bit: SYMBOL_FLAG_SUBT_DEP.  */
 
-#define MACHO_SYMBOL_FLAG_VARIABLE (SYMBOL_FLAG_MACH_DEP)
-#define MACHO_SYMBOL_FLAG_DEFINED ((SYMBOL_FLAG_MACH_DEP) << 1)
+/* Is a variable. */
+#define MACHO_SYMBOL_FLAG_VARIABLE (SYMBOL_FLAG_SUBT_DEP)
+#define MACHO_SYMBOL_VARIABLE_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_VARIABLE) != 0)
 
+/* Set on a symbol that must be indirected, even when there is a
+   definition in the TU.  The ABI mandates that common symbols are so
+   indirected, as are weak.  If 'fix-and-continue' is operational then
+   data symbols might also be.  */
+
+#define MACHO_SYMBOL_FLAG_MUST_INDIRECT ((SYMBOL_FLAG_SUBT_DEP) << 1)
+#define MACHO_SYMBOL_MUST_INDIRECT_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_MUST_INDIRECT) != 0)
+
+/* Set on a symbol with SYMBOL_FLAG_FUNCTION or MACHO_SYMBOL_FLAG_VARIABLE
+   to indicate that the function or variable is considered defined in this
+   translation unit.  */
+
+#define MACHO_SYMBOL_FLAG_DEFINED ((SYMBOL_FLAG_SUBT_DEP) << 2)
+#define MACHO_SYMBOL_DEFINED_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_DEFINED) != 0)
+
+/* Set on a symbol that has specified non-default visibility.  */
+
+#define MACHO_SYMBOL_FLAG_HIDDEN_VIS ((SYMBOL_FLAG_SUBT_DEP) << 3)
+#define MACHO_SYMBOL_HIDDEN_VIS_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_HIDDEN_VIS) != 0)
+
+/* Set on a symbol that is a pic stub or symbol indirection (i.e. the
+   L_xxxxx${stub,non_lazy_ptr,lazy_ptr}.  */
+
+#define MACHO_SYMBOL_FLAG_INDIRECTION ((SYMBOL_FLAG_SUBT_DEP) << 5)
+#define MACHO_SYMBOL_INDIRECTION_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_INDIRECTION) != 0)
+
 /* Set on a symbol to indicate when fix-and-continue style code
    generation is being used and the symbol refers to a static symbol
    that should be rebound from new instances of a translation unit to
    the original instance of the data.  */
 
-#define MACHO_SYMBOL_STATIC ((SYMBOL_FLAG_MACH_DEP) << 2)
+#define MACHO_SYMBOL_FLAG_STATIC ((SYMBOL_FLAG_SUBT_DEP) << 6)
+#define MACHO_SYMBOL_STATIC_P(RTX) \
+  ((SYMBOL_REF_FLAGS (RTX) & MACHO_SYMBOL_FLAG_STATIC) != 0)
 
 /* Symbolic names for various things we might know about a symbol.  */
 
@@ -972,8 +1044,12 @@
    _tested_ version known to support this so far.  */
 #define MIN_LD64_NO_COAL_SECTS "236.4"
 
+/* From at least version 62.1, ld64 can build symbol indirection stubs as
+   needed, and there is no need for the compiler to emit them.  */
+#define MIN_LD64_OMIT_STUBS "85.2"
+
 #ifndef LD64_VERSION
-#define LD64_VERSION "85.2"
+#define LD64_VERSION "62.1"
 #else
 #define DEF_LD64 LD64_VERSION
 #endif
Index: gcc/config/darwin10.h
===================================================================
diff --git a/gcc/config/darwin10.h b/gcc/config/darwin10.h
--- a/gcc/config/darwin10.h	(revision 278653)
+++ b/gcc/config/darwin10.h	(revision 278653)
@@ -18,17 +18,13 @@
 along with GCC; see the file COPYING3.  If not see
 <http://www.gnu.org/licenses/>.  */
 
-/* Fix PR41260 by passing -no_compact_unwind on darwin10 and later until
-   unwinder in libSystem is fixed to digest new epilog unwinding notes.
+/* Fix PR47558 by linking against libSystem ahead of libgcc_ext. */
 
-   Fix PR47558 by linking against libSystem ahead of libgcc_ext. */
 #undef  LINK_GCC_C_SEQUENCE_SPEC
 #define LINK_GCC_C_SEQUENCE_SPEC \
-"%:version-compare(>= 10.6 mmacosx-version-min= -no_compact_unwind) \
-   %{!static:%{!static-libgcc: \
-      %:version-compare(>= 10.6 mmacosx-version-min= -lSystem) } } \
-   %{fno-pic|fno-PIC|fno-pie|fno-PIE|fapple-kext|mkernel|static|mdynamic-no-pic: \
-      %:version-compare(>= 10.7 mmacosx-version-min= -no_pie) } %G %L"
+"%{!static:%{!static-libgcc: \
+   %:version-compare(>= 10.6 mmacosx-version-min= -lSystem) } } \
+ %G %L"
 
 #undef DEF_MIN_OSX_VERSION
 #define DEF_MIN_OSX_VERSION "10.6"
Index: gcc/config/arm/arm.c
===================================================================
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
--- a/gcc/config/arm/arm.c	(revision 278653)
+++ b/gcc/config/arm/arm.c	(revision 278653)
@@ -8879,11 +8879,16 @@
 arm_cannot_force_const_mem (machine_mode mode ATTRIBUTE_UNUSED, rtx x)
 {
   rtx base, offset;
+  split_const (x, &base, &offset);
 
-  if (ARM_OFFSETS_MUST_BE_WITHIN_SECTIONS_P)
+  if (SYMBOL_REF_P (base))
     {
-      split_const (x, &base, &offset);
-      if (GET_CODE (base) == SYMBOL_REF
+      /* Function symbols cannot have an offset due to the Thumb bit.  */
+      if ((SYMBOL_REF_FLAGS (base) & SYMBOL_FLAG_FUNCTION)
+	  && INTVAL (offset) != 0)
+	return true;
+
+      if (ARM_OFFSETS_MUST_BE_WITHIN_SECTIONS_P
 	  && !offset_within_block_p (base, INTVAL (offset)))
 	return true;
     }
@@ -11930,8 +11935,7 @@
   else
     {
       n_elts = 1;
-      if (mode == VOIDmode)
-	mode = DImode;
+      gcc_assert (mode != VOIDmode);
     }
 
   innersize = GET_MODE_UNIT_SIZE (mode);
@@ -13095,6 +13099,9 @@
   if (load && (REGNO (reg) == SP_REGNUM) && (REGNO (addr) != SP_REGNUM))
     return false;
 
+  if (regno == REGNO (addr))
+    addr_reg_in_reglist = true;
+
   for (; i < count; i++)
     {
       elt = XVECEXP (op, 0, i);
@@ -13289,7 +13296,6 @@
   int unsorted_regs[MAX_LDM_STM_OPS];
   HOST_WIDE_INT unsorted_offsets[MAX_LDM_STM_OPS];
   int order[MAX_LDM_STM_OPS];
-  rtx base_reg_rtx = NULL;
   int base_reg = -1;
   int i, ldm_case;
 
@@ -13334,7 +13340,6 @@
 	  if (i == 0)
 	    {
 	      base_reg = REGNO (reg);
-	      base_reg_rtx = reg;
 	      if (TARGET_THUMB1 && base_reg > LAST_LO_REGNUM)
 		return 0;
 	    }
@@ -13393,10 +13398,6 @@
       *load_offset = unsorted_offsets[order[0]];
     }
 
-  if (TARGET_THUMB1
-      && !peep2_reg_dead_p (nops, base_reg_rtx))
-    return 0;
-
   if (unsorted_offsets[order[0]] == 0)
     ldm_case = 1; /* ldmia */
   else if (TARGET_ARM && unsorted_offsets[order[0]] == 4)
@@ -13772,9 +13773,17 @@
 
   if (TARGET_THUMB1)
     {
-      gcc_assert (peep2_reg_dead_p (nops, base_reg_rtx));
       gcc_assert (ldm_case == 1 || ldm_case == 5);
-      write_back = TRUE;
+
+      /* Thumb-1 ldm uses writeback except if the base is loaded.  */
+      write_back = true;
+      for (i = 0; i < nops; i++)
+	if (base_reg == regs[i])
+	  write_back = false;
+
+      /* Ensure the base is dead if it is updated.  */
+      if (write_back && !peep2_reg_dead_p (nops, base_reg_rtx))
+	return false;
     }
 
   if (ldm_case == 5)
@@ -13782,8 +13791,7 @@
       rtx newbase = TARGET_THUMB1 ? base_reg_rtx : gen_rtx_REG (SImode, regs[0]);
       emit_insn (gen_addsi3 (newbase, base_reg_rtx, GEN_INT (offset)));
       offset = 0;
-      if (!TARGET_THUMB1)
-	base_reg_rtx = newbase;
+      base_reg_rtx = newbase;
     }
 
   for (i = 0; i < nops; i++)
@@ -19508,6 +19516,35 @@
   return save_reg_mask;
 }
 
+/* Return a mask for the call-clobbered low registers that are unused
+   at the end of the prologue.  */
+static unsigned long
+thumb1_prologue_unused_call_clobbered_lo_regs (void)
+{
+  unsigned long mask = 0;
+
+  for (int reg = 0; reg <= LAST_LO_REGNUM; reg++)
+    if (!callee_saved_reg_p (reg)
+	&& !REGNO_REG_SET_P (df_get_live_out (ENTRY_BLOCK_PTR_FOR_FN (cfun)),
+			     reg))
+      mask |= 1 << reg;
+  return mask;
+}
+
+/* Similarly for the start of the epilogue.  */
+static unsigned long
+thumb1_epilogue_unused_call_clobbered_lo_regs (void)
+{
+  unsigned long mask = 0;
+
+  for (int reg = 0; reg <= LAST_LO_REGNUM; reg++)
+    if (!callee_saved_reg_p (reg)
+	&& !REGNO_REG_SET_P (df_get_live_in (EXIT_BLOCK_PTR_FOR_FN (cfun)),
+			     reg))
+      mask |= 1 << reg;
+  return mask;
+}
+
 /* Compute a bit mask of which core registers need to be
    saved on the stack for the current function.  */
 static unsigned long
@@ -19539,10 +19576,19 @@
   if (mask & 0xff || thumb_force_lr_save ())
     mask |= (1 << LR_REGNUM);
 
-  /* Make sure we have a low work register if we need one.
-     We will need one if we are going to push a high register,
-     but we are not currently intending to push a low register.  */
+  bool call_clobbered_scratch
+    = (thumb1_prologue_unused_call_clobbered_lo_regs ()
+       && thumb1_epilogue_unused_call_clobbered_lo_regs ());
+
+  /* Make sure we have a low work register if we need one.  We will
+     need one if we are going to push a high register, but we are not
+     currently intending to push a low register.  However if both the
+     prologue and epilogue have a spare call-clobbered low register,
+     then we won't need to find an additional work register.  It does
+     not need to be the same register in the prologue and
+     epilogue.  */
   if ((mask & 0xff) == 0
+      && !call_clobbered_scratch
       && ((mask & 0x0f00) || TARGET_BACKTRACE))
     {
       /* Use thumb_find_work_register to choose which register
@@ -24768,12 +24814,7 @@
       unsigned long mask = live_regs_mask & 0xff;
       int next_hi_reg;
 
-      /* The available low registers depend on the size of the value we are
-         returning.  */
-      if (size <= 12)
-	mask |=  1 << 3;
-      if (size <= 8)
-	mask |= 1 << 2;
+      mask |= thumb1_epilogue_unused_call_clobbered_lo_regs ();
 
       if (mask == 0)
 	/* Oh dear!  We have no low registers into which we can pop
@@ -24781,7 +24822,7 @@
 	internal_error
 	  ("no low registers available for popping high registers");
 
-      for (next_hi_reg = 8; next_hi_reg < 13; next_hi_reg++)
+      for (next_hi_reg = 12; next_hi_reg > LAST_LO_REGNUM; next_hi_reg--)
 	if (live_regs_mask & (1 << next_hi_reg))
 	  break;
 
@@ -24789,7 +24830,7 @@
 	{
 	  /* Find lo register(s) into which the high register(s) can
              be popped.  */
-	  for (regno = 0; regno <= LAST_LO_REGNUM; regno++)
+	  for (regno = LAST_LO_REGNUM; regno >= 0; regno--)
 	    {
 	      if (mask & (1 << regno))
 		high_regs_pushed--;
@@ -24797,13 +24838,14 @@
 		break;
 	    }
 
-	  mask &= (2 << regno) - 1;	/* A noop if regno == 8 */
+	  if (high_regs_pushed == 0 && regno >= 0)
+	    mask &= ~((1 << regno) - 1);
 
 	  /* Pop the values into the low register(s).  */
 	  thumb_pop (asm_out_file, mask);
 
 	  /* Move the value(s) into the high registers.  */
-	  for (regno = 0; regno <= LAST_LO_REGNUM; regno++)
+	  for (regno = LAST_LO_REGNUM; regno >= 0; regno--)
 	    {
 	      if (mask & (1 << regno))
 		{
@@ -24810,7 +24852,8 @@
 		  asm_fprintf (asm_out_file, "\tmov\t%r, %r\n", next_hi_reg,
 			       regno);
 
-		  for (next_hi_reg++; next_hi_reg < 13; next_hi_reg++)
+		  for (next_hi_reg--; next_hi_reg > LAST_LO_REGNUM;
+		       next_hi_reg--)
 		    if (live_regs_mask & (1 << next_hi_reg))
 		      break;
 		}
@@ -25192,10 +25235,20 @@
 	  break;
 
       /* Here we need to mask out registers used for passing arguments
-	 even if they can be pushed.  This is to avoid using them to stash the high
-	 registers.  Such kind of stash may clobber the use of arguments.  */
+	 even if they can be pushed.  This is to avoid using them to
+	 stash the high registers.  Such kind of stash may clobber the
+	 use of arguments.  */
       pushable_regs = l_mask & (~arg_regs_mask);
-      if (lr_needs_saving)
+      pushable_regs |= thumb1_prologue_unused_call_clobbered_lo_regs ();
+
+      /* Normally, LR can be used as a scratch register once it has been
+	 saved; but if the function examines its own return address then
+	 the value is still live and we need to avoid using it.  */
+      bool return_addr_live
+	= REGNO_REG_SET_P (df_get_live_out (ENTRY_BLOCK_PTR_FOR_FN (cfun)),
+			   LR_REGNUM);
+
+      if (lr_needs_saving || return_addr_live)
 	pushable_regs &= ~(1 << LR_REGNUM);
 
       if (pushable_regs == 0)
@@ -25236,6 +25289,11 @@
 	      push_mask |= 1 << LR_REGNUM;
 	      real_regs_mask |= 1 << LR_REGNUM;
 	      lr_needs_saving = false;
+	      /* If the return address is not live at this point, we
+		 can add LR to the list of registers that we can use
+		 for pushes.  */
+	      if (!return_addr_live)
+		pushable_regs |= 1 << LR_REGNUM;
 	    }
 
 	  insn = thumb1_emit_multi_reg_push (push_mask, real_regs_mask);
Index: gcc/config/arm/arm.h
===================================================================
diff --git a/gcc/config/arm/arm.h b/gcc/config/arm/arm.h
--- a/gcc/config/arm/arm.h	(revision 278653)
+++ b/gcc/config/arm/arm.h	(revision 278653)
@@ -191,7 +191,7 @@
 /* FPU supports converting between HFmode and DFmode in a single hardware
    step.  */
 #define TARGET_FP16_TO_DOUBLE						\
-  (TARGET_HARD_FLOAT && (TARGET_FP16 && TARGET_VFP5))
+  (TARGET_HARD_FLOAT && TARGET_FP16 && TARGET_VFP5 && TARGET_VFP_DOUBLE)
 
 /* FPU supports fused-multiply-add operations.  */
 #define TARGET_FMA (bitmap_bit_p (arm_active_target.isa, isa_bit_vfpv4))
Index: gcc/config/arm/arm_acle.h
===================================================================
diff --git a/gcc/config/arm/arm_acle.h b/gcc/config/arm/arm_acle.h
--- a/gcc/config/arm/arm_acle.h	(revision 278653)
+++ b/gcc/config/arm/arm_acle.h	(revision 278653)
@@ -174,8 +174,12 @@
 #endif /* (!__thumb__ || __thumb2__) &&  __ARM_ARCH >= 4.  */
 
 #pragma GCC push_options
-#if __ARM_ARCH >= 8
+#ifdef __ARM_FEATURE_CRC32
+#ifdef __ARM_FP
+#pragma GCC target ("arch=armv8-a+crc+simd")
+#else
 #pragma GCC target ("arch=armv8-a+crc")
+#endif
 
 __extension__ static __inline uint32_t __attribute__ ((__always_inline__))
 __crc32b (uint32_t __a, uint8_t __b)
@@ -235,7 +239,7 @@
 }
 #endif
 
-#endif /* __ARM_ARCH >= 8.  */
+#endif /* __ARM_FEATURE_CRC32  */
 #pragma GCC pop_options
 
 #ifdef __cplusplus
Index: gcc/config/arm/neon.md
===================================================================
diff --git a/gcc/config/arm/neon.md b/gcc/config/arm/neon.md
--- a/gcc/config/arm/neon.md	(revision 278653)
+++ b/gcc/config/arm/neon.md	(revision 278653)
@@ -25,14 +25,14 @@
 
 (define_insn "*neon_mov<mode>"
   [(set (match_operand:VDX 0 "nonimmediate_operand"
-	  "=w,Un,w, w,  ?r,?w,?r,?r, ?Us")
+	  "=w,Un,w, w, w,  ?r,?w,?r,?r, ?Us")
 	(match_operand:VDX 1 "general_operand"
-	  " w,w, Dn,Uni, w, r, r, Usi,r"))]
+	  " w,w, Dm,Dn,Uni, w, r, r, Usi,r"))]
   "TARGET_NEON
    && (register_operand (operands[0], <MODE>mode)
        || register_operand (operands[1], <MODE>mode))"
 {
-  if (which_alternative == 2)
+  if (which_alternative == 2 || which_alternative == 3)
     {
       int width, is_valid;
       static char templ[40];
@@ -53,31 +53,32 @@
   switch (which_alternative)
     {
     case 0: return "vmov\t%P0, %P1  @ <mode>";
-    case 1: case 3: return output_move_neon (operands);
-    case 2: gcc_unreachable ();
-    case 4: return "vmov\t%Q0, %R0, %P1  @ <mode>";
-    case 5: return "vmov\t%P0, %Q1, %R1  @ <mode>";
+    case 1: case 4: return output_move_neon (operands);
+    case 2: case 3: gcc_unreachable ();
+    case 5: return "vmov\t%Q0, %R0, %P1  @ <mode>";
+    case 6: return "vmov\t%P0, %Q1, %R1  @ <mode>";
     default: return output_move_double (operands, true, NULL);
     }
 }
  [(set_attr "type" "neon_move<q>,neon_store1_1reg,neon_move<q>,\
-                    neon_load1_1reg, neon_to_gp<q>,neon_from_gp<q>,mov_reg,\
-                    neon_load1_2reg, neon_store1_2reg")
-  (set_attr "length" "4,4,4,4,4,4,8,8,8")
-  (set_attr "arm_pool_range"     "*,*,*,1020,*,*,*,1020,*")
-  (set_attr "thumb2_pool_range"     "*,*,*,1018,*,*,*,1018,*")
-  (set_attr "neg_pool_range" "*,*,*,1004,*,*,*,1004,*")])
+                    neon_move<q>,neon_load1_1reg, neon_to_gp<q>,\
+		    neon_from_gp<q>,mov_reg,neon_load1_2reg,\
+		    neon_store1_2reg")
+  (set_attr "length" "4,4,4,4,4,4,4,8,8,8")
+  (set_attr "arm_pool_range"     "*,*,*,*,1020,*,*,*,1020,*")
+  (set_attr "thumb2_pool_range"     "*,*,*,*,1018,*,*,*,1018,*")
+  (set_attr "neg_pool_range" "*,*,*,*,1004,*,*,*,1004,*")])
 
 (define_insn "*neon_mov<mode>"
   [(set (match_operand:VQXMOV 0 "nonimmediate_operand"
-  	  "=w,Un,w, w,  ?r,?w,?r,?r,  ?Us")
+	  "=w,Un,w, w, w,  ?r,?w,?r,?r,  ?Us")
 	(match_operand:VQXMOV 1 "general_operand"
-	  " w,w, Dn,Uni, w, r, r, Usi, r"))]
+	  " w,w, Dm,DN,Uni, w, r, r, Usi, r"))]
   "TARGET_NEON
    && (register_operand (operands[0], <MODE>mode)
        || register_operand (operands[1], <MODE>mode))"
 {
-  if (which_alternative == 2)
+  if (which_alternative == 2 || which_alternative == 3)
     {
       int width, is_valid;
       static char templ[40];
@@ -98,20 +99,20 @@
   switch (which_alternative)
     {
     case 0: return "vmov\t%q0, %q1  @ <mode>";
-    case 1: case 3: return output_move_neon (operands);
-    case 2: gcc_unreachable ();
-    case 4: return "vmov\t%Q0, %R0, %e1  @ <mode>\;vmov\t%J0, %K0, %f1";
-    case 5: return "vmov\t%e0, %Q1, %R1  @ <mode>\;vmov\t%f0, %J1, %K1";
+    case 1: case 4: return output_move_neon (operands);
+    case 2: case 3: gcc_unreachable ();
+    case 5: return "vmov\t%Q0, %R0, %e1  @ <mode>\;vmov\t%J0, %K0, %f1";
+    case 6: return "vmov\t%e0, %Q1, %R1  @ <mode>\;vmov\t%f0, %J1, %K1";
     default: return output_move_quad (operands);
     }
 }
   [(set_attr "type" "neon_move_q,neon_store2_2reg_q,neon_move_q,\
-                     neon_load2_2reg_q,neon_to_gp_q,neon_from_gp_q,\
-                     mov_reg,neon_load1_4reg,neon_store1_4reg")
-   (set_attr "length" "4,8,4,8,8,8,16,8,16")
-   (set_attr "arm_pool_range" "*,*,*,1020,*,*,*,1020,*")
-   (set_attr "thumb2_pool_range" "*,*,*,1018,*,*,*,1018,*")
-   (set_attr "neg_pool_range" "*,*,*,996,*,*,*,996,*")])
+                     neon_move_q,neon_load2_2reg_q,neon_to_gp_q,\
+                     neon_from_gp_q,mov_reg,neon_load1_4reg,neon_store1_4reg")
+   (set_attr "length" "4,8,4,4,8,8,8,16,8,16")
+   (set_attr "arm_pool_range" "*,*,*,*,1020,*,*,*,1020,*")
+   (set_attr "thumb2_pool_range" "*,*,*,*,1018,*,*,*,1018,*")
+   (set_attr "neg_pool_range" "*,*,*,*,996,*,*,*,996,*")])
 
 /* We define these mov expanders to match the standard mov$a optab to prevent
    the mid-end from trying to do a subreg for these modes which is the most
@@ -1033,7 +1034,7 @@
 (define_insn "vashl<mode>3"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w,w")
 	(ashift:VDQIW (match_operand:VDQIW 1 "s_register_operand" "w,w")
-		      (match_operand:VDQIW 2 "imm_lshift_or_reg_neon" "w,Dn")))]
+		      (match_operand:VDQIW 2 "imm_lshift_or_reg_neon" "w,Dm")))]
   "TARGET_NEON"
   {
     switch (which_alternative)
@@ -1052,7 +1053,7 @@
 (define_insn "vashr<mode>3_imm"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
 	(ashiftrt:VDQIW (match_operand:VDQIW 1 "s_register_operand" "w")
-			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dn")))]
+			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dm")))]
   "TARGET_NEON"
   {
     return neon_output_shift_immediate ("vshr", 's', &operands[2],
@@ -1065,7 +1066,7 @@
 (define_insn "vlshr<mode>3_imm"
   [(set (match_operand:VDQIW 0 "s_register_operand" "=w")
 	(lshiftrt:VDQIW (match_operand:VDQIW 1 "s_register_operand" "w")
-			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dn")))]
+			(match_operand:VDQIW 2 "imm_for_neon_rshift_operand" "Dm")))]
   "TARGET_NEON"
   {
     return neon_output_shift_immediate ("vshr", 'u', &operands[2],
Index: gcc/config/arm/constraints.md
===================================================================
diff --git a/gcc/config/arm/constraints.md b/gcc/config/arm/constraints.md
--- a/gcc/config/arm/constraints.md	(revision 278653)
+++ b/gcc/config/arm/constraints.md	(revision 278653)
@@ -31,7 +31,8 @@
 ;; 'H' was previously used for FPA.
 
 ;; The following multi-letter normal constraints have been used:
-;; in ARM/Thumb-2 state: Da, Db, Dc, Dd, Dn, Dl, DL, Do, Dv, Dy, Di, Dt, Dp, Dz
+;; in ARM/Thumb-2 state: Da, Db, Dc, Dd, Dn, DN, Dm, Dl, DL, Do, Dv, Dy, Di,
+;;			 Dt, Dp, Dz
 ;; in Thumb-1 state: Pa, Pb, Pc, Pd, Pe
 ;; in Thumb-2 state: Pj, PJ, Ps, Pt, Pu, Pv, Pw, Px, Py
 ;; in all states: Pf
@@ -294,14 +295,28 @@
  (and (match_code "const_double,const_int")
       (match_test "TARGET_32BIT && arm_const_double_by_immediates (op)")))
 
-(define_constraint "Dn"
+(define_constraint "Dm"
  "@internal
-  In ARM/Thumb-2 state a const_vector or const_int which can be loaded with a
-  Neon vmov immediate instruction."
- (and (match_code "const_vector,const_int")
+  In ARM/Thumb-2 state a const_vector which can be loaded with a Neon vmov
+  immediate instruction."
+ (and (match_code "const_vector")
       (match_test "TARGET_32BIT
 		   && imm_for_neon_mov_operand (op, GET_MODE (op))")))
 
+(define_constraint "Dn"
+ "@internal
+  In ARM/Thumb-2 state a DImode const_int which can be loaded with a Neon vmov
+  immediate instruction."
+ (and (match_code "const_int")
+      (match_test "TARGET_32BIT && imm_for_neon_mov_operand (op, DImode)")))
+
+(define_constraint "DN"
+ "@internal
+  In ARM/Thumb-2 state a TImode const_int which can be loaded with a Neon vmov
+  immediate instruction."
+ (and (match_code "const_int")
+      (match_test "TARGET_32BIT && imm_for_neon_mov_operand (op, TImode)")))
+
 (define_constraint "Dl"
  "@internal
   In ARM/Thumb-2 state a const_vector which can be used with a Neon vorr or
Index: gcc/config/arm/t-rtems
===================================================================
diff --git a/gcc/config/arm/t-rtems b/gcc/config/arm/t-rtems
--- a/gcc/config/arm/t-rtems	(revision 278653)
+++ b/gcc/config/arm/t-rtems	(revision 278653)
@@ -17,8 +17,8 @@
 MULTILIB_OPTIONS	+= mthumb
 MULTILIB_DIRNAMES	+= thumb
 
-MULTILIB_OPTIONS	+= march=armv5te+fp/march=armv6-m/march=armv7-a/march=armv7-a+simd/march=armv7-r/march=armv7-r+fp/march=armv7-m/march=armv7e-m+fp/march=armv7e-m+fp.dp
-MULTILIB_DIRNAMES	+= armv5te+fp       armv6-m       armv7-a       armv7-a+simd       armv7-r       armv7-r+fp       armv7-m       armv7e-m+fp        armv7e-m+fp.dp
+MULTILIB_OPTIONS	+= march=armv5te+fp/march=armv6-m/march=armv7-a/march=armv7-a+simd/march=armv7-r/march=armv7-r+fp/mcpu=cortex-m3/mcpu=cortex-m4/mcpu=cortex-m4+nofp/mcpu=cortex-m7
+MULTILIB_DIRNAMES	+= armv5te+fp       armv6-m       armv7-a       armv7-a+simd       armv7-r       armv7-r+fp       cortex-m3      cortex-m4      cortex-m4+nofp      cortex-m7
 
 MULTILIB_OPTIONS	+= mfloat-abi=hard
 MULTILIB_DIRNAMES	+= hard
@@ -31,7 +31,8 @@
 MULTILIB_REQUIRED	+= mthumb/march=armv7-a
 MULTILIB_REQUIRED	+= mthumb/march=armv7-r+fp/mfloat-abi=hard
 MULTILIB_REQUIRED	+= mthumb/march=armv7-r
-MULTILIB_REQUIRED	+= mthumb/march=armv7e-m+fp/mfloat-abi=hard
-MULTILIB_REQUIRED	+= mthumb/march=armv7e-m+fp.dp/mfloat-abi=hard
-MULTILIB_REQUIRED	+= mthumb/march=armv7-m
+MULTILIB_REQUIRED	+= mthumb/mcpu=cortex-m3
+MULTILIB_REQUIRED	+= mthumb/mcpu=cortex-m4/mfloat-abi=hard
+MULTILIB_REQUIRED	+= mthumb/mcpu=cortex-m4+nofp
+MULTILIB_REQUIRED	+= mthumb/mcpu=cortex-m7/mfloat-abi=hard
 MULTILIB_REQUIRED	+= mthumb
Index: gcc/config/arm/arm.md
===================================================================
diff --git a/gcc/config/arm/arm.md b/gcc/config/arm/arm.md
--- a/gcc/config/arm/arm.md	(revision 278653)
+++ b/gcc/config/arm/arm.md	(revision 278653)
@@ -4448,62 +4448,78 @@
 ; ARMv6+ unaligned load/store instructions (used for packed structure accesses).
 
 (define_insn "unaligned_loadsi"
-  [(set (match_operand:SI 0 "s_register_operand" "=l,r")
-	(unspec:SI [(match_operand:SI 1 "memory_operand" "Uw,m")]
+  [(set (match_operand:SI 0 "s_register_operand" "=l,l,r")
+	(unspec:SI [(match_operand:SI 1 "memory_operand" "m,Uw,m")]
 		   UNSPEC_UNALIGNED_LOAD))]
   "unaligned_access"
-  "ldr%?\t%0, %1\t@ unaligned"
-  [(set_attr "arch" "t2,any")
-   (set_attr "length" "2,4")
-   (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "yes,no")
+  "@
+   ldr\t%0, %1\t@ unaligned
+   ldr%?\t%0, %1\t@ unaligned
+   ldr%?\t%0, %1\t@ unaligned"
+  [(set_attr "arch" "t1,t2,32")
+   (set_attr "length" "2,2,4")
+   (set_attr "predicable" "no,yes,yes")
+   (set_attr "predicable_short_it" "no,yes,no")
    (set_attr "type" "load_4")])
 
+;; The 16-bit Thumb1 variant of ldrsh requires two registers in the
+;; address (there's no immediate format).  That's tricky to support
+;; here and we don't really need this pattern for that case, so only
+;; enable for 32-bit ISAs.
 (define_insn "unaligned_loadhis"
   [(set (match_operand:SI 0 "s_register_operand" "=r")
 	(sign_extend:SI
 	  (unspec:HI [(match_operand:HI 1 "memory_operand" "Uh")]
 		     UNSPEC_UNALIGNED_LOAD)))]
-  "unaligned_access"
+  "unaligned_access && TARGET_32BIT"
   "ldrsh%?\t%0, %1\t@ unaligned"
   [(set_attr "predicable" "yes")
    (set_attr "type" "load_byte")])
 
 (define_insn "unaligned_loadhiu"
-  [(set (match_operand:SI 0 "s_register_operand" "=l,r")
+  [(set (match_operand:SI 0 "s_register_operand" "=l,l,r")
 	(zero_extend:SI
-	  (unspec:HI [(match_operand:HI 1 "memory_operand" "Uw,m")]
+	  (unspec:HI [(match_operand:HI 1 "memory_operand" "m,Uw,m")]
 		     UNSPEC_UNALIGNED_LOAD)))]
   "unaligned_access"
-  "ldrh%?\t%0, %1\t@ unaligned"
-  [(set_attr "arch" "t2,any")
-   (set_attr "length" "2,4")
-   (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "yes,no")
+  "@
+   ldrh\t%0, %1\t@ unaligned
+   ldrh%?\t%0, %1\t@ unaligned
+   ldrh%?\t%0, %1\t@ unaligned"
+  [(set_attr "arch" "t1,t2,32")
+   (set_attr "length" "2,2,4")
+   (set_attr "predicable" "no,yes,yes")
+   (set_attr "predicable_short_it" "no,yes,no")
    (set_attr "type" "load_byte")])
 
 (define_insn "unaligned_storesi"
-  [(set (match_operand:SI 0 "memory_operand" "=Uw,m")
-	(unspec:SI [(match_operand:SI 1 "s_register_operand" "l,r")]
+  [(set (match_operand:SI 0 "memory_operand" "=m,Uw,m")
+	(unspec:SI [(match_operand:SI 1 "s_register_operand" "l,l,r")]
 		   UNSPEC_UNALIGNED_STORE))]
   "unaligned_access"
-  "str%?\t%1, %0\t@ unaligned"
-  [(set_attr "arch" "t2,any")
-   (set_attr "length" "2,4")
-   (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "yes,no")
+  "@
+   str\t%1, %0\t@ unaligned
+   str%?\t%1, %0\t@ unaligned
+   str%?\t%1, %0\t@ unaligned"
+  [(set_attr "arch" "t1,t2,32")
+   (set_attr "length" "2,2,4")
+   (set_attr "predicable" "no,yes,yes")
+   (set_attr "predicable_short_it" "no,yes,no")
    (set_attr "type" "store_4")])
 
 (define_insn "unaligned_storehi"
-  [(set (match_operand:HI 0 "memory_operand" "=Uw,m")
-	(unspec:HI [(match_operand:HI 1 "s_register_operand" "l,r")]
+  [(set (match_operand:HI 0 "memory_operand" "=m,Uw,m")
+	(unspec:HI [(match_operand:HI 1 "s_register_operand" "l,l,r")]
 		   UNSPEC_UNALIGNED_STORE))]
   "unaligned_access"
-  "strh%?\t%1, %0\t@ unaligned"
-  [(set_attr "arch" "t2,any")
-   (set_attr "length" "2,4")
-   (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "yes,no")
+  "@
+   strh\t%1, %0\t@ unaligned
+   strh%?\t%1, %0\t@ unaligned
+   strh%?\t%1, %0\t@ unaligned"
+  [(set_attr "arch" "t1,t2,32")
+   (set_attr "length" "2,2,4")
+   (set_attr "predicable" "no,yes,yes")
+   (set_attr "predicable_short_it" "no,yes,no")
    (set_attr "type" "store_4")])
 
 
@@ -5976,52 +5992,29 @@
         }
     }
 
-  if (ARM_OFFSETS_MUST_BE_WITHIN_SECTIONS_P)
+  split_const (operands[1], &base, &offset);
+  if (INTVAL (offset) != 0
+      && targetm.cannot_force_const_mem (SImode, operands[1]))
     {
-      split_const (operands[1], &base, &offset);
-      if (GET_CODE (base) == SYMBOL_REF
-	  && !offset_within_block_p (base, INTVAL (offset)))
-	{
-	  tmp = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];
-	  emit_move_insn (tmp, base);
-	  emit_insn (gen_addsi3 (operands[0], tmp, offset));
-	  DONE;
-	}
+      tmp = can_create_pseudo_p () ? gen_reg_rtx (SImode) : operands[0];
+      emit_move_insn (tmp, base);
+      emit_insn (gen_addsi3 (operands[0], tmp, offset));
+      DONE;
     }
 
+  tmp = can_create_pseudo_p () ? NULL_RTX : operands[0];
+
   /* Recognize the case where operand[1] is a reference to thread-local
-     data and load its address to a register.  */
+     data and load its address to a register.  Offsets have been split off
+     already.  */
   if (arm_tls_referenced_p (operands[1]))
-    {
-      rtx tmp = operands[1];
-      rtx addend = NULL;
-
-      if (GET_CODE (tmp) == CONST && GET_CODE (XEXP (tmp, 0)) == PLUS)
-        {
-          addend = XEXP (XEXP (tmp, 0), 1);
-          tmp = XEXP (XEXP (tmp, 0), 0);
-        }
-
-      gcc_assert (GET_CODE (tmp) == SYMBOL_REF);
-      gcc_assert (SYMBOL_REF_TLS_MODEL (tmp) != 0);
-
-      tmp = legitimize_tls_address (tmp,
-				    !can_create_pseudo_p () ? operands[0] : 0);
-      if (addend)
-        {
-          tmp = gen_rtx_PLUS (SImode, tmp, addend);
-          tmp = force_operand (tmp, operands[0]);
-        }
-      operands[1] = tmp;
-    }
+    operands[1] = legitimize_tls_address (operands[1], tmp);
   else if (flag_pic
 	   && (CONSTANT_P (operands[1])
 	       || symbol_mentioned_p (operands[1])
 	       || label_mentioned_p (operands[1])))
-      operands[1] = legitimize_pic_address (operands[1], SImode,
-					    (!can_create_pseudo_p ()
-					     ? operands[0]
-					     : 0));
+    operands[1] =
+      legitimize_pic_address (operands[1], SImode, tmp);
   }
   "
 )
Index: gcc/config/darwin-driver.c
===================================================================
diff --git a/gcc/config/darwin-driver.c b/gcc/config/darwin-driver.c
--- a/gcc/config/darwin-driver.c	(revision 278653)
+++ b/gcc/config/darwin-driver.c	(revision 278653)
@@ -26,6 +26,91 @@
 #include "opts.h"
 #include "diagnostic-core.h"
 
+/* Validate a version string (either given on the command line or, perhaps
+   as MACOSX_DEPLOYMENT_TARGET).
+
+   The specs %version-compare() function doesn't accept leading '0' on
+   numbers so strip them out.  Do sanity checking here too.
+
+   Return:
+     * original string means it was OK and we didn't want to change it.
+     * new string means it was OK but we rewrote it to avoid possible format
+     problems.
+     * NULL means we didn't like what we saw.
+*/
+
+static const char *
+validate_macosx_version_min (const char *version_str)
+{
+  size_t version_len;
+  unsigned long major, minor, tiny = 0;
+  char *end;
+  const char *old_version = version_str;
+  bool need_rewrite = false;
+
+  version_len = strlen (version_str);
+  if (version_len < 4) /* The minimum would be 10.x  */
+    return NULL;
+
+  /* Version string must consist of digits and periods only.  */
+  if (strspn (version_str, "0123456789.") != version_len)
+    return NULL;
+
+  if (!ISDIGIT (version_str[0]) || !ISDIGIT (version_str[version_len - 1]))
+    return NULL;
+
+  if (version_str[0] == '0')
+    need_rewrite = true;
+
+  major = strtoul (version_str, &end, 10);
+  version_str = end + ((*end == '.') ? 1 : 0);
+
+  if (major != 10) /* So far .. all MacOS 10 ... */
+    return NULL;
+
+  /* Version string components must be present and numeric.  */
+  if (!ISDIGIT (version_str[0]))
+    return NULL;
+
+  /* If we have one or more leading zeros on a component, then rewrite the
+     version string.  */
+  if (version_str[0] == '0' && version_str[1] != '\0'
+      && version_str[1] != '.')
+    need_rewrite = true;
+
+  minor = strtoul (version_str, &end, 10);
+  version_str = end + ((*end == '.') ? 1 : 0);
+  if (minor > 99)
+    return NULL;
+
+  /* If 'tiny' is present it must be numeric.  */
+  if (*end != '\0' && !ISDIGIT (version_str[0]))
+    return NULL;
+
+  /* If we have one or more leading zeros on a component, then rewrite the
+     version string.  */
+  if (*end != '\0' && version_str[0] == '0'
+      && version_str[1] != '\0')
+    need_rewrite = true;
+
+  tiny = strtoul (version_str, &end, 10);
+  if (tiny > 99)
+    return NULL;
+
+  /* Version string must contain no more than three tokens.  */
+  if (*end != '\0')
+    return NULL;
+
+  if (need_rewrite)
+    {
+      char *new_version;
+      asprintf (&new_version, "10.%lu.%lu", minor, tiny);
+      return new_version;
+    }
+
+  return old_version;
+}
+
 #ifndef CROSS_DIRECTORY_STRUCTURE
 #include <sys/sysctl.h>
 #include "xregex.h"
@@ -114,16 +199,39 @@
 
   if (new_flag != NULL)
     {
-      size_t len = strlen (new_flag);
-      if (len > 128) { /* Arbitrary limit, number should be like xx.yy.zz */
-	warning (0, "couldn%'t understand version %s\n", new_flag);
-	return NULL;
-      }
-      new_flag = xstrndup (new_flag, len);
+      const char *checked = validate_macosx_version_min (new_flag);
+      if (checked == NULL)
+	{
+	  warning (0, "couldn%'t understand version %s\n", new_flag);
+	  return NULL;
+	}
+      new_flag = xstrndup (checked, strlen (checked));
     }
   return new_flag;
 }
 
+/* See if we can find the sysroot from the SDKROOT environment variable.  */
+
+static const char *
+maybe_get_sysroot_from_sdkroot ()
+{
+  const char *maybe_sysroot = getenv ("SDKROOT");
+
+  /* We'll use the same rules as the clang driver, for compatibility.
+     1) The path must be absolute
+     2) Ignore "/", that is the default anyway and we do not want the
+	sysroot semantics to be applied to it.
+     3) It must exist (actually, we'll check it's readable too).  */
+
+   if (maybe_sysroot  == NULL
+       || *maybe_sysroot != '/'
+       || strlen (maybe_sysroot) == 1
+       || access (maybe_sysroot, R_OK) == -1)
+    return NULL;
+
+  return xstrndup (maybe_sysroot, strlen (maybe_sysroot));
+}
+
 /* Translate -filelist and -framework options in *DECODED_OPTIONS
    (size *DECODED_OPTIONS_COUNT) to use -Xlinker so that they are
    considered to be linker inputs in the case that no other inputs are
@@ -148,6 +256,7 @@
   bool appendM64 = false;
   const char *vers_string = NULL;
   bool seen_version_min = false;
+  bool seen_sysroot_p = false;
 
   for (i = 1; i < *decoded_options_count; i++)
     {
@@ -175,7 +284,7 @@
 	  if (*decoded_options_count > i) {
 	    memmove (*decoded_options + i,
 		     *decoded_options + i + 1,
-		     ((*decoded_options_count - i)
+		     ((*decoded_options_count - i - 1)
 		      * sizeof (struct cl_decoded_option)));
 	  }
 	  --i;
@@ -209,8 +318,30 @@
 
 	case OPT_mmacosx_version_min_:
 	  seen_version_min = true;
-	  vers_string = xstrndup ((*decoded_options)[i].arg, 32);
+	  vers_string =
+	    validate_macosx_version_min ((*decoded_options)[i].arg);
+	  if (vers_string == NULL)
+	    warning (0, "%qs is not valid for %<mmacosx-version-min%>\n",
+		     (*decoded_options)[i].arg);
+	  else if (vers_string == (*decoded_options)[i].arg)
+	    vers_string = xstrndup ((*decoded_options)[i].arg, 32);
+	  /* Now we've examined it, and verified/re-written, put it to
+	     one side and append later.  */
+	  if (*decoded_options_count > i) {
+	    memmove (*decoded_options + i,
+		     *decoded_options + i + 1,
+		     ((*decoded_options_count - i - 1)
+		      * sizeof (struct cl_decoded_option)));
+	  }
+	  --i;
+	  --*decoded_options_count;
+	  break;
 
+	case OPT__sysroot_:
+	case OPT_isysroot:
+	  seen_sysroot_p = true;
+	  break;
+
 	default:
 	  break;
 	}
@@ -272,26 +403,40 @@
 		       &(*decoded_options)[*decoded_options_count - 1]);
     }
 
-  /* We will need to know the OS X version we're trying to build for here
-     so that we can figure out the mechanism and source for the sysroot to
-     be used.  */
-  if (! seen_version_min && *decoded_options_count > 1)
+  if (! seen_sysroot_p)
     {
-      /* Not set by the User, try to figure it out.  */
-      vers_string = darwin_default_min_version ();
-      if (vers_string != NULL)
+      /* We will pick up an SDKROOT if we didn't specify a sysroot and treat
+	 it as overriding any configure-time --with-sysroot.  */
+       const char *sdkroot = maybe_get_sysroot_from_sdkroot ();
+       if (sdkroot)
 	{
 	  ++*decoded_options_count;
 	  *decoded_options = XRESIZEVEC (struct cl_decoded_option,
 					 *decoded_options,
 					 *decoded_options_count);
-	  generate_option (OPT_mmacosx_version_min_, vers_string, 1, CL_DRIVER,
-			  &(*decoded_options)[*decoded_options_count - 1]);
+	  generate_option (OPT__sysroot_, sdkroot, 1, CL_DRIVER,
+			   &(*decoded_options)[*decoded_options_count - 1]);
 	}
     }
-  /* Create and push the major version for assemblers that need it.  */
+
+  /* We will need to know the OS X version we're trying to build for here
+     so that we can figure out the mechanism and source for the sysroot to
+     be used.  */
+  if (! seen_version_min && *decoded_options_count > 1)
+    /* Not set by the User, try to figure it out.  */
+    vers_string = darwin_default_min_version ();
+
+  /* Create and push a cleaned up version, plus the major version for
+     assemblers and other cases that need it.  */
   if (vers_string != NULL)
     {
+       ++*decoded_options_count;
+       *decoded_options = XRESIZEVEC (struct cl_decoded_option,
+				      *decoded_options,
+				      *decoded_options_count);
+      generate_option (OPT_mmacosx_version_min_, vers_string, 1, CL_DRIVER,
+		       &(*decoded_options)[*decoded_options_count - 1]);
+
       char *asm_major = NULL;
       const char *first_period = strchr(vers_string, '.');
       if (first_period != NULL)
Index: gcc/config/pa/pa.md
===================================================================
diff --git a/gcc/config/pa/pa.md b/gcc/config/pa/pa.md
--- a/gcc/config/pa/pa.md	(revision 278653)
+++ b/gcc/config/pa/pa.md	(revision 278653)
@@ -5319,8 +5319,8 @@
 
 (define_insn "umulsidi3"
   [(set (match_operand:DI 0 "register_operand" "=f")
-	(mult:DI (zero_extend:DI (match_operand:SI 1 "nonimmediate_operand" "f"))
-		 (zero_extend:DI (match_operand:SI 2 "nonimmediate_operand" "f"))))]
+	(mult:DI (zero_extend:DI (match_operand:SI 1 "register_operand" "f"))
+		 (zero_extend:DI (match_operand:SI 2 "register_operand" "f"))))]
   "TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT"
   "xmpyu %1,%2,%0"
   [(set_attr "type" "fpmuldbl")
@@ -5328,7 +5328,7 @@
 
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=f")
-	(mult:DI (zero_extend:DI (match_operand:SI 1 "nonimmediate_operand" "f"))
+	(mult:DI (zero_extend:DI (match_operand:SI 1 "register_operand" "f"))
 		 (match_operand:DI 2 "uint32_operand" "f")))]
   "TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT && !TARGET_64BIT"
   "xmpyu %1,%R2,%0"
@@ -5337,7 +5337,7 @@
 
 (define_insn ""
   [(set (match_operand:DI 0 "register_operand" "=f")
-	(mult:DI (zero_extend:DI (match_operand:SI 1 "nonimmediate_operand" "f"))
+	(mult:DI (zero_extend:DI (match_operand:SI 1 "register_operand" "f"))
 		 (match_operand:DI 2 "uint32_operand" "f")))]
   "TARGET_PA_11 && ! TARGET_DISABLE_FPREGS && ! TARGET_SOFT_FLOAT && TARGET_64BIT"
   "xmpyu %1,%2R,%0"
@@ -6904,21 +6904,24 @@
   rtx stack = operands[2];
   rtx fp = operands[3];
 
-  lab = copy_to_reg (lab);
-
   emit_clobber (gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode)));
   emit_clobber (gen_rtx_MEM (BLKmode, hard_frame_pointer_rtx));
 
-  /* Restore the frame pointer.  The virtual_stack_vars_rtx is saved
-     instead of the hard_frame_pointer_rtx in the save area.  As a
-     result, an extra instruction is needed to adjust for the offset
+  lab = copy_to_reg (lab);
+
+  /* Restore the stack and frame pointers.  The virtual_stack_vars_rtx
+     is saved instead of the hard_frame_pointer_rtx in the save area.
+     As a result, an extra instruction is needed to adjust for the offset
      of the virtual stack variables and the hard frame pointer.  */
-  if (GET_CODE (fp) != REG)
-    fp = force_reg (Pmode, fp);
+  fp = copy_to_reg (fp);
+  emit_stack_restore (SAVE_NONLOCAL, stack);
+
+  /* Ensure the frame pointer move is not optimized.  */
+  emit_insn (gen_blockage ());
+  emit_clobber (hard_frame_pointer_rtx);
+  emit_clobber (frame_pointer_rtx);
   emit_move_insn (hard_frame_pointer_rtx, plus_constant (Pmode, fp, -8));
 
-  emit_stack_restore (SAVE_NONLOCAL, stack);
-
   emit_use (hard_frame_pointer_rtx);
   emit_use (stack_pointer_rtx);
 
@@ -8695,23 +8698,26 @@
   emit_clobber (gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (VOIDmode)));
   emit_clobber (gen_rtx_MEM (BLKmode, hard_frame_pointer_rtx));
 
-  /* Restore the frame pointer.  The virtual_stack_vars_rtx is saved
-     instead of the hard_frame_pointer_rtx in the save area.  We need
-     to adjust for the offset between these two values.  */
-  if (GET_CODE (fp) != REG)
-    fp = force_reg (Pmode, fp);
+  /* Load the label we are jumping through into r1 so that we know
+     where to look for it when we get back to setjmp's function for
+     restoring the gp.  */
+  emit_move_insn (pv, lab);
+
+  /* Restore the stack and frame pointers.  The virtual_stack_vars_rtx
+     is saved instead of the hard_frame_pointer_rtx in the save area.
+     We need to adjust for the offset between these two values.  */
+  fp = copy_to_reg (fp);
+  emit_stack_restore (SAVE_NONLOCAL, stack);
+
+  /* Ensure the frame pointer move is not optimized.  */
+  emit_insn (gen_blockage ());
+  emit_clobber (hard_frame_pointer_rtx);
+  emit_clobber (frame_pointer_rtx);
   emit_move_insn (hard_frame_pointer_rtx, plus_constant (Pmode, fp, -8));
 
-  /* This bit is the same as expand_builtin_longjmp.  */
-  emit_stack_restore (SAVE_NONLOCAL, stack);
   emit_use (hard_frame_pointer_rtx);
   emit_use (stack_pointer_rtx);
 
-  /* Load the label we are jumping through into r1 so that we know
-     where to look for it when we get back to setjmp's function for
-     restoring the gp.  */
-  emit_move_insn (pv, lab);
-
   /* Prevent the insns above from being scheduled into the delay slot
      of the interspace jump because the space register could change.  */
   emit_insn (gen_blockage ());
@@ -10085,23 +10091,55 @@
    (set_attr "length" "4,16")])
 
 ;; PA 2.0 hardware supports out-of-order execution of loads and stores, so
-;; we need a memory barrier to enforce program order for memory references.
-;; Since we want PA 1.x code to be PA 2.0 compatible, we also need the
-;; barrier when generating PA 1.x code.
+;; we need memory barriers to enforce program order for memory references
+;; when the TLB and PSW O bits are not set.  We assume all PA 2.0 systems
+;; are weakly ordered since neither HP-UX or Linux set the PSW O bit.  Since
+;; we want PA 1.x code to be PA 2.0 compatible, we also need barriers when
+;; generating PA 1.x code even though all PA 1.x systems are strongly ordered.
 
+;; When barriers are needed, we use a strongly ordered ldcw instruction as
+;; the barrier.  Most PA 2.0 targets are cache coherent.  In that case, we
+;; can use the coherent cache control hint and avoid aligning the ldcw
+;; address.  In spite of its description, it is not clear that the sync
+;; instruction works as a barrier.
+
 (define_expand "memory_barrier"
-  [(set (match_dup 0)
-        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))]
+  [(parallel
+     [(set (match_dup 0) (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))
+      (clobber (match_dup 1))])]
   ""
 {
-  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  /* We don't need a barrier if the target uses ordered memory references.  */
+  if (TARGET_ORDERED)
+    FAIL;
+  operands[1] = gen_reg_rtx (Pmode);
+  operands[0] = gen_rtx_MEM (BLKmode, operands[1]);
   MEM_VOLATILE_P (operands[0]) = 1;
 })
 
-(define_insn "*memory_barrier"
+(define_insn "*memory_barrier_coherent"
   [(set (match_operand:BLK 0 "" "")
-        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))]
+        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))
+   (clobber (match_operand 1 "pmode_register_operand" "=r"))]
+  "TARGET_PA_20 && TARGET_COHERENT_LDCW"
+  "ldcw,co 0(%%sp),%1"
+  [(set_attr "type" "binary")
+   (set_attr "length" "4")])
+
+(define_insn "*memory_barrier_64"
+  [(set (match_operand:BLK 0 "" "")
+        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))
+    (clobber (match_operand 1 "pmode_register_operand" "=&r"))]
+  "TARGET_64BIT"
+  "ldo 15(%%sp),%1\n\tdepd %%r0,63,3,%1\n\tldcw 0(%1),%1"
+  [(set_attr "type" "binary")
+   (set_attr "length" "12")])
+
+(define_insn "*memory_barrier_32"
+  [(set (match_operand:BLK 0 "" "")
+        (unspec:BLK [(match_dup 0)] UNSPEC_MEMORY_BARRIER))
+    (clobber (match_operand 1 "pmode_register_operand" "=&r"))]
   ""
-  "sync"
+  "ldo 15(%%sp),%1\n\t{dep|depw} %%r0,31,3,%1\n\tldcw 0(%1),%1"
   [(set_attr "type" "binary")
-   (set_attr "length" "4")])
+   (set_attr "length" "12")])
Index: gcc/config/pa/pa.opt
===================================================================
diff --git a/gcc/config/pa/pa.opt b/gcc/config/pa/pa.opt
--- a/gcc/config/pa/pa.opt	(revision 278653)
+++ b/gcc/config/pa/pa.opt	(revision 278653)
@@ -45,6 +45,10 @@
 Target Report Mask(CALLER_COPIES)
 Caller copies function arguments passed by hidden reference.
 
+mcoherent-ldcw
+Target Report Var(TARGET_COHERENT_LDCW) Init(1)
+Use ldcw/ldcd coherent cache-control hint.
+
 mdisable-fpregs
 Target Report Mask(DISABLE_FPREGS)
 Disable FP regs.
@@ -90,6 +94,10 @@
 Target RejectNegative Report Mask(NO_SPACE_REGS)
 Disable space regs.
 
+mordered
+Target Report Var(TARGET_ORDERED) Init(0)
+Assume memory references are ordered and barriers are not needed.
+
 mpa-risc-1-0
 Target RejectNegative
 Generate PA1.0 code.
Index: gcc/config/pa/pa-protos.h
===================================================================
diff --git a/gcc/config/pa/pa-protos.h b/gcc/config/pa/pa-protos.h
--- a/gcc/config/pa/pa-protos.h	(revision 278653)
+++ b/gcc/config/pa/pa-protos.h	(revision 278653)
@@ -108,5 +108,6 @@
 extern void pa_hpux_asm_output_external (FILE *, tree, const char *);
 extern HOST_WIDE_INT pa_initial_elimination_offset (int, int);
 extern HOST_WIDE_INT pa_function_arg_size (machine_mode, const_tree);
+extern void pa_output_function_label (FILE *);
 
 extern const int pa_magic_milli[];
Index: gcc/config/pa/pa.c
===================================================================
diff --git a/gcc/config/pa/pa.c b/gcc/config/pa/pa.c
--- a/gcc/config/pa/pa.c	(revision 278653)
+++ b/gcc/config/pa/pa.c	(revision 278653)
@@ -118,11 +118,11 @@
 static rtx pa_function_value (const_tree, const_tree, bool);
 static rtx pa_libcall_value (machine_mode, const_rtx);
 static bool pa_function_value_regno_p (const unsigned int);
-static void pa_output_function_prologue (FILE *);
+static void pa_output_function_prologue (FILE *) ATTRIBUTE_UNUSED;
+static void pa_linux_output_function_prologue (FILE *) ATTRIBUTE_UNUSED;
 static void update_total_code_bytes (unsigned int);
 static void pa_output_function_epilogue (FILE *);
 static int pa_adjust_cost (rtx_insn *, int, rtx_insn *, int, unsigned int);
-static int pa_adjust_priority (rtx_insn *, int);
 static int pa_issue_rate (void);
 static int pa_reloc_rw_mask (void);
 static void pa_som_asm_init_sections (void) ATTRIBUTE_UNUSED;
@@ -263,8 +263,6 @@
 #undef TARGET_ASM_INTEGER
 #define TARGET_ASM_INTEGER pa_assemble_integer
 
-#undef TARGET_ASM_FUNCTION_PROLOGUE
-#define TARGET_ASM_FUNCTION_PROLOGUE pa_output_function_prologue
 #undef TARGET_ASM_FUNCTION_EPILOGUE
 #define TARGET_ASM_FUNCTION_EPILOGUE pa_output_function_epilogue
 
@@ -280,8 +278,6 @@
 
 #undef TARGET_SCHED_ADJUST_COST
 #define TARGET_SCHED_ADJUST_COST pa_adjust_cost
-#undef TARGET_SCHED_ADJUST_PRIORITY
-#define TARGET_SCHED_ADJUST_PRIORITY pa_adjust_priority
 #undef TARGET_SCHED_ISSUE_RATE
 #define TARGET_SCHED_ISSUE_RATE pa_issue_rate
 
@@ -3842,16 +3838,10 @@
 	  & ~(PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT - 1));
 }
 
-/* On HP-PA, move-double insns between fpu and cpu need an 8-byte block
-   of memory.  If any fpu reg is used in the function, we allocate
-   such a block here, at the bottom of the frame, just in case it's needed.
+/* Output function label, and associated .PROC and .CALLINFO statements.  */
 
-   If this function is a leaf procedure, then we may choose not
-   to do a "save" insn.  The decision about whether or not
-   to do this is made in regclass.c.  */
-
-static void
-pa_output_function_prologue (FILE *file)
+void
+pa_output_function_label (FILE *file)
 {
   /* The function's label and associated .PROC must never be
      separated and must be output *after* any profiling declarations
@@ -3897,10 +3887,25 @@
     fprintf (file, ",ENTRY_FR=%d", fr_saved + 11);
 
   fputs ("\n\t.ENTRY\n", file);
+}
 
+/* Output function prologue.  */
+
+static void
+pa_output_function_prologue (FILE *file)
+{
+  pa_output_function_label (file);
   remove_useless_addtr_insns (0);
 }
 
+/* The label is output by ASM_DECLARE_FUNCTION_NAME on linux.  */
+
+static void
+pa_linux_output_function_prologue (FILE *file ATTRIBUTE_UNUSED)
+{
+  remove_useless_addtr_insns (0);
+}
+
 void
 pa_expand_prologue (void)
 {
@@ -4569,10 +4574,6 @@
 void
 hppa_profile_hook (int label_no)
 {
-  /* We use SImode for the address of the function in both 32 and
-     64-bit code to avoid having to provide DImode versions of the
-     lcla2 and load_offset_label_address insn patterns.  */
-  rtx reg = gen_reg_rtx (SImode);
   rtx_code_label *label_rtx = gen_label_rtx ();
   int reg_parm_stack_space = REG_PARM_STACK_SPACE (NULL_TREE);
   rtx arg_bytes, begin_label_rtx, mcount, sym;
@@ -4604,18 +4605,13 @@
   if (!use_mcount_pcrel_call)
     {
       /* The address of the function is loaded into %r25 with an instruction-
-	 relative sequence that avoids the use of relocations.  The sequence
-	 is split so that the load_offset_label_address instruction can
-	 occupy the delay slot of the call to _mcount.  */
+	 relative sequence that avoids the use of relocations.  We use SImode
+	 for the address of the function in both 32 and 64-bit code to avoid
+	 having to provide DImode versions of the lcla2 pattern.  */
       if (TARGET_PA_20)
-	emit_insn (gen_lcla2 (reg, label_rtx));
+	emit_insn (gen_lcla2 (gen_rtx_REG (SImode, 25), label_rtx));
       else
-	emit_insn (gen_lcla1 (reg, label_rtx));
-
-      emit_insn (gen_load_offset_label_address (gen_rtx_REG (SImode, 25), 
-						reg,
-						begin_label_rtx,
-						label_rtx));
+	emit_insn (gen_lcla1 (gen_rtx_REG (SImode, 25), label_rtx));
     }
 
   if (!NO_DEFERRED_PROFILE_COUNTERS)
@@ -4992,37 +4988,6 @@
     }
 }
 
-/* Adjust scheduling priorities.  We use this to try and keep addil
-   and the next use of %r1 close together.  */
-static int
-pa_adjust_priority (rtx_insn *insn, int priority)
-{
-  rtx set = single_set (insn);
-  rtx src, dest;
-  if (set)
-    {
-      src = SET_SRC (set);
-      dest = SET_DEST (set);
-      if (GET_CODE (src) == LO_SUM
-	  && symbolic_operand (XEXP (src, 1), VOIDmode)
-	  && ! read_only_operand (XEXP (src, 1), VOIDmode))
-	priority >>= 3;
-
-      else if (GET_CODE (src) == MEM
-	       && GET_CODE (XEXP (src, 0)) == LO_SUM
-	       && symbolic_operand (XEXP (XEXP (src, 0), 1), VOIDmode)
-	       && ! read_only_operand (XEXP (XEXP (src, 0), 1), VOIDmode))
-	priority >>= 1;
-
-      else if (GET_CODE (dest) == MEM
-	       && GET_CODE (XEXP (dest, 0)) == LO_SUM
-	       && symbolic_operand (XEXP (XEXP (dest, 0), 1), VOIDmode)
-	       && ! read_only_operand (XEXP (XEXP (dest, 0), 1), VOIDmode))
-	priority >>= 3;
-    }
-  return priority;
-}
-
 /* The 700 can only issue a single insn at a time.
    The 7XXX processors can issue two insns at a time.
    The 8000 can issue 4 insns at a time.  */
@@ -7888,7 +7853,7 @@
 
   /* 64-bit plabel sequence.  */
   else if (TARGET_64BIT && !local_call)
-    length += sibcall ? 28 : 24;
+    length += 24;
 
   /* non-pic long absolute branch sequence.  */
   else if ((TARGET_LONG_ABS_CALL || local_call) && !flag_pic)
@@ -7960,12 +7925,9 @@
 	  xoperands[0] = pa_get_deferred_plabel (call_dest);
 	  xoperands[1] = gen_label_rtx ();
 
-	  /* If this isn't a sibcall, we put the load of %r27 into the
-	     delay slot.  We can't do this in a sibcall as we don't
-	     have a second call-clobbered scratch register available.
-	     We don't need to do anything when generating fast indirect
-	     calls.  */
-	  if (seq_length != 0 && !sibcall)
+	  /* Put the load of %r27 into the delay slot.  We don't need to
+	     do anything when generating fast indirect calls.  */
+	  if (seq_length != 0)
 	    {
 	      final_scan_insn (NEXT_INSN (insn), asm_out_file,
 			       optimize, 0, NULL);
@@ -7972,26 +7934,15 @@
 
 	      /* Now delete the delay insn.  */
 	      SET_INSN_DELETED (NEXT_INSN (insn));
-	      seq_length = 0;
 	    }
 
 	  output_asm_insn ("addil LT'%0,%%r27", xoperands);
 	  output_asm_insn ("ldd RT'%0(%%r1),%%r1", xoperands);
 	  output_asm_insn ("ldd 0(%%r1),%%r1", xoperands);
-
-	  if (sibcall)
-	    {
-	      output_asm_insn ("ldd 24(%%r1),%%r27", xoperands);
-	      output_asm_insn ("ldd 16(%%r1),%%r1", xoperands);
-	      output_asm_insn ("bve (%%r1)", xoperands);
-	    }
-	  else
-	    {
-	      output_asm_insn ("ldd 16(%%r1),%%r2", xoperands);
-	      output_asm_insn ("bve,l (%%r2),%%r2", xoperands);
-	      output_asm_insn ("ldd 24(%%r1),%%r27", xoperands);
-	      seq_length = 1;
-	    }
+	  output_asm_insn ("ldd 16(%%r1),%%r2", xoperands);
+	  output_asm_insn ("bve,l (%%r2),%%r2", xoperands);
+	  output_asm_insn ("ldd 24(%%r1),%%r27", xoperands);
+	  seq_length = 1;
 	}
       else
 	{
@@ -8084,20 +8035,22 @@
 		    {
 		      output_asm_insn ("addil LT'%0,%%r19", xoperands);
 		      output_asm_insn ("ldw RT'%0(%%r1),%%r1", xoperands);
-		      output_asm_insn ("ldw 0(%%r1),%%r1", xoperands);
+		      output_asm_insn ("ldw 0(%%r1),%%r22", xoperands);
 		    }
 		  else
 		    {
 		      output_asm_insn ("addil LR'%0-$global$,%%r27",
 				       xoperands);
-		      output_asm_insn ("ldw RR'%0-$global$(%%r1),%%r1",
+		      output_asm_insn ("ldw RR'%0-$global$(%%r1),%%r22",
 				       xoperands);
 		    }
 
-		  output_asm_insn ("bb,>=,n %%r1,30,.+16", xoperands);
-		  output_asm_insn ("depi 0,31,2,%%r1", xoperands);
-		  output_asm_insn ("ldw 4(%%sr0,%%r1),%%r19", xoperands);
-		  output_asm_insn ("ldw 0(%%sr0,%%r1),%%r1", xoperands);
+		  output_asm_insn ("bb,>=,n %%r22,30,.+16", xoperands);
+		  output_asm_insn ("depi 0,31,2,%%r22", xoperands);
+		  /* Should this be an ordered load to ensure the target
+	             address is loaded before the global pointer?  */
+		  output_asm_insn ("ldw 0(%%r22),%%r1", xoperands);
+		  output_asm_insn ("ldw 4(%%r22),%%r19", xoperands);
 
 		  if (!sibcall && !TARGET_PA_20)
 		    {
@@ -8190,10 +8143,6 @@
   if (TARGET_PORTABLE_RUNTIME)
     return 16;
 
-  /* Inline version of $$dyncall.  */
-  if ((TARGET_NO_SPACE_REGS || TARGET_PA_20) && !optimize_size)
-    return 20;
-
   if (!TARGET_LONG_CALLS
       && ((TARGET_PA_20 && !TARGET_SOM && distance < 7600000)
 	  || distance < MAX_PCREL17F_OFFSET))
@@ -8203,13 +8152,16 @@
   if (!flag_pic)
     return 12;
 
-  /* Inline version of $$dyncall.  */
-  if (TARGET_NO_SPACE_REGS || TARGET_PA_20)
-    return 20;
-
+  /* Inline versions of $$dyncall.  */
   if (!optimize_size)
-    return 36;
+    {
+      if (TARGET_NO_SPACE_REGS)
+	return 28;
 
+      if (TARGET_PA_20)
+	return 32;
+    }
+
   /* Long PIC pc-relative call.  */
   return 20;
 }
@@ -8246,22 +8198,6 @@
       return "blr %%r0,%%r2\n\tbv,n %%r0(%%r31)";
     }
 
-  /* Maybe emit a fast inline version of $$dyncall.  */
-  if ((TARGET_NO_SPACE_REGS || TARGET_PA_20) && !optimize_size)
-    {
-      output_asm_insn ("bb,>=,n %%r22,30,.+12\n\t"
-		       "ldw 2(%%r22),%%r19\n\t"
-		       "ldw -2(%%r22),%%r22", xoperands);
-      pa_output_arg_descriptor (insn);
-      if (TARGET_NO_SPACE_REGS)
-	{
-	  if (TARGET_PA_20)
-	    return "bve,l,n (%%r22),%%r2\n\tnop";
-	  return "ble 0(%%sr4,%%r22)\n\tcopy %%r31,%%r2";
-	}
-      return "bve,l (%%r22),%%r2\n\tstw %%r2,-24(%%sp)";
-    }
-
   /* Now the normal case -- we can reach $$dyncall directly or
      we're sure that we can get there via a long-branch stub. 
 
@@ -8290,35 +8226,40 @@
       return "ble R'$$dyncall(%%sr4,%%r2)\n\tcopy %%r31,%%r2";
     }
 
-  /* Maybe emit a fast inline version of $$dyncall.  The long PIC
-     pc-relative call sequence is five instructions.  The inline PA 2.0
-     version of $$dyncall is also five instructions.  The PA 1.X versions
-     are longer but still an overall win.  */
-  if (TARGET_NO_SPACE_REGS || TARGET_PA_20 || !optimize_size)
+  /* The long PIC pc-relative call sequence is five instructions.  So,
+     let's use an inline version of $$dyncall when the calling sequence
+     has a roughly similar number of instructions and we are not optimizing
+     for size.  We need two instructions to load the return pointer plus
+     the $$dyncall implementation.  */
+  if (!optimize_size)
     {
-      output_asm_insn ("bb,>=,n %%r22,30,.+12\n\t"
-		       "ldw 2(%%r22),%%r19\n\t"
-		       "ldw -2(%%r22),%%r22", xoperands);
       if (TARGET_NO_SPACE_REGS)
 	{
 	  pa_output_arg_descriptor (insn);
-	  if (TARGET_PA_20)
-	    return "bve,l,n (%%r22),%%r2\n\tnop";
-	  return "ble 0(%%sr4,%%r22)\n\tcopy %%r31,%%r2";
+	  output_asm_insn ("bl .+8,%%r2\n\t"
+			   "ldo 20(%%r2),%%r2\n\t"
+			   "extru,<> %%r22,30,1,%%r0\n\t"
+			   "bv,n %%r0(%%r22)\n\t"
+			   "ldw -2(%%r22),%%r21\n\t"
+			   "bv %%r0(%%r21)\n\t"
+			   "ldw 2(%%r22),%%r19", xoperands);
+	  return "";
 	}
       if (TARGET_PA_20)
 	{
 	  pa_output_arg_descriptor (insn);
-	  return "bve,l (%%r22),%%r2\n\tstw %%r2,-24(%%sp)";
+	  output_asm_insn ("bl .+8,%%r2\n\t"
+			   "ldo 24(%%r2),%%r2\n\t"
+			   "stw %%r2,-24(%%sp)\n\t"
+			   "extru,<> %r22,30,1,%%r0\n\t"
+			   "bve,n (%%r22)\n\t"
+			   "ldw -2(%%r22),%%r21\n\t"
+			   "bve (%%r21)\n\t"
+			   "ldw 2(%%r22),%%r19", xoperands);
+	  return "";
 	}
-      output_asm_insn ("bl .+8,%%r2\n\t"
-		       "ldo 16(%%r2),%%r2\n\t"
-		       "ldsid (%%r22),%%r1\n\t"
-		       "mtsp %%r1,%%sr0", xoperands);
-      pa_output_arg_descriptor (insn);
-      return "be 0(%%sr0,%%r22)\n\tstw %%r2,-24(%%sp)";
     }
- 
+
   /* We need a long PIC call to $$dyncall.  */
   xoperands[0] = gen_rtx_SYMBOL_REF (Pmode, "$$dyncall");
   xoperands[1] = gen_rtx_REG (Pmode, 2);
@@ -10039,10 +9980,11 @@
   /* There is no way to load QImode or HImode values directly from memory
      to a FP register.  SImode loads to the FP registers are not zero
      extended.  On the 64-bit target, this conflicts with the definition
-     of LOAD_EXTEND_OP.  Thus, we can't allow changing between modes with
-     different sizes in the floating-point registers.  */
+     of LOAD_EXTEND_OP.  Thus, we reject all mode changes in the FP registers
+     except for DImode to SImode on the 64-bit target.  It is handled by
+     register renaming in pa_print_operand.  */
   if (MAYBE_FP_REG_CLASS_P (rclass))
-    return false;
+    return TARGET_64BIT && from == DImode && to == SImode;
 
   /* TARGET_HARD_REGNO_MODE_OK places modes with sizes larger than a word
      in specific sets of registers.  Thus, we cannot allow changing
@@ -10076,7 +10018,7 @@
 
 /* Length in units of the trampoline instruction code.  */
 
-#define TRAMPOLINE_CODE_SIZE (TARGET_64BIT ? 24 : (TARGET_PA_20 ? 32 : 40))
+#define TRAMPOLINE_CODE_SIZE (TARGET_64BIT ? 24 : (TARGET_PA_20 ? 36 : 48))
 
 
 /* Output assembler code for a block containing the constant parts
@@ -10097,27 +10039,46 @@
 {
   if (!TARGET_64BIT)
     {
-      fputs ("\tldw	36(%r22),%r21\n", f);
-      fputs ("\tbb,>=,n	%r21,30,.+16\n", f);
-      if (ASSEMBLER_DIALECT == 0)
-	fputs ("\tdepi	0,31,2,%r21\n", f);
-      else
-	fputs ("\tdepwi	0,31,2,%r21\n", f);
-      fputs ("\tldw	4(%r21),%r19\n", f);
-      fputs ("\tldw	0(%r21),%r21\n", f);
       if (TARGET_PA_20)
 	{
-	  fputs ("\tbve	(%r21)\n", f);
-	  fputs ("\tldw	40(%r22),%r29\n", f);
+	  fputs ("\tmfia	%r20\n", f);
+	  fputs ("\tldw		48(%r20),%r22\n", f);
+	  fputs ("\tcopy	%r22,%r21\n", f);
+	  fputs ("\tbb,>=,n	%r22,30,.+16\n", f);
+	  fputs ("\tdepwi	0,31,2,%r22\n", f);
+	  fputs ("\tldw		0(%r22),%r21\n", f);
+	  fputs ("\tldw		4(%r22),%r19\n", f);
+	  fputs ("\tbve		(%r21)\n", f);
+	  fputs ("\tldw		52(%r1),%r29\n", f);
 	  fputs ("\t.word	0\n", f);
 	  fputs ("\t.word	0\n", f);
+	  fputs ("\t.word	0\n", f);
 	}
       else
 	{
+	  if (ASSEMBLER_DIALECT == 0)
+	    {
+	      fputs ("\tbl	.+8,%r20\n", f);
+	      fputs ("\tdepi	0,31,2,%r20\n", f);
+	    }
+	  else
+	    {
+	      fputs ("\tb,l	.+8,%r20\n", f);
+	      fputs ("\tdepwi	0,31,2,%r20\n", f);
+	    }
+	  fputs ("\tldw		40(%r20),%r22\n", f);
+	  fputs ("\tcopy	%r22,%r21\n", f);
+	  fputs ("\tbb,>=,n	%r22,30,.+16\n", f);
+	  if (ASSEMBLER_DIALECT == 0)
+	    fputs ("\tdepi	0,31,2,%r22\n", f);
+	  else
+	    fputs ("\tdepwi	0,31,2,%r22\n", f);
+	  fputs ("\tldw		0(%r22),%r21\n", f);
+	  fputs ("\tldw		4(%r22),%r19\n", f);
 	  fputs ("\tldsid	(%r21),%r1\n", f);
 	  fputs ("\tmtsp	%r1,%sr0\n", f);
-	  fputs ("\tbe	0(%sr0,%r21)\n", f);
-	  fputs ("\tldw	40(%r22),%r29\n", f);
+	  fputs ("\tbe		0(%sr0,%r21)\n", f);
+	  fputs ("\tldw		44(%r20),%r29\n", f);
 	}
       fputs ("\t.word	0\n", f);
       fputs ("\t.word	0\n", f);
@@ -10131,11 +10092,11 @@
       fputs ("\t.dword 0\n", f);
       fputs ("\t.dword 0\n", f);
       fputs ("\tmfia	%r31\n", f);
-      fputs ("\tldd	24(%r31),%r1\n", f);
-      fputs ("\tldd	24(%r1),%r27\n", f);
-      fputs ("\tldd	16(%r1),%r1\n", f);
+      fputs ("\tldd	24(%r31),%r27\n", f);
+      fputs ("\tldd	32(%r31),%r31\n", f);
+      fputs ("\tldd	16(%r27),%r1\n", f);
       fputs ("\tbve	(%r1)\n", f);
-      fputs ("\tldd	32(%r31),%r31\n", f);
+      fputs ("\tldd	24(%r27),%r27\n", f);
       fputs ("\t.dword 0  ; fptr\n", f);
       fputs ("\t.dword 0  ; static link\n", f);
     }
@@ -10145,10 +10106,10 @@
    FNADDR is an RTX for the address of the function's pure code.
    CXT is an RTX for the static chain value for the function.
 
-   Move the function address to the trampoline template at offset 36.
-   Move the static chain value to trampoline template at offset 40.
-   Move the trampoline address to trampoline template at offset 44.
-   Move r19 to trampoline template at offset 48.  The latter two
+   Move the function address to the trampoline template at offset 48.
+   Move the static chain value to trampoline template at offset 52.
+   Move the trampoline address to trampoline template at offset 56.
+   Move r19 to trampoline template at offset 60.  The latter two
    words create a plabel for the indirect call to the trampoline.
 
    A similar sequence is used for the 64-bit port but the plabel is
@@ -10174,15 +10135,15 @@
 
   if (!TARGET_64BIT)
     {
-      tmp = adjust_address (m_tramp, Pmode, 36);
+      tmp = adjust_address (m_tramp, Pmode, 48);
       emit_move_insn (tmp, fnaddr);
-      tmp = adjust_address (m_tramp, Pmode, 40);
+      tmp = adjust_address (m_tramp, Pmode, 52);
       emit_move_insn (tmp, chain_value);
 
       /* Create a fat pointer for the trampoline.  */
-      tmp = adjust_address (m_tramp, Pmode, 44);
+      tmp = adjust_address (m_tramp, Pmode, 56);
       emit_move_insn (tmp, r_tramp);
-      tmp = adjust_address (m_tramp, Pmode, 48);
+      tmp = adjust_address (m_tramp, Pmode, 60);
       emit_move_insn (tmp, gen_rtx_REG (Pmode, 19));
 
       /* fdc and fic only use registers for the address to flush,
@@ -10234,7 +10195,7 @@
     }
 
 #ifdef HAVE_ENABLE_EXECUTE_STACK
-  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, "__enable_execute_stack"),
+  emit_library_call (gen_rtx_SYMBOL_REF (Pmode, "__enable_execute_stack"),
 		     LCT_NORMAL, VOIDmode, XEXP (m_tramp, 0), Pmode);
 #endif
 }
@@ -10241,13 +10202,13 @@
 
 /* Perform any machine-specific adjustment in the address of the trampoline.
    ADDR contains the address that was passed to pa_trampoline_init.
-   Adjust the trampoline address to point to the plabel at offset 44.  */
+   Adjust the trampoline address to point to the plabel at offset 56.  */
 
 static rtx
 pa_trampoline_adjust_address (rtx addr)
 {
   if (!TARGET_64BIT)
-    addr = memory_address (Pmode, plus_constant (Pmode, addr, 46));
+    addr = memory_address (Pmode, plus_constant (Pmode, addr, 58));
   return addr;
 }
 
Index: gcc/config/pa/pa-linux.h
===================================================================
diff --git a/gcc/config/pa/pa-linux.h b/gcc/config/pa/pa-linux.h
--- a/gcc/config/pa/pa-linux.h	(revision 278653)
+++ b/gcc/config/pa/pa-linux.h	(revision 278653)
@@ -101,7 +101,7 @@
 
 /* FIXME: Hacked from the <elfos.h> one so that we avoid multiple
    labels in a function declaration (since pa.c seems determined to do
-   it differently)  */
+   it differently).  */
 
 #undef ASM_DECLARE_FUNCTION_NAME
 #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)		\
@@ -109,9 +109,14 @@
     {								\
       ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, "function");	\
       ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));		\
+      pa_output_function_label (FILE);				\
     }								\
   while (0)
 
+/* Output function prologue for linux.  */
+#undef TARGET_ASM_FUNCTION_PROLOGUE
+#define TARGET_ASM_FUNCTION_PROLOGUE pa_linux_output_function_prologue
+
 /* As well as globalizing the label, we need to encode the label
    to ensure a plabel is generated in an indirect call.  */
 
Index: gcc/config/pa/pa.h
===================================================================
diff --git a/gcc/config/pa/pa.h b/gcc/config/pa/pa.h
--- a/gcc/config/pa/pa.h	(revision 278653)
+++ b/gcc/config/pa/pa.h	(revision 278653)
@@ -689,7 +689,7 @@
 
 /* Length in units of the trampoline for entering a nested function.  */
 
-#define TRAMPOLINE_SIZE (TARGET_64BIT ? 72 : 52)
+#define TRAMPOLINE_SIZE (TARGET_64BIT ? 72 : 64)
 
 /* Alignment required by the trampoline.  */
 
@@ -1293,12 +1293,14 @@
 #endif
 
 /* The maximum offset in bytes for a PA 1.X pc-relative call to the
-   head of the preceding stub table.  The selected offsets have been
-   chosen so that approximately one call stub is allocated for every
-   86.7 instructions.  A long branch stub is two instructions when
-   not generating PIC code.  For HP-UX and ELF targets, PIC stubs are
-   seven and four instructions, respectively.  */  
-#define MAX_PCREL17F_OFFSET \
-  (flag_pic ? (TARGET_HPUX ? 198164 : 221312) : 240000)
+   head of the preceding stub table.  A long branch stub is two or three
+   instructions for non-PIC and PIC, respectively.  Import stubs are
+   seven and five instructions for HP-UX and ELF targets, respectively.
+   The default stub group size for ELF targets is 217856 bytes.
+   FIXME: We need an option to set the maximum offset.  */  
+#define MAX_PCREL17F_OFFSET (TARGET_HPUX ? 198164 : 217856)
 
 #define NEED_INDICATE_EXEC_STACK 0
+
+/* Output default function prologue for hpux.  */
+#define TARGET_ASM_FUNCTION_PROLOGUE pa_output_function_prologue
Index: gcc/config/darwin9.h
===================================================================
diff --git a/gcc/config/darwin9.h b/gcc/config/darwin9.h
--- a/gcc/config/darwin9.h	(revision 278653)
+++ b/gcc/config/darwin9.h	(revision 278653)
@@ -35,12 +35,6 @@
 /* Tell collect2 to run dsymutil for us as necessary.  */
 #define COLLECT_RUN_DSYMUTIL 1
 
-#undef DARWIN_PIE_SPEC
-#define DARWIN_PIE_SPEC \
-  "%{fpie|pie|fPIE: \
-     %{mdynamic-no-pic: %n'-mdynamic-no-pic' overrides '-pie', '-fpie' or '-fPIE'; \
-      :-pie}}"
-
 /* Only ask as for debug data if the debug style is stabs (since as doesn't
    yet generate dwarf.)  */
 
Index: gcc/config/mips/mips.md
===================================================================
diff --git a/gcc/config/mips/mips.md b/gcc/config/mips/mips.md
--- a/gcc/config/mips/mips.md	(revision 278653)
+++ b/gcc/config/mips/mips.md	(revision 278653)
@@ -5772,8 +5772,8 @@
   "ISA_HAS_ROR"
 {
   if (CONST_INT_P (operands[2]))
-    gcc_assert (INTVAL (operands[2]) >= 0
-		&& INTVAL (operands[2]) < GET_MODE_BITSIZE (<MODE>mode));
+    operands[2] = GEN_INT (INTVAL (operands[2])
+                           & (GET_MODE_BITSIZE (<MODE>mode) - 1));
 
   return "<d>ror\t%0,%1,%2";
 }
@@ -7502,7 +7502,7 @@
 ;; __builtin_mips_get_fcsr: move the FCSR into operand 0.
 (define_expand "mips_get_fcsr"
   [(set (match_operand:SI 0 "register_operand")
-  	(unspec_volatile [(const_int 0)] UNSPEC_GET_FCSR))]
+       (unspec_volatile:SI [(const_int 0)] UNSPEC_GET_FCSR))]
   "TARGET_HARD_FLOAT_ABI"
 {
   if (TARGET_MIPS16)
@@ -7514,7 +7514,7 @@
 
 (define_insn "*mips_get_fcsr"
   [(set (match_operand:SI 0 "register_operand" "=d")
-  	(unspec_volatile [(const_int 0)] UNSPEC_GET_FCSR))]
+       (unspec_volatile:SI [(const_int 0)] UNSPEC_GET_FCSR))]
   "TARGET_HARD_FLOAT"
   "cfc1\t%0,$31")
 
Index: gcc/config/mips/mips.c
===================================================================
diff --git a/gcc/config/mips/mips.c b/gcc/config/mips/mips.c
--- a/gcc/config/mips/mips.c	(revision 278653)
+++ b/gcc/config/mips/mips.c	(revision 278653)
@@ -9532,7 +9532,7 @@
 {
   machine_mode mode = default_dwarf_frame_reg_mode (regno);
 
-  if (FP_REG_P (regno) && mips_abi == ABI_32 && TARGET_FLOAT64)
+  if (FP_REG_P (regno) && mips_abi == ABI_32 && !TARGET_FLOAT32)
     mode = SImode;
 
   return mode;
@@ -16788,6 +16788,19 @@
       std::swap (ops[1], ops[2]);
       break;
 
+    case CODE_FOR_msa_maddv_b:
+    case CODE_FOR_msa_maddv_h:
+    case CODE_FOR_msa_maddv_w:
+    case CODE_FOR_msa_maddv_d:
+    case CODE_FOR_msa_fmadd_w:
+    case CODE_FOR_msa_fmadd_d:
+    case CODE_FOR_msa_fmsub_w:
+    case CODE_FOR_msa_fmsub_d:
+      /* fma(a, b, c) results into (a * b + c), however builtin_msa_fmadd expects
+	 it to be (a + b * c).  Swap the 1st and 3rd operands.  */
+      std::swap (ops[1], ops[3]);
+      break;
+
     case CODE_FOR_msa_slli_b:
     case CODE_FOR_msa_slli_h:
     case CODE_FOR_msa_slli_w:
Index: gcc/tree-vect-slp.c
===================================================================
diff --git a/gcc/tree-vect-slp.c b/gcc/tree-vect-slp.c
--- a/gcc/tree-vect-slp.c	(revision 278653)
+++ b/gcc/tree-vect-slp.c	(revision 278653)
@@ -1308,6 +1308,9 @@
 	  && nops == 2
 	  && oprnds_info[1]->first_dt == vect_internal_def
 	  && is_gimple_assign (stmt)
+	  /* Swapping operands for reductions breaks assumptions later on.  */
+	  && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) != vect_reduction_def
+	  && STMT_VINFO_DEF_TYPE (vinfo_for_stmt (stmt)) != vect_double_reduction_def
 	  /* Do so only if the number of not successful permutes was nor more
 	     than a cut-ff as re-trying the recursive match on
 	     possibly each level of the tree would expose exponential
Index: gcc/cfgrtl.c
===================================================================
diff --git a/gcc/cfgrtl.c b/gcc/cfgrtl.c
--- a/gcc/cfgrtl.c	(revision 278653)
+++ b/gcc/cfgrtl.c	(revision 278653)
@@ -4233,7 +4233,7 @@
 /* Create a duplicate of the basic block BB.  */
 
 static basic_block
-cfg_layout_duplicate_bb (basic_block bb)
+cfg_layout_duplicate_bb (basic_block bb, copy_bb_data *)
 {
   rtx_insn *insn;
   basic_block new_bb;
@@ -5059,9 +5059,9 @@
 }
 
 static basic_block
-rtl_duplicate_bb (basic_block bb)
+rtl_duplicate_bb (basic_block bb, copy_bb_data *id)
 {
-  bb = cfg_layout_duplicate_bb (bb);
+  bb = cfg_layout_duplicate_bb (bb, id);
   bb->aux = NULL;
   return bb;
 }
Index: gcc/dce.c
===================================================================
diff --git a/gcc/dce.c b/gcc/dce.c
--- a/gcc/dce.c	(revision 278653)
+++ b/gcc/dce.c	(revision 278653)
@@ -35,6 +35,7 @@
 #include "valtrack.h"
 #include "tree-pass.h"
 #include "dbgcnt.h"
+#include "rtl-iter.h"
 
 
 /* -------------------------------------------------------------------------
@@ -86,7 +87,33 @@
     }
 }
 
+/* Don't delete calls that may throw if we cannot do so.  */
 
+static bool
+can_delete_call (rtx_insn *insn)
+{
+  if (cfun->can_delete_dead_exceptions && can_alter_cfg)
+    return true;
+  if (!insn_nothrow_p (insn))
+    return false;
+  if (can_alter_cfg)
+    return true;
+  /* If we can't alter cfg, even when the call can't throw exceptions, it
+     might have EDGE_ABNORMAL_CALL edges and so we shouldn't delete such
+     calls.  */
+  gcc_assert (CALL_P (insn));
+  if (BLOCK_FOR_INSN (insn) && BB_END (BLOCK_FOR_INSN (insn)) == insn)
+    {
+      edge e;
+      edge_iterator ei;
+
+      FOR_EACH_EDGE (e, ei, BLOCK_FOR_INSN (insn)->succs)
+	if ((e->flags & EDGE_ABNORMAL_CALL) != 0)
+	  return false;
+    }
+  return true;
+}
+
 /* Return true if INSN is a normal instruction that can be deleted by
    the DCE pass.  */
 
@@ -110,8 +137,7 @@
       && (RTL_CONST_OR_PURE_CALL_P (insn)
 	  && !RTL_LOOPING_CONST_OR_PURE_CALL_P (insn))
       /* Don't delete calls that may throw if we cannot do so.  */
-      && ((cfun->can_delete_dead_exceptions && can_alter_cfg)
-	  || insn_nothrow_p (insn)))
+      && can_delete_call (insn))
     return find_call_stack_args (as_a <rtx_call_insn *> (insn), false,
 				 fast, arg_stores);
 
@@ -204,8 +230,7 @@
 	  && !SIBLING_CALL_P (insn)
 	  && (RTL_CONST_OR_PURE_CALL_P (insn)
 	      && !RTL_LOOPING_CONST_OR_PURE_CALL_P (insn))
-	  && ((cfun->can_delete_dead_exceptions && can_alter_cfg)
-	      || insn_nothrow_p (insn)))
+	  && can_delete_call (insn))
 	find_call_stack_args (as_a <rtx_call_insn *> (insn), true, fast, NULL);
     }
 }
@@ -265,7 +290,101 @@
   return true;
 }
 
+/* If MEM has sp address, return 0, if it has sp + const address,
+   return that const, if it has reg address where reg is set to sp + const
+   and FAST is false, return const, otherwise return
+   INTTYPE_MINUMUM (HOST_WIDE_INT).  */
 
+static HOST_WIDE_INT
+sp_based_mem_offset (rtx_call_insn *call_insn, const_rtx mem, bool fast)
+{
+  HOST_WIDE_INT off = 0;
+  rtx addr = XEXP (mem, 0);
+  if (GET_CODE (addr) == PLUS
+      && REG_P (XEXP (addr, 0))
+      && CONST_INT_P (XEXP (addr, 1)))
+    {
+      off = INTVAL (XEXP (addr, 1));
+      addr = XEXP (addr, 0);
+    }
+  if (addr == stack_pointer_rtx)
+    return off;
+
+  if (!REG_P (addr) || fast)
+    return INTTYPE_MINIMUM (HOST_WIDE_INT);
+
+  /* If not fast, use chains to see if addr wasn't set to sp + offset.  */
+  df_ref use;
+  FOR_EACH_INSN_USE (use, call_insn)
+  if (rtx_equal_p (addr, DF_REF_REG (use)))
+    break;
+
+  if (use == NULL)
+    return INTTYPE_MINIMUM (HOST_WIDE_INT);
+
+  struct df_link *defs;
+  for (defs = DF_REF_CHAIN (use); defs; defs = defs->next)
+    if (! DF_REF_IS_ARTIFICIAL (defs->ref))
+      break;
+
+  if (defs == NULL)
+    return INTTYPE_MINIMUM (HOST_WIDE_INT);
+
+  rtx set = single_set (DF_REF_INSN (defs->ref));
+  if (!set)
+    return INTTYPE_MINIMUM (HOST_WIDE_INT);
+
+  if (GET_CODE (SET_SRC (set)) != PLUS
+      || XEXP (SET_SRC (set), 0) != stack_pointer_rtx
+      || !CONST_INT_P (XEXP (SET_SRC (set), 1)))
+    return INTTYPE_MINIMUM (HOST_WIDE_INT);
+
+  off += INTVAL (XEXP (SET_SRC (set), 1));
+  return off;
+}
+
+/* Data for check_argument_load called via note_uses.  */
+struct check_argument_load_data {
+  bitmap sp_bytes;
+  HOST_WIDE_INT min_sp_off, max_sp_off;
+  rtx_call_insn *call_insn;
+  bool fast;
+  bool load_found;
+};
+
+/* Helper function for find_call_stack_args.  Check if there are
+   any loads from the argument slots in between the const/pure call
+   and store to the argument slot, set LOAD_FOUND if any is found.  */
+
+static void
+check_argument_load (rtx *loc, void *data)
+{
+  struct check_argument_load_data *d
+    = (struct check_argument_load_data *) data;
+  subrtx_iterator::array_type array;
+  FOR_EACH_SUBRTX (iter, array, *loc, NONCONST)
+    {
+      const_rtx mem = *iter;
+      HOST_WIDE_INT size;
+      if (MEM_P (mem)
+	  && MEM_SIZE_KNOWN_P (mem)
+	  && MEM_SIZE (mem).is_constant (&size))
+	{
+	  HOST_WIDE_INT off = sp_based_mem_offset (d->call_insn, mem, d->fast);
+	  if (off != INTTYPE_MINIMUM (HOST_WIDE_INT)
+	      && off < d->max_sp_off
+	      && off + size > d->min_sp_off)
+	    for (HOST_WIDE_INT byte = MAX (off, d->min_sp_off);
+		 byte < MIN (off + size, d->max_sp_off); byte++)
+	      if (bitmap_bit_p (d->sp_bytes, byte - d->min_sp_off))
+		{
+		  d->load_found = true;
+		  return;
+		}
+	}
+    }
+}
+
 /* Try to find all stack stores of CALL_INSN arguments if
    ACCUMULATE_OUTGOING_ARGS.  If all stack stores have been found
    and it is therefore safe to eliminate the call, return true,
@@ -302,58 +421,13 @@
     if (GET_CODE (XEXP (p, 0)) == USE
 	&& MEM_P (XEXP (XEXP (p, 0), 0)))
       {
-	rtx mem = XEXP (XEXP (p, 0), 0), addr;
-	HOST_WIDE_INT off = 0, size;
+	rtx mem = XEXP (XEXP (p, 0), 0);
+	HOST_WIDE_INT size;
 	if (!MEM_SIZE_KNOWN_P (mem) || !MEM_SIZE (mem).is_constant (&size))
 	  return false;
-	addr = XEXP (mem, 0);
-	if (GET_CODE (addr) == PLUS
-	    && REG_P (XEXP (addr, 0))
-	    && CONST_INT_P (XEXP (addr, 1)))
-	  {
-	    off = INTVAL (XEXP (addr, 1));
-	    addr = XEXP (addr, 0);
-	  }
-	if (addr != stack_pointer_rtx)
-	  {
-	    if (!REG_P (addr))
-	      return false;
-	    /* If not fast, use chains to see if addr wasn't set to
-	       sp + offset.  */
-	    if (!fast)
-	      {
-		df_ref use;
-		struct df_link *defs;
-		rtx set;
-
-		FOR_EACH_INSN_USE (use, call_insn)
-		  if (rtx_equal_p (addr, DF_REF_REG (use)))
-		    break;
-
-		if (use == NULL)
-		  return false;
-
-		for (defs = DF_REF_CHAIN (use); defs; defs = defs->next)
-		  if (! DF_REF_IS_ARTIFICIAL (defs->ref))
-		    break;
-
-		if (defs == NULL)
-		  return false;
-
-		set = single_set (DF_REF_INSN (defs->ref));
-		if (!set)
-		  return false;
-
-		if (GET_CODE (SET_SRC (set)) != PLUS
-		    || XEXP (SET_SRC (set), 0) != stack_pointer_rtx
-		    || !CONST_INT_P (XEXP (SET_SRC (set), 1)))
-		  return false;
-
-		off += INTVAL (XEXP (SET_SRC (set), 1));
-	      }
-	    else
-	      return false;
-	  }
+	HOST_WIDE_INT off = sp_based_mem_offset (call_insn, mem, fast);
+	if (off == INTTYPE_MINIMUM (HOST_WIDE_INT))
+	  return false;
 	min_sp_off = MIN (min_sp_off, off);
 	max_sp_off = MAX (max_sp_off, off + size);
       }
@@ -369,51 +443,24 @@
     if (GET_CODE (XEXP (p, 0)) == USE
 	&& MEM_P (XEXP (XEXP (p, 0), 0)))
       {
-	rtx mem = XEXP (XEXP (p, 0), 0), addr;
-	HOST_WIDE_INT off = 0, byte, size;
+	rtx mem = XEXP (XEXP (p, 0), 0);
 	/* Checked in the previous iteration.  */
-	size = MEM_SIZE (mem).to_constant ();
-	addr = XEXP (mem, 0);
-	if (GET_CODE (addr) == PLUS
-	    && REG_P (XEXP (addr, 0))
-	    && CONST_INT_P (XEXP (addr, 1)))
-	  {
-	    off = INTVAL (XEXP (addr, 1));
-	    addr = XEXP (addr, 0);
-	  }
-	if (addr != stack_pointer_rtx)
-	  {
-	    df_ref use;
-	    struct df_link *defs;
-	    rtx set;
-
-	    FOR_EACH_INSN_USE (use, call_insn)
-	      if (rtx_equal_p (addr, DF_REF_REG (use)))
-		break;
-
-	    for (defs = DF_REF_CHAIN (use); defs; defs = defs->next)
-	      if (! DF_REF_IS_ARTIFICIAL (defs->ref))
-		break;
-
-	    set = single_set (DF_REF_INSN (defs->ref));
-	    off += INTVAL (XEXP (SET_SRC (set), 1));
-	  }
-	for (byte = off; byte < off + size; byte++)
-	  {
-	    if (!bitmap_set_bit (sp_bytes, byte - min_sp_off))
-	      gcc_unreachable ();
-	  }
+	HOST_WIDE_INT size = MEM_SIZE (mem).to_constant ();
+	HOST_WIDE_INT off = sp_based_mem_offset (call_insn, mem, fast);
+	gcc_checking_assert (off != INTTYPE_MINIMUM (HOST_WIDE_INT));
+	for (HOST_WIDE_INT byte = off; byte < off + size; byte++)
+	  if (!bitmap_set_bit (sp_bytes, byte - min_sp_off))
+	    gcc_unreachable ();
       }
 
   /* Walk backwards, looking for argument stores.  The search stops
-     when seeing another call, sp adjustment or memory store other than
-     argument store.  */
+     when seeing another call, sp adjustment, memory store other than
+     argument store or a read from an argument stack slot.  */
+  struct check_argument_load_data data
+    = { sp_bytes, min_sp_off, max_sp_off, call_insn, fast, false };
   ret = false;
   for (insn = PREV_INSN (call_insn); insn; insn = prev_insn)
     {
-      rtx set, mem, addr;
-      HOST_WIDE_INT off;
-
       if (insn == BB_HEAD (BLOCK_FOR_INSN (call_insn)))
 	prev_insn = NULL;
       else
@@ -425,62 +472,22 @@
       if (!NONDEBUG_INSN_P (insn))
 	continue;
 
-      set = single_set (insn);
+      rtx set = single_set (insn);
       if (!set || SET_DEST (set) == stack_pointer_rtx)
 	break;
 
+      note_uses (&PATTERN (insn), check_argument_load, &data);
+      if (data.load_found)
+	break;
+
       if (!MEM_P (SET_DEST (set)))
 	continue;
 
-      mem = SET_DEST (set);
-      addr = XEXP (mem, 0);
-      off = 0;
-      if (GET_CODE (addr) == PLUS
-	  && REG_P (XEXP (addr, 0))
-	  && CONST_INT_P (XEXP (addr, 1)))
-	{
-	  off = INTVAL (XEXP (addr, 1));
-	  addr = XEXP (addr, 0);
-	}
-      if (addr != stack_pointer_rtx)
-	{
-	  if (!REG_P (addr))
-	    break;
-	  if (!fast)
-	    {
-	      df_ref use;
-	      struct df_link *defs;
-	      rtx set;
+      rtx mem = SET_DEST (set);
+      HOST_WIDE_INT off = sp_based_mem_offset (call_insn, mem, fast);
+      if (off == INTTYPE_MINIMUM (HOST_WIDE_INT))
+	break;
 
-	      FOR_EACH_INSN_USE (use, insn)
-		if (rtx_equal_p (addr, DF_REF_REG (use)))
-		  break;
-
-	      if (use == NULL)
-		break;
-
-	      for (defs = DF_REF_CHAIN (use); defs; defs = defs->next)
-		if (! DF_REF_IS_ARTIFICIAL (defs->ref))
-		  break;
-
-	      if (defs == NULL)
-		break;
-
-	      set = single_set (DF_REF_INSN (defs->ref));
-	      if (!set)
-		break;
-
-	      if (GET_CODE (SET_SRC (set)) != PLUS
-		  || XEXP (SET_SRC (set), 0) != stack_pointer_rtx
-		  || !CONST_INT_P (XEXP (SET_SRC (set), 1)))
-		break;
-
-	      off += INTVAL (XEXP (SET_SRC (set), 1));
-	    }
-	  else
-	    break;
-	}
-
       HOST_WIDE_INT size;
       if (!MEM_SIZE_KNOWN_P (mem)
 	  || !MEM_SIZE (mem).is_constant (&size)
Index: gcc/params.def
===================================================================
diff --git a/gcc/params.def b/gcc/params.def
--- a/gcc/params.def	(revision 278653)
+++ b/gcc/params.def	(revision 278653)
@@ -1331,6 +1331,11 @@
 	 "Maximum number of bits for which we avoid creating FMAs.",
 	 0, 0, 512)
 
+DEFPARAM(PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT,
+	 "logical-op-non-short-circuit",
+	 "True if a non-short-circuit operation is optimal.",
+	 -1, -1, 1)
+
 /*
 
 Local variables:
Index: gcc/tree-ssanames.c
===================================================================
diff --git a/gcc/tree-ssanames.c b/gcc/tree-ssanames.c
--- a/gcc/tree-ssanames.c	(revision 278653)
+++ b/gcc/tree-ssanames.c	(revision 278653)
@@ -788,7 +788,12 @@
     {
       /* points-to info is not flow-sensitive.  */
       if (SSA_NAME_PTR_INFO (name))
-	mark_ptr_info_alignment_unknown (SSA_NAME_PTR_INFO (name));
+	{
+	  /* [E]VRP can derive context sensitive alignment info and
+	     non-nullness properties.  We must reset both.  */
+	  mark_ptr_info_alignment_unknown (SSA_NAME_PTR_INFO (name));
+	  SSA_NAME_PTR_INFO (name)->pt.null = 1;
+	}
     }
   else
     SSA_NAME_RANGE_INFO (name) = NULL;
Index: gcc/convert.c
===================================================================
diff --git a/gcc/convert.c b/gcc/convert.c
--- a/gcc/convert.c	(revision 278653)
+++ b/gcc/convert.c	(revision 278653)
@@ -193,12 +193,15 @@
 	  CASE_MATHFN (FABS)
 	  CASE_MATHFN (LOGB)
 #undef CASE_MATHFN
+	    if (call_expr_nargs (expr) != 1
+		|| !SCALAR_FLOAT_TYPE_P (TREE_TYPE (CALL_EXPR_ARG (expr, 0))))
+	      break;
 	    {
 	      tree arg0 = strip_float_extensions (CALL_EXPR_ARG (expr, 0));
 	      tree newtype = type;
 
-	      /* We have (outertype)sqrt((innertype)x).  Choose the wider mode from
-		 the both as the safe type for operation.  */
+	      /* We have (outertype)sqrt((innertype)x).  Choose the wider mode
+		 from the both as the safe type for operation.  */
 	      if (TYPE_PRECISION (TREE_TYPE (arg0)) > TYPE_PRECISION (type))
 		newtype = TREE_TYPE (arg0);
 
@@ -592,7 +595,8 @@
 	CASE_FLT_FN (BUILT_IN_ROUND):
 	CASE_FLT_FN_FLOATN_NX (BUILT_IN_ROUND):
 	  /* Only convert in ISO C99 mode and with -fno-math-errno.  */
-	  if (!targetm.libc_has_function (function_c99_misc) || flag_errno_math)
+	  if (!targetm.libc_has_function (function_c99_misc)
+	      || flag_errno_math)
 	    break;
 	  if (outprec < TYPE_PRECISION (integer_type_node)
 	      || (outprec == TYPE_PRECISION (integer_type_node)
@@ -615,7 +619,8 @@
 	CASE_FLT_FN (BUILT_IN_RINT):
 	CASE_FLT_FN_FLOATN_NX (BUILT_IN_RINT):
 	  /* Only convert in ISO C99 mode and with -fno-math-errno.  */
-	  if (!targetm.libc_has_function (function_c99_misc) || flag_errno_math)
+	  if (!targetm.libc_has_function (function_c99_misc)
+	      || flag_errno_math)
 	    break;
 	  if (outprec < TYPE_PRECISION (integer_type_node)
 	      || (outprec == TYPE_PRECISION (integer_type_node)
@@ -631,14 +636,20 @@
 
 	CASE_FLT_FN (BUILT_IN_TRUNC):
 	CASE_FLT_FN_FLOATN_NX (BUILT_IN_TRUNC):
-	  return convert_to_integer_1 (type, CALL_EXPR_ARG (s_expr, 0), dofold);
+	  if (call_expr_nargs (s_expr) != 1
+	      || !SCALAR_FLOAT_TYPE_P (TREE_TYPE (CALL_EXPR_ARG (s_expr, 0))))
+	    break;
+	  return convert_to_integer_1 (type, CALL_EXPR_ARG (s_expr, 0),
+				       dofold);
 
 	default:
 	  break;
 	}
 
-      if (fn)
-        {
+      if (fn
+	  && call_expr_nargs (s_expr) == 1
+	  && SCALAR_FLOAT_TYPE_P (TREE_TYPE (CALL_EXPR_ARG (s_expr, 0))))
+	{
 	  tree newexpr = build_call_expr (fn, 1, CALL_EXPR_ARG (s_expr, 0));
 	  return convert_to_integer_1 (type, newexpr, dofold);
 	}
@@ -668,7 +679,9 @@
 	  break;
 	}
 
-      if (fn)
+      if (fn
+	  && call_expr_nargs (s_expr) == 1
+	  && SCALAR_FLOAT_TYPE_P (TREE_TYPE (CALL_EXPR_ARG (s_expr, 0))))
         {
 	  tree newexpr = build_call_expr (fn, 1, CALL_EXPR_ARG (s_expr, 0));
 	  return convert_to_integer_1 (type, newexpr, dofold);
Index: gcc/lto-streamer.h
===================================================================
diff --git a/gcc/lto-streamer.h b/gcc/lto-streamer.h
--- a/gcc/lto-streamer.h	(revision 278653)
+++ b/gcc/lto-streamer.h	(revision 278653)
@@ -121,7 +121,7 @@
      form followed by the data for the string.  */
 
 #define LTO_major_version 7
-#define LTO_minor_version 1
+#define LTO_minor_version 3
 
 typedef unsigned char	lto_decl_flags_t;
 
Index: libgfortran/intrinsics/random.c
===================================================================
diff --git a/libgfortran/intrinsics/random.c b/libgfortran/intrinsics/random.c
--- a/libgfortran/intrinsics/random.c	(revision 278653)
+++ b/libgfortran/intrinsics/random.c	(revision 278653)
@@ -272,31 +272,20 @@
 }
 
 
-/* Super-simple LCG generator used in getosrandom () if /dev/urandom
-   doesn't exist.  */
+/* Splitmix64 recommended by xorshift author for initializing.  After
+   getting one uint64_t value from the OS, this is used to fill in the
+   rest of the state.  */
 
-#define M 2147483647 /* 2^31 - 1 (A large prime number) */
-#define A 16807      /* Prime root of M, passes statistical tests and produces a full cycle */
-#define Q 127773 /* M / A (To avoid overflow on A * seed) */
-#define R 2836   /* M % A (To avoid overflow on A * seed) */
-
-__attribute__((unused)) static uint32_t
-lcg_parkmiller(uint32_t seed)
+static uint64_t
+splitmix64 (uint64_t x)
 {
-    uint32_t hi = seed / Q;
-    uint32_t lo = seed % Q;
-    int32_t test = A * lo - R * hi;
-    if (test <= 0)
-        test += M;
-    return test;
+  uint64_t z = (x += 0x9e3779b97f4a7c15);
+  z = (z ^ (z >> 30)) * 0xbf58476d1ce4e5b9;
+  z = (z ^ (z >> 27)) * 0x94d049bb133111eb;
+  return z ^ (z >> 31);
 }
 
-#undef M
-#undef A
-#undef Q
-#undef R
 
-
 /* Get some random bytes from the operating system in order to seed
    the PRNG.  */
 
@@ -326,7 +315,7 @@
       close (fd);
       return res;
     }
-  uint32_t seed = 1234567890;
+  uint64_t seed = 0x047f7684e9fc949dULL;
   time_t secs;
   long usecs;
   if (gf_gettime (&secs, &usecs) == 0)
@@ -338,13 +327,9 @@
   pid_t pid = getpid();
   seed ^= pid;
 #endif
-  uint32_t* ub = buf;
-  for (size_t i = 0; i < buflen / sizeof (uint32_t); i++)
-    {
-      ub[i] = seed;
-      seed = lcg_parkmiller (seed);
-    }
-  return buflen;
+  size_t size = buflen < sizeof (uint64_t) ? buflen : sizeof (uint64_t);
+  memcpy (buf, &seed, size);
+  return size;
 #endif /* __MINGW64_VERSION_MAJOR  */
 }
 
@@ -359,7 +344,13 @@
     __gthread_mutex_lock (&random_lock);
   if (!master_init)
     {
-      getosrandom (master_state, sizeof (master_state));
+      uint64_t os_seed;
+      getosrandom (&os_seed, sizeof (os_seed));
+      for (uint64_t i = 0; i < sizeof (master_state) / sizeof (uint64_t); i++)
+	{
+	  os_seed = splitmix64 (os_seed);
+	  master_state[i] = os_seed;
+	}
       njumps = 0;
       master_init = true;
     }
Index: libgfortran/ChangeLog
===================================================================
diff --git a/libgfortran/ChangeLog b/libgfortran/ChangeLog
--- a/libgfortran/ChangeLog	(revision 278653)
+++ b/libgfortran/ChangeLog	(revision 278653)
@@ -1,3 +1,28 @@
+2019-08-13  Janne Blomqvist  <jb@gcc.gnu.org>
+
+	Partial backport from trunk
+	PR fortran/91414
+	* intrinsics/random.c (lcg_parkmiller): Replace with splitmix64.
+	(splitmix64): New function.
+	(getosrandom): Simplify.
+	(init_rand_state): Use getosrandom only to get 8 bytes, splitmix64
+	to fill rest of state.
+
+2019-04-16  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2019-03-25  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR libgfortran/79540
+	* io/write_float.def (build_float_string): Don't copy digits when
+	ndigits is negative.
+
+2019-03-02  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libfortran/89020
+	* io/close.c (st_close): Generate error if calls to 'remove' return
+	an error.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: libgfortran/io/close.c
===================================================================
diff --git a/libgfortran/io/close.c b/libgfortran/io/close.c
--- a/libgfortran/io/close.c	(revision 278653)
+++ b/libgfortran/io/close.c	(revision 278653)
@@ -90,7 +90,10 @@
 	      else
 		{
 #if HAVE_UNLINK_OPEN_FILE
-		  remove (u->filename);
+
+		  if (remove (u->filename))
+		    generate_error (&clp->common, LIBERROR_OS,
+				    "File cannot be deleted");
 #else
 		  path = strdup (u->filename);
 #endif
@@ -103,7 +106,9 @@
 #if !HAVE_UNLINK_OPEN_FILE
       if (path != NULL)
 	{
-	  remove (path);
+	  if (remove (path))
+	    generate_error (&clp->common, LIBERROR_OS,
+			    "File cannot be deleted");
 	  free (path);
 	}
 #endif
Index: libgfortran/io/write_float.def
===================================================================
diff --git a/libgfortran/io/write_float.def b/libgfortran/io/write_float.def
--- a/libgfortran/io/write_float.def	(revision 278653)
+++ b/libgfortran/io/write_float.def	(revision 278653)
@@ -620,7 +620,7 @@
     }
 
   /* Set digits after the decimal point, padding with zeros.  */
-  if (nafter > 0)
+  if (ndigits >= 0 && nafter > 0)
     {
       if (nafter > ndigits)
 	i = ndigits;
@@ -627,7 +627,8 @@
       else
 	i = nafter;
 
-      memcpy (put, digits, i);
+      if (i > 0)
+	memcpy (put, digits, i);
       while (i < nafter)
 	put[i++] = '0';
 
Index: libcpp/directives.c
===================================================================
diff --git a/libcpp/directives.c b/libcpp/directives.c
--- a/libcpp/directives.c	(revision 278653)
+++ b/libcpp/directives.c	(revision 278653)
@@ -1574,6 +1574,8 @@
   node = _cpp_lex_identifier (pfile, c->name);
   if (node->type == NT_VOID)
     c->is_undef = 1;
+  else if (node->type == NT_MACRO && (node->flags & NODE_BUILTIN))
+    c->is_builtin = 1;
   else
     {
       defn = cpp_macro_definition (pfile, node);
@@ -2504,6 +2506,11 @@
   cpp_hashnode *node = _cpp_lex_identifier (pfile, c->name);
   if (node == NULL)
     return;
+  if (c->is_builtin)
+    {
+      _cpp_restore_special_builtin (pfile, c);
+      return;
+    }
 
   if (pfile->cb.before_define)
     pfile->cb.before_define (pfile);
Index: libcpp/line-map.c
===================================================================
diff --git a/libcpp/line-map.c b/libcpp/line-map.c
--- a/libcpp/line-map.c	(revision 278653)
+++ b/libcpp/line-map.c	(revision 278653)
@@ -755,6 +755,11 @@
       if (line_delta < 0
 	  || last_line != ORDINARY_MAP_STARTING_LINE_NUMBER (map)
 	  || SOURCE_COLUMN (map, highest) >= (1U << (column_bits - range_bits))
+	  || ( /* We can't reuse the map if the line offset is sufficiently
+		  large to cause overflow when computing location_t values.  */
+	      (to_line - ORDINARY_MAP_STARTING_LINE_NUMBER (map))
+	      >= (((uint64_t) 1)
+		  << (CHAR_BIT * sizeof (linenum_type) - column_bits)))
 	  || range_bits < map->m_range_bits)
 	map = linemap_check_ordinary
 	        (const_cast <line_map *>
Index: libcpp/init.c
===================================================================
diff --git a/libcpp/init.c b/libcpp/init.c
--- a/libcpp/init.c	(revision 278653)
+++ b/libcpp/init.c	(revision 278653)
@@ -488,6 +488,26 @@
     }
 }
 
+/* Restore macro C to builtin macro definition.  */
+
+void
+_cpp_restore_special_builtin (cpp_reader *pfile, struct def_pragma_macro *c)
+{
+  size_t len = strlen (c->name);
+
+  for (const struct builtin_macro *b = builtin_array;
+       b < builtin_array + ARRAY_SIZE (builtin_array); b++)
+    if (b->len == len && memcmp (c->name, b->name, len + 1) == 0)
+      {
+	cpp_hashnode *hp = cpp_lookup (pfile, b->name, b->len);
+	hp->type = NT_MACRO;
+	hp->flags |= NODE_BUILTIN;
+	if (b->always_warn_if_redefined)
+	  hp->flags |= NODE_WARN;
+	hp->value.builtin = (enum cpp_builtin_type) b->value;
+      }
+}
+
 /* Read the builtins table above and enter them, and language-specific
    macros, into the hash table.  HOSTED is true if this is a hosted
    environment.  */
Index: libcpp/ChangeLog
===================================================================
diff --git a/libcpp/ChangeLog b/libcpp/ChangeLog
--- a/libcpp/ChangeLog	(revision 278653)
+++ b/libcpp/ChangeLog	(revision 278653)
@@ -1,3 +1,36 @@
+2019-11-21  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2019-10-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/92296
+	* internal.h (struct def_pragma_macro): Add is_builtin bitfield.
+	(_cpp_restore_special_builtin): Declare.
+	* init.c (_cpp_restore_special_builtin): New function.
+	* directives.c (do_pragma_push_macro): For NT_MACRO with NODE_BUILTIN
+	set is_builtin and don't try to grab definition.
+	(cpp_pop_definition): Use _cpp_restore_special_builtin to restore
+	builtin macros.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-18  Martin Liska  <mliska@suse.cz>
+
+	PR c++/89383
+	* line-map.c (linemap_line_start): Use 1UL in order
+	to not overflow.
+
+2019-03-11  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2019-02-11  Martin Liska  <mliska@suse.cz>
+
+	PR lto/88147
+	* line-map.c (linemap_line_start): Don't reuse the existing line
+	map if the line offset is sufficiently large to cause overflow
+	when computing location_t values.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: libcpp/internal.h
===================================================================
diff --git a/libcpp/internal.h b/libcpp/internal.h
--- a/libcpp/internal.h	(revision 278653)
+++ b/libcpp/internal.h	(revision 278653)
@@ -381,6 +381,8 @@
 
   /* Mark if we save an undefined macro.  */
   unsigned int is_undef : 1;
+  /* Nonzero if it was a builtin macro.  */
+  unsigned int is_builtin : 1;
 };
 
 /* A cpp_reader encapsulates the "state" of a pre-processor run.
@@ -689,6 +691,8 @@
 /* In init.c.  */
 extern void _cpp_maybe_push_include_file (cpp_reader *);
 extern const char *cpp_named_operator2name (enum cpp_ttype type);
+extern void _cpp_restore_special_builtin (cpp_reader *pfile,
+					  struct def_pragma_macro *);
 
 /* In directives.c */
 extern int _cpp_test_assertion (cpp_reader *, unsigned int *);
Index: fixincludes/ChangeLog
===================================================================
diff --git a/fixincludes/ChangeLog b/fixincludes/ChangeLog
--- a/fixincludes/ChangeLog	(revision 278653)
+++ b/fixincludes/ChangeLog	(revision 278653)
@@ -1,3 +1,60 @@
+2019-08-25  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-08-18  C.G. Dogan  <gcc+cgdogan.00@gmail.com>
+		    Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR target/83531
+	* inclhack.def (darwin_api_availability): New; strip leading
+	underscores from API_XXXX defines.
+	* fixincl.x: Regenerate.
+	* tests/base/os/availability.h: New file.
+
+2019-08-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* inclhack.def: Replace the complex test using __STRICT_ANSI__ and
+	__STDC_VERSION__ with a test using __DARWIN_NO_LONG_LONG.
+	Ensure that the top level math.h uses <> to wrap included headers
+	rather than "".
+	* fixincl.x: Regenerated.
+	* tests/base/architecture/ppc/math.h: Update test to include the
+	__DARWIN_NO_LONG_LONG case.
+
+2019-08-24  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-06-21  Iain Sandoe  <iain@sandoe.co.uk>
+
+	* inclhack.def: Guard __has_attribute and __has_extension in
+	os/base.h.
+	Guard Apple blocks syntax in dispatch/object.h.
+	* fixincl.x: Regenerate.
+	* tests/base/dispatch/object.h: New file.
+	* tests/base/os/base.h: New file.
+
+2019-06-01  Iain Sandoe  <iain@sandoe.co.uk>
+
+	Backport from mainline.
+	2019-05-11  Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR bootstrap/89864
+	* inclhack.def (darwin_ucred__Atomic): Do not supply test_text
+	for wrap fixes.
+	* fixincl.x: Regenerated.
+
+	Backport from mainline.
+	2019-04-18  Erik Schnetter  <schnetter@gmail.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+		    Iain Sandoe  <iain@sandoe.co.uk>
+
+	PR bootstrap/89864
+	* inclhack.def (darwin_ucred__Atomic): New, work around _Atomic keyword
+	use in headers included by C++.
+	* fixincl.x: Regenerated.
+
 2019-02-22  Release Manager
 
 	* GCC 8.3.0 released.
Index: fixincludes/tests/base/dispatch/object.h
===================================================================
diff --git a/fixincludes/tests/base/dispatch/object.h b/fixincludes/tests/base/dispatch/object.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/fixincludes/tests/base/dispatch/object.h	(revision 278653)
@@ -0,0 +1,18 @@
+/*  DO NOT EDIT THIS FILE.
+
+    It has been auto-edited by fixincludes from:
+
+	"fixinc/tests/inc/dispatch/object.h"
+
+    This had to be done to correct non-standard usages in the
+    original, manufacturer supplied header file.  */
+
+
+
+#if defined( DARWIN_DISPATCH_OBJECT_1_CHECK )
+#if __BLOCKS__
+typedef void (^dispatch_block_t)(void);
+#endif
+
+__BEGIN_DECLS
+#endif  /* DARWIN_DISPATCH_OBJECT_1_CHECK */
Index: fixincludes/tests/base/os/availability.h
===================================================================
diff --git a/fixincludes/tests/base/os/availability.h b/fixincludes/tests/base/os/availability.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/fixincludes/tests/base/os/availability.h	(revision 278653)
@@ -0,0 +1,18 @@
+/*  DO NOT EDIT THIS FILE.
+
+    It has been auto-edited by fixincludes from:
+
+	"fixinc/tests/inc/os/availability.h"
+
+    This had to be done to correct non-standard usages in the
+    original, manufacturer supplied header file.  */
+
+
+
+#if defined( DARWIN_API_AVAILABILITY_CHECK )
+    #define API_AVAILABLE(...)
+    #define API_DEPRECATED(...)
+    #define API_DEPRECATED_WITH_REPLACEMENT(...)
+    #define API_UNAVAILABLE(...)
+
+#endif  /* DARWIN_API_AVAILABILITY_CHECK */
Index: fixincludes/tests/base/os/base.h
===================================================================
diff --git a/fixincludes/tests/base/os/base.h b/fixincludes/tests/base/os/base.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/fixincludes/tests/base/os/base.h	(revision 278653)
@@ -0,0 +1,20 @@
+/*  DO NOT EDIT THIS FILE.
+
+    It has been auto-edited by fixincludes from:
+
+	"fixinc/tests/inc/os/base.h"
+
+    This had to be done to correct non-standard usages in the
+    original, manufacturer supplied header file.  */
+
+
+
+#if defined( DARWIN_OS_BASE_1_CHECK )
+#define __has_attribute(x) 0
+#endif
+#ifndef __has_extension
+#define __has_extension(x) 0
+#endif
+
+#if __GNUC__
+#endif  /* DARWIN_OS_BASE_1_CHECK */
Index: fixincludes/tests/base/architecture/ppc/math.h
===================================================================
diff --git a/fixincludes/tests/base/architecture/ppc/math.h b/fixincludes/tests/base/architecture/ppc/math.h
--- a/fixincludes/tests/base/architecture/ppc/math.h	(revision 278653)
+++ b/fixincludes/tests/base/architecture/ppc/math.h	(revision 278653)
@@ -12,3 +12,8 @@
 #if defined( BROKEN_NAN_CHECK )
 #if 1
 #endif  /* BROKEN_NAN_CHECK */
+
+
+#if defined( DARWIN_LL_FUNCS_AVAIL_CHECK )
+#if !(__DARWIN_NO_LONG_LONG)
+#endif  /* DARWIN_LL_FUNCS_AVAIL_CHECK */
Index: fixincludes/fixincl.x
===================================================================
diff --git a/fixincludes/fixincl.x b/fixincludes/fixincl.x
--- a/fixincludes/fixincl.x	(revision 278653)
+++ b/fixincludes/fixincl.x	(revision 278653)
@@ -2,11 +2,11 @@
  *
  * DO NOT EDIT THIS FILE   (fixincl.x)
  *
- * It has been AutoGen-ed  February 22, 2018 at 03:46:51 PM by AutoGen 5.18
+ * It has been AutoGen-ed  August 24, 2019 at 04:04:26 PM by AutoGen 5.17.4
  * From the definitions    inclhack.def
  * and the template file   fixincl
  */
-/* DO NOT SVN-MERGE THIS FILE, EITHER Thu Feb 22 15:46:51 UTC 2018
+/* DO NOT SVN-MERGE THIS FILE, EITHER Sat Aug 24 16:04:26 BST 2019
  *
  * You must regenerate it.  Use the ./genfixes script.
  *
@@ -15,7 +15,7 @@
  * certain ANSI-incompatible system header files which are fixed to work
  * correctly with ANSI C and placed in a directory that GNU C will search.
  *
- * This file contains 249 fixup descriptions.
+ * This file contains 254 fixup descriptions.
  *
  * See README for more information.
  *
@@ -269,6 +269,56 @@
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
+ *  Description of Darwin_Api_Availability fix
+ */
+tSCC zDarwin_Api_AvailabilityName[] =
+     "darwin_api_availability";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zDarwin_Api_AvailabilityList[] =
+  "os/availability.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzDarwin_Api_AvailabilityMachs[] = {
+        "*-*-darwin*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zDarwin_Api_AvailabilitySelect0[] =
+       " *#define __API_AVAILABLE.*\n\
+ *#define __API_DEPRECATED.*\n\
+ *#define __API_DEPRECATED_WITH_REPLACEMENT.*\n\
+ *#define __API_UNAVAILABLE.*\n";
+
+/*
+ *  content bypass pattern - skip fix if pattern found
+ */
+tSCC zDarwin_Api_AvailabilityBypass0[] =
+       "__IPHONE_OS_VERSION_MIN_REQUIRED";
+
+#define    DARWIN_API_AVAILABILITY_TEST_CT  2
+static tTestDesc aDarwin_Api_AvailabilityTests[] = {
+  { TT_NEGREP,   zDarwin_Api_AvailabilityBypass0, (regex_t*)NULL },
+  { TT_EGREP,    zDarwin_Api_AvailabilitySelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Darwin_Api_Availability
+ */
+static const char* apzDarwin_Api_AvailabilityPatch[] = {
+    "format",
+    "    #define API_AVAILABLE(...)\n\
+    #define API_DEPRECATED(...)\n\
+    #define API_DEPRECATED_WITH_REPLACEMENT(...)\n\
+    #define API_UNAVAILABLE(...)\n",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
  *  Description of Aab_Fd_Zero_Asm_Posix_Types_H fix
  */
 tSCC zAab_Fd_Zero_Asm_Posix_Types_HName[] =
@@ -2598,7 +2648,7 @@
  *  Machine/OS name selection pattern
  */
 tSCC* apzDarwin_9_Long_Double_Funcs_2Machs[] = {
-        "*-*-darwin7.9*",
+        "*-*-darwin*",
         (const char*)NULL };
 
 /*
@@ -2704,6 +2754,42 @@
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
+ *  Description of Darwin_Ll_Funcs_Avail fix
+ */
+tSCC zDarwin_Ll_Funcs_AvailName[] =
+     "darwin_ll_funcs_avail";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zDarwin_Ll_Funcs_AvailList[] =
+  "architecture/ppc/math.h\0architecture/i386/math.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzDarwin_Ll_Funcs_AvailMachs[] = {
+        "*-*-darwin*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zDarwin_Ll_Funcs_AvailSelect0[] =
+       "#if[^_]*__STDC_VERSION__[^_]*__STDC_VERSION__[^1]*199901L[^_]*__STRICT_ANSI__[^_]*__GNUC__[^)]*";
+
+#define    DARWIN_LL_FUNCS_AVAIL_TEST_CT  1
+static tTestDesc aDarwin_Ll_Funcs_AvailTests[] = {
+  { TT_EGREP,    zDarwin_Ll_Funcs_AvailSelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Darwin_Ll_Funcs_Avail
+ */
+static const char* apzDarwin_Ll_Funcs_AvailPatch[] = { sed_cmd_z,
+    "-e", "s/#if[^_]*__STDC_VERSION__[^_]*__STDC_VERSION__[^_]*199901L[^_]*__STRICT_ANSI__[^_]*__GNUC__[^\\)]*)/#if !(__DARWIN_NO_LONG_LONG)/",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
  *  Description of Darwin_Longjmp_Noreturn fix
  */
 tSCC zDarwin_Longjmp_NoreturnName[] =
@@ -2866,6 +2952,86 @@
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
+ *  Description of Darwin_Os_Base_1 fix
+ */
+tSCC zDarwin_Os_Base_1Name[] =
+     "darwin_os_base_1";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zDarwin_Os_Base_1List[] =
+  "os/base.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzDarwin_Os_Base_1Machs[] = {
+        "*-*-darwin*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zDarwin_Os_Base_1Select0[] =
+       "#define __has_attribute.*\n\
+#endif";
+
+#define    DARWIN_OS_BASE_1_TEST_CT  1
+static tTestDesc aDarwin_Os_Base_1Tests[] = {
+  { TT_EGREP,    zDarwin_Os_Base_1Select0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Darwin_Os_Base_1
+ */
+static const char* apzDarwin_Os_Base_1Patch[] = {
+    "format",
+    "%0\n\
+#ifndef __has_extension\n\
+#define __has_extension(x) 0\n\
+#endif",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
+ *  Description of Darwin_Dispatch_Object_1 fix
+ */
+tSCC zDarwin_Dispatch_Object_1Name[] =
+     "darwin_dispatch_object_1";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zDarwin_Dispatch_Object_1List[] =
+  "dispatch/object.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzDarwin_Dispatch_Object_1Machs[] = {
+        "*-*-darwin*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zDarwin_Dispatch_Object_1Select0[] =
+       "typedef void.*\\^dispatch_block_t.*";
+
+#define    DARWIN_DISPATCH_OBJECT_1_TEST_CT  1
+static tTestDesc aDarwin_Dispatch_Object_1Tests[] = {
+  { TT_EGREP,    zDarwin_Dispatch_Object_1Select0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Darwin_Dispatch_Object_1
+ */
+static const char* apzDarwin_Dispatch_Object_1Patch[] = {
+    "format",
+    "#if __BLOCKS__\n\
+%0\n\
+#endif",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
  *  Description of Darwin_Private_Extern fix
  */
 tSCC zDarwin_Private_ExternName[] =
@@ -3222,6 +3388,48 @@
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
+ *  Description of Darwin_Ucred__Atomic fix
+ */
+tSCC zDarwin_Ucred__AtomicName[] =
+     "darwin_ucred__Atomic";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zDarwin_Ucred__AtomicList[] =
+  "sys/ucred.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzDarwin_Ucred__AtomicMachs[] = {
+        "*-*-darwin*",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zDarwin_Ucred__AtomicSelect0[] =
+       "_Atomic";
+
+#define    DARWIN_UCRED__ATOMIC_TEST_CT  1
+static tTestDesc aDarwin_Ucred__AtomicTests[] = {
+  { TT_EGREP,    zDarwin_Ucred__AtomicSelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Darwin_Ucred__Atomic
+ */
+static const char* apzDarwin_Ucred__AtomicPatch[] = {
+    "wrap",
+    "#if (__STDC_VERSION__ < 201112L) || defined(__cplusplus)\n\
+# define _Atomic volatile\n\
+#endif\n",
+    "#if (__STDC_VERSION__ < 201112L) || defined(__cplusplus)\n\
+# undef _Atomic\n\
+#endif\n",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
  *  Description of Dec_Intern_Asm fix
  */
 tSCC zDec_Intern_AsmName[] =
@@ -10099,9 +10307,9 @@
  *
  *  List of all fixes
  */
-#define REGEX_COUNT          287
+#define REGEX_COUNT          293
 #define MACH_LIST_SIZE_LIMIT 187
-#define FIX_COUNT            249
+#define FIX_COUNT            254
 
 /*
  *  Enumerate the fixes
@@ -10110,6 +10318,7 @@
     AAB_AIX_STDIO_FIXIDX,
     AAB_AIX_FCNTL_FIXIDX,
     AAB_DARWIN7_9_LONG_DOUBLE_FUNCS_FIXIDX,
+    DARWIN_API_AVAILABILITY_FIXIDX,
     AAB_FD_ZERO_ASM_POSIX_TYPES_H_FIXIDX,
     AAB_FD_ZERO_GNU_TYPES_H_FIXIDX,
     AAB_FD_ZERO_SELECTBITS_H_FIXIDX,
@@ -10171,10 +10380,13 @@
     DARWIN_9_LONG_DOUBLE_FUNCS_2_FIXIDX,
     DARWIN_EXTERNC_FIXIDX,
     DARWIN_GCC4_BREAKAGE_FIXIDX,
+    DARWIN_LL_FUNCS_AVAIL_FIXIDX,
     DARWIN_LONGJMP_NORETURN_FIXIDX,
     DARWIN_OS_TRACE_1_FIXIDX,
     DARWIN_OS_TRACE_2_FIXIDX,
     DARWIN_OS_TRACE_3_FIXIDX,
+    DARWIN_OS_BASE_1_FIXIDX,
+    DARWIN_DISPATCH_OBJECT_1_FIXIDX,
     DARWIN_PRIVATE_EXTERN_FIXIDX,
     DARWIN_STDINT_1_FIXIDX,
     DARWIN_STDINT_2_FIXIDX,
@@ -10183,6 +10395,7 @@
     DARWIN_STDINT_5_FIXIDX,
     DARWIN_STDINT_6_FIXIDX,
     DARWIN_STDINT_7_FIXIDX,
+    DARWIN_UCRED__ATOMIC_FIXIDX,
     DEC_INTERN_ASM_FIXIDX,
     DJGPP_WCHAR_H_FIXIDX,
     ECD_CURSOR_FIXIDX,
@@ -10374,6 +10587,11 @@
      AAB_DARWIN7_9_LONG_DOUBLE_FUNCS_TEST_CT, FD_MACH_ONLY | FD_REPLACEMENT,
      aAab_Darwin7_9_Long_Double_FuncsTests,   apzAab_Darwin7_9_Long_Double_FuncsPatch, 0 },
 
+  {  zDarwin_Api_AvailabilityName,    zDarwin_Api_AvailabilityList,
+     apzDarwin_Api_AvailabilityMachs,
+     DARWIN_API_AVAILABILITY_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aDarwin_Api_AvailabilityTests,   apzDarwin_Api_AvailabilityPatch, 0 },
+
   {  zAab_Fd_Zero_Asm_Posix_Types_HName,    zAab_Fd_Zero_Asm_Posix_Types_HList,
      apzAab_Fd_Zero_Asm_Posix_Types_HMachs,
      AAB_FD_ZERO_ASM_POSIX_TYPES_H_TEST_CT, FD_MACH_ONLY | FD_REPLACEMENT,
@@ -10679,6 +10897,11 @@
      DARWIN_GCC4_BREAKAGE_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
      aDarwin_Gcc4_BreakageTests,   apzDarwin_Gcc4_BreakagePatch, 0 },
 
+  {  zDarwin_Ll_Funcs_AvailName,    zDarwin_Ll_Funcs_AvailList,
+     apzDarwin_Ll_Funcs_AvailMachs,
+     DARWIN_LL_FUNCS_AVAIL_TEST_CT, FD_MACH_ONLY,
+     aDarwin_Ll_Funcs_AvailTests,   apzDarwin_Ll_Funcs_AvailPatch, 0 },
+
   {  zDarwin_Longjmp_NoreturnName,    zDarwin_Longjmp_NoreturnList,
      apzDarwin_Longjmp_NoreturnMachs,
      DARWIN_LONGJMP_NORETURN_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
@@ -10699,6 +10922,16 @@
      DARWIN_OS_TRACE_3_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
      aDarwin_Os_Trace_3Tests,   apzDarwin_Os_Trace_3Patch, 0 },
 
+  {  zDarwin_Os_Base_1Name,    zDarwin_Os_Base_1List,
+     apzDarwin_Os_Base_1Machs,
+     DARWIN_OS_BASE_1_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aDarwin_Os_Base_1Tests,   apzDarwin_Os_Base_1Patch, 0 },
+
+  {  zDarwin_Dispatch_Object_1Name,    zDarwin_Dispatch_Object_1List,
+     apzDarwin_Dispatch_Object_1Machs,
+     DARWIN_DISPATCH_OBJECT_1_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aDarwin_Dispatch_Object_1Tests,   apzDarwin_Dispatch_Object_1Patch, 0 },
+
   {  zDarwin_Private_ExternName,    zDarwin_Private_ExternList,
      apzDarwin_Private_ExternMachs,
      DARWIN_PRIVATE_EXTERN_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
@@ -10739,6 +10972,11 @@
      DARWIN_STDINT_7_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
      aDarwin_Stdint_7Tests,   apzDarwin_Stdint_7Patch, 0 },
 
+  {  zDarwin_Ucred__AtomicName,    zDarwin_Ucred__AtomicList,
+     apzDarwin_Ucred__AtomicMachs,
+     DARWIN_UCRED__ATOMIC_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aDarwin_Ucred__AtomicTests,   apzDarwin_Ucred__AtomicPatch, 0 },
+
   {  zDec_Intern_AsmName,    zDec_Intern_AsmList,
      apzDec_Intern_AsmMachs,
      DEC_INTERN_ASM_TEST_CT, FD_MACH_ONLY,
Index: fixincludes/inclhack.def
===================================================================
diff --git a/fixincludes/inclhack.def b/fixincludes/inclhack.def
--- a/fixincludes/inclhack.def	(revision 278653)
+++ b/fixincludes/inclhack.def	(revision 278653)
@@ -195,6 +195,33 @@
 };
 
 /*
+ *  SDKs for 10.13 and 10.14 omit the definitions for API_AVAILABLE where
+ *  __attribute__((availability)) is not supported.
+ */
+fix = {
+    hackname  = darwin_api_availability;
+    mach      = "*-*-darwin*";
+    files     = os/availability.h;
+    bypass    = "__IPHONE_OS_VERSION_MIN_REQUIRED";
+    select    =
+    " *#define __API_AVAILABLE.*\n"
+    " *#define __API_DEPRECATED.*\n"
+    " *#define __API_DEPRECATED_WITH_REPLACEMENT.*\n"
+    " *#define __API_UNAVAILABLE.*\n";
+    c_fix     = format;
+    c_fix_arg =
+    "    #define API_AVAILABLE(...)\n"
+    "    #define API_DEPRECATED(...)\n"
+    "    #define API_DEPRECATED_WITH_REPLACEMENT(...)\n"
+    "    #define API_UNAVAILABLE(...)\n";
+    test_text =
+    "#define __API_AVAILABLE(...)\n"
+    "#define __API_DEPRECATED(...)\n"
+    "#define __API_DEPRECATED_WITH_REPLACEMENT(...)\n"
+    "#define __API_UNAVAILABLE(...)\n";
+};
+
+/*
  *  This fixes __FD_ZERO bug for linux 2.x.y (x <= 2 && y <= some n)
  */
 fix = {
@@ -1268,12 +1295,12 @@
 };
 
 /*
- *  For the AAB_darwin7_9_long_double_funcs fix to be useful,
- *  you have to not use "" includes.
+ *  For the AAB_darwin7_9_long_double_funcs fix (and later fixes for long long)
+ *  to be useful, the main math.h must use <> and not "" includes.
  */
 fix = {
     hackname  = darwin_9_long_double_funcs_2;
-    mach      = "*-*-darwin7.9*";
+    mach      = "*-*-darwin*";
     files     = math.h;
     select    = '#include[ \t]+\"';
     c_fix     = format;
@@ -1281,7 +1308,7 @@
   
     c_fix_arg = '([ \t]*#[ \t]*include[ \t]+)"([a-z0-9/]+)\.h"';
   
-    test_text = '#include "architecture/ppc/math.h"';
+    test_text = '#include <architecture/ppc/math.h>';
 };
 
 /*
@@ -1325,6 +1352,22 @@
 };
 
 /*
+ * math.h hides the long long functions that are available on the system for
+ * 10.5 and 10.6 SDKs, we expect to use them in G++ without specifying a value
+ * for __STDC_VERSION__, or switching __STRICT_ANSI__ off.
+ */
+fix = {
+  hackname  = darwin_ll_funcs_avail;
+  mach      = "*-*-darwin*";
+  files     = architecture/ppc/math.h, architecture/i386/math.h;
+  select    = "#if[^_]*__STDC_VERSION__[^_]*__STDC_VERSION__[^1]*199901L[^_]*"
+	      "__STRICT_ANSI__[^_]*__GNUC__[^\)]*";
+  sed       = "s/#if[^_]*__STDC_VERSION__[^_]*__STDC_VERSION__[^_]*199901L[^_]*"
+	      "__STRICT_ANSI__[^_]*__GNUC__[^\\)]*\)/#if\ !\(__DARWIN_NO_LONG_LONG\)/";
+  test_text = "#if\ !(__DARWIN_NO_LONG_LONG)";
+};
+
+/*
  *  Before Mac OS X 10.8 <i386/setjmp.h> doesn't mark longjump noreturn.
  */
 fix = {
@@ -1396,6 +1439,49 @@
 };
 
 /*
+ *  In macOS 10.10 <os/base.h>, doesn't have __has_extension guarded.
+ */
+fix = {
+  hackname  = darwin_os_base_1;
+  mach      = "*-*-darwin*";
+  files     = os/base.h;
+  select    = <<- OS_BASE_1_SEL
+#define __has_attribute.*
+#endif
+OS_BASE_1_SEL;
+  c_fix     = format;
+  c_fix_arg = <<- OS_BASE_1_FIX
+%0
+#ifndef __has_extension
+#define __has_extension(x) 0
+#endif
+OS_BASE_1_FIX;
+  test_text = <<- OS_BASE_1_TEST
+#define __has_attribute(x) 0
+#endif
+
+#if __GNUC__
+OS_BASE_1_TEST;
+};
+
+/*
+ *  In macOS 10.10 <dispatch/object.h>, has unguarded block syntax.
+ */
+fix = {
+  hackname  = darwin_dispatch_object_1;
+  mach      = "*-*-darwin*";
+  files     = dispatch/object.h;
+  select    = "typedef void.*\\^dispatch_block_t.*";
+  c_fix     = format;
+  c_fix_arg = "#if __BLOCKS__\n%0\n#endif";
+  test_text = <<- DISPATCH_OBJECT_1_TEST
+typedef void (^dispatch_block_t)(void);
+
+__BEGIN_DECLS
+DISPATCH_OBJECT_1_TEST;
+};
+
+/*
  *  __private_extern__ doesn't exist in FSF GCC.  Even if it did,
  *  why would you ever put it in a system header file?
  */
@@ -1592,6 +1678,25 @@
 		"#define UINTMAX_C(v) (v ## ULL)";
 };
 
+/*  The SDK included with XCode 10.2 has the file <sys/ucred.h> that uses the
+    C11 _Atomic keyword (exposing it to C++ code).  The work-around here follows
+    the header in declaring the entity volatile when _Atomic is not available.
+*/
+fix = {
+    hackname  = darwin_ucred__Atomic;
+    mach      = "*-*-darwin*";
+    files     = sys/ucred.h;
+    select    = "_Atomic";
+    c_fix     = wrap;
+    c_fix_arg = "#if (__STDC_VERSION__ < 201112L) || defined(__cplusplus)\n"
+		"# define _Atomic volatile\n"
+		"#endif\n";
+    c_fix_arg = "#if (__STDC_VERSION__ < 201112L) || defined(__cplusplus)\n"
+		"# undef _Atomic\n"
+		"#endif\n";
+    test_text = ""; /* Don't provide this for wrap fixes.  */
+};
+
 /*
  *  Fix <c_asm.h> on Digital UNIX V4.0:
  *  It contains a prototype for a DEC C internal asm() function,
Index: .
===================================================================
diff --git a/tags b/tags
--- a/tags	(revision 278653)
+++ b/tags	(revision 278653)

Property changes on: tags
___________________________________________________________________
Modified: svn:mergeinfo
## -0,0 +0,1 ##
   Merged /trunk:r260603
